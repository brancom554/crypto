/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/arrayslicer/lib/compare/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/arrayslicer/lib/compare/index.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * Utility compare functions
 */

module.exports = {

    /**
     * Compare two numbers.
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    numcmp: function (a, b) {
        return a - b;
    },

    /**
     * Compare two strings.
     *
     * @param {Number|String} a
     * @param {Number|String} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    strcmp: function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

};


/***/ }),

/***/ "./node_modules/arrayslicer/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/arrayslicer/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Indexed Array Binary Search module
 */

/**
 * Dependencies
 */
var util = __webpack_require__(/*! ./util */ "./node_modules/arrayslicer/lib/util.js"),
    cmp = __webpack_require__(/*! ./compare */ "./node_modules/arrayslicer/lib/compare/index.js"),
    bin = __webpack_require__(/*! ./search/binary */ "./node_modules/arrayslicer/lib/search/binary.js");

/**
 * Module interface definition
 */
module.exports = IndexedArray;

/**
 * Indexed Array constructor
 *
 * It loads the array data, defines the index field and the comparison function
 * to be used.
 *
 * @param {Array} data is an array of objects
 * @param {String} index is the object's property used to search the array
 */
function IndexedArray(data, index) {

    // is data sortable array or array-like object?
    if (!util.isSortableArrayLike(data))
        throw new Error("Invalid data");

    // is index a valid property?
    if (!index || data.length > 0 && !(index in data[0]))
        throw new Error("Invalid index");

    // data array
    this.data = data;

    // name of the index property
    this.index = index;

    // set index boundary values
    this.setBoundaries();

    // default comparison function
    this.compare = typeof this.minv === "number" ? cmp.numcmp : cmp.strcmp;

    // default search function
    this.search = bin.search;

    // cache of index values to array positions
    // each value stores an object as { found: true|false, index: array-index }
    this.valpos = {};

    // cursor and adjacent positions
    this.cursor = null;
    this.nextlow = null;
    this.nexthigh = null;
}

/**
 * Set the comparison function
 *
 * @param {Function} fn to compare index values that returnes 1, 0, -1
 */
IndexedArray.prototype.setCompare = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.compare = fn;
    return this;
};

/**
 * Set the search function
 *
 * @param {Function} fn to search index values in the array of objects
 */
IndexedArray.prototype.setSearch = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.search = fn;
    return this;
};

/**
 * Sort the data array by its index property
 */
IndexedArray.prototype.sort = function () {
    var self = this,
        index = this.index;

    // sort the array
    this.data.sort(function (a, b) {
        return self.compare(a[index], b[index]);
    });

    // recalculate boundary values
    this.setBoundaries();

    return this;
};

/**
 * Inspect and set the boundaries of the internal data array
 */
IndexedArray.prototype.setBoundaries = function () {
    var data = this.data,
        index = this.index;

    this.minv = data.length && data[0][index];
    this.maxv = data.length && data[data.length - 1][index];

    return this;
};

/**
 * Get the position of the object corresponding to the given index
 *
 * @param {Number|String} index is the id of the requested object
 * @returns {Number} the position of the object in the array
 */
IndexedArray.prototype.fetch = function (value) {
    // check data has objects
    if (this.data.length === 0) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = null;
        return this;
    }

    // check the request is within range
    if (this.compare(value, this.minv) === -1) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = 0;
        return this;
    }
    if (this.compare(value, this.maxv) === 1) {
        this.cursor = null;
        this.nextlow = this.data.length - 1;
        this.nexthigh = null;
        return this;
    }

    var valpos = this.valpos,
        pos = valpos[value];

    // if the request is memorized, just give it back
    if (pos) {
        if (pos.found) {
            this.cursor = pos.index;
            this.nextlow = null;
            this.nexthigh = null;
        } else {
            this.cursor = null;
            this.nextlow = pos.prev;
            this.nexthigh = pos.next;
        }
        return this;
    }

    // if not, do the search
    var result = this.search.call(this, value);
    this.cursor = result.index;
    this.nextlow = result.prev;
    this.nexthigh = result.next;
    return this;
};

/**
 * Get the object corresponding to the given index
 *
 * When no value is given, the function will default to the last fetched item.
 *
 * @param {Number|String} [optional] index is the id of the requested object
 * @returns {Object} the found object or null
 */
IndexedArray.prototype.get = function (value) {
    if (value)
        this.fetch(value);

    var pos = this.cursor;
    return pos !== null ? this.data[pos] : null;
};

/**
 * Get an slice of the data array
 *
 * Boundaries have to be in order.
 *
 * @param {Number|String} begin index is the id of the requested object
 * @param {Number|String} end index is the id of the requested object
 * @returns {Object} the slice of data array or []
 */
IndexedArray.prototype.getRange = function (begin, end) {
    // check if boundaries are in order
    if (this.compare(begin, end) === 1) {
        return [];
    }

    // fetch start and default to the next index above
    this.fetch(begin);
    var start = this.cursor || this.nexthigh;

    // fetch finish and default to the next index below
    this.fetch(end);
    var finish = this.cursor || this.nextlow;

    // if any boundary is not set, return no range
    if (start === null || finish === null) {
        return [];
    }

    // return range
    return this.data.slice(start, finish + 1);
};


/***/ }),

/***/ "./node_modules/arrayslicer/lib/search/binary.js":
/*!*******************************************************!*\
  !*** ./node_modules/arrayslicer/lib/search/binary.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * Binary search implementation
 */

/**
 * Main search recursive function
 */
function loop(data, min, max, index, valpos) {

    // set current position as the middle point between min and max
    var curr = (max + min) >>> 1;

    // compare current index value with the one we are looking for
    var diff = this.compare(data[curr][this.index], index);

    // found?
    if (!diff) {
        return valpos[index] = {
            "found": true,
            "index": curr,
            "prev": null,
            "next": null
        };
    }

    // no more positions available?
    if (min >= max) {
        return valpos[index] = {
            "found": false,
            "index": null,
            "prev": (diff < 0) ? max : max - 1,
            "next": (diff < 0) ? max + 1 : max
        };
    }

    // continue looking for index in one of the remaining array halves
    // current position can be skept as index is not there...
    if (diff > 0)
        return loop.call(this, data, min, curr - 1, index, valpos);
    else
        return loop.call(this, data, curr + 1, max, index, valpos);
}

/**
 * Search bootstrap
 * The function has to be executed in the context of the IndexedArray object
 */
function search(index) {
    var data = this.data;
    return loop.call(this, data, 0, data.length - 1, index, this.valpos);
}

/**
 * Export search function
 */
module.exports.search = search;


/***/ }),

/***/ "./node_modules/arrayslicer/lib/util.js":
/*!**********************************************!*\
  !*** ./node_modules/arrayslicer/lib/util.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Utils module
 */

/**
 * Check if an object is an array-like object
 *
 * @credit Javascript: The Definitive Guide, O'Reilly, 2011
 */
function isArrayLike(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        isFinite(o.length) &&                // o.length is a finite number
        o.length >= 0 &&                     // o.length is non-negative
        o.length === Math.floor(o.length) && // o.length is an integer
        o.length < 4294967296)               // o.length < 2^32
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for the existence of the sort function in the object
 */
function isSortable(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        typeof o.sort === "function")        // o.sort is a function
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for sortable-array-like objects
 */
module.exports.isSortableArrayLike = function (o) {
    return isArrayLike(o) && isSortable(o);
};


/***/ }),

/***/ "./build/chart-link/chart-link-dev.js":
/*!********************************************!*\
  !*** ./build/chart-link/chart-link-dev.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "widgets": () => (/* binding */ widgets),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/chart-link/main.js */ "./src/extensions/chart-link/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'chart-link';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/grid-resize/grid-resize-dev.js":
/*!**********************************************!*\
  !*** ./build/grid-resize/grid-resize-dev.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "widgets": () => (/* binding */ widgets),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/grid-resize/main.js */ "./src/extensions/grid-resize/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'grid-resize';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/legend-buttons/legend-buttons-dev.js":
/*!****************************************************!*\
  !*** ./build/legend-buttons/legend-buttons-dev.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "widgets": () => (/* binding */ widgets),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/legend-buttons/main.js */ "./src/extensions/legend-buttons/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'legend-buttons';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/settings-win/settings-win-dev.js":
/*!************************************************!*\
  !*** ./build/settings-win/settings-win-dev.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "widgets": () => (/* binding */ widgets),
/* harmony export */   "SettingsWin": () => (/* reexport safe */ _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/settings-win/SettingsWin.vue */ "./src/extensions/settings-win/SettingsWin.vue");
/* harmony import */ var _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/extensions/settings-win/main.js */ "./src/extensions/settings-win/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'


_src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"].__name__ = 'settings-win';
var widgets = {
  SettingsWin: _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  SettingsWin: _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var tvjs_overlays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tvjs-overlays */ "./node_modules/tvjs-overlays/dist/tvjs-overlays.js");
/* harmony import */ var tvjs_overlays__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(tvjs_overlays__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _resources_data_data_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/data/data.json */ "./resources/data/data.json");
/* harmony import */ var _stuff_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stuff/utils.js */ "./src/stuff/utils.js");
/* harmony import */ var _stuff_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stuff/constants.js */ "./src/stuff/constants.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./stream.js */ "./src/stream.js");
/* harmony import */ var _index_dev__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./index_dev */ "./src/index_dev.js");


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






 // Gettin' data through webpeck proxy

var symbolsm = window.location.pathname.toLowerCase().split('/')[3] + 'usdt';
var symbolbg = window.location.pathname.toUpperCase().split('/')[3] + 'USDT';
var URL = "https://binance-watch-wrapper.herokuapp.com/https://api.binance.com/api/v1/klines?symbol=";
var WSS = "wss://stream.binance.com:9443/ws/".concat(symbolsm, "@aggTrade");
var datas = "datasets.binance-".concat(symbolsm); //const PORT = location.port
//const URL = `http://localhost:${PORT}/api/v1/klines?symbol=`
//const WSS = `ws://localhost:${PORT}/ws/${symbolsm}@aggTrade`

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'App',
  components: {
    TradingVue: trading_vue_js__WEBPACK_IMPORTED_MODULE_1__.TradingVue
  },
  data: function data() {
    return {
      dc: new trading_vue_js__WEBPACK_IMPORTED_MODULE_1__.DataCube(_resources_data_data_json__WEBPACK_IMPORTED_MODULE_3__),
      title: symbolbg,
      width: 0,
      height: 0,
      log_scale: true,
      symbol: symbolbg,
      index_based: true,
      timezone: this.timezoned(),
      xsett: {
        'grid-resize': {
          min_height: 30
        }
      },
      ovs: Object.values((tvjs_overlays__WEBPACK_IMPORTED_MODULE_2___default())),
      ext: Object.values(_index_dev__WEBPACK_IMPORTED_MODULE_7__["default"]),
      night: true,
      top: 50,
      resetkey: 0
    };
  },
  computed: {
    colors: function colors() {
      return this.night ? {} : {
        colorBack: '#fff',
        colorGrid: '#eee',
        colorText: '#333'
      };
    }
  },
  mounted: function mounted() {
    var _this = this;

    window.addEventListener('resize', this.onResize);
    var q = this.win_query();
    if (q.nm === 'false') this.night = false;
    if (q.ov) this.current = q.ov;
    if (q.header === 'false') this.top = 0;
    this.onResize(), window.dc = this.dc;
    window.tv = this.$refs.tvjs; // Load the last data chunk & init DataCube:

    var now = _stuff_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"].now();
    this.load_chunk([now - _stuff_constants_js__WEBPACK_IMPORTED_MODULE_5__["default"].HOUR4, now]).then(function (data) {
      dc.data.chart.data = data['chart.data']; // Register onrange callback & And a stream of trades

      _this.dc.onrange(_this.load_chunk);

      _this.stream = new _stream_js__WEBPACK_IMPORTED_MODULE_6__["default"](WSS);
      _this.stream.ontrades = _this.on_trades;
      window.dc = _this.chart; // Debug

      window.tv = _this.$refs.tvjs; // Debug
    });
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('resize', this.onResize);
    if (this.stream) this.stream.off();
  },
  methods: {
    onResize: function onResize() {
      if (window.innerWidth < '500') {
        this.width = window.innerWidth;
        this.height = window.innerHeight * 0.53;
      }
      /* else if (window.innerWidth > '768'  && window.innerWidth <= '992') {
         this.width = (window.innerWidth - (window.innerWidth * 0.26))
      }*/
      else {
        this.width = window.innerWidth * 0.7;
        this.height = window.innerHeight * 0.68;
      }
    },
    spline: function spline() {
      this.dc.data.chart.type = "Spline";
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    candles: function candles() {
      this.dc.data.chart.type = "Candles";
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    xbars: function xbars() {
      this.data.ovs = 'XOhlcBars';
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    trade: function trade() {
      this.dc.data.chart.type = "Spline";
    },
    win_query: function win_query() {
      var qs = function (a) {
        if (a == "") return {};
        var b = {};

        for (var i = 0; i < a.length; ++i) {
          var p = a[i].split('=', 2);
          if (p.length == 1) b[p[0]] = "";else b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
        }

        return b;
      }(window.location.search.substr(1).split('&'));

      return qs;
    },
    reset: function reset(state) {
      var sub = Object.keys(state).filter(function (x) {
        return state[x];
      });
      this.extensions = sub.map(function (x) {
        return _index_dev__WEBPACK_IMPORTED_MODULE_7__["default"][x];
      });
      this.resetkey++;
    },
    onselect: function onselect(id) {
      this.current = id;
    },
    timezoned: function timezoned() {
      var offset = new Date().getTimezoneOffset();
      var minutes = Math.abs(offset);
      var hours = Math.floor(minutes / 60);
      var prefix = offset < 0 ? "" : "-";
      return parseInt(prefix + hours);
    },
    // New data handler. Should return Promise, or
    // use callback: load_chunk(range, tf, callback)
    load_chunk: function load_chunk(range) {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {
        var _range, t1, t2, x, q, r;

        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _range = _slicedToArray(range, 2), t1 = _range[0], t2 = _range[1];
                x = symbolbg;
                q = "".concat(x, "&interval=1m&startTime=").concat(t1, "&endTime=").concat(t2);
                _context.next = 5;
                return fetch(URL + q).then(function (r) {
                  return r.json();
                });

              case 5:
                r = _context.sent;
                return _context.abrupt("return", _this2.format(_this2.parse_binance(r)));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    // Parse a specific exchange format
    parse_binance: function parse_binance(data) {
      if (!Array.isArray(data)) return [];
      return data.map(function (x) {
        for (var i = 0; i < x.length; i++) {
          x[i] = parseFloat(x[i]);
        }

        return x.slice(0, 6);
      });
    },
    format: function format(data) {
      return {
        'chart.data': data
      };
    },
    on_trades: function on_trades(trade) {
      this.dc.update({
        t: trade.T,
        // Exchange time (optional)
        price: parseFloat(trade.p),
        // Trade price
        volume: parseFloat(trade.q),
        // Trade amount
        datas: [// Update dataset
        trade.T, trade.m ? 0 : 1, // Sell or Buy
        parseFloat(trade.q), parseFloat(trade.p)] // ... other onchart/offchart updates

      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'StdInput',
  props: ['value', 'name', 'type', 'list', 'colors'],
  data: function data() {
    return {};
  },
  computed: {
    style: function style() {
      return {//background: this.$props.colors.back,
        //color: this.$props.colors.text
      };
    }
  },
  methods: {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dragg.js */ "./src/components/dragg.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'Window',
  mixins: [_dragg_js__WEBPACK_IMPORTED_MODULE_0__["default"]],
  props: ['title', 'tv'],
  data: function data() {
    return {
      ww: 0,
      wh: 0,
      x: 0,
      y: 0
    };
  },
  computed: {
    style: function style() {
      return {
        top: "".concat(this.y, "px"),
        left: "".concat(this.x, "px")
      };
    },
    tvw: function tvw() {
      return this.$props.tv.width;
    },
    tvh: function tvh() {
      return this.$props.tv.height;
    }
  },
  mounted: function mounted() {
    this.ww = this.$refs.win.clientWidth;
    this.wh = this.$refs.win.clientHeight;
    this.x = this.tvw * 0.5 - this.ww * 0.5;
    this.y = this.tvh * 0.5 - this.wh * 0.5;
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/grid-resize/utils.js");
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'Splitter',
  props: ['id', 'main', 'dc', 'tv', 'data'],
  computed: {
    hs_style: function hs_style() {
      return {
        drag: null,
        top: this.data.grid2.offset + 'px' //backgroundColor: this.colors.splitter

      };
    }
  },
  mounted: function mounted() {
    this.MIN_HEIGHT = this.data.sett.min_height || 20;
  },
  methods: {
    hs_mousedown: function hs_mousedown(e) {
      this.drag = {
        type: 'hs',
        y: e.clientY,
        h1: this.data.grid1.height,
        h2: this.data.grid2.height
      };
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].add_style('disable-user-select', "body * {\n                user-select: none;\n            }\n            .trading-vue-chart {\n                pointer-events: none;\n            }");
    },
    hs_mouseup: function hs_mouseup(e) {
      this.drag = null;
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].rem_style('disable-user-select');
    },
    hs_mousemove: function hs_mousemove(e) {
      if (this.drag) {
        var off = e.clientY - this.drag.y;
        var new_h1 = this.drag.h1 + off;
        var new_h2 = this.drag.h2 - off;

        if (new_h1 > this.MIN_HEIGHT && new_h2 > this.MIN_HEIGHT) {
          this.data.grid1.height = new_h1;
          this.data.grid2.height = new_h2;
        }

        this.main.calc_heights();
      }
    },
    hs_mouseleave: function hs_mouseleave(e) {
      this.drag = null;
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].rem_style('disable-user-select');
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/Window.vue */ "./src/components/Window.vue");
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'AddWin',
  components: {
    Window: _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  props: ['id', 'main', 'dc', 'tv', 'data'],
  data: function data() {
    return {
      ovs: this.tv.overlays.filter(function (x) {
        return x.methods.calc;
      })
    };
  },
  computed: {
    sett: function sett() {
      return this.$props.data.ov.settings;
    }
  },
  mounted: function mounted() {},
  methods: {
    on_close: function on_close() {
      this.$props.main.remove_widget(this.$props.id);
    },
    on_click: function on_click(name) {
      this.on_close();
      this.main.add_overlay({
        side: this.data.type,
        index: this.data.index,
        type: name
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js& ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/Window.vue */ "./src/components/Window.vue");
/* harmony import */ var _components_StdInput_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/StdInput.vue */ "./src/components/StdInput.vue");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/settings-win/utils.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'SettingsWin',
  components: {
    Window: _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
    StdInput: _components_StdInput_vue__WEBPACK_IMPORTED_MODULE_1__["default"]
  },
  props: ['id', 'main', 'dc', 'tv', 'data'],
  computed: {
    sett: function sett() {
      return this.$props.data.ov.settings;
    },
    settlist: function settlist() {
      var _this = this;

      return Object.keys(this.sett).filter(function (x) {
        return x[0] !== '$' && _this.sett.$props && _this.sett.$props.includes(x);
      });
    }
  },
  mounted: function mounted() {},
  methods: {
    s2d: function s2d(str) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].sett2desc(str);
    },
    on_close: function on_close() {
      this.$props.main.remove_widget(this.$props.id);
    },
    update_sett: function update_sett(k, val) {
      var dcid = this.$props.data.ov.id;
      var valN = parseFloat(val);
      if (valN !== valN) valN = val;
      this.$props.dc.merge("".concat(dcid, ".settings"), _defineProperty({}, k, valN));
    }
  }
});

/***/ }),

/***/ "./src/components/dragg.js":
/*!*********************************!*\
  !*** ./src/components/dragg.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  methods: {
    onMouseDown: function onMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      this.drag.offset_x = e.clientX - this.x;
      this.drag.offset_y = e.clientY - this.y;
      document.onmouseup = this.stopdrag;
      document.onmousemove = this.ondrag;
    },
    ondrag: function ondrag(e) {
      e = e || window.event;
      e.preventDefault();
      this.x = e.clientX - this.drag.offset_x;
      this.y = e.clientY - this.drag.offset_y;
    },
    stopdrag: function stopdrag() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  },
  data: function data() {
    return {
      drag: {
        offset_x: 0,
        offset_y: 0
      }
    };
  }
});

/***/ }),

/***/ "./src/extensions/chart-link/main.js":
/*!*******************************************!*\
  !*** ./src/extensions/chart-link/main.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ "./src/extensions/chart-link/shared.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/chart-link/utils.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* Example:

rules: {
    '* -> *': {},     // From each to each
    '*': {            // The same as ^
        cursor: true, // bool, 'X', 'Y', 'XY'
        position: 'X', // bool, 'X', 'Y', 'XY'
        tools: true
    },
    'trading-vue-1 -> trading-vue-2': {
        data: [
            'onchart.SMA',
            'RSI4H',
            {
                from: 'chart.data',
                to: 'datasets',
                obj: {
                    id: 'small-tf-data',
                    type: 'SourceData'
                }
            }
        ]
    },
    'none': {
        range: 'X', // bool, 'X', 'Y', 'XY'
    }
}
*/



var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    _classCallCheck(this, Main);

    if (sett.use_window) {
      if (!window.xchartlink$) {
        window.xchartlink$ = {};
      }

      this.shared = window.xchartlink$;
    } else {
      this.shared = _shared_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    }

    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
    this.targets = {};
    this.onsettings({
      'chart-link': sett
    });
  }

  _createClass(Main, [{
    key: "onsettings",
    value: function onsettings(all) {
      var _this = this;

      clearTimeout(this.reset_id);
      this.sett = all['chart-link'];

      if (!this.shared.rules) {
        this.shared.rules = {};
        this.shared.refs = {};
        this.shared.meta = {};
      }

      var el = document.getElementById(this.tv.id);

      if (this.sett.rules && el) {
        this.shared.rules[this.tv.id] = this.sett.rules;
      }

      this.shared.refs[this.tv.id] = this.tv;
      this.combine();
      this.reset_id = setTimeout(function () {
        return _this.reset();
      });
    } //  Combine rules from different instances

  }, {
    key: "combine",
    value: function combine() {
      this.shared.combined = {};

      for (var id in this.shared.rules) {
        for (var r in this.shared.rules[id]) {
          this.shared.combined[r] = this.shared.rules[id][r];
        }
      }
    } // Compile rules for this instance

  }, {
    key: "compile",
    value: function compile() {
      var gebcn = 'getElementsByClassName';

      var els = _toConsumableArray(document[gebcn]('trading-vue'));

      this.targets = {};

      var _iterator = _createForOfIteratorHelper(els),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var el = _step.value;
          if (el.id === this.tv.id) continue;
          this.targets[el.id] = {};
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var rules = this.rank(this.shared.combined);

      var _iterator2 = _createForOfIteratorHelper(rules),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var r = _step2.value;
          var dst = r.pair[1];

          if (dst === '*') {
            dst = Object.keys(this.targets);
          }

          if (Array.isArray(dst)) {
            var _iterator3 = _createForOfIteratorHelper(dst),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var d = _step3.value;
                if (!(d in this.targets)) continue;
                Object.assign(this.targets[d], r.r);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } else {
            if (!(dst in this.targets)) continue;
            Object.assign(this.targets[dst], r.r);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } // Select, rank & sort the rules

  }, {
    key: "rank",
    value: function rank(rules) {
      var out = [];

      for (var r in rules) {
        var pair = this.splitr(r);
        if (!this.matches(pair[0])) continue;

        if (pair[0] === '*') {
          var rank = 20;
        } else if (Array.isArray(pair[0])) {
          rank = 10;
        } else {
          rank = 0;
        }

        if (pair[1] === '*') {
          rank += 2;
        } else if (Array.isArray(pair[1])) {
          rank += 1;
        } else {
          rank += 0;
        }

        out.push({
          pair: pair,
          rank: rank,
          r: rules[r]
        });
      }

      return out.sort(function (a, b) {
        return b.rank - a.rank;
      });
    } // Check if the source of a rule matches tv.id

  }, {
    key: "matches",
    value: function matches(src) {
      return src === '*' || src === this.tv.id || Array.isArray(src) && src.includes(this.tv.id);
    }
  }, {
    key: "splitr",
    value: function splitr(rule) {
      if (rule.trim() === '*') return ['*', '*'];
      return rule.split('->').map(function (x) {
        var tup = x.split(',');

        if (tup.length > 1) {
          return tup.map(function (y) {
            return y.trim();
          });
        }

        return x.trim();
      });
    } // Apply all rules for this instance

  }, {
    key: "reset",
    value: function reset() {
      var _this2 = this;

      this.compile(); // Enable some chart hook events

      this.tv.$refs.chart.hooks('xchanged');
      this.tv.$watch(function (x) {
        return _this2.dc.get('.').filter(function (x) {
          return x.settings.$state;
        });
      }, this.ontools.bind(this));
    } // Listening to the Chart.vue hooks &
    // other events

  }, {
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case '?x-changed':
          var cursor = e.args[0];
          if (cursor.preventDefault) return;
          var main = this.tv.$refs.chart._layout.grids[cursor.grid_id];
          var mc = this.tv.$refs.chart.cursor;
          cursor.t = mc.t;
          cursor.$ = mc.y$;

          for (var id in this.targets) {
            var r = this.targets[id].cursor;

            if (r) {
              var tv = this.shared.refs[id];
              var g = tv.$refs.chart._layout.grids[0];
              var xx = this.isX(r);
              var yy = g.id === main.id && this.isY(r);
              var upd = {
                preventDefault: true,
                x: xx ? g.t2screen(cursor.t) : -10,
                y: yy ? g.$2screen(cursor.$) : -10,
                grid_id: 0
              };
              tv.$refs.chart.cursor_changed(upd);
              tv.$refs.chart.cursor.t = xx ? cursor.t : -10;
              tv.$refs.chart.cursor.y$ = yy ? cursor.$ : -10;
            }
          }

          break;

        case 'range-changed':
          var now = new Date().getTime();
          var meta = this.shared.meta[this.tv.id];

          if (meta && meta.position) {
            if (meta.position.lock > now) return;
          }

          var range = e.args[0];

          for (var id in this.targets) {
            var _r = this.targets[id].position;
            var _tv = this.shared.refs[id];

            var _xx = this.isX(_r);

            var _yy = this.isY(_r);

            if (!this.shared.meta[id]) {
              this.shared.meta[id] = {};
            } // Prevents an infinite loop


            this.shared.meta[id].position = {
              lock: now + 100
            };
            if (_xx) _tv["goto"](range[1]);
          }

          break;
      }
    }
  }, {
    key: "ontools",
    value: function ontools(n, p) {
      var _this3 = this;

      var rem = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].removed(n.map(function (x) {
        return x.settings.$uuid;
      }), p.map(function (x) {
        return x.settings.$uuid;
      }));
      var now = new Date().getTime();
      var meta = this.shared.meta[this.tv.id];

      if (meta && meta.tools) {
        if (meta.tools.lock > now) return;
      }

      var _loop = function _loop() {
        var r = _this3.targets[id].tools;
        var tv = _this3.shared.refs[id];

        if (r) {
          if (!_this3.shared.meta[id]) {
            _this3.shared.meta[id] = {};
          } // Prevents an infinite loop


          _this3.shared.meta[id].tools = {
            lock: now + 100
          };

          _this3.copy_tools(n, tv);

          rem.forEach(function (r) {
            return tv.data.del("".concat(r));
          });
        }
      };

      for (var id in this.targets) {
        _loop();
      }
    }
  }, {
    key: "copy_tools",
    value: function copy_tools(n, tv) {
      var _iterator4 = _createForOfIteratorHelper(n),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var tool = _step4.value;
          if (tool.id.includes('offchart')) continue;
          var uuid = tool.settings.$uuid;
          var exi = tv.data.get_one("".concat(uuid));

          if (exi) {
            tv.$set(exi, 'settings', _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].copy(tool.settings, {
              $selected: false,
              $state: 'finished'
            })); // TODO: maybe add a proper method
            // of accessing overlays

            var ovs = tv.$refs.chart.$refs.sec[0].$refs.grid.$children.filter(function (x) {
              return x.tool;
            });

            var _iterator5 = _createForOfIteratorHelper(ovs),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var ov = _step5.value;
                ov.pins.forEach(function (x) {
                  return x.re_init();
                });
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          } else {
            var copy = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].copy(tool);
            copy.settings.$selected = false;
            copy.settings.$state = 'finished';
            tv.data.add('onchart', copy);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "isX",
    value: function isX(rule) {
      return rule === true || typeof rule === 'string' && rule.includes('X');
    }
  }, {
    key: "isY",
    value: function isY(rule) {
      return rule === true || typeof rule === 'string' && rule.includes('Y');
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/chart-link/shared.js":
/*!*********************************************!*\
  !*** ./src/extensions/chart-link/shared.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//  Object shared beetween tvjs instances
var Shared = /*#__PURE__*/_createClass(function Shared() {
  _classCallCheck(this, Shared);

  this.__id__ = Math.random();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Shared());

/***/ }),

/***/ "./src/extensions/chart-link/utils.js":
/*!********************************************!*\
  !*** ./src/extensions/chart-link/utils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  copy: function copy(obj, mod) {
    var copy = JSON.parse(JSON.stringify(obj));
    return Object.assign(copy, mod);
  },
  removed: function removed(ids, prev) {
    var list = [];

    var _iterator = _createForOfIteratorHelper(prev),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var id = _step.value;

        if (!ids.includes(id)) {
          list.push(id);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return list;
  }
});

/***/ }),

/***/ "./src/extensions/grid-resize/main.js":
/*!********************************************!*\
  !*** ./src/extensions/grid-resize/main.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _Splitter_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Splitter.vue */ "./src/extensions/grid-resize/Splitter.vue");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    var _this = this;

    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
    setTimeout(function () {
      _this.tv.$el.addEventListener('mousemove', _this.onmousemove.bind(_this));

      _this.tv.$el.addEventListener('mouseup', _this.onmouseup.bind(_this));

      _this.tv.$el.addEventListener('mouseleave', _this.onmouseleave.bind(_this));

      _this.place_splitters();

      _this.calc_heights(); // Track changes of grids count


      _this.tv.$watch(function (x) {
        return _this.dc.get('.').map(function (x) {
          return x.id;
        });
      }, _this.ongrids.bind(_this));
    });
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {}
    } // Extension settings has changed

  }, {
    key: "onsettings",
    value: function onsettings(sett) {}
  }, {
    key: "ongrids",
    value: function ongrids() {
      var _this2 = this;

      setTimeout(function () {
        _this2.remove_widgets();

        _this2.place_splitters();
      });
    }
  }, {
    key: "onmousemove",
    value: function onmousemove(e) {
      var _this3 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this3;
      });

      var _iterator = _createForOfIteratorHelper(list),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var s = _step.value;
          s.hs_mousemove(e);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "onmouseup",
    value: function onmouseup(e) {
      var _this4 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this4;
      });

      var _iterator2 = _createForOfIteratorHelper(list),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          s.hs_mouseup(e);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "onmouseleave",
    value: function onmouseleave(e) {
      var _this5 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this5;
      });

      var _iterator3 = _createForOfIteratorHelper(list),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var s = _step3.value;
          s.hs_mouseleave(e);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "place_splitters",
    value: function place_splitters() {
      var grids = this.tv.$refs.chart._layout.grids;

      for (var i = 1; i < grids.length; i++) {
        var g1 = grids[i - 1];
        var g2 = grids[i];
        var id = "Splitter-".concat(g1.id, "-").concat(g2.id, "-").concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
        vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(this.widgets, id, {
          id: id,
          cls: _Splitter_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
          data: {
            grid1: g1,
            grid2: g2,
            sett: this.sett
          }
        });
      }
    }
  }, {
    key: "calc_heights",
    value: function calc_heights() {
      var hs = [];

      var _iterator4 = _createForOfIteratorHelper(this.tv.$refs.chart._layout.grids),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var g = _step4.value;
          hs.push(g.height);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var sum = hs.reduce(function (a, b) {
        return a + b;
      }, 0);
      hs = hs.map(function (h) {
        return h / sum;
      });
      this.grid_ovs().forEach(function (ov, i) {
        if (!ov.grid) {
          vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(ov, 'grid', {});
        }

        vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(ov.grid, 'height', hs[i] || 1);
      });
    } // Grid defining overlays

  }, {
    key: "grid_ovs",
    value: function grid_ovs() {
      var list = [this.dc.data.chart];

      var _iterator5 = _createForOfIteratorHelper(this.dc.data.offchart),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ov = _step5.value;

          if (!ov.grid || ov.grid.id === undefined) {
            list.push(ov);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return list;
    }
  }, {
    key: "remove_widgets",
    value: function remove_widgets() {
      for (var id in this.widgets) {
        this.tv.$delete(this.widgets, id);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.tv.$el.removeEventListener('mousemove', this.onmousemove);
      this.tv.$el.removeEventListener('mouseup', this.mouseup);
      this.tv.$el.removeEventListener('mouseleave', this.mouseleave);
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/grid-resize/utils.js":
/*!*********************************************!*\
  !*** ./src/extensions/grid-resize/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  add_style: function add_style(id, style) {
    var stbr = document.getElementById(id);

    if (stbr) {
      var sheetParent = stbr.parentNode;
      sheetParent.removeChild(stbr);
    }

    var sheet = document.createElement('style');
    sheet.setAttribute("id", id);
    sheet.innerHTML = style;
    document.body.appendChild(sheet);
  },
  rem_style: function rem_style(id, style) {
    var stbr = document.getElementById(id);

    if (stbr) {
      var sheetParent = stbr.parentNode;
      sheetParent.removeChild(stbr);
    }
  }
});

/***/ }),

/***/ "./src/extensions/legend-buttons/main.js":
/*!***********************************************!*\
  !*** ./src/extensions/legend-buttons/main.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _AddWin_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddWin.vue */ "./src/extensions/legend-buttons/AddWin.vue");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case 'legend-button-click':
          this.onbutton(e.args[0]);
          break;
      }
    }
  }, {
    key: "onbutton",
    value: function onbutton(e) {
      var ov = this.dc.get(e.type)[e.dataIndex];
      var onchart = this.dc.data.onchart;
      var offchart = this.dc.data.offchart;
      if (!ov) return;

      switch (e.button) {
        case 'display':
          if (ov.settings.display === undefined) {
            var flag = false;
          } else {
            flag = !ov.settings.display;
          }

          this.tv.$set(ov.settings, 'display', flag);
          break;

        case 'up':
          if (e.type === 'offchart') {
            if (e.dataIndex === 0) {
              offchart.splice(e.dataIndex, 1);
              onchart.push(ov);
            } else {
              var data = offchart;
              var i0 = e.dataIndex;
              var i1 = e.dataIndex - 1;
              data[i0] = data.splice(i1, 1, data[i0])[0];
            }
          }

          this.dc.update_ids();
          break;

        case 'down':
          if (e.type === 'onchart') {
            var h = this.avg_grid_h(offchart);
            onchart.splice(e.dataIndex, 1);
            offchart.unshift(ov);
            this.tv.$set(ov, 'grid', {
              height: h
            });
          } else {
            var n = offchart.length;
            var _data = offchart;

            if (e.dataIndex < n - 1) {
              var _i = e.dataIndex;

              var _i2 = e.dataIndex + 1;

              _data[_i] = _data.splice(_i2, 1, _data[_i])[0];
            }
          }

          this.dc.update_ids();
          break;

        case 'add':
          try {
            var id = "AddWin-".concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
            var _ov = this.dc.data[e.type][e.dataIndex];
            var f = Object.values(this.widgets).find(function (x) {
              return x.data.ov === _ov;
            });

            if (f) {
              this.tv.$delete(this.widgets, f.id);
              break;
            }

            this.tv.$set(this.widgets, id, {
              id: id,
              cls: _AddWin_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
              data: {
                ov: _ov,
                type: e.type,
                index: e.dataIndex
              }
            });
          } catch (e) {
            console.log(e);
          }

          break;

        case 'remove':
          this.dc.data[e.type].splice(e.dataIndex, 1);
          this.dc.update_ids();
          break;
      }
    } // Called from AddWin.vue

  }, {
    key: "add_overlay",
    value: function add_overlay(e) {
      var preset = this.get_preset(e.type) || {};
      if (preset.side) e.side = preset.side;
      var onchart = this.dc.data.onchart;
      var offchart = this.dc.data.offchart;

      if (e.side === 'onchart') {
        onchart.splice(e.index + 1, 0, {
          name: preset.name,
          type: e.type,
          data: [],
          settings: preset.settings || {}
        });
      } else {
        var h = this.avg_grid_h(offchart);
        offchart.splice(e.index + 1, 0, {
          name: preset.name,
          type: e.type,
          data: [],
          settings: preset.settings || {},
          grid: {
            height: h
          }
        });
      }

      this.dc.update_ids();
    } // Get preset (default settings, colors) if defined

  }, {
    key: "get_preset",
    value: function get_preset(type) {
      var proto = this.tv.overlays.find(function (x) {
        return x.name === type;
      });

      if (proto && proto.methods.meta_info) {
        var meta = proto.methods.meta_info();
        return meta.preset;
      }
    } // Extension settings has changed

  }, {
    key: "onsettings",
    value: function onsettings(sett) {}
  }, {
    key: "avg_grid_h",
    value: function avg_grid_h(ovs) {
      if (!ovs.length) return 0.25;
      var gh = 0;

      var _iterator = _createForOfIteratorHelper(ovs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ov = _step.value;

          if (ov.grid && typeof ov.grid.height === 'number') {
            gh += ov.grid.height;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return gh / ovs.length;
    }
  }, {
    key: "remove_widget",
    value: function remove_widget(id) {
      this.tv.$delete(this.widgets, id);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/settings-win/main.js":
/*!*********************************************!*\
  !*** ./src/extensions/settings-win/main.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _SettingsWin_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingsWin.vue */ "./src/extensions/settings-win/SettingsWin.vue");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc) {
    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case 'legend-button-click':
          var id = "SettingsWin-".concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
          var args = e.args[0];
          if (args.button !== 'settings') break;

          try {
            var ov = this.dc.data[args.type][args.dataIndex];
            var f = Object.values(this.widgets).find(function (x) {
              return x.data.ov === ov;
            });

            if (f) {
              this.tv.$delete(this.widgets, f.id);
              break;
            }

            this.tv.$set(this.widgets, id, {
              id: id,
              cls: _SettingsWin_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
              data: {
                ov: ov
              }
            });
          } catch (e) {
            console.log(e);
          }

          break;
      }
    }
  }, {
    key: "remove_widget",
    value: function remove_widget(id) {
      this.tv.$delete(this.widgets, id);
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/settings-win/utils.js":
/*!**********************************************!*\
  !*** ./src/extensions/settings-win/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  sett2desc: function sett2desc(sett) {
    function setCharAt(str, index, chr) {
      if (index > str.length - 1) return str;
      return str.substring(0, index) + chr + str.substring(index + 1);
    }

    sett = sett.replace(/([^A-Z])([A-Z])/g, '$1 $2');
    sett = sett.replace(/-|_/g, ' ');
    var tuple = sett.split(' ');
    tuple = tuple.filter(function (x) {
      return x.length;
    }).map(function (x) {
      return setCharAt(x, 0, x[0].toUpperCase());
    });
    return tuple.join(' ');
  }
});

/***/ }),

/***/ "./src/index_dev.js":
/*!**************************!*\
  !*** ./src/index_dev.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _build_chart_link_chart_link_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../build/chart-link/chart-link-dev.js */ "./build/chart-link/chart-link-dev.js");
/* harmony import */ var _build_grid_resize_grid_resize_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../build/grid-resize/grid-resize-dev.js */ "./build/grid-resize/grid-resize-dev.js");
/* harmony import */ var _build_legend_buttons_legend_buttons_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../build/legend-buttons/legend-buttons-dev.js */ "./build/legend-buttons/legend-buttons-dev.js");
/* harmony import */ var _build_settings_win_settings_win_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../build/settings-win/settings-win-dev.js */ "./build/settings-win/settings-win-dev.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'




var Pack = {
  'chart-link': _build_chart_link_chart_link_dev_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'grid-resize': _build_grid_resize_grid_resize_dev_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  'legend-buttons': _build_legend_buttons_legend_buttons_dev_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  'settings-win': _build_settings_win_settings_win_dev_js__WEBPACK_IMPORTED_MODULE_3__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./src/stream.js":
/*!***********************!*\
  !*** ./src/stream.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stream)
/* harmony export */ });
function Stream(url) {
  var ws = new WebSocket(url);

  var cb = function cb() {};

  ws.onopen = function () {
    console.log('Websocket is opened');
  };

  ws.onmessage = function (data) {
    try {
      data = JSON.parse(data.data);
      cb(data);
    } catch (e) {
      console.log(e);
    }
  };

  return {
    set ontrades(val) {
      cb = val;
    },

    off: function off() {
      ws.close(1000);
    }
  };
}

/***/ }),

/***/ "./src/stuff/constants.js":
/*!********************************!*\
  !*** ./src/stuff/constants.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var SECOND = 1000;
var MINUTE = SECOND * 60;
var MINUTE3 = MINUTE * 3;
var MINUTE5 = MINUTE * 5;
var MINUTE15 = MINUTE * 15;
var MINUTE30 = MINUTE * 30;
var HOUR = MINUTE * 60;
var HOUR4 = HOUR * 4;
var HOUR12 = HOUR * 12;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = WEEK * 4;
var YEAR = DAY * 365;
var MONTHMAP = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; // Grid time steps

var TIMESCALES = [YEAR * 10, YEAR * 5, YEAR * 3, YEAR * 2, YEAR, MONTH * 6, MONTH * 4, MONTH * 3, MONTH * 2, MONTH, DAY * 15, DAY * 10, DAY * 7, DAY * 5, DAY * 3, DAY * 2, DAY, HOUR * 12, HOUR * 6, HOUR * 3, HOUR * 1.5, HOUR, MINUTE30, MINUTE15, MINUTE * 10, MINUTE5, MINUTE * 2, MINUTE]; // Grid $ steps

var $SCALES = [0.05, 0.1, 0.2, 0.25, 0.5, 0.8, 1, 2, 5];
var ChartConfig = {
  SBMIN: 60,
  // Minimal sidebar px
  SBMAX: Infinity,
  // Max sidebar, px
  TOOLBAR: 57,
  // Toolbar width px
  TB_ICON: 25,
  // Toolbar icon size px
  TB_ITEM_M: 6,
  // Toolbar item margin px
  TB_ICON_BRI: 1,
  // Toolbar icon brightness
  TB_ICON_HOLD: 420,
  // ms, wait to expand
  TB_BORDER: 1,
  // Toolbar border px
  TB_B_STYLE: 'dotted',
  // Toolbar border style
  TOOL_COLL: 7,
  // Tool collision threshold
  EXPAND: 0.15,
  // %/100 of range
  CANDLEW: 0.6,
  // %/100 of step
  GRIDX: 100,
  // px
  GRIDY: 47,
  // px
  BOTBAR: 28,
  // px
  PANHEIGHT: 22,
  // px
  DEFAULT_LEN: 50,
  // candles
  MINIMUM_LEN: 5,
  // candles,
  MIN_ZOOM: 25,
  // candles
  MAX_ZOOM: 1000,
  // candles,
  VOLSCALE: 0.15,
  // %/100 of height
  UX_OPACITY: 0.9,
  // Ux background opacity
  ZOOM_MODE: 'tv',
  // 'tv' or 'tl'
  L_BTN_SIZE: 21,
  // Legend Button size, px
  L_BTN_MARGIN: '-6px 0 -6px 0',
  // css margin
  SCROLL_WHEEL: 'prevent' // 'pass', 'click'

};
ChartConfig.FONT = "11px -apple-system,BlinkMacSystemFont,\n    Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,\n    Fira Sans,Droid Sans,Helvetica Neue,\n    sans-serif";
var IB_TF_WARN = "When using IB mode you should specify " + "timeframe ('tf' filed in 'chart' object)," + "otherwise you can get an unexpected behaviour";
var MAP_UNIT = {
  "1s": SECOND,
  "5s": SECOND * 5,
  "10s": SECOND * 10,
  "20s": SECOND * 20,
  "30s": SECOND * 30,
  "1m": MINUTE,
  "3m": MINUTE3,
  "5m": MINUTE5,
  "15m": MINUTE15,
  "30m": MINUTE30,
  "1H": HOUR,
  "2H": HOUR * 2,
  "3H": HOUR * 3,
  "4H": HOUR4,
  "12H": HOUR12,
  "1D": DAY,
  "1W": WEEK,
  "1M": MONTH,
  "1Y": YEAR
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  SECOND: SECOND,
  MINUTE: MINUTE,
  MINUTE5: MINUTE5,
  MINUTE15: MINUTE15,
  MINUTE30: MINUTE30,
  HOUR: HOUR,
  HOUR4: HOUR4,
  DAY: DAY,
  WEEK: WEEK,
  MONTH: MONTH,
  YEAR: YEAR,
  MONTHMAP: MONTHMAP,
  TIMESCALES: TIMESCALES,
  $SCALES: $SCALES,
  ChartConfig: ChartConfig,
  map_unit: MAP_UNIT,
  IB_TF_WARN: IB_TF_WARN
});

/***/ }),

/***/ "./src/stuff/utils.js":
/*!****************************!*\
  !*** ./src/stuff/utils.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var arrayslicer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! arrayslicer */ "./node_modules/arrayslicer/lib/index.js");
/* harmony import */ var arrayslicer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(arrayslicer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./src/stuff/constants.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name2Name: function name2Name(sett) {
    function setCharAt(str, index, chr) {
      if (index > str.length - 1) return str;
      return str.substring(0, index) + chr + str.substring(index + 1);
    }

    sett = sett.replace(/([^A-Z])([A-Z])/g, '$1 $2');
    sett = sett.replace(/-|_/g, ' ');
    var tuple = sett.split(' ');
    tuple = tuple.filter(function (x) {
      return x.length;
    }).map(function (x) {
      return setCharAt(x, 0, x[0].toUpperCase());
    });
    return tuple.join('');
  },
  clamp: function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
  },
  add_zero: function add_zero(i) {
    if (i < 10) {
      i = "0" + i;
    }

    return i;
  },
  // Start of the day (zero millisecond)
  day_start: function day_start(t) {
    var start = new Date(t);
    return start.setUTCHours(0, 0, 0, 0);
  },
  // Start of the month
  month_start: function month_start(t) {
    var date = new Date(t);
    return Date.UTC(date.getFullYear(), date.getMonth(), 1);
  },
  // Start of the year
  year_start: function year_start(t) {
    return Date.UTC(new Date(t).getFullYear());
  },
  get_year: function get_year(t) {
    if (!t) return undefined;
    return new Date(t).getUTCFullYear();
  },
  get_month: function get_month(t) {
    if (!t) return undefined;
    return new Date(t).getUTCMonth();
  },
  // Nearest in array
  nearest_a: function nearest_a(x, array) {
    var dist = Infinity;
    var val = null;
    var index = -1;

    for (var i = 0; i < array.length; i++) {
      var xi = array[i];

      if (Math.abs(xi - x) < dist) {
        dist = Math.abs(xi - x);
        val = xi;
        index = i;
      }
    }

    return [index, val];
  },
  round: function round(num) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
    return parseFloat(num.toFixed(decimals));
  },
  // Strip? No, it's ugly floats in js
  strip: function strip(number) {
    return parseFloat(parseFloat(number).toPrecision(12));
  },
  get_day: function get_day(t) {
    return t ? new Date(t).getDate() : null;
  },
  // Update array keeping the same reference
  overwrite: function overwrite(arr, new_arr) {
    arr.splice.apply(arr, [0, arr.length].concat(_toConsumableArray(new_arr)));
  },
  // Copy layout in reactive way
  copy_layout: function copy_layout(obj, new_obj) {
    for (var k in obj) {
      if (Array.isArray(obj[k])) {
        // (some offchart indicators are added/removed)
        // we need to update layout in a reactive way
        if (obj[k].length !== new_obj[k].length) {
          this.overwrite(obj[k], new_obj[k]);
          continue;
        }

        for (var m in obj[k]) {
          Object.assign(obj[k][m], new_obj[k][m]);
        }
      } else {
        Object.assign(obj[k], new_obj[k]);
      }
    }
  },
  // Detects candles interval
  detect_interval: function detect_interval(ohlcv) {
    var len = Math.min(ohlcv.length - 1, 99);
    var min = Infinity;
    ohlcv.slice(0, len).forEach(function (x, i) {
      var d = ohlcv[i + 1][0] - x[0];
      if (d === d && d < min) min = d;
    }); // This saves monthly chart from being awkward

    if (min >= _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].MONTH && min <= _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].DAY * 30) {
      return _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].DAY * 31;
    }

    return min;
  },
  // Gets numberic part of overlay id (e.g 'EMA_1' = > 1)
  get_num_id: function get_num_id(id) {
    return parseInt(id.split('_').pop());
  },
  // Fast filter. Really fast, like 10X
  fast_filter: function fast_filter(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];

    try {
      var ia = new (arrayslicer__WEBPACK_IMPORTED_MODULE_0___default())(arr, "0");
      var res = ia.getRange(t1, t2);
      var i0 = ia.valpos[t1].next;
      return [res, i0];
    } catch (e) {
      // Something wrong with fancy slice lib
      // Fast fix: fallback to filter
      return [arr.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }), 0];
    }
  },
  // Fast filter (index-based)
  fast_filter_i: function fast_filter_i(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];
    var i1 = Math.floor(t1);
    if (i1 < 0) i1 = 0;
    var i2 = Math.floor(t2 + 1);
    var res = arr.slice(i1, i2);
    return [res, i1];
  },
  // Nearest indexes (left and right)
  fast_nearest: function fast_nearest(arr, t1) {
    var ia = new (arrayslicer__WEBPACK_IMPORTED_MODULE_0___default())(arr, "0");
    ia.fetch(t1);
    return [ia.nextlow, ia.nexthigh];
  },
  now: function now() {
    return new Date().getTime();
  },
  pause: function pause(delay) {
    return new Promise(function (rs, rj) {
      return setTimeout(rs, delay);
    });
  },
  // Limit crazy wheel delta values
  smart_wheel: function smart_wheel(delta) {
    var abs = Math.abs(delta);

    if (abs > 500) {
      return (200 + Math.log(abs)) * Math.sign(delta);
    }

    return delta;
  },
  // Parse the original mouse event to find deltaX
  get_deltaX: function get_deltaX(event) {
    return event.originalEvent.deltaX / 12;
  },
  // Parse the original mouse event to find deltaY
  get_deltaY: function get_deltaY(event) {
    return event.originalEvent.deltaY / 12;
  },
  // Apply opacity to a hex color
  apply_opacity: function apply_opacity(c, op) {
    if (c.length === 7) {
      var n = Math.floor(op * 255);
      n = this.clamp(n, 0, 255);
      c += n.toString(16);
    }

    return c;
  },
  // Parse timeframe or return value in ms
  parse_tf: function parse_tf(smth) {
    if (typeof smth === 'string') {
      return _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].map_unit[smth];
    } else {
      return smth;
    }
  },
  // Detect index shift between the main data sub
  // and the overlay's sub (for IB-mode)
  index_shift: function index_shift(sub, data) {
    // Find the second timestamp (by value)
    if (!data.length) return 0;
    var first = data[0][0];
    var second;

    for (var i = 1; i < data.length; i++) {
      if (data[i][0] !== first) {
        second = data[i][0];
        break;
      }
    }

    for (var j = 0; j < sub.length; j++) {
      if (sub[j][0] === second) {
        return j - i;
      }
    }

    return 0;
  },
  // Fallback fix for Brave browser
  // https://github.com/brave/brave-browser/issues/1738
  measureText: function measureText(ctx, text, tv_id) {
    var m = ctx.measureTextOrg(text);

    if (m.width === 0) {
      var doc = document;
      var id = 'tvjs-measure-text';
      var el = doc.getElementById(id);

      if (!el) {
        var base = doc.getElementById(tv_id);
        el = doc.createElement("div");
        el.id = id;
        el.style.position = 'absolute';
        el.style.top = '-1000px';
        base.appendChild(el);
      }

      if (ctx.font) el.style.font = ctx.font;
      el.innerText = text.replace(/ /g, '.');
      return {
        width: el.offsetWidth
      };
    } else {
      return m;
    }
  },
  uuid: function uuid() {
    var temp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    return temp.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  },
  uuid2: function uuid2() {
    return this.uuid('xxxxxxxxxxxx');
  },
  // Delayed warning, f = condition lambda fn
  warn: function warn(f, text) {
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    setTimeout(function () {
      if (f()) console.warn(text);
    }, delay);
  },
  // Checks if script props updated
  // (and not style settings or something else)
  is_scr_props_upd: function is_scr_props_upd(n, prev) {
    var p = prev.find(function (x) {
      return x.v.$uuid === n.v.$uuid;
    });
    if (!p) return false;
    var props = n.p.settings.$props;
    if (!props) return false;
    return props.some(function (x) {
      return n.v[x] !== p.v[x];
    });
  },
  // Checks if it's time to make a script update
  // (based on execInterval in ms)
  delayed_exec: function delayed_exec(v) {
    if (!v.script || !v.script.execInterval) return true;
    var t = this.now();
    var dt = v.script.execInterval;

    if (!v.settings.$last_exec || t > v.settings.$last_exec + dt) {
      v.settings.$last_exec = t;
      return true;
    }

    return false;
  },
  // Format names such 'RSI, $length', where
  // length - is one of the settings
  format_name: function format_name(ov) {
    if (!ov.name) return undefined;
    var name = ov.name;

    for (var k in ov.settings || {}) {
      var val = ov.settings[k];
      var reg = new RegExp("\\$".concat(k), 'g');
      name = name.replace(reg, val);
    }

    return name;
  },
  // Default cursor mode
  xmode: function xmode() {
    return this.is_mobile ? 'explore' : 'default';
  },
  default_prevented: function default_prevented(event) {
    if (event.original) {
      return event.original.defaultPrevented;
    }

    return event.defaultPrevented;
  },
  // WTF with modern web development
  is_mobile: function (w) {
    return 'onorientationchange' in w && (!!navigator.maxTouchPoints || !!navigator.msMaxTouchPoints || 'ontouchstart' in w || w.DocumentTouch && document instanceof w.DocumentTouch);
  }(typeof window !== 'undefined' ? window : {})
});

/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=style&index=0&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=style&index=0&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.app-content {\n    padding: calc(2rem + 2.45rem) 0 0 0rem !important;\n    overflow-x: hidden;\n}\n@media (max-width: 767.98px){\nhtml body.navbar-sticky .app-content {\n        padding: calc(1rem - 0.8rem + 4.45rem) 0 0 0 !important;\n}\n}\n.flexed {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    align-content: center;\n    flex-wrap: nowrap;\n}\n#app-conainer {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-content: space-between;\n    align-items: flex-start;\n    flex-wrap: nowrap;\n}\n\n/* @media (max-width: 767.98px){\n    #app-conainer {\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        align-content: space-between;\n        align-items: flex-start;\n        flex-wrap: nowrap;\n    }\n} */\n#tradebar {\n    color: #ddd;\n}\n#tvjs-header {\n    position: absolute;\n    display: flex;\n    align-content: center;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: center;\n    align-items: center;\n    height: 40px;\n    color: #ddd;\n    width: 100%;\n    background-color: #121826;\n}\n.night-mode {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n}\n#trading-vue-js-grid-0-canvas,\n#trading-vue-js-sidebar-0-canvas,\n#trading-vue-js-grid-1-canvas,\n#trading-vue-js-sidebar-1-canvas,\n#trading-vue-js-botbar-canvas {\n    background-color: rgb(0 0 0 / 0%) !important;\n}\n#trading-vue-tbitem {\n    background-color: rgb(18, 24, 38);\n}\n@media only screen and (max-device-width: 480px) {\n.tf-selector {\n        top: 50px;\n        right: 140px;\n        max-width: 140px;\n        font: 12px -apple-system, BlinkMacSystemFont,\n            Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell,\n            Fira Sans, Droid Sans, Helvetica Neue,\n            sans-serif;\n}\n}\n.box {\n    width: 280px;\n    margin: 0 auto;\n    box-shadow: 0 1.5px 5px -2px rgba(0, 0, 0, 0.2);\n    border-radius: 3px;\n    padding: 0 15px 0 15px;\n}\ntable {\n    font-size: 13px;\n    font-weight: 500;\n    color: rgb(183, 189, 198);\n    overflow: hidden;\n    width: 100%;\n}\ntd {\n    position: relative;\n    height: 20px;\n    line-height: 20px;\n}\ntd.price {\n    width: 30%;\n}\ntd.price span {\n    padding-left: 5px;\n}\ntd.quantity {\n    width: 30%;\n    text-align: right;\n}\ntd.time {\n    width: 40%;\n    text-align: right;\n    color: #999;\n    padding-right: 5px;\n}\ntd.btc {\n    width: 40%;\n    text-align: right;\n    padding-right: 5px;\n}\ntd span {\n    position: relative;\n    z-index: 2;\n}\ntable.asks .percent {\n    background-color: rgba(246, 70, 94, 0.2);\n}\ntable.bids .percent {\n    background-color: rgba(14, 203, 129, 0.2);\n}\ntd .percent {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n}\n.newest {\n    border-bottom: 1px solid #eee;\n    margin: 15px -15px;\n}\n.card-110 {\n    top: 110px !important;\n    left: 70px;\n}\n/* Style page content - use this if you want to push the page content to the right when you open the side navigation */\n#main {\n    transition: margin-left .5s;\n    /* If you want a transition effect */\n}\n\n/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */\n@media screen and (max-height: 450px) {\n.sidebar1 {\n        padding-top: 15px;\n}\n.sidebar1 a {\n        font-size: 18px;\n}\n}\n.btn-circle {\n    width: 30px;\n    height: 30px;\n    padding: 6px 0px;\n    border-radius: 15px;\n    font-size: 8px;\n    text-align: center;\n}\n#chartdiv {\n    min-height: 300px;\n    max-height: 400px;\n    height: 70vh;\n}\n", "",{"version":3,"sources":["webpack://./src/MainM.vue"],"names":[],"mappings":";AAkTA;IACA,iDAAA;IACA,kBAAA;AACA;AACA;AACA;QACA,uDAAA;AACA;AACA;AACA;IACA,aAAA;IACA,sBAAA;IACA,mBAAA;IACA,uBAAA;IACA,qBAAA;IACA,iBAAA;AACA;AAEA;IACA,aAAA;IACA,mBAAA;IACA,8BAAA;IACA,4BAAA;IACA,uBAAA;IACA,iBAAA;AACA;;AAEA;;;;;;;;;GASA;AACA;IACA,WAAA;AACA;AAEA;IACA,kBAAA;IACA,aAAA;IACA,qBAAA;IACA,mBAAA;IACA,iBAAA;IACA,uBAAA;IACA,mBAAA;IACA,YAAA;IACA,WAAA;IACA,WAAA;IACA,yBAAA;AACA;AAEA;IACA,kBAAA;IACA,SAAA;IACA,WAAA;AACA;AAEA;;;;;IAKA,4CAAA;AACA;AAEA;IACA,iCAAA;AACA;AAEA;AACA;QACA,SAAA;QACA,YAAA;QACA,gBAAA;QACA;;;sBAGA;AACA;AACA;AAEA;IACA,YAAA;IACA,cAAA;IACA,+CAAA;IACA,kBAAA;IACA,sBAAA;AACA;AAEA;IACA,eAAA;IACA,gBAAA;IACA,yBAAA;IACA,gBAAA;IACA,WAAA;AACA;AAEA;IACA,kBAAA;IACA,YAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;AACA;AAEA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;IACA,WAAA;IACA,kBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;IACA,kBAAA;AACA;AAEA;IACA,kBAAA;IACA,UAAA;AACA;AAEA;IACA,wCAAA;AACA;AAEA;IACA,yCAAA;AACA;AAEA;IACA,kBAAA;IACA,MAAA;IACA,SAAA;IACA,QAAA;AACA;AAEA;IACA,6BAAA;IACA,kBAAA;AACA;AAEA;IACA,qBAAA;IACA,UAAA;AACA;AACA,sHAAA;AACA;IACA,2BAAA;IACA,oCAAA;AACA;;AAEA,gIAAA;AACA;AACA;QACA,iBAAA;AACA;AAEA;QACA,eAAA;AACA;AACA;AAEA;IACA,WAAA;IACA,YAAA;IACA,gBAAA;IACA,mBAAA;IACA,cAAA;IACA,kBAAA;AACA;AAEA;IACA,iBAAA;IACA,iBAAA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <div class=\"flex-start col-10 col-xll-10 col-xl-10 col-lg-10 col-md-9 col-sm-12\">\n        <div id=\"tvjs-header\">\n            <a><span id=\"toggleContracts\" class=\"me-1 badge bg-light-info\" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#collapseContracts\" aria-expanded=\"false\" aria-controls=\"collapseContracts\"><i\n                        class=\"bi bi-briefcase\" /><div class=\"d-md-inline d-none\"> Contracts</div></span></a>\n            <a><span v-on:click=\"candles\" class=\"me-1 badge bg-light-secondary\"><i class=\"bi bi-bar-chart\" /><div class=\"d-md-inline d-none\">  Candles</div></span></a>\n            <a><span v-on:click=\"spline\" class=\"me-1 badge bg-light-secondary\"><i class=\"bi bi-graph-up\" /><div class=\"d-md-inline d-none\">  Spline</div></span></a>\n            <a><span id=\"toggleInfo\" class=\"me-1 badge bg-light-info\" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#collapseInfos\" aria-expanded=\"false\" aria-controls=\"collapseInfos\"><i\n                        class=\"bi bi-info-circle\" /><div class=\"d-md-inline d-none\">  Info</div></span></a>\n            <a><span id=\"toggleDepth\" class=\"me-1 badge bg-light-primary \" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#collapseDepth\" aria-expanded=\"false\" aria-controls=\"collapseDepth\"><i\n                        class=\"bi bi-kanban\" /><div class=\"d-md-inline d-none\">  Depth View</div></span></a>\n            <a><span id=\"toggleOrders\" class=\"me-1 badge bg-light-warning \" data-bs-toggle=\"collapse\"\n            data-bs-target=\"#collapseOrders\" aria-expanded=\"false\" aria-controls=\"collapseOrders\"><i\n                        class=\"bi bi-file-bar-graph\" /><div class=\"d-md-inline d-none\">  Order Book</div></span></a>\n        </div>\n        <div id=\"collapseInfos\"\n            class=\"collapse col-lg-4 col-md-5 col-sm-6 position-absolute sticky-top card-110 \">\n            <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                <div class=\"card-header\">\n                    <div class=\"col-md-8\">\n                        <h4 class=\"card-title\">\n                            {{ symbol }}\n                        </h4>\n                    </div>\n                </div>\n                <div class=\"card-content\">\n                    <div class=\"card-body\">\n                        <div class=\"row\">\n                            <div class=\"col-8\">\n                                <div id=\"show_b\" class=\"text-start fs-1\">\n                                    ...\n                                </div>\n                            </div>\n                            <div class=\"col-4\">\n                                <div id=\"show_p\" class=\"text-end\" style=\"font-size:14px;\">\n                                    ...\n                                </div>\n                                <div id=\"show_P\" class=\"text-end\" style=\"font-size:14px;\">\n                                    ...\n                                </div>\n                            </div>\n                        </div>\n                        <div class=\"row mt-1\">\n                            <div id=\"myRangeColor\" class=\"progress\">\n                                <div id=\"myRange\" class=\"progress-bar progress-bar-striped progress-bar-animated\"\n                                    role=\"progressbar\" aria-valuenow=\"50\" aria-valuemin=\"0\" aria-valuemax=\"100\"\n                                    style=\"width: 80%\" />\n                            </div>\n                        </div>\n                        <div class=\"row d-flex justify-content-between align-items-center\">\n                            <div id=\"show_l\" class=\"col text-start text-danger\" style=\"font-size:10px;\" />\n                            <div class=\"col text-dark text-center\" style=\"font-size:10px;\">\n                                Day Range\n                            </div>\n                            <div id=\"show_h\" class=\"col text-end text-success\" style=\"font-size:10px;\" />\n                        </div>\n                        <div class=\"row mt-1\">\n                            <small class=\"col text-start text-dark clearfix\">Volume 24H</small>\n                            <small id=\"show_v\" class=\"col text-end text-warning clearfix\" />\n                            <hr>\n                        </div>\n                        <div class=\"row\">\n                            <small class=\"col text-start text-dark clearfix\">Market Cap</small>\n                            <small id=\"show_mc\" class=\"col text-end text-warning clearfix\" />\n                            <hr>\n                        </div>\n\n                        <div class=\"row\">\n                            <small class=\"col text-start text-dark clearfix\">Total Supply</small>\n                            <small id=\"show_ts\" class=\"col text-end text-warning clearfix\" />\n                            <hr>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div id=\"collapseDepth\"\n            class=\"collapse col-lg-6 col-md-10 col-sm-12 col-12 position-absolute sticky-top card-110 \">\n            <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                <div class=\"card-content\">\n                    <div id=\"chartdiv\"></div>\n                </div>\n            </div>\n        </div>\n        <div id=\"collapseOrders\"\n            class=\"collapse col-lg-4 col-md-4 col-sm-6 col-12 position-absolute sticky-top card-110\" style=\"max-width:280px;\">\n            <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                <div class=\"card-content my-1\">\n                    <div class=\"box\">\n                        <table>\n                            <thead>\n                                <tr class=\"mb-1\">\n                                    <th class=\"text-start ps-1 text-dark\">\n                                        Price\n                                    </th>\n                                    <th class=\"text-center ps-1 text-dark\">\n                                        Quantity\n                                    </th>\n                                    <th class=\"text-end pe-1 text-dark\">\n                                        Total\n                                    </th>\n                                </tr>\n                            </thead>\n                        </table>\n                        <table class=\"asks\" />\n                        <div class=\"newest\" />\n                        <table class=\"bids\" />\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div class=\"app-container\" style=\"margin-top:40px\">\n            <trading-vue :key=\"resetkey\" ref=\"tvjs\" :data=\"dc\" :width=\"width\" :height=\"height\" :title-txt=\"title\"\n                color-title=\"#ff9f43\" :legend-buttons=\"['display', 'settings', 'up', 'down', 'add', 'remove']\"\n                :chart-config=\"{DEFAULT_LEN:30,MIN_ZOOM:1}\" :color-back=\"colors.colorBack\"\n                :color-grid=\"colors.colorGrid\" :color-text=\"colors.colorText\" :extensions=\"ext\" :overlays=\"ovs\"\n                :night=\"night\" :resetkey=\"resetkey\" :x-settings=\"xsett\" :timezone=\"timezone\" />\n        </div>\n    </div>\n</template>\n\n<script>\nimport { TradingVue, DataCube } from 'trading-vue-js'\nimport Overlays from 'tvjs-overlays'\nimport Data from '../resources/data/data.json'\nimport Utils from './stuff/utils.js'\nimport Const from './stuff/constants.js'\nimport Stream from './stream.js'\nimport Extensions from './index_dev'\n\n// Gettin' data through webpeck proxy\nconst symbolsm = window.location.pathname.toLowerCase().split('/')[3]+'usdt'\nconst symbolbg = window.location.pathname.toUpperCase().split('/')[3]+'USDT'\nconst URL = `https://binance-watch-wrapper.herokuapp.com/https://api.binance.com/api/v1/klines?symbol=`\nconst WSS = `wss://stream.binance.com:9443/ws/${symbolsm}@aggTrade`\nconst datas = `datasets.binance-${symbolsm}`\n//const PORT = location.port\n//const URL = `http://localhost:${PORT}/api/v1/klines?symbol=`\n//const WSS = `ws://localhost:${PORT}/ws/${symbolsm}@aggTrade`\n\nexport default {\n    name: 'App',\n    components: {\n        TradingVue\n    },\n    data() {\n        return {\n            dc: new DataCube(Data),\n            title: symbolbg,\n            width: 0,\n            height: 0,\n            log_scale: true,\n            symbol: symbolbg,\n            index_based: true,\n            timezone: this.timezoned(),\n            xsett: {\n                'grid-resize': { min_height: 30 }\n            },\n            ovs: Object.values(Overlays),\n            ext: Object.values(Extensions),\n            night: true,\n            top: 50,\n            resetkey: 0\n        }\n    },\n    computed: {\n        colors() {\n            return this.night ? {} : {\n                colorBack: '#fff',\n                colorGrid: '#eee',\n                colorText: '#333'\n            }\n        }\n    },\n    mounted() {\n        window.addEventListener('resize', this.onResize)\n        let q = this.win_query()\n        if (q.nm === 'false') this.night = false\n        if (q.ov) this.current = q.ov\n        if (q.header === 'false') this.top = 0\n        this.onResize(),\n        window.dc = this.dc\n        window.tv = this.$refs.tvjs\n        // Load the last data chunk & init DataCube:\n        let now = Utils.now()\n        this.load_chunk([now - Const.HOUR4, now]).then(data => {\n            dc.data.chart.data = data['chart.data']\n            // Register onrange callback & And a stream of trades\n            this.dc.onrange(this.load_chunk)\n            this.stream = new Stream(WSS)\n            this.stream.ontrades = this.on_trades\n            window.dc = this.chart      // Debug\n            window.tv = this.$refs.tvjs // Debug\n        })\n    },\n    beforeDestroy() {\n        window.removeEventListener('resize', this.onResize)\n        if (this.stream) this.stream.off()\n    },\n    methods: {\n        onResize() {\n            if (window.innerWidth < '500') {\n                this.width = window.innerWidth\n                this.height = window.innerHeight * 0.53\n            }/* else if (window.innerWidth > '768'  && window.innerWidth <= '992') {\n                this.width = (window.innerWidth - (window.innerWidth * 0.26))\n            }*/ else {\n                this.width = window.innerWidth * 0.7\n                this.height = window.innerHeight * 0.68\n            }\n\n        },\n        spline () {\n            this.dc.data.chart.type = \"Spline\"\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        candles () {\n            this.dc.data.chart.type = \"Candles\"\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        xbars () {\n            this.data.ovs = 'XOhlcBars'\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        trade () {\n            this.dc.data.chart.type = \"Spline\"\n        },\n        win_query() {\n            let qs = (function(a) {\n                if (a == \"\") return {};\n                var b = {};\n                for (var i = 0; i < a.length; ++i) {\n                    var p=a[i].split('=', 2);\n                    if (p.length == 1)\n                        b[p[0]] = \"\";\n                    else\n                        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n                }\n                return b;\n            })(window.location.search.substr(1).split('&'));\n            return qs\n        },\n        reset(state) {\n            let sub = Object.keys(state).filter(x => state[x])\n            this.extensions = sub.map(x => Extensions[x])\n            this.resetkey++\n        },\n        onselect(id) {\n            this.current = id\n        },\n        timezoned() {\n            var offset = new Date().getTimezoneOffset();\n            var minutes = Math.abs(offset);\n            var hours = Math.floor(minutes / 60);\n            var prefix = offset < 0 ? \"\" : \"-\";\n            return parseInt(prefix+hours);\n        },\n        // New data handler. Should return Promise, or\n        // use callback: load_chunk(range, tf, callback)\n        async load_chunk(range) {\n            let [t1, t2] = range\n            let x = symbolbg\n            let q = `${x}&interval=1m&startTime=${t1}&endTime=${t2}`\n            let r = await fetch(URL + q).then(r => r.json())\n            return this.format(this.parse_binance(r))\n        },\n        // Parse a specific exchange format\n        parse_binance(data) {\n            if (!Array.isArray(data)) return []\n            return data.map(x => {\n                for (var i = 0; i < x.length; i++) {\n                    x[i] = parseFloat(x[i])\n                }\n                return x.slice(0,6)\n            })\n        },\n        format(data) {\n            return {\n                'chart.data': data,\n            }\n        },\n        on_trades(trade) {\n            this.dc.update({\n                t: trade.T,     // Exchange time (optional)\n                price: parseFloat(trade.p),   // Trade price\n                volume: parseFloat(trade.q),  // Trade amount\n                datas : [ // Update dataset\n                    trade.T,\n                    trade.m ? 0 : 1,          // Sell or Buy\n                    parseFloat(trade.q),\n                    parseFloat(trade.p)\n                ],\n                // ... other onchart/offchart updates\n            })\n        }\n    }\n}\n</script>\n\n<style>\n.app-content {\n    padding: calc(2rem + 2.45rem) 0 0 0rem !important;\n    overflow-x: hidden;\n}\n@media (max-width: 767.98px){\n    html body.navbar-sticky .app-content {\n        padding: calc(1rem - 0.8rem + 4.45rem) 0 0 0 !important;\n    }\n}\n.flexed {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    align-content: center;\n    flex-wrap: nowrap;\n}\n\n#app-conainer {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-content: space-between;\n    align-items: flex-start;\n    flex-wrap: nowrap;\n}\n\n/* @media (max-width: 767.98px){\n    #app-conainer {\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        align-content: space-between;\n        align-items: flex-start;\n        flex-wrap: nowrap;\n    }\n} */\n#tradebar {\n    color: #ddd;\n}\n\n#tvjs-header {\n    position: absolute;\n    display: flex;\n    align-content: center;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: center;\n    align-items: center;\n    height: 40px;\n    color: #ddd;\n    width: 100%;\n    background-color: #121826;\n}\n\n.night-mode {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n}\n\n#trading-vue-js-grid-0-canvas,\n#trading-vue-js-sidebar-0-canvas,\n#trading-vue-js-grid-1-canvas,\n#trading-vue-js-sidebar-1-canvas,\n#trading-vue-js-botbar-canvas {\n    background-color: rgb(0 0 0 / 0%) !important;\n}\n\n#trading-vue-tbitem {\n    background-color: rgb(18, 24, 38);\n}\n\n@media only screen and (max-device-width: 480px) {\n    .tf-selector {\n        top: 50px;\n        right: 140px;\n        max-width: 140px;\n        font: 12px -apple-system, BlinkMacSystemFont,\n            Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell,\n            Fira Sans, Droid Sans, Helvetica Neue,\n            sans-serif;\n    }\n}\n\n.box {\n    width: 280px;\n    margin: 0 auto;\n    box-shadow: 0 1.5px 5px -2px rgba(0, 0, 0, 0.2);\n    border-radius: 3px;\n    padding: 0 15px 0 15px;\n}\n\ntable {\n    font-size: 13px;\n    font-weight: 500;\n    color: rgb(183, 189, 198);\n    overflow: hidden;\n    width: 100%;\n}\n\ntd {\n    position: relative;\n    height: 20px;\n    line-height: 20px;\n}\n\ntd.price {\n    width: 30%;\n}\n\ntd.price span {\n    padding-left: 5px;\n}\n\ntd.quantity {\n    width: 30%;\n    text-align: right;\n}\n\ntd.time {\n    width: 40%;\n    text-align: right;\n    color: #999;\n    padding-right: 5px;\n}\n\ntd.btc {\n    width: 40%;\n    text-align: right;\n    padding-right: 5px;\n}\n\ntd span {\n    position: relative;\n    z-index: 2;\n}\n\ntable.asks .percent {\n    background-color: rgba(246, 70, 94, 0.2);\n}\n\ntable.bids .percent {\n    background-color: rgba(14, 203, 129, 0.2);\n}\n\ntd .percent {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n}\n\n.newest {\n    border-bottom: 1px solid #eee;\n    margin: 15px -15px;\n}\n\n.card-110 {\n    top: 110px !important;\n    left: 70px;\n}\n/* Style page content - use this if you want to push the page content to the right when you open the side navigation */\n#main {\n    transition: margin-left .5s;\n    /* If you want a transition effect */\n}\n\n/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */\n@media screen and (max-height: 450px) {\n    .sidebar1 {\n        padding-top: 15px;\n    }\n\n    .sidebar1 a {\n        font-size: 18px;\n    }\n}\n\n.btn-circle {\n    width: 30px;\n    height: 30px;\n    padding: 6px 0px;\n    border-radius: 15px;\n    font-size: 8px;\n    text-align: center;\n}\n\n#chartdiv {\n    min-height: 300px;\n    max-height: 400px;\n    height: 70vh;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-std-input {\r\n    margin: 5px;\r\n    background-color: #161b27;\r\n    border: 1px dotted #353940;\r\n    height: 22px;\r\n    border-radius: 3px;\r\n    padding: 2px 0px 3px 10px;\r\n    color: whitesmoke;\r\n    font-size: 1.2em;\r\n    outline: none;\r\n    width: 100px;\n}\nselect.tvjs-std-input {\r\n    height: 29px;\r\n    -moz-appearance: none;\n}\nselect.tvjs-std-input  {\r\n    //display: none; /*hide original SELECT element: */\n}\n.tvjs-std-input::-moz-placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\n.tvjs-std-input:-ms-input-placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\n.tvjs-std-input::placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\r\n", "",{"version":3,"sources":["webpack://./src/components/StdInput.vue"],"names":[],"mappings":";AA4CA;IACA,WAAA;IACA,yBAAA;IACA,0BAAA;IACA,YAAA;IACA,kBAAA;IACA,yBAAA;IACA,iBAAA;IACA,gBAAA;IACA,aAAA;IACA,YAAA;AACA;AAEA;IACA,YAAA;IACA,qBAAA;AAEA;AAEA;IACA,eAAA,EAAA,iCAAA;AACA;AAGA;IACA,cAAA;IACA,aAAA;AACA;AAHA;IACA,cAAA;IACA,aAAA;AACA;AAHA;IACA,cAAA;IACA,aAAA;AACA","sourcesContent":["<template>\r\n    <span>\r\n        <input\nv-if=\"type==='text' || !type\"\r\n            :value=\"value\"\nclass=\"tvjs-std-input\"\n:style=\"style\"\r\n            :placeholder=\"name\"\r\n            @change=\"$emit('change', $event.target.value)\"\r\n            @input=\"$emit('input', $event.target.value)\"\n>\r\n        <select\nv-else-if=\"type==='select'\"\r\n            class=\"tvjs-std-input\"\n:style=\"style\"\r\n            :value=\"value\"\r\n            @input=\"$emit('input', $event.target.value)\"\n>\r\n            <option v-for=\"opt in list\">{{ opt }}</option>\r\n        </select>\r\n    </span>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name: 'StdInput',\r\n    props: ['value', 'name', 'type', 'list', 'colors'],\r\n    data() {\r\n        return {\r\n        }\r\n    },\r\n    computed: {\r\n        style() {\r\n            return {\r\n                //background: this.$props.colors.back,\r\n                //color: this.$props.colors.text\r\n            }\r\n        }\r\n    },\r\n    methods: {}\r\n}\r\n</script>\r\n\r\n<style>\r\n.tvjs-std-input {\r\n    margin: 5px;\r\n    background-color: #161b27;\r\n    border: 1px dotted #353940;\r\n    height: 22px;\r\n    border-radius: 3px;\r\n    padding: 2px 0px 3px 10px;\r\n    color: whitesmoke;\r\n    font-size: 1.2em;\r\n    outline: none;\r\n    width: 100px;\r\n}\r\n\r\nselect.tvjs-std-input {\r\n    height: 29px;\r\n    -moz-appearance: none;\r\n\r\n}\r\n\r\nselect.tvjs-std-input  {\r\n    //display: none; /*hide original SELECT element: */\r\n}\r\n\r\n\r\n.tvjs-std-input::placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window {\r\n    position: absolute;\r\n    background: #1b202def;\r\n    border-radius: 3px;\r\n    pointer-events: all;\r\n    padding-left: 7px;\r\n    z-index: 100;\r\n    color: #dedddd;\n}\n.tvjs-x-window-head {\r\n    font-size: 2em;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n        -ms-user-select: none;\r\n            user-select: none;\r\n    display: flex;\r\n    flex-direction: row;\r\n    flex-wrap: nowrap;\r\n    justify-content: flex-start;\r\n    align-content: center;\r\n    align-items: center;\r\n    height: 36px;\r\n    padding: 10px;\r\n    cursor: -webkit-grab;\r\n    cursor: grab;\n}\n.tvjs-x-window-body {\r\n    padding: 10px;\r\n    font-size: 1.1em;\n}\n.tvjs-x-window-title {\r\n    width: 300px;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n        -ms-user-select: none;\r\n            user-select: none;\n}\n.tvjs-x-window-close {\r\n    width: 26px;\r\n    cursor: pointer;\r\n    margin: -1em;\r\n    padding: 1em;\r\n    font-size: 0.75em;\n}\r\n", "",{"version":3,"sources":["webpack://./src/components/Window.vue"],"names":[],"mappings":";AAgEA;IACA,kBAAA;IACA,qBAAA;IACA,kBAAA;IACA,mBAAA;IACA,iBAAA;IACA,YAAA;IACA,cAAA;AACA;AACA;IACA,cAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;IACA,aAAA;IACA,mBAAA;IACA,iBAAA;IACA,2BAAA;IACA,qBAAA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,oBAAA;IAAA,YAAA;AACA;AAEA;IACA,aAAA;IACA,gBAAA;AACA;AACA;IACA,YAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;AACA;AACA;IACA,WAAA;IACA,eAAA;IACA,YAAA;IACA,YAAA;IACA,iBAAA;AACA","sourcesContent":["<template>\r\n    <div\nref=\"win\"\nclass=\"tvjs-x-window\"\n:style=\"style\"\n>\r\n        <div class=\"tvjs-x-window-head\">\r\n            <div\nclass=\"tvjs-x-window-title\"\r\n                @mousedown=\"onMouseDown\"\n>\r\n                {{ title }}\r\n            </div>\r\n            <div\nclass=\"tvjs-x-window-close\"\r\n                @click=\"$emit('close')\"\n>\r\n                ╳\r\n            </div>\r\n        </div>\r\n        <div class=\"tvjs-x-window-body\">\r\n            <slot />\r\n        </div>\r\n    </div>\r\n</template>\r\n<script>\r\n\r\nimport Dragg from './dragg.js'\r\n\r\nexport default {\r\n    name: 'Window',\r\n    mixins: [Dragg],\r\n    props: ['title', 'tv'],\r\n    data() {\r\n        return {\r\n            ww: 0,\r\n            wh: 0,\r\n            x: 0,\r\n            y: 0\r\n        }\r\n    },\r\n    computed: {\r\n        style() {\r\n            return {\r\n                top: `${this.y}px`,\r\n                left: `${this.x}px`\r\n            }\r\n        },\r\n        tvw() {\r\n            return this.$props.tv.width\r\n        },\r\n        tvh() {\r\n            return this.$props.tv.height\r\n        }\r\n    },\r\n    mounted() {\r\n        this.ww = this.$refs.win.clientWidth\r\n        this.wh = this.$refs.win.clientHeight\r\n        this.x = this.tvw * 0.5 - this.ww * 0.5\r\n        this.y = this.tvh * 0.5 - this.wh * 0.5\r\n    }\r\n}\r\n</script>\r\n<style>\r\n.tvjs-x-window {\r\n    position: absolute;\r\n    background: #1b202def;\r\n    border-radius: 3px;\r\n    pointer-events: all;\r\n    padding-left: 7px;\r\n    z-index: 100;\r\n    color: #dedddd;\r\n}\r\n.tvjs-x-window-head {\r\n    font-size: 2em;\r\n    user-select: none;\r\n    display: flex;\r\n    flex-direction: row;\r\n    flex-wrap: nowrap;\r\n    justify-content: flex-start;\r\n    align-content: center;\r\n    align-items: center;\r\n    height: 36px;\r\n    padding: 10px;\r\n    cursor: grab;\r\n}\r\n\r\n.tvjs-x-window-body {\r\n    padding: 10px;\r\n    font-size: 1.1em;\r\n}\r\n.tvjs-x-window-title {\r\n    width: 300px;\r\n    user-select: none;\r\n}\r\n.tvjs-x-window-close {\r\n    width: 26px;\r\n    cursor: pointer;\r\n    margin: -1em;\r\n    padding: 1em;\r\n    font-size: 0.75em;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.h-splitter[data-v-189fccad] {\r\n    position: absolute;\r\n    left: 0;\r\n    height: 5px;\r\n    margin-top: -2px;\r\n    width: 100%;\r\n    z-index: 1;\r\n    background-color: #3ee4afb5;\r\n    opacity: 0;\r\n    pointer-events: all;\n}\n.h-splitter[data-v-189fccad]:hover {\r\n    cursor: row-resize;\r\n    opacity: 1;\n}\r\n", "",{"version":3,"sources":["webpack://./src/extensions/grid-resize/Splitter.vue"],"names":[],"mappings":";AAkEA;IACA,kBAAA;IACA,OAAA;IACA,WAAA;IACA,gBAAA;IACA,WAAA;IACA,UAAA;IACA,2BAAA;IACA,UAAA;IACA,mBAAA;AACA;AACA;IACA,kBAAA;IACA,UAAA;AACA","sourcesContent":["<template>\r\n    <span\nclass=\"h-splitter\"\r\n        :style=\"hs_style\"\n@mousedown=\"hs_mousedown\"\n/>\r\n</template>\r\n<script>\r\n\r\nimport Utils from './utils.js'\r\n\r\nexport default {\r\n    name: 'Splitter',\r\n    props: ['id', 'main', 'dc', 'tv', 'data'],\r\n    computed: {\r\n        hs_style() {\r\n            return {\r\n                drag: null,\r\n                top: this.data.grid2.offset + 'px',\r\n                //backgroundColor: this.colors.splitter\r\n            }\r\n        },\r\n    },\r\n    mounted() {\r\n        this.MIN_HEIGHT = this.data.sett.min_height || 20\r\n    },\r\n    methods: {\r\n        hs_mousedown(e) {\r\n            this.drag = {\r\n                type: 'hs',\r\n                y: e.clientY,\r\n                h1: this.data.grid1.height,\r\n                h2: this.data.grid2.height\r\n            }\r\n            Utils.add_style('disable-user-select', `body * {\r\n                user-select: none;\r\n            }\r\n            .trading-vue-chart {\r\n                pointer-events: none;\r\n            }`)\r\n        },\r\n        hs_mouseup(e) {\r\n            this.drag = null\r\n            Utils.rem_style('disable-user-select')\r\n        },\r\n        hs_mousemove(e) {\r\n            if (this.drag) {\r\n                let off = e.clientY - this.drag.y\r\n                let new_h1 = this.drag.h1 + off\r\n                let new_h2 = this.drag.h2 - off\r\n                if (new_h1 > this.MIN_HEIGHT &&\r\n                    new_h2 > this.MIN_HEIGHT) {\r\n                    this.data.grid1.height = new_h1\r\n                    this.data.grid2.height = new_h2\r\n                }\r\n                this.main.calc_heights()\r\n            }\r\n        },\r\n        hs_mouseleave(e) {\r\n            this.drag = null\r\n            Utils.rem_style('disable-user-select')\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style scoped>\r\n.h-splitter {\r\n    position: absolute;\r\n    left: 0;\r\n    height: 5px;\r\n    margin-top: -2px;\r\n    width: 100%;\r\n    z-index: 1;\r\n    background-color: #3ee4afb5;\r\n    opacity: 0;\r\n    pointer-events: all;\r\n}\r\n.h-splitter:hover {\r\n    cursor: row-resize;\r\n    opacity: 1;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window.add-win[data-v-53408ac7] {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.add-win-list[data-v-53408ac7] {\n    height: 300px;\n    overflow-x: hidden;\n    overflow-y: auto;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n/* Hide scrollbar for Chrome, Safari and Opera */\n.add-win-list[data-v-53408ac7]::-webkit-scrollbar {\n  display: none;\n}\n\n/* Hide scrollbar for IE, Edge and Firefox */\n.add-win-list[data-v-53408ac7] {\n  -ms-overflow-style: none;  /* IE and Edge */\n  scrollbar-width: none;  /* Firefox */\n}\n.add-win-item[data-v-53408ac7] {\n    color: #ffffff88;\n    width: 100%;\n    padding: 5px;\n    cursor: pointer;\n}\n.add-win-item[data-v-53408ac7]:hover {\n    background: #88888822;\n    color: #ffffffff;\n}\n.add-win-item-desc[data-v-53408ac7] {\n    color: #ffffff33;\n    margin-left: 3px;\n}\n.add-win-item:hover .add-win-item-desc[data-v-53408ac7] {\n    color: #ffffff44;\n}\n.add-win-empty[data-v-53408ac7] {\n    opacity: 0.5;\n}\n", "",{"version":3,"sources":["webpack://./src/extensions/legend-buttons/AddWin.vue"],"names":[],"mappings":";AAgDA;IACA,oBAAA;IACA,2BAAA;AACA;AACA;IACA,aAAA;IACA,kBAAA;IACA,gBAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;AACA;AACA,gDAAA;AACA;EACA,aAAA;AACA;;AAEA,4CAAA;AACA;EACA,wBAAA,GAAA,gBAAA;EACA,qBAAA,GAAA,YAAA;AACA;AACA;IACA,gBAAA;IACA,WAAA;IACA,YAAA;IACA,eAAA;AACA;AACA;IACA,qBAAA;IACA,gBAAA;AACA;AACA;IACA,gBAAA;IACA,gBAAA;AACA;AACA;IACA,gBAAA;AACA;AACA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <window title=\"Add Indicator\" class=\"add-win\" :tv=\"tv\" @close=\"on_close\">\n        <div class=\"add-win-list\">\n            <div v-for=\"ov of ovs\" class=\"add-win-item\" @click=\"on_click(ov.name)\">\n                <span>{{ ov.name }}</span>\n                <span class=\"add-win-item-desc\">\n                    {{ ov.methods.meta_info().desc }}\n                </span>\n            </div>\n        </div>\n    </window>\n</template>\n<script>\n\nimport Window from '../../components/Window.vue'\n\nexport default {\n    name: 'AddWin',\n    components: { Window },\n    props: ['id', 'main', 'dc', 'tv', 'data'],\n    data() {\n        return {\n            ovs: this.tv.overlays.filter(x => x.methods.calc)\n        }\n    },\n    computed: {\n        sett() {\n            return this.$props.data.ov.settings\n        }\n    },\n    mounted() {\n    },\n    methods: {\n        on_close() {\n            this.$props.main.remove_widget(this.$props.id)\n        },\n        on_click(name) {\n            this.on_close()\n            this.main.add_overlay({\n                side: this.data.type,\n                index: this.data.index,\n                type: name\n            })\n        }\n    }\n}\n</script>\n<style scoped>\n.tvjs-x-window.add-win {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.add-win-list {\n    height: 300px;\n    overflow-x: hidden;\n    overflow-y: auto;\n    user-select: none;\n}\n/* Hide scrollbar for Chrome, Safari and Opera */\n.add-win-list::-webkit-scrollbar {\n  display: none;\n}\n\n/* Hide scrollbar for IE, Edge and Firefox */\n.add-win-list {\n  -ms-overflow-style: none;  /* IE and Edge */\n  scrollbar-width: none;  /* Firefox */\n}\n.add-win-item {\n    color: #ffffff88;\n    width: 100%;\n    padding: 5px;\n    cursor: pointer;\n}\n.add-win-item:hover {\n    background: #88888822;\n    color: #ffffffff;\n}\n.add-win-item-desc {\n    color: #ffffff33;\n    margin-left: 3px;\n}\n.add-win-item:hover .add-win-item-desc {\n    color: #ffffff44;\n}\n.add-win-empty {\n    opacity: 0.5;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window.sett-win[data-v-5d223b0e] {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.sett-win-item[data-v-5d223b0e] {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-content: center;\n    align-items: center;\n}\n.sett-win-item label[data-v-5d223b0e] {\n    min-width: 80px;\n    color: #35a776;\n}\n.sett-win-empty[data-v-5d223b0e] {\n    opacity: 0.5;\n}\n", "",{"version":3,"sources":["webpack://./src/extensions/settings-win/SettingsWin.vue"],"names":[],"mappings":";AAsDA;IACA,oBAAA;IACA,2BAAA;AACA;AACA;IACA,aAAA;IACA,mBAAA;IACA,iBAAA;IACA,2BAAA;IACA,qBAAA;IACA,mBAAA;AACA;AACA;IACA,eAAA;IACA,cAAA;AACA;AACA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <window :title=\"data.ov.name\" class=\"sett-win\" :tv=\"tv\" @close=\"on_close\">\n        <div v-for=\"k in settlist\" class=\"sett-win-item\">\n            <label>{{ s2d(k) }}</label>\n            <std-input :value=\"sett[k]\" @input=\"update_sett(k, $event)\" />\n        </div>\n        <span v-if=\"!settlist.length\" class=\"sett-win-empty\">\n            <i>No script settings</i>\n        </span>\n    </window>\n</template>\n<script>\n\nimport Window from '../../components/Window.vue'\nimport StdInput from '../../components/StdInput.vue'\nimport Utils from './utils.js'\n\nexport default {\n    name: 'SettingsWin',\n    components: { Window, StdInput },\n    props: ['id', 'main', 'dc', 'tv', 'data'],\n    computed: {\n        sett() {\n            return this.$props.data.ov.settings\n        },\n        settlist() {\n            return Object.keys(this.sett).filter(x =>\n                x[0] !== '$' && this.sett.$props &&\n                this.sett.$props.includes(x))\n        }\n    },\n    mounted() {\n    },\n    methods: {\n        s2d(str) {\n            return Utils.sett2desc(str)\n        },\n        on_close() {\n            this.$props.main.remove_widget(this.$props.id)\n        },\n        update_sett(k, val) {\n            let dcid = this.$props.data.ov.id\n\n            let valN = parseFloat(val)\n            if (valN !== valN) valN = val\n\n            this.$props.dc.merge(`${dcid}.settings`,\n                { [k]: valN }\n            )\n        }\n    }\n}\n</script>\n<style scoped>\n.tvjs-x-window.sett-win {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.sett-win-item {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-content: center;\n    align-items: center;\n}\n.sett-win-item label {\n    min-width: 80px;\n    color: #35a776;\n}\n.sett-win-empty {\n    opacity: 0.5;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js":
/*!******************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=style&index=0&lang=css&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=style&index=0&lang=css& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./MainM.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/trading-vue-js/dist/trading-vue.js":
/*!*********************************************************!*\
  !*** ./node_modules/trading-vue-js/dist/trading-vue.js ***!
  \*********************************************************/
/***/ ((module) => {

/*!
 * TradingVue.JS - v1.0.2 - Thu Mar 18 2021
 *     https://github.com/tvjsx/trading-vue-js
 *     Copyright (c) 2019 C451 Code's All Right;
 *     Licensed under the MIT license
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 757:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_694__) => {

module.exports = __nested_webpack_require_694__(666);


/***/ }),

/***/ 546:
/***/ ((module) => {

/**
 * Utility compare functions
 */

module.exports = {

    /**
     * Compare two numbers.
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    numcmp: function (a, b) {
        return a - b;
    },

    /**
     * Compare two strings.
     *
     * @param {Number|String} a
     * @param {Number|String} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    strcmp: function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

};


/***/ }),

/***/ 678:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1415__) => {

/**
 * Indexed Array Binary Search module
 */

/**
 * Dependencies
 */
var util = __nested_webpack_require_1415__(500),
    cmp = __nested_webpack_require_1415__(546),
    bin = __nested_webpack_require_1415__(101);

/**
 * Module interface definition
 */
module.exports = IndexedArray;

/**
 * Indexed Array constructor
 *
 * It loads the array data, defines the index field and the comparison function
 * to be used.
 *
 * @param {Array} data is an array of objects
 * @param {String} index is the object's property used to search the array
 */
function IndexedArray(data, index) {

    // is data sortable array or array-like object?
    if (!util.isSortableArrayLike(data))
        throw new Error("Invalid data");

    // is index a valid property?
    if (!index || data.length > 0 && !(index in data[0]))
        throw new Error("Invalid index");

    // data array
    this.data = data;

    // name of the index property
    this.index = index;

    // set index boundary values
    this.setBoundaries();

    // default comparison function
    this.compare = typeof this.minv === "number" ? cmp.numcmp : cmp.strcmp;

    // default search function
    this.search = bin.search;

    // cache of index values to array positions
    // each value stores an object as { found: true|false, index: array-index }
    this.valpos = {};

    // cursor and adjacent positions
    this.cursor = null;
    this.nextlow = null;
    this.nexthigh = null;
}

/**
 * Set the comparison function
 *
 * @param {Function} fn to compare index values that returnes 1, 0, -1
 */
IndexedArray.prototype.setCompare = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.compare = fn;
    return this;
};

/**
 * Set the search function
 *
 * @param {Function} fn to search index values in the array of objects
 */
IndexedArray.prototype.setSearch = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.search = fn;
    return this;
};

/**
 * Sort the data array by its index property
 */
IndexedArray.prototype.sort = function () {
    var self = this,
        index = this.index;

    // sort the array
    this.data.sort(function (a, b) {
        return self.compare(a[index], b[index]);
    });

    // recalculate boundary values
    this.setBoundaries();

    return this;
};

/**
 * Inspect and set the boundaries of the internal data array
 */
IndexedArray.prototype.setBoundaries = function () {
    var data = this.data,
        index = this.index;

    this.minv = data.length && data[0][index];
    this.maxv = data.length && data[data.length - 1][index];

    return this;
};

/**
 * Get the position of the object corresponding to the given index
 *
 * @param {Number|String} index is the id of the requested object
 * @returns {Number} the position of the object in the array
 */
IndexedArray.prototype.fetch = function (value) {
    // check data has objects
    if (this.data.length === 0) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = null;
        return this;
    }

    // check the request is within range
    if (this.compare(value, this.minv) === -1) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = 0;
        return this;
    }
    if (this.compare(value, this.maxv) === 1) {
        this.cursor = null;
        this.nextlow = this.data.length - 1;
        this.nexthigh = null;
        return this;
    }

    var valpos = this.valpos,
        pos = valpos[value];

    // if the request is memorized, just give it back
    if (pos) {
        if (pos.found) {
            this.cursor = pos.index;
            this.nextlow = null;
            this.nexthigh = null;
        } else {
            this.cursor = null;
            this.nextlow = pos.prev;
            this.nexthigh = pos.next;
        }
        return this;
    }

    // if not, do the search
    var result = this.search.call(this, value);
    this.cursor = result.index;
    this.nextlow = result.prev;
    this.nexthigh = result.next;
    return this;
};

/**
 * Get the object corresponding to the given index
 *
 * When no value is given, the function will default to the last fetched item.
 *
 * @param {Number|String} [optional] index is the id of the requested object
 * @returns {Object} the found object or null
 */
IndexedArray.prototype.get = function (value) {
    if (value)
        this.fetch(value);

    var pos = this.cursor;
    return pos !== null ? this.data[pos] : null;
};

/**
 * Get an slice of the data array
 *
 * Boundaries have to be in order.
 *
 * @param {Number|String} begin index is the id of the requested object
 * @param {Number|String} end index is the id of the requested object
 * @returns {Object} the slice of data array or []
 */
IndexedArray.prototype.getRange = function (begin, end) {
    // check if boundaries are in order
    if (this.compare(begin, end) === 1) {
        return [];
    }

    // fetch start and default to the next index above
    this.fetch(begin);
    var start = this.cursor || this.nexthigh;

    // fetch finish and default to the next index below
    this.fetch(end);
    var finish = this.cursor || this.nextlow;

    // if any boundary is not set, return no range
    if (start === null || finish === null) {
        return [];
    }

    // return range
    return this.data.slice(start, finish + 1);
};


/***/ }),

/***/ 101:
/***/ ((module) => {

/**
 * Binary search implementation
 */

/**
 * Main search recursive function
 */
function loop(data, min, max, index, valpos) {

    // set current position as the middle point between min and max
    var curr = (max + min) >>> 1;

    // compare current index value with the one we are looking for
    var diff = this.compare(data[curr][this.index], index);

    // found?
    if (!diff) {
        return valpos[index] = {
            "found": true,
            "index": curr,
            "prev": null,
            "next": null
        };
    }

    // no more positions available?
    if (min >= max) {
        return valpos[index] = {
            "found": false,
            "index": null,
            "prev": (diff < 0) ? max : max - 1,
            "next": (diff < 0) ? max + 1 : max
        };
    }

    // continue looking for index in one of the remaining array halves
    // current position can be skept as index is not there...
    if (diff > 0)
        return loop.call(this, data, min, curr - 1, index, valpos);
    else
        return loop.call(this, data, curr + 1, max, index, valpos);
}

/**
 * Search bootstrap
 * The function has to be executed in the context of the IndexedArray object
 */
function search(index) {
    var data = this.data;
    return loop.call(this, data, 0, data.length - 1, index, this.valpos);
}

/**
 * Export search function
 */
module.exports.search = search;


/***/ }),

/***/ 500:
/***/ ((module) => {

/**
 * Utils module
 */

/**
 * Check if an object is an array-like object
 *
 * @credit Javascript: The Definitive Guide, O'Reilly, 2011
 */
function isArrayLike(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        isFinite(o.length) &&                // o.length is a finite number
        o.length >= 0 &&                     // o.length is non-negative
        o.length === Math.floor(o.length) && // o.length is an integer
        o.length < 4294967296)               // o.length < 2^32
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for the existence of the sort function in the object
 */
function isSortable(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        typeof o.sort === "function")        // o.sort is a function
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for sortable-array-like objects
 */
module.exports.isSortableArrayLike = function (o) {
    return isArrayLike(o) && isSortable(o);
};


/***/ }),

/***/ 851:
/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_9759__) => {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_9759__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_9759__.d(__webpack_exports__, {
  "Candle": () => (/* reexport */ CandleExt),
  "Constants": () => (/* reexport */ constants),
  "DataCube": () => (/* reexport */ DataCube),
  "Interface": () => (/* reexport */ mixins_interface),
  "Overlay": () => (/* reexport */ overlay),
  "Tool": () => (/* reexport */ tool),
  "TradingVue": () => (/* reexport */ TradingVue),
  "Utils": () => (/* reexport */ utils),
  "Volbar": () => (/* reexport */ VolbarExt),
  "default": () => (/* binding */ src),
  "layout_cnv": () => (/* reexport */ layout_cnv),
  "layout_vol": () => (/* reexport */ layout_vol),
  "primitives": () => (/* binding */ primitives)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=template&id=235c0ade&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "trading-vue",
      style: {
        color: this.chart_props.colors.text,
        font: this.font_comp,
        width: this.width + "px",
        height: this.height + "px"
      },
      attrs: { id: _vm.id },
      on: { mousedown: _vm.mousedown, mouseleave: _vm.mouseleave }
    },
    [
      _vm.toolbar
        ? _c(
            "toolbar",
            _vm._b(
              {
                ref: "toolbar",
                attrs: { config: _vm.chart_config },
                on: { "custom-event": _vm.custom_event }
              },
              "toolbar",
              _vm.chart_props,
              false
            )
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.controllers.length
        ? _c("widgets", {
            ref: "widgets",
            attrs: {
              map: _vm.ws,
              width: _vm.width,
              height: _vm.height,
              tv: this,
              dc: _vm.data
            }
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "chart",
        _vm._b(
          {
            key: _vm.reset,
            ref: "chart",
            attrs: { tv_id: _vm.id, config: _vm.chart_config },
            on: {
              "custom-event": _vm.custom_event,
              "range-changed": _vm.range_changed,
              "legend-button-click": _vm.legend_button
            }
          },
          "chart",
          _vm.chart_props,
          false
        )
      ),
      _vm._v(" "),
      _c(
        "transition",
        { attrs: { name: "tvjs-drift" } },
        [
          _vm.tip
            ? _c("the-tip", {
                attrs: { data: _vm.tip },
                on: {
                  "remove-me": function($event) {
                    _vm.tip = null
                  }
                }
              })
            : _vm._e()
        ],
        1
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=template&id=235c0ade&

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./src/stuff/constants.js
var SECOND = 1000;
var MINUTE = SECOND * 60;
var MINUTE3 = MINUTE * 3;
var MINUTE5 = MINUTE * 5;
var MINUTE15 = MINUTE * 15;
var MINUTE30 = MINUTE * 30;
var HOUR = MINUTE * 60;
var HOUR4 = HOUR * 4;
var HOUR12 = HOUR * 12;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = WEEK * 4;
var YEAR = DAY * 365;
var MONTHMAP = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; // Grid time steps

var TIMESCALES = [YEAR * 10, YEAR * 5, YEAR * 3, YEAR * 2, YEAR, MONTH * 6, MONTH * 4, MONTH * 3, MONTH * 2, MONTH, DAY * 15, DAY * 10, DAY * 7, DAY * 5, DAY * 3, DAY * 2, DAY, HOUR * 12, HOUR * 6, HOUR * 3, HOUR * 1.5, HOUR, MINUTE30, MINUTE15, MINUTE * 10, MINUTE5, MINUTE * 2, MINUTE]; // Grid $ steps

var $SCALES = [0.05, 0.1, 0.2, 0.25, 0.5, 0.8, 1, 2, 5];
var ChartConfig = {
  SBMIN: 60,
  // Minimal sidebar px
  SBMAX: Infinity,
  // Max sidebar, px
  TOOLBAR: 57,
  // Toolbar width px
  TB_ICON: 25,
  // Toolbar icon size px
  TB_ITEM_M: 6,
  // Toolbar item margin px
  TB_ICON_BRI: 1,
  // Toolbar icon brightness
  TB_ICON_HOLD: 420,
  // ms, wait to expand
  TB_BORDER: 1,
  // Toolbar border px
  TB_B_STYLE: 'dotted',
  // Toolbar border style
  TOOL_COLL: 7,
  // Tool collision threshold
  EXPAND: 0.15,
  // %/100 of range
  CANDLEW: 0.6,
  // %/100 of step
  GRIDX: 100,
  // px
  GRIDY: 47,
  // px
  BOTBAR: 28,
  // px
  PANHEIGHT: 22,
  // px
  DEFAULT_LEN: 50,
  // candles
  MINIMUM_LEN: 5,
  // candles,
  MIN_ZOOM: 25,
  // candles
  MAX_ZOOM: 1000,
  // candles,
  VOLSCALE: 0.15,
  // %/100 of height
  UX_OPACITY: 0.9,
  // Ux background opacity
  ZOOM_MODE: 'tv',
  // 'tv' or 'tl'
  L_BTN_SIZE: 21,
  // Legend Button size, px
  L_BTN_MARGIN: '-6px 0 -6px 0',
  // css margin
  SCROLL_WHEEL: 'prevent' // 'pass', 'click'

};
ChartConfig.FONT = "11px -apple-system,BlinkMacSystemFont,\n    Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,\n    Fira Sans,Droid Sans,Helvetica Neue,\n    sans-serif";
var IB_TF_WARN = "When using IB mode you should specify " + "timeframe ('tf' filed in 'chart' object)," + "otherwise you can get an unexpected behaviour";
var MAP_UNIT = {
  "1s": SECOND,
  "5s": SECOND * 5,
  "10s": SECOND * 10,
  "20s": SECOND * 20,
  "30s": SECOND * 30,
  "1m": MINUTE,
  "3m": MINUTE3,
  "5m": MINUTE5,
  "15m": MINUTE15,
  "30m": MINUTE30,
  "1H": HOUR,
  "2H": HOUR * 2,
  "3H": HOUR * 3,
  "4H": HOUR4,
  "12H": HOUR12,
  "1D": DAY,
  "1W": WEEK,
  "1M": MONTH,
  "1Y": YEAR
};
/* harmony default export */ const constants = ({
  SECOND: SECOND,
  MINUTE: MINUTE,
  MINUTE5: MINUTE5,
  MINUTE15: MINUTE15,
  MINUTE30: MINUTE30,
  HOUR: HOUR,
  HOUR4: HOUR4,
  DAY: DAY,
  WEEK: WEEK,
  MONTH: MONTH,
  YEAR: YEAR,
  MONTHMAP: MONTHMAP,
  TIMESCALES: TIMESCALES,
  $SCALES: $SCALES,
  ChartConfig: ChartConfig,
  map_unit: MAP_UNIT,
  IB_TF_WARN: IB_TF_WARN
});
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Chart.vue?vue&type=template&id=4d06a4de&
var Chartvue_type_template_id_4d06a4de_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-chart", style: _vm.styles },
    [
      _c("keyboard", { ref: "keyboard" }),
      _vm._v(" "),
      _vm._l(this._layout.grids, function(grid, i) {
        return _c("grid-section", {
          key: grid.id,
          ref: "sec",
          refInFor: true,
          attrs: { common: _vm.section_props(i), grid_id: i },
          on: {
            "register-kb-listener": _vm.register_kb,
            "remove-kb-listener": _vm.remove_kb,
            "range-changed": _vm.range_changed,
            "cursor-changed": _vm.cursor_changed,
            "cursor-locked": _vm.cursor_locked,
            "sidebar-transform": _vm.set_ytransform,
            "layer-meta-props": _vm.layer_meta_props,
            "custom-event": _vm.emit_custom_event,
            "legend-button-click": _vm.legend_button_click
          }
        })
      }),
      _vm._v(" "),
      _c(
        "botbar",
        _vm._b(
          { attrs: { shaders: _vm.shaders, timezone: _vm.timezone } },
          "botbar",
          _vm.botbar_props,
          false
        )
      )
    ],
    2
  )
}
var Chartvue_type_template_id_4d06a4de_staticRenderFns = []
Chartvue_type_template_id_4d06a4de_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Chart.vue?vue&type=template&id=4d06a4de&

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
;// CONCATENATED MODULE: ./src/stuff/context.js
// Canvas context for text measurments
function Context($p) {
  var el = document.createElement('canvas');
  var ctx = el.getContext("2d");
  ctx.font = $p.font;
  return ctx;
}

/* harmony default export */ const context = (Context);
// EXTERNAL MODULE: ./node_modules/arrayslicer/lib/index.js
var lib = __nested_webpack_require_9759__(678);
var lib_default = /*#__PURE__*/__nested_webpack_require_9759__.n(lib);
;// CONCATENATED MODULE: ./src/stuff/utils.js



/* harmony default export */ const utils = ({
  clamp: function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
  },
  add_zero: function add_zero(i) {
    if (i < 10) {
      i = "0" + i;
    }

    return i;
  },
  // Start of the day (zero millisecond)
  day_start: function day_start(t) {
    var start = new Date(t);
    return start.setUTCHours(0, 0, 0, 0);
  },
  // Start of the month
  month_start: function month_start(t) {
    var date = new Date(t);
    return Date.UTC(date.getFullYear(), date.getMonth(), 1);
  },
  // Start of the year
  year_start: function year_start(t) {
    return Date.UTC(new Date(t).getFullYear());
  },
  get_year: function get_year(t) {
    if (!t) return undefined;
    return new Date(t).getUTCFullYear();
  },
  get_month: function get_month(t) {
    if (!t) return undefined;
    return new Date(t).getUTCMonth();
  },
  // Nearest in array
  nearest_a: function nearest_a(x, array) {
    var dist = Infinity;
    var val = null;
    var index = -1;

    for (var i = 0; i < array.length; i++) {
      var xi = array[i];

      if (Math.abs(xi - x) < dist) {
        dist = Math.abs(xi - x);
        val = xi;
        index = i;
      }
    }

    return [index, val];
  },
  round: function round(num, decimals) {
    if (decimals === void 0) {
      decimals = 8;
    }

    return parseFloat(num.toFixed(decimals));
  },
  // Strip? No, it's ugly floats in js
  strip: function strip(number) {
    return parseFloat(parseFloat(number).toPrecision(12));
  },
  get_day: function get_day(t) {
    return t ? new Date(t).getDate() : null;
  },
  // Update array keeping the same reference
  overwrite: function overwrite(arr, new_arr) {
    arr.splice.apply(arr, [0, arr.length].concat(_toConsumableArray(new_arr)));
  },
  // Copy layout in reactive way
  copy_layout: function copy_layout(obj, new_obj) {
    for (var k in obj) {
      if (Array.isArray(obj[k])) {
        // (some offchart indicators are added/removed)
        // we need to update layout in a reactive way
        if (obj[k].length !== new_obj[k].length) {
          this.overwrite(obj[k], new_obj[k]);
          continue;
        }

        for (var m in obj[k]) {
          Object.assign(obj[k][m], new_obj[k][m]);
        }
      } else {
        Object.assign(obj[k], new_obj[k]);
      }
    }
  },
  // Detects candles interval
  detect_interval: function detect_interval(ohlcv) {
    var len = Math.min(ohlcv.length - 1, 99);
    var min = Infinity;
    ohlcv.slice(0, len).forEach(function (x, i) {
      var d = ohlcv[i + 1][0] - x[0];
      if (d === d && d < min) min = d;
    }); // This saves monthly chart from being awkward

    if (min >= constants.MONTH && min <= constants.DAY * 30) {
      return constants.DAY * 31;
    }

    return min;
  },
  // Gets numberic part of overlay id (e.g 'EMA_1' = > 1)
  get_num_id: function get_num_id(id) {
    return parseInt(id.split('_').pop());
  },
  // Fast filter. Really fast, like 10X
  fast_filter: function fast_filter(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];

    try {
      var ia = new (lib_default())(arr, "0");
      var res = ia.getRange(t1, t2);
      var i0 = ia.valpos[t1].next;
      return [res, i0];
    } catch (e) {
      // Something wrong with fancy slice lib
      // Fast fix: fallback to filter
      return [arr.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }), 0];
    }
  },
  // Fast filter (index-based)
  fast_filter_i: function fast_filter_i(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];
    var i1 = Math.floor(t1);
    if (i1 < 0) i1 = 0;
    var i2 = Math.floor(t2 + 1);
    var res = arr.slice(i1, i2);
    return [res, i1];
  },
  // Nearest indexes (left and right)
  fast_nearest: function fast_nearest(arr, t1) {
    var ia = new (lib_default())(arr, "0");
    ia.fetch(t1);
    return [ia.nextlow, ia.nexthigh];
  },
  now: function now() {
    return new Date().getTime();
  },
  pause: function pause(delay) {
    return new Promise(function (rs, rj) {
      return setTimeout(rs, delay);
    });
  },
  // Limit crazy wheel delta values
  smart_wheel: function smart_wheel(delta) {
    var abs = Math.abs(delta);

    if (abs > 500) {
      return (200 + Math.log(abs)) * Math.sign(delta);
    }

    return delta;
  },
  // Parse the original mouse event to find deltaX
  get_deltaX: function get_deltaX(event) {
    return event.originalEvent.deltaX / 12;
  },
  // Parse the original mouse event to find deltaY
  get_deltaY: function get_deltaY(event) {
    return event.originalEvent.deltaY / 12;
  },
  // Apply opacity to a hex color
  apply_opacity: function apply_opacity(c, op) {
    if (c.length === 7) {
      var n = Math.floor(op * 255);
      n = this.clamp(n, 0, 255);
      c += n.toString(16);
    }

    return c;
  },
  // Parse timeframe or return value in ms
  parse_tf: function parse_tf(smth) {
    if (typeof smth === 'string') {
      return constants.map_unit[smth];
    } else {
      return smth;
    }
  },
  // Detect index shift between the main data sub
  // and the overlay's sub (for IB-mode)
  index_shift: function index_shift(sub, data) {
    // Find the second timestamp (by value)
    if (!data.length) return 0;
    var first = data[0][0];
    var second;

    for (var i = 1; i < data.length; i++) {
      if (data[i][0] !== first) {
        second = data[i][0];
        break;
      }
    }

    for (var j = 0; j < sub.length; j++) {
      if (sub[j][0] === second) {
        return j - i;
      }
    }

    return 0;
  },
  // Fallback fix for Brave browser
  // https://github.com/brave/brave-browser/issues/1738
  measureText: function measureText(ctx, text, tv_id) {
    var m = ctx.measureTextOrg(text);

    if (m.width === 0) {
      var doc = document;
      var id = 'tvjs-measure-text';
      var el = doc.getElementById(id);

      if (!el) {
        var base = doc.getElementById(tv_id);
        el = doc.createElement("div");
        el.id = id;
        el.style.position = 'absolute';
        el.style.top = '-1000px';
        base.appendChild(el);
      }

      if (ctx.font) el.style.font = ctx.font;
      el.innerText = text.replace(/ /g, '.');
      return {
        width: el.offsetWidth
      };
    } else {
      return m;
    }
  },
  uuid: function uuid(temp) {
    if (temp === void 0) {
      temp = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    }

    return temp.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  },
  uuid2: function uuid2() {
    return this.uuid('xxxxxxxxxxxx');
  },
  // Delayed warning, f = condition lambda fn
  warn: function warn(f, text, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    setTimeout(function () {
      if (f()) console.warn(text);
    }, delay);
  },
  // Checks if script props updated
  // (and not style settings or something else)
  is_scr_props_upd: function is_scr_props_upd(n, prev) {
    var p = prev.find(function (x) {
      return x.v.$uuid === n.v.$uuid;
    });
    if (!p) return false;
    var props = n.p.settings.$props;
    if (!props) return false;
    return props.some(function (x) {
      return n.v[x] !== p.v[x];
    });
  },
  // Checks if it's time to make a script update
  // (based on execInterval in ms)
  delayed_exec: function delayed_exec(v) {
    if (!v.script || !v.script.execInterval) return true;
    var t = this.now();
    var dt = v.script.execInterval;

    if (!v.settings.$last_exec || t > v.settings.$last_exec + dt) {
      v.settings.$last_exec = t;
      return true;
    }

    return false;
  },
  // Format names such 'RSI, $length', where
  // length - is one of the settings
  format_name: function format_name(ov) {
    if (!ov.name) return undefined;
    var name = ov.name;

    for (var k in ov.settings || {}) {
      var val = ov.settings[k];
      var reg = new RegExp("\\$".concat(k), 'g');
      name = name.replace(reg, val);
    }

    return name;
  },
  // Default cursor mode
  xmode: function xmode() {
    return this.is_mobile ? 'explore' : 'default';
  },
  default_prevented: function default_prevented(event) {
    if (event.original) {
      return event.original.defaultPrevented;
    }

    return event.defaultPrevented;
  },
  // WTF with modern web development
  is_mobile: function (w) {
    return 'onorientationchange' in w && (!!navigator.maxTouchPoints || !!navigator.msMaxTouchPoints || 'ontouchstart' in w || w.DocumentTouch && document instanceof w.DocumentTouch);
  }(typeof window !== 'undefined' ? window : {})
});
;// CONCATENATED MODULE: ./src/stuff/math.js
// Math/Geometry
/* harmony default export */ const math = ({
  // Distance from point to line
  // p1 = point, (p2, p3) = line
  point2line: function point2line(p1, p2, p3) {
    var _this$tri = this.tri(p1, p2, p3),
        area = _this$tri.area,
        base = _this$tri.base;

    return Math.abs(this.tri_h(area, base));
  },
  // Distance from point to segment
  // p1 = point, (p2, p3) = segment
  point2seg: function point2seg(p1, p2, p3) {
    var _this$tri2 = this.tri(p1, p2, p3),
        area = _this$tri2.area,
        base = _this$tri2.base; // Vector projection


    var proj = this.dot_prod(p1, p2, p3) / base; // Distance from left pin

    var l1 = Math.max(-proj, 0); // Distance from right pin

    var l2 = Math.max(proj - base, 0); // Normal

    var h = Math.abs(this.tri_h(area, base));
    return Math.max(h, l1, l2);
  },
  // Distance from point to ray
  // p1 = point, (p2, p3) = ray
  point2ray: function point2ray(p1, p2, p3) {
    var _this$tri3 = this.tri(p1, p2, p3),
        area = _this$tri3.area,
        base = _this$tri3.base; // Vector projection


    var proj = this.dot_prod(p1, p2, p3) / base; // Distance from left pin

    var l1 = Math.max(-proj, 0); // Normal

    var h = Math.abs(this.tri_h(area, base));
    return Math.max(h, l1);
  },
  tri: function tri(p1, p2, p3) {
    var area = this.area(p1, p2, p3);
    var dx = p3[0] - p2[0];
    var dy = p3[1] - p2[1];
    var base = Math.sqrt(dx * dx + dy * dy);
    return {
      area: area,
      base: base
    };
  },

  /* Area of triangle:
          p1
        /    \
      p2  _  p3
  */
  area: function area(p1, p2, p3) {
    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]);
  },
  // Triangle height
  tri_h: function tri_h(area, base) {
    return area / base;
  },
  // Dot product of (p2, p3) and (p2, p1)
  dot_prod: function dot_prod(p1, p2, p3) {
    var v1 = [p3[0] - p2[0], p3[1] - p2[1]];
    var v2 = [p1[0] - p2[0], p1[1] - p2[1]];
    return v1[0] * v2[0] + v1[1] * v2[1];
  },
  // Symmetrical log
  log: function log(x) {
    // TODO: log for small values
    return Math.sign(x) * Math.log(Math.abs(x) + 1);
  },
  // Symmetrical exp
  exp: function exp(x) {
    return Math.sign(x) * (Math.exp(Math.abs(x)) - 1);
  },
  // Middle line on log scale based on range & px height
  log_mid: function log_mid(r, h) {
    var log_hi = this.log(r[0]);
    var log_lo = this.log(r[1]);
    var px = h / 2;
    var gx = log_hi - px * (log_hi - log_lo) / h;
    return this.exp(gx);
  },
  // Return new adjusted range, based on the previous
  // range, new $_hi, target middle line
  re_range: function re_range(r1, hi2, mid) {
    var log_hi1 = this.log(r1[0]);
    var log_lo1 = this.log(r1[1]);
    var log_hi2 = this.log(hi2);
    var log_$ = this.log(mid);
    var W = (log_hi2 - log_$) * (log_hi1 - log_lo1) / (log_hi1 - log_$);
    return this.exp(log_hi2 - W);
  } // Return new adjusted range, based on the previous
  // range, new $_hi, target middle line + dy (shift)
  // WASTE

  /*range_shift(r1, hi2, mid, dy, h) {
      let log_hi1 = this.log(r1[0])
      let log_lo1 = this.log(r1[1])
      let log_hi2 = this.log(hi2)
      let log_$ = this.log(mid)
       let W = h * (log_hi2 - log_$) /
              (h * (log_hi1 - log_$) / (log_hi1 - log_lo1) + dy)
       return this.exp(log_hi2 - W)
   }*/

});
;// CONCATENATED MODULE: ./src/components/js/layout_fn.js
// Layout functional interface


/* harmony default export */ function layout_fn(self, range) {
  var ib = self.ti_map.ib;
  var dt = range[1] - range[0];
  var r = self.spacex / dt;
  var ls = self.grid.logScale || false;
  Object.assign(self, {
    // Time to screen coordinates
    t2screen: function t2screen(t) {
      if (ib) t = self.ti_map.smth2i(t);
      return Math.floor((t - range[0]) * r) - 0.5;
    },
    // $ to screen coordinates
    $2screen: function $2screen(y) {
      if (ls) y = math.log(y);
      return Math.floor(y * self.A + self.B) - 0.5;
    },
    // Time-axis nearest step
    t_magnet: function t_magnet(t) {
      if (ib) t = self.ti_map.smth2i(t);
      var cn = self.candles || self.master_grid.candles;
      var arr = cn.map(function (x) {
        return x.raw[0];
      });
      var i = utils.nearest_a(t, arr)[0];
      if (!cn[i]) return;
      return Math.floor(cn[i].x) - 0.5;
    },
    // Screen-Y to dollar value (or whatever)
    screen2$: function screen2$(y) {
      if (ls) return math.exp((y - self.B) / self.A);
      return (y - self.B) / self.A;
    },
    // Screen-X to timestamp
    screen2t: function screen2t(x) {
      // TODO: most likely Math.floor not needed
      // return Math.floor(range[0] + x / r)
      return range[0] + x / r;
    },
    // $-axis nearest step
    $_magnet: function $_magnet(price) {},
    // Nearest candlestick
    c_magnet: function c_magnet(t) {
      var cn = self.candles || self.master_grid.candles;
      var arr = cn.map(function (x) {
        return x.raw[0];
      });
      var i = utils.nearest_a(t, arr)[0];
      return cn[i];
    },
    // Nearest data points
    data_magnet: function data_magnet(t) {
      /* TODO: implement */
    }
  });
  return self;
}
;// CONCATENATED MODULE: ./src/components/js/log_scale.js
// Log-scale mode helpers
// TODO: all-negative numbers (sometimes wrong scaling)

/* harmony default export */ const log_scale = ({
  candle: function candle(self, mid, p, $p) {
    return {
      x: mid,
      w: self.px_step * $p.config.CANDLEW,
      o: Math.floor(math.log(p[1]) * self.A + self.B),
      h: Math.floor(math.log(p[2]) * self.A + self.B),
      l: Math.floor(math.log(p[3]) * self.A + self.B),
      c: Math.floor(math.log(p[4]) * self.A + self.B),
      raw: p
    };
  },
  expand: function expand(self, height) {
    // expand log scale
    var A = -height / (math.log(self.$_hi) - math.log(self.$_lo));
    var B = -math.log(self.$_hi) * A;
    var top = -height * 0.1;
    var bot = height * 1.1;
    self.$_hi = math.exp((top - B) / A);
    self.$_lo = math.exp((bot - B) / A);
  }
});
;// CONCATENATED MODULE: ./src/components/js/grid_maker.js






var grid_maker_TIMESCALES = constants.TIMESCALES,
    grid_maker_$SCALES = constants.$SCALES,
    grid_maker_WEEK = constants.WEEK,
    grid_maker_MONTH = constants.MONTH,
    grid_maker_YEAR = constants.YEAR,
    grid_maker_HOUR = constants.HOUR,
    grid_maker_DAY = constants.DAY;
var MAX_INT = Number.MAX_SAFE_INTEGER; // master_grid - ref to the master grid

function GridMaker(id, params, master_grid) {
  if (master_grid === void 0) {
    master_grid = null;
  }

  var sub = params.sub,
      interval = params.interval,
      range = params.range,
      ctx = params.ctx,
      $p = params.$p,
      layers_meta = params.layers_meta,
      height = params.height,
      y_t = params.y_t,
      ti_map = params.ti_map,
      grid = params.grid,
      timezone = params.timezone;
  var self = {
    ti_map: ti_map
  };
  var lm = layers_meta[id];
  var y_range_fn = null;
  var ls = grid.logScale;

  if (lm && Object.keys(lm).length) {
    // Gets last y_range fn()
    var yrs = Object.values(lm).filter(function (x) {
      return x.y_range;
    }); // The first y_range() determines the range

    if (yrs.length) y_range_fn = yrs[0].y_range;
  } // Calc vertical ($/₿) range


  function calc_$range() {
    if (!master_grid) {
      // $ candlestick range
      if (y_range_fn) {
        var _y_range_fn = y_range_fn(hi, lo),
            _y_range_fn2 = _slicedToArray(_y_range_fn, 2),
            hi = _y_range_fn2[0],
            lo = _y_range_fn2[1];
      } else {
        hi = -Infinity, lo = Infinity;

        for (var i = 0, n = sub.length; i < n; i++) {
          var x = sub[i];
          if (x[2] > hi) hi = x[2];
          if (x[3] < lo) lo = x[3];
        }
      }
    } else {
      // Offchart indicator range
      hi = -Infinity, lo = Infinity;

      for (var i = 0; i < sub.length; i++) {
        for (var j = 1; j < sub[i].length; j++) {
          var v = sub[i][j];
          if (v > hi) hi = v;
          if (v < lo) lo = v;
        }
      }

      if (y_range_fn) {
        var _y_range_fn3 = y_range_fn(hi, lo),
            _y_range_fn4 = _slicedToArray(_y_range_fn3, 3),
            hi = _y_range_fn4[0],
            lo = _y_range_fn4[1],
            exp = _y_range_fn4[2];
      }
    } // Fixed y-range in non-auto mode


    if (y_t && !y_t.auto && y_t.range) {
      self.$_hi = y_t.range[0];
      self.$_lo = y_t.range[1];
    } else {
      if (!ls) {
        exp = exp === false ? 0 : 1;
        self.$_hi = hi + (hi - lo) * $p.config.EXPAND * exp;
        self.$_lo = lo - (hi - lo) * $p.config.EXPAND * exp;
      } else {
        self.$_hi = hi;
        self.$_lo = lo;
        log_scale.expand(self, height);
      }

      if (self.$_hi === self.$_lo) {
        if (!ls) {
          self.$_hi *= 1.05; // Expand if height range === 0

          self.$_lo *= 0.95;
        } else {
          log_scale.expand(self, height);
        }
      }
    }
  }

  function calc_sidebar() {
    if (sub.length < 2) {
      self.prec = 0;
      self.sb = $p.config.SBMIN;
      return;
    } // TODO: improve sidebar width calculation
    // at transition point, when one precision is
    // replaced with another
    // Gets formated levels (their lengths),
    // calculates max and measures the sidebar length
    // from it:
    // TODO: add custom formatter f()


    self.prec = calc_precision(sub);
    var lens = [];
    lens.push(self.$_hi.toFixed(self.prec).length);
    lens.push(self.$_lo.toFixed(self.prec).length);
    var str = '0'.repeat(Math.max.apply(Math, lens)) + '    ';
    self.sb = ctx.measureText(str).width;
    self.sb = Math.max(Math.floor(self.sb), $p.config.SBMIN);
    self.sb = Math.min(self.sb, $p.config.SBMAX);
  } // Calculate $ precision for the Y-axis


  function calc_precision(data) {
    var max_r = 0,
        max_l = 0;
    var min = Infinity;
    var max = -Infinity; // Speed UP

    for (var i = 0, n = data.length; i < n; i++) {
      var x = data[i];
      if (x[1] > max) max = x[1];else if (x[1] < min) min = x[1];
    } // Get max lengths of integer and fractional parts


    [min, max].forEach(function (x) {
      // Fix undefined bug
      var str = x != null ? x.toString() : '';

      if (x < 0.000001) {
        // Parsing the exponential form. Gosh this
        // smells trickily
        var _str$split = str.split('e-'),
            _str$split2 = _slicedToArray(_str$split, 2),
            ls = _str$split2[0],
            rs = _str$split2[1];

        var _ls$split = ls.split('.'),
            _ls$split2 = _slicedToArray(_ls$split, 2),
            l = _ls$split2[0],
            r = _ls$split2[1];

        if (!r) r = '';
        r = {
          length: r.length + parseInt(rs) || 0
        };
      } else {
        var _str$split3 = str.split('.'),
            _str$split4 = _slicedToArray(_str$split3, 2),
            l = _str$split4[0],
            r = _str$split4[1];
      }

      if (r && r.length > max_r) {
        max_r = r.length;
      }

      if (l && l.length > max_l) {
        max_l = l.length;
      }
    }); // Select precision scheme depending
    // on the left and right part lengths
    //

    var even = max_r - max_r % 2 + 2;

    if (max_l === 1) {
      return Math.min(8, Math.max(2, even));
    }

    if (max_l <= 2) {
      return Math.min(4, Math.max(2, even));
    }

    return 2;
  }

  function calc_positions() {
    if (sub.length < 2) return;
    var dt = range[1] - range[0]; // A pixel space available to draw on (x-axis)

    self.spacex = $p.width - self.sb; // Candle capacity

    var capacity = dt / interval;
    self.px_step = self.spacex / capacity; // px / time ratio

    var r = self.spacex / dt;
    self.startx = (sub[0][0] - range[0]) * r; // Candle Y-transform: (A = scale, B = shift)

    if (!grid.logScale) {
      self.A = -height / (self.$_hi - self.$_lo);
      self.B = -self.$_hi * self.A;
    } else {
      self.A = -height / (math.log(self.$_hi) - math.log(self.$_lo));
      self.B = -math.log(self.$_hi) * self.A;
    }
  } // Select nearest good-loking t step (m is target scale)


  function time_step() {
    var k = ti_map.ib ? 60000 : 1;
    var xrange = (range[1] - range[0]) * k;
    var m = xrange * ($p.config.GRIDX / $p.width);
    var s = grid_maker_TIMESCALES;
    return utils.nearest_a(m, s)[1] / k;
  } // Select nearest good-loking $ step (m is target scale)


  function dollar_step() {
    var yrange = self.$_hi - self.$_lo;
    var m = yrange * ($p.config.GRIDY / height);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    var d = Math.pow(10, p);
    var s = grid_maker_$SCALES.map(function (x) {
      return x * d;
    }); // TODO: center the range (look at RSI for example,
    // it looks ugly when "80" is near the top)

    return utils.strip(utils.nearest_a(m, s)[1]);
  }

  function dollar_mult() {
    var mult_hi = dollar_mult_hi();
    var mult_lo = dollar_mult_lo();
    return Math.max(mult_hi, mult_lo);
  } // Price step multiplier (for the log-scale mode)


  function dollar_mult_hi() {
    var h = Math.min(self.B, height);
    if (h < $p.config.GRIDY) return 1;
    var n = h / $p.config.GRIDY; // target grid N

    var yrange = self.$_hi;

    if (self.$_lo > 0) {
      var yratio = self.$_hi / self.$_lo;
    } else {
      yratio = self.$_hi / 1; // TODO: small values
    }

    var m = yrange * ($p.config.GRIDY / h);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    return Math.pow(yratio, 1 / n);
  }

  function dollar_mult_lo() {
    var h = Math.min(height - self.B, height);
    if (h < $p.config.GRIDY) return 1;
    var n = h / $p.config.GRIDY; // target grid N

    var yrange = Math.abs(self.$_lo);

    if (self.$_hi < 0 && self.$_lo < 0) {
      var yratio = Math.abs(self.$_lo / self.$_hi);
    } else {
      yratio = Math.abs(self.$_lo) / 1;
    }

    var m = yrange * ($p.config.GRIDY / h);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    return Math.pow(yratio, 1 / n);
  }

  function grid_x() {
    // If this is a subgrid, no need to calc a timeline,
    // we just borrow it from the master_grid
    if (!master_grid) {
      self.t_step = time_step();
      self.xs = [];
      var dt = range[1] - range[0];
      var r = self.spacex / dt;
      /* TODO: remove the left-side glitch
       let year_0 = Utils.get_year(sub[0][0])
      for (var t0 = year_0; t0 < range[0]; t0 += self.t_step) {}
       let m0 = Utils.get_month(t0)*/

      for (var i = 0; i < sub.length; i++) {
        var p = sub[i];
        var prev = sub[i - 1] || [];
        var prev_xs = self.xs[self.xs.length - 1] || [0, []];
        var x = Math.floor((p[0] - range[0]) * r);
        insert_line(prev, p, x); // Filtering lines that are too near

        var xs = self.xs[self.xs.length - 1] || [0, []];
        if (prev_xs === xs) continue;

        if (xs[1][0] - prev_xs[1][0] < self.t_step * 0.8) {
          // prev_xs is a higher "rank" label
          if (xs[2] <= prev_xs[2]) {
            self.xs.pop();
          } else {
            // Otherwise
            self.xs.splice(self.xs.length - 2, 1);
          }
        }
      } // TODO: fix grid extension for bigger timeframes


      if (interval < grid_maker_WEEK && r > 0) {
        extend_left(dt, r);
        extend_right(dt, r);
      }
    } else {
      self.t_step = master_grid.t_step;
      self.px_step = master_grid.px_step;
      self.startx = master_grid.startx;
      self.xs = master_grid.xs;
    }
  }

  function insert_line(prev, p, x, m0) {
    var prev_t = ti_map.ib ? ti_map.i2t(prev[0]) : prev[0];
    var p_t = ti_map.ib ? ti_map.i2t(p[0]) : p[0];

    if (ti_map.tf < grid_maker_DAY) {
      prev_t += timezone * grid_maker_HOUR;
      p_t += timezone * grid_maker_HOUR;
    }

    var d = timezone * grid_maker_HOUR; // TODO: take this block =========> (see below)

    if ((prev[0] || interval === grid_maker_YEAR) && utils.get_year(p_t) !== utils.get_year(prev_t)) {
      self.xs.push([x, p, grid_maker_YEAR]); // [px, [...], rank]
    } else if (prev[0] && utils.get_month(p_t) !== utils.get_month(prev_t)) {
      self.xs.push([x, p, grid_maker_MONTH]);
    } // TODO: should be added if this day !== prev day
    // And the same for 'botbar.js', TODO(*)
    else if (utils.day_start(p_t) === p_t) {
        self.xs.push([x, p, grid_maker_DAY]);
      } else if (p[0] % self.t_step === 0) {
        self.xs.push([x, p, interval]);
      }
  }

  function extend_left(dt, r) {
    if (!self.xs.length || !isFinite(r)) return;
    var t = self.xs[0][1][0];

    while (true) {
      t -= self.t_step;
      var x = Math.floor((t - range[0]) * r);
      if (x < 0) break; // TODO: ==========> And insert it here somehow

      if (t % interval === 0) {
        self.xs.unshift([x, [t], interval]);
      }
    }
  }

  function extend_right(dt, r) {
    if (!self.xs.length || !isFinite(r)) return;
    var t = self.xs[self.xs.length - 1][1][0];

    while (true) {
      t += self.t_step;
      var x = Math.floor((t - range[0]) * r);
      if (x > self.spacex) break;

      if (t % interval === 0) {
        self.xs.push([x, [t], interval]);
      }
    }
  }

  function grid_y() {
    // Prevent duplicate levels
    var m = Math.pow(10, -self.prec);
    self.$_step = Math.max(m, dollar_step());
    self.ys = [];
    var y1 = self.$_lo - self.$_lo % self.$_step;

    for (var y$ = y1; y$ <= self.$_hi; y$ += self.$_step) {
      var y = Math.floor(y$ * self.A + self.B);
      if (y > height) continue;
      self.ys.push([y, utils.strip(y$)]);
    }
  }

  function grid_y_log() {
    // TODO: Prevent duplicate levels, is this even
    // a problem here ?
    self.$_mult = dollar_mult();
    self.ys = [];
    if (!sub.length) return;
    var v = Math.abs(sub[sub.length - 1][1] || 1);
    var y1 = search_start_pos(v);
    var y2 = search_start_neg(-v);
    var yp = -Infinity; // Previous y value

    var n = height / $p.config.GRIDY; // target grid N

    var q = 1 + (self.$_mult - 1) / 2; // Over 0

    for (var y$ = y1; y$ > 0; y$ /= self.$_mult) {
      y$ = log_rounder(y$, q);
      var y = Math.floor(math.log(y$) * self.A + self.B);
      self.ys.push([y, utils.strip(y$)]);
      if (y > height) break;
      if (y - yp < $p.config.GRIDY * 0.7) break;
      if (self.ys.length > n + 1) break;
      yp = y;
    } // Under 0


    yp = Infinity;

    for (var y$ = y2; y$ < 0; y$ /= self.$_mult) {
      y$ = log_rounder(y$, q);

      var _y = Math.floor(math.log(y$) * self.A + self.B);

      if (yp - _y < $p.config.GRIDY * 0.7) break;
      self.ys.push([_y, utils.strip(y$)]);
      if (_y < 0) break;
      if (self.ys.length > n * 3 + 1) break;
      yp = _y;
    } // TODO: remove lines near to 0

  } // Search a start for the top grid so that
  // the fixed value always included


  function search_start_pos(value) {
    var N = height / $p.config.GRIDY; // target grid N

    var y = Infinity,
        y$ = value,
        count = 0;

    while (y > 0) {
      y = Math.floor(math.log(y$) * self.A + self.B);
      y$ *= self.$_mult;
      if (count++ > N * 3) return 0; // Prevents deadloops
    }

    return y$;
  }

  function search_start_neg(value) {
    var N = height / $p.config.GRIDY; // target grid N

    var y = -Infinity,
        y$ = value,
        count = 0;

    while (y < height) {
      y = Math.floor(math.log(y$) * self.A + self.B);
      y$ *= self.$_mult;
      if (count++ > N * 3) break; // Prevents deadloops
    }

    return y$;
  } // Make log scale levels look great again


  function log_rounder(x, quality) {
    var s = Math.sign(x);
    x = Math.abs(x);

    if (x > 10) {
      for (var div = 10; div < MAX_INT; div *= 10) {
        var nice = Math.floor(x / div) * div;

        if (x / nice > quality) {
          // More than 10% off
          break;
        }
      }

      div /= 10;
      return s * Math.floor(x / div) * div;
    } else if (x < 1) {
      for (var ro = 10; ro >= 1; ro--) {
        var _nice = utils.round(x, ro);

        if (x / _nice > quality) {
          // More than 10% off
          break;
        }
      }

      return s * utils.round(x, ro + 1);
    } else {
      return s * Math.floor(x);
    }
  }

  function apply_sizes() {
    self.width = $p.width - self.sb;
    self.height = height;
  }

  calc_$range();
  calc_sidebar();
  return {
    // First we need to calculate max sidebar width
    // (among all grids). Then we can actually make
    // them
    create: function create() {
      calc_positions();
      grid_x();

      if (grid.logScale) {
        grid_y_log();
      } else {
        grid_y();
      }

      apply_sizes(); // Link to the master grid (candlesticks)

      if (master_grid) {
        self.master_grid = master_grid;
      }

      self.grid = grid; // Grid params
      // Here we add some helpful functions for
      // plugin creators

      return layout_fn(self, range);
    },
    get_layout: function get_layout() {
      return self;
    },
    set_sidebar: function set_sidebar(v) {
      return self.sb = v;
    },
    get_sidebar: function get_sidebar() {
      return self.sb;
    }
  };
}

/* harmony default export */ const grid_maker = (GridMaker);
;// CONCATENATED MODULE: ./src/components/js/layout.js



function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = layout_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function layout_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return layout_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return layout_arrayLikeToArray(o, minLen); }

function layout_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Calculates all necessary s*it to build the chart
// Heights, widths, transforms, ... = everything
// Why such a mess you ask? Well, that's because
// one components size can depend on other component
// data formatting (e.g. grid width depends on sidebar precision)
// So it's better to calc all in one place.





function Layout(params) {
  var chart = params.chart,
      sub = params.sub,
      offsub = params.offsub,
      interval = params.interval,
      range = params.range,
      ctx = params.ctx,
      layers_meta = params.layers_meta,
      ti_map = params.ti_map,
      $p = params.$props,
      y_ts = params.y_transforms;
  var mgrid = chart.grid || {};
  offsub = offsub.filter(function (x, i) {
    // Skip offchart overlays with custom grid id,
    // because they will be mergred with the existing grids
    return !(x.grid && x.grid.id);
  }); // Splits space between main chart
  // and offchart indicator grids

  function grid_hs() {
    var height = $p.height - $p.config.BOTBAR; // When at least one height defined (default = 1),
    // Pxs calculated as: (sum of weights) / number

    if (mgrid.height || offsub.find(function (x) {
      return x.grid.height;
    })) {
      return weighted_hs(mgrid, height);
    }

    var n = offsub.length;
    var off_h = 2 * Math.sqrt(n) / 7 / (n || 1); // Offchart grid height

    var px = Math.floor(height * off_h); // Main grid height

    var m = height - px * n;
    return [m].concat(Array(n).fill(px));
  }

  function weighted_hs(grid, height) {
    var hs = [{
      grid: grid
    }].concat(_toConsumableArray(offsub)).map(function (x) {
      return x.grid.height || 1;
    });
    var sum = hs.reduce(function (a, b) {
      return a + b;
    }, 0);
    hs = hs.map(function (x) {
      return Math.floor(x / sum * height);
    }); // Refine the height if Math.floor decreased px sum

    sum = hs.reduce(function (a, b) {
      return a + b;
    }, 0);

    for (var i = 0; i < height - sum; i++) {
      hs[i % hs.length]++;
    }

    return hs;
  }

  function candles_n_vol() {
    self.candles = [];
    self.volume = [];
    var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
      return x[5];
    })));
    var vs = $p.config.VOLSCALE * $p.height / maxv;
    var x1,
        x2,
        mid,
        prev = undefined;
    var splitter = self.px_step > 5 ? 1 : 0;
    var hf_px_step = self.px_step * 0.5;

    for (var i = 0; i < sub.length; i++) {
      var p = sub[i];
      mid = self.t2screen(p[0]) + 0.5;
      self.candles.push(mgrid.logScale ? log_scale.candle(self, mid, p, $p) : {
        x: mid,
        w: self.px_step * $p.config.CANDLEW,
        o: Math.floor(p[1] * self.A + self.B),
        h: Math.floor(p[2] * self.A + self.B),
        l: Math.floor(p[3] * self.A + self.B),
        c: Math.floor(p[4] * self.A + self.B),
        raw: p
      }); // Clear volume bar if there is a time gap

      if (sub[i - 1] && p[0] - sub[i - 1][0] > interval) {
        prev = null;
      }

      x1 = prev || Math.floor(mid - hf_px_step);
      x2 = Math.floor(mid + hf_px_step) - 0.5;
      self.volume.push({
        x1: x1,
        x2: x2,
        h: p[5] * vs,
        green: p[4] >= p[1],
        raw: p
      });
      prev = x2 + splitter;
    }
  } // Main grid


  var hs = grid_hs();
  var specs = {
    sub: sub,
    interval: interval,
    range: range,
    ctx: ctx,
    $p: $p,
    layers_meta: layers_meta,
    ti_map: ti_map,
    height: hs[0],
    y_t: y_ts[0],
    grid: mgrid,
    timezone: $p.timezone
  };
  var gms = [new grid_maker(0, specs)]; // Sub grids

  var _iterator = _createForOfIteratorHelper(offsub.entries()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          i = _step$value[0],
          _step$value$ = _step$value[1],
          data = _step$value$.data,
          grid = _step$value$.grid;

      specs.sub = data;
      specs.height = hs[i + 1];
      specs.y_t = y_ts[i + 1];
      specs.grid = grid || {};
      gms.push(new grid_maker(i + 1, specs, gms[0].get_layout()));
    } // Max sidebar among all grinds

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var sb = Math.max.apply(Math, _toConsumableArray(gms.map(function (x) {
    return x.get_sidebar();
  })));
  var grids = [],
      offset = 0;

  for (i = 0; i < gms.length; i++) {
    gms[i].set_sidebar(sb);
    grids.push(gms[i].create());
    grids[i].id = i;
    grids[i].offset = offset;
    offset += grids[i].height;
  }

  var self = grids[0];
  candles_n_vol();
  return {
    grids: grids,
    botbar: {
      width: $p.width,
      height: $p.config.BOTBAR,
      offset: offset,
      xs: grids[0] ? grids[0].xs : []
    }
  };
}

/* harmony default export */ const layout = (Layout);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function classCallCheck_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function createClass_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
;// CONCATENATED MODULE: ./src/components/js/updater.js




function updater_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = updater_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function updater_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return updater_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return updater_arrayLikeToArray(o, minLen); }

function updater_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Cursor updater: calculates current values for
// OHLCV and all other indicators


var CursorUpdater = /*#__PURE__*/function () {
  function CursorUpdater(comp) {
    classCallCheck_classCallCheck(this, CursorUpdater);

    this.comp = comp, this.grids = comp._layout.grids, this.cursor = comp.cursor;
  }

  createClass_createClass(CursorUpdater, [{
    key: "sync",
    value: function sync(e) {
      // TODO: values not displaying if a custom grid id is set:
      // grid: { id: N }
      this.cursor.grid_id = e.grid_id;
      var once = true;

      var _iterator = updater_createForOfIteratorHelper(this.grids),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var grid = _step.value;
          var c = this.cursor_data(grid, e);

          if (!this.cursor.locked) {
            // TODO: find a better fix to invisible cursor prob
            if (once) {
              this.cursor.t = this.cursor_time(grid, e, c);
              if (this.cursor.t) once = false;
            }

            if (c.values) {
              this.comp.$set(this.cursor.values, grid.id, c.values);
            }
          }

          if (grid.id !== e.grid_id) continue;
          this.cursor.x = grid.t2screen(this.cursor.t);
          this.cursor.y = c.y;
          this.cursor.y$ = c.y$;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "overlay_data",
    value: function overlay_data(grid, e) {
      var s = grid.id === 0 ? 'main_section' : 'sub_section';
      var data = this.comp[s].data; // Split offchart data between offchart grids

      if (grid.id > 0) {
        // Sequential grids
        var _d = data.filter(function (x) {
          return x.grid.id === undefined;
        }); // grids with custom ids (for merging)


        var m = data.filter(function (x) {
          return x.grid.id === grid.id;
        });
        data = [_d[grid.id - 1]].concat(_toConsumableArray(m));
      }

      var t = grid.screen2t(e.x);
      var ids = {},
          res = {};

      var _iterator2 = updater_createForOfIteratorHelper(data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var d = _step2.value;
          var ts = d.data.map(function (x) {
            return x[0];
          });
          var i = utils.nearest_a(t, ts)[0];
          d.type in ids ? ids[d.type]++ : ids[d.type] = 0;
          res["".concat(d.type, "_").concat(ids[d.type])] = d.data[i];
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return res;
    } // Nearest datapoints

  }, {
    key: "cursor_data",
    value: function cursor_data(grid, e) {
      var data = this.comp.main_section.sub;
      var xs = data.map(function (x) {
        return grid.t2screen(x[0]) + 0.5;
      });
      var i = utils.nearest_a(e.x, xs)[0];
      if (!xs[i]) return {};
      return {
        x: Math.floor(xs[i]) - 0.5,
        y: Math.floor(e.y - 2) - 0.5 - grid.offset,
        y$: grid.screen2$(e.y - 2 - grid.offset),
        t: (data[i] || [])[0],
        values: Object.assign({
          ohlcv: grid.id === 0 ? data[i] : undefined
        }, this.overlay_data(grid, e))
      };
    } // Get cursor t-position (extended)

  }, {
    key: "cursor_time",
    value: function cursor_time(grid, mouse, candle) {
      var t = grid.screen2t(mouse.x);
      var r = Math.abs((t - candle.t) / this.comp.interval);
      var sign = Math.sign(t - candle.t);

      if (r >= 0.5) {
        // Outside the data range
        var n = Math.round(r);
        return candle.t + n * this.comp.interval * sign;
      } // Inside the data range


      return candle.t;
    }
  }]);

  return CursorUpdater;
}();

/* harmony default export */ const updater = (CursorUpdater);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=template&id=8fbe9336&
var Sectionvue_type_template_id_8fbe9336_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-section" },
    [
      _c("chart-legend", {
        ref: "legend",
        attrs: {
          values: _vm.section_values,
          grid_id: _vm.grid_id,
          common: _vm.legend_props,
          meta_props: _vm.get_meta_props
        },
        on: { "legend-button-click": _vm.button_click }
      }),
      _vm._v(" "),
      _c(
        "grid",
        _vm._b(
          {
            ref: "grid",
            attrs: { grid_id: _vm.grid_id },
            on: {
              "register-kb-listener": _vm.register_kb,
              "remove-kb-listener": _vm.remove_kb,
              "range-changed": _vm.range_changed,
              "cursor-changed": _vm.cursor_changed,
              "cursor-locked": _vm.cursor_locked,
              "layer-meta-props": _vm.emit_meta_props,
              "custom-event": _vm.emit_custom_event,
              "sidebar-transform": _vm.sidebar_transform,
              "rezoom-range": _vm.rezoom_range
            }
          },
          "grid",
          _vm.grid_props,
          false
        )
      ),
      _vm._v(" "),
      _c(
        "sidebar",
        _vm._b(
          {
            ref: "sb-" + _vm.grid_id,
            attrs: { grid_id: _vm.grid_id, rerender: _vm.rerender },
            on: { "sidebar-transform": _vm.sidebar_transform }
          },
          "sidebar",
          _vm.sidebar_props,
          false
        )
      )
    ],
    1
  )
}
var Sectionvue_type_template_id_8fbe9336_staticRenderFns = []
Sectionvue_type_template_id_8fbe9336_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=template&id=8fbe9336&

;// CONCATENATED MODULE: ./src/stuff/frame.js


// Annimation frame with a fallback for
// slower devices


var FrameAnimation = /*#__PURE__*/function () {
  function FrameAnimation(cb) {
    var _this = this;

    classCallCheck_classCallCheck(this, FrameAnimation);

    this.t0 = this.t = utils.now();
    this.id = setInterval(function () {
      // The prev frame took too long
      if (utils.now() - _this.t > 100) return;

      if (utils.now() - _this.t0 > 1200) {
        _this.stop();
      }

      if (_this.id) cb(_this);
      _this.t = utils.now();
    }, 16);
  }

  createClass_createClass(FrameAnimation, [{
    key: "stop",
    value: function stop() {
      clearInterval(this.id);
      this.id = null;
    }
  }]);

  return FrameAnimation;
}();


// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js
var hammer = __nested_webpack_require_9759__(840);
// EXTERNAL MODULE: ./node_modules/hamsterjs/hamster.js
var hamster = __nested_webpack_require_9759__(981);
var hamster_default = /*#__PURE__*/__nested_webpack_require_9759__.n(hamster);
;// CONCATENATED MODULE: ./src/components/js/grid.js





function grid_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = grid_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function grid_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return grid_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return grid_arrayLikeToArray(o, minLen); }

function grid_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Grid.js listens to various user-generated events,
// emits Vue-events if something has changed (e.g. range)
// Think of it as an I/O system for Grid.vue




 // Grid is good.

var Grid = /*#__PURE__*/function () {
  function Grid(canvas, comp) {
    classCallCheck_classCallCheck(this, Grid);

    this.MIN_ZOOM = comp.config.MIN_ZOOM;
    this.MAX_ZOOM = comp.config.MAX_ZOOM;
    if (utils.is_mobile) this.MIN_ZOOM *= 0.5;
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.id = this.$p.grid_id;
    this.layout = this.$p.layout.grids[this.id];
    this.interval = this.$p.interval;
    this.cursor = comp.$props.cursor;
    this.offset_x = 0;
    this.offset_y = 0;
    this.deltas = 0; // Wheel delta events

    this.wmode = this.$p.config.SCROLL_WHEEL;
    this.listeners();
    this.overlays = [];
  }

  createClass_createClass(Grid, [{
    key: "listeners",
    value: function listeners() {
      var _this = this;

      this.hm = hamster_default()(this.canvas);
      this.hm.wheel(function (event, delta) {
        return _this.mousezoom(-delta * 50, event);
      });
      var mc = this.mc = new hammer.Manager(this.canvas);
      var T = utils.is_mobile ? 10 : 0;
      mc.add(new hammer.Pan({
        threshold: T
      }));
      mc.add(new hammer.Tap());
      mc.add(new hammer.Pinch({
        threshold: 0
      }));
      mc.get('pinch').set({
        enable: true
      });
      if (utils.is_mobile) mc.add(new hammer.Press());
      mc.on('panstart', function (event) {
        if (_this.cursor.scroll_lock) return;

        if (_this.cursor.mode === 'aim') {
          return _this.emit_cursor_coord(event);
        }

        var tfrm = _this.$p.y_transform;
        _this.drug = {
          x: event.center.x + _this.offset_x,
          y: event.center.y + _this.offset_y,
          r: _this.range.slice(),
          t: _this.range[1] - _this.range[0],
          o: tfrm ? tfrm.offset || 0 : 0,
          y_r: tfrm && tfrm.range ? tfrm.range.slice() : undefined,
          B: _this.layout.B,
          t0: utils.now()
        };

        _this.comp.$emit('cursor-changed', {
          grid_id: _this.id,
          x: event.center.x + _this.offset_x,
          y: event.center.y + _this.offset_y
        });

        _this.comp.$emit('cursor-locked', true);
      });
      mc.on('panmove', function (event) {
        if (utils.is_mobile) {
          _this.calc_offset();

          _this.propagate('mousemove', _this.touch2mouse(event));
        }

        if (_this.drug) {
          _this.mousedrag(_this.drug.x + event.deltaX, _this.drug.y + event.deltaY);

          _this.comp.$emit('cursor-changed', {
            grid_id: _this.id,
            x: event.center.x + _this.offset_x,
            y: event.center.y + _this.offset_y
          });
        } else if (_this.cursor.mode === 'aim') {
          _this.emit_cursor_coord(event);
        }
      });
      mc.on('panend', function (event) {
        if (utils.is_mobile && _this.drug) {
          _this.pan_fade(event);
        }

        _this.drug = null;

        _this.comp.$emit('cursor-locked', false);
      });
      mc.on('tap', function (event) {
        if (!utils.is_mobile) return;

        _this.sim_mousedown(event);

        if (_this.fade) _this.fade.stop();

        _this.comp.$emit('cursor-changed', {});

        _this.comp.$emit('cursor-changed', {
          /*grid_id: this.id,
          x: undefined,//event.center.x + this.offset_x,
          y: undefined,//event.center.y + this.offset_y,*/
          mode: 'explore'
        });

        _this.update();
      });
      mc.on('pinchstart', function () {
        _this.drug = null;
        _this.pinch = {
          t: _this.range[1] - _this.range[0],
          r: _this.range.slice()
        };
      });
      mc.on('pinchend', function () {
        _this.pinch = null;
      });
      mc.on('pinch', function (event) {
        if (_this.pinch) _this.pinchzoom(event.scale);
      });
      mc.on('press', function (event) {
        if (!utils.is_mobile) return;
        if (_this.fade) _this.fade.stop();

        _this.calc_offset();

        _this.emit_cursor_coord(event, {
          mode: 'aim'
        });

        setTimeout(function () {
          return _this.update();
        });

        _this.sim_mousedown(event);
      });
      var add = addEventListener;
      add("gesturestart", this.gesturestart);
      add("gesturechange", this.gesturechange);
      add("gestureend", this.gestureend);
    }
  }, {
    key: "gesturestart",
    value: function gesturestart(event) {
      event.preventDefault();
    }
  }, {
    key: "gesturechange",
    value: function gesturechange(event) {
      event.preventDefault();
    }
  }, {
    key: "gestureend",
    value: function gestureend(event) {
      event.preventDefault();
    }
  }, {
    key: "mousemove",
    value: function mousemove(event) {
      if (utils.is_mobile) return;
      this.comp.$emit('cursor-changed', {
        grid_id: this.id,
        x: event.layerX,
        y: event.layerY + this.layout.offset
      });
      this.calc_offset();
      this.propagate('mousemove', event);
    }
  }, {
    key: "mouseout",
    value: function mouseout(event) {
      if (utils.is_mobile) return;
      this.comp.$emit('cursor-changed', {});
      this.propagate('mouseout', event);
    }
  }, {
    key: "mouseup",
    value: function mouseup(event) {
      this.drug = null;
      this.comp.$emit('cursor-locked', false);
      this.propagate('mouseup', event);
    }
  }, {
    key: "mousedown",
    value: function mousedown(event) {
      if (utils.is_mobile) return;
      this.propagate('mousedown', event);
      this.comp.$emit('cursor-locked', true);
      if (event.defaultPrevented) return;
      this.comp.$emit('custom-event', {
        event: 'grid-mousedown',
        args: [this.id, event]
      });
    } // Simulated mousedown (for mobile)

  }, {
    key: "sim_mousedown",
    value: function sim_mousedown(event) {
      var _this2 = this;

      if (event.srcEvent.defaultPrevented) return;
      this.comp.$emit('custom-event', {
        event: 'grid-mousedown',
        args: [this.id, event]
      });
      this.propagate('mousemove', this.touch2mouse(event));
      this.update();
      this.propagate('mousedown', this.touch2mouse(event));
      setTimeout(function () {
        _this2.propagate('click', _this2.touch2mouse(event));
      });
    } // Convert touch to "mouse" event

  }, {
    key: "touch2mouse",
    value: function touch2mouse(e) {
      this.calc_offset();
      return {
        original: e.srcEvent,
        layerX: e.center.x + this.offset_x,
        layerY: e.center.y + this.offset_y,
        preventDefault: function preventDefault() {
          this.original.preventDefault();
        }
      };
    }
  }, {
    key: "click",
    value: function click(event) {
      this.propagate('click', event);
    }
  }, {
    key: "emit_cursor_coord",
    value: function emit_cursor_coord(event, add) {
      if (add === void 0) {
        add = {};
      }

      this.comp.$emit('cursor-changed', Object.assign({
        grid_id: this.id,
        x: event.center.x + this.offset_x,
        y: event.center.y + this.offset_y + this.layout.offset
      }, add));
    }
  }, {
    key: "pan_fade",
    value: function pan_fade(event) {
      var _this3 = this;

      var dt = utils.now() - this.drug.t0;
      var dx = this.range[1] - this.drug.r[1];
      var v = 42 * dx / dt;
      var v0 = Math.abs(v * 0.01);
      if (dt > 500) return;
      if (this.fade) this.fade.stop();
      this.fade = new FrameAnimation(function (self) {
        v *= 0.85;

        if (Math.abs(v) < v0) {
          self.stop();
        }

        _this3.range[0] += v;
        _this3.range[1] += v;

        _this3.change_range();
      });
    }
  }, {
    key: "calc_offset",
    value: function calc_offset() {
      var rect = this.canvas.getBoundingClientRect();
      this.offset_x = -rect.x;
      this.offset_y = -rect.y;
    }
  }, {
    key: "new_layer",
    value: function new_layer(layer) {
      if (layer.name === 'crosshair') {
        this.crosshair = layer;
      } else {
        this.overlays.push(layer);
      }

      this.update();
    }
  }, {
    key: "del_layer",
    value: function del_layer(id) {
      this.overlays = this.overlays.filter(function (x) {
        return x.id !== id;
      });
      this.update();
    }
  }, {
    key: "show_hide_layer",
    value: function show_hide_layer(event) {
      var l = this.overlays.filter(function (x) {
        return x.id === event.id;
      });
      if (l.length) l[0].display = event.display;
    }
  }, {
    key: "update",
    value: function update() {
      var _this4 = this;

      // Update reference to the grid
      // TODO: check what happens if data changes interval
      this.layout = this.$p.layout.grids[this.id];
      this.interval = this.$p.interval;
      if (!this.layout) return;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (this.$p.shaders.length) this.apply_shaders();
      this.grid();
      var overlays = [];
      overlays.push.apply(overlays, _toConsumableArray(this.overlays)); // z-index sorting

      overlays.sort(function (l1, l2) {
        return l1.z - l2.z;
      });
      overlays.forEach(function (l) {
        if (!l.display) return;

        _this4.ctx.save();

        var r = l.renderer;
        if (r.pre_draw) r.pre_draw(_this4.ctx);
        r.draw(_this4.ctx);
        if (r.post_draw) r.post_draw(_this4.ctx);

        _this4.ctx.restore();
      });

      if (this.crosshair) {
        this.crosshair.renderer.draw(this.ctx);
      }
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.$p.layout.grids[this.id];
      var props = {
        layout: layout,
        range: this.range,
        interval: this.interval,
        tf: layout.ti_map.tf,
        cursor: this.cursor,
        colors: this.$p.colors,
        sub: this.data,
        font: this.$p.font,
        config: this.$p.config,
        meta: this.$p.meta
      };

      var _iterator = grid_createForOfIteratorHelper(this.$p.shaders),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var s = _step.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } // Actually draws the grid (for real)

  }, {
    key: "grid",
    value: function grid() {
      this.ctx.strokeStyle = this.$p.colors.grid;
      this.ctx.beginPath();
      var ymax = this.layout.height;

      var _iterator2 = grid_createForOfIteratorHelper(this.layout.xs),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              x = _step2$value[0],
              p = _step2$value[1];

          this.ctx.moveTo(x - 0.5, 0);
          this.ctx.lineTo(x - 0.5, ymax);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = grid_createForOfIteratorHelper(this.layout.ys),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              y = _step3$value[0],
              y$ = _step3$value[1];

          this.ctx.moveTo(0, y - 0.5);
          this.ctx.lineTo(this.layout.width, y - 0.5);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.ctx.stroke();
      if (this.$p.grid_id) this.upper_border();
    }
  }, {
    key: "upper_border",
    value: function upper_border() {
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(this.layout.width, 0.5);
      this.ctx.stroke();
    }
  }, {
    key: "mousezoom",
    value: function mousezoom(delta, event) {
      // TODO: for mobile
      if (this.wmode !== 'pass') {
        if (this.wmode === 'click' && !this.$p.meta.activated) {
          return;
        }

        event.originalEvent.preventDefault();
        event.preventDefault();
      }

      event.deltaX = event.deltaX || utils.get_deltaX(event);
      event.deltaY = event.deltaY || utils.get_deltaY(event);

      if (Math.abs(event.deltaX) > 0) {
        this.trackpad = true;

        if (Math.abs(event.deltaX) >= Math.abs(event.deltaY)) {
          delta *= 0.1;
        }

        this.trackpad_scroll(event);
      }

      if (this.trackpad) delta *= 0.032;
      delta = utils.smart_wheel(delta); // TODO: mouse zooming is a little jerky,
      // needs to follow f(mouse_wheel_speed) and
      // if speed is low, scroll shoud be slower

      if (delta < 0 && this.data.length <= this.MIN_ZOOM) return;
      if (delta > 0 && this.data.length > this.MAX_ZOOM) return;
      var k = this.interval / 1000;
      var diff = delta * k * this.data.length;
      var tl = this.comp.config.ZOOM_MODE === 'tl';

      if (event.originalEvent.ctrlKey || tl) {
        var offset = event.originalEvent.offsetX;
        var diff1 = offset / (this.canvas.width - 1) * diff;
        var diff2 = diff - diff1;
        this.range[0] -= diff1;
        this.range[1] += diff2;
      } else {
        this.range[0] -= diff;
      }

      if (tl) {
        var _offset = event.originalEvent.offsetY;

        var _diff = _offset / (this.canvas.height - 1) * 2;

        var _diff2 = 2 - _diff;

        var z = diff / (this.range[1] - this.range[0]); //rezoom_range(z, diff_x, diff_y)

        this.comp.$emit('rezoom-range', {
          grid_id: this.id,
          z: z,
          diff1: _diff,
          diff2: _diff2
        });
      }

      this.change_range();
    }
  }, {
    key: "mousedrag",
    value: function mousedrag(x, y) {
      var dt = this.drug.t * (this.drug.x - x) / this.layout.width;
      var d$ = this.layout.$_hi - this.layout.$_lo;
      d$ *= (this.drug.y - y) / this.layout.height;
      var offset = this.drug.o + d$;
      var ls = this.layout.grid.logScale;

      if (ls && this.drug.y_r) {
        var dy = this.drug.y - y;
        var range = this.drug.y_r.slice();
        range[0] = math.exp((0 - this.drug.B + dy) / this.layout.A);
        range[1] = math.exp((this.layout.height - this.drug.B + dy) / this.layout.A);
      }

      if (this.drug.y_r && this.$p.y_transform && !this.$p.y_transform.auto) {
        this.comp.$emit('sidebar-transform', {
          grid_id: this.id,
          range: ls ? range || this.drug.y_r : [this.drug.y_r[0] - offset, this.drug.y_r[1] - offset]
        });
      }

      this.range[0] = this.drug.r[0] + dt;
      this.range[1] = this.drug.r[1] + dt;
      this.change_range();
    }
  }, {
    key: "pinchzoom",
    value: function pinchzoom(scale) {
      if (scale > 1 && this.data.length <= this.MIN_ZOOM) return;
      if (scale < 1 && this.data.length > this.MAX_ZOOM) return;
      var t = this.pinch.t;
      var nt = t * 1 / scale;
      this.range[0] = this.pinch.r[0] - (nt - t) * 0.5;
      this.range[1] = this.pinch.r[1] + (nt - t) * 0.5;
      this.change_range();
    }
  }, {
    key: "trackpad_scroll",
    value: function trackpad_scroll(event) {
      var dt = this.range[1] - this.range[0];
      this.range[0] += event.deltaX * dt * 0.011;
      this.range[1] += event.deltaX * dt * 0.011;
      this.change_range();
    }
  }, {
    key: "change_range",
    value: function change_range() {
      // TODO: better way to limit the view. Problem:
      // when you are at the dead end of the data,
      // and keep scrolling,
      // the chart continues to scale down a little.
      // Solution: I don't know yet
      if (!this.range.length || this.data.length < 2) return;
      var l = this.data.length - 1;
      var data = this.data;
      var range = this.range;
      range[0] = utils.clamp(range[0], -Infinity, data[l][0] - this.interval * 5.5);
      range[1] = utils.clamp(range[1], data[0][0] + this.interval * 5.5, Infinity); // TODO: IMPORTANT scrolling is jerky The Problem caused
      // by the long round trip of 'range-changed' event.
      // First it propagates up to update layout in Chart.vue,
      // then it moves back as watch() update. It takes 1-5 ms.
      // And because the delay is different each time we see
      // the lag. No smooth movement and it's annoying.
      // Solution: we could try to calc the layout immediatly
      // somewhere here. Still will hurt the sidebar & bottombar

      this.comp.$emit('range-changed', range);
    } // Propagate mouse event to overlays

  }, {
    key: "propagate",
    value: function propagate(name, event) {
      var _iterator4 = grid_createForOfIteratorHelper(this.overlays),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var layer = _step4.value;

          if (layer.renderer[name]) {
            layer.renderer[name](event);
          }

          var mouse = layer.renderer.mouse;
          var keys = layer.renderer.keys;

          if (mouse.listeners) {
            mouse.emit(name, event);
          }

          if (keys && keys.listeners) {
            keys.emit(name, event);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var rm = removeEventListener;
      rm("gesturestart", this.gesturestart);
      rm("gesturechange", this.gesturechange);
      rm("gestureend", this.gestureend);
      if (this.mc) this.mc.destroy();
      if (this.hm) this.hm.unwheel();
    }
  }]);

  return Grid;
}();


;// CONCATENATED MODULE: ./src/mixins/canvas.js
// Interactive canvas-based component
// Should implement: mousemove, mouseout, mouseup, mousedown, click

/* harmony default export */ const canvas = ({
  methods: {
    setup: function setup() {
      var _this = this;

      var id = "".concat(this.$props.tv_id, "-").concat(this._id, "-canvas");
      var canvas = document.getElementById(id);
      var dpr = window.devicePixelRatio || 1;
      canvas.style.width = "".concat(this._attrs.width, "px");
      canvas.style.height = "".concat(this._attrs.height, "px");
      if (dpr < 1) dpr = 1; // Realy ? That's it? Issue #63

      this.$nextTick(function () {
        var rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        var ctx = canvas.getContext('2d', {// TODO: test the boost:
          //alpha: false,
          //desynchronized: true,
          //preserveDrawingBuffer: false
        });
        ctx.scale(dpr, dpr);

        _this.redraw(); // Fallback fix for Brave browser
        // https://github.com/brave/brave-browser/issues/1738


        if (!ctx.measureTextOrg) {
          ctx.measureTextOrg = ctx.measureText;
        }

        ctx.measureText = function (text) {
          return utils.measureText(ctx, text, _this.$props.tv_id);
        };
      });
    },
    create_canvas: function create_canvas(h, id, props) {
      var _this2 = this;

      this._id = id;
      this._attrs = props.attrs;
      return h('div', {
        "class": "trading-vue-".concat(id),
        style: {
          left: props.position.x + 'px',
          top: props.position.y + 'px',
          position: 'absolute'
        }
      }, [h('canvas', {
        on: {
          mousemove: function mousemove(e) {
            return _this2.renderer.mousemove(e);
          },
          mouseout: function mouseout(e) {
            return _this2.renderer.mouseout(e);
          },
          mouseup: function mouseup(e) {
            return _this2.renderer.mouseup(e);
          },
          mousedown: function mousedown(e) {
            return _this2.renderer.mousedown(e);
          }
        },
        attrs: Object.assign({
          id: "".concat(this.$props.tv_id, "-").concat(id, "-canvas")
        }, props.attrs),
        ref: 'canvas',
        style: props.style
      })].concat(props.hs || []));
    },
    redraw: function redraw() {
      if (!this.renderer) return;
      this.renderer.update();
    }
  },
  watch: {
    width: function width(val) {
      this._attrs.width = val;
      this.setup();
    },
    height: function height(val) {
      this._attrs.height = val;
      this.setup();
    }
  }
});
;// CONCATENATED MODULE: ./src/mixins/uxlist.js
// Manager for Inteerface objects
/* harmony default export */ const uxlist = ({
  methods: {
    on_ux_event: function on_ux_event(d, target) {
      if (d.event === 'new-interface') {
        if (d.args[0].target === target) {
          d.args[0].vars = d.args[0].vars || {};
          d.args[0].grid_id = d.args[1];
          d.args[0].overlay_id = d.args[2];
          this.uxs.push(d.args[0]); // this.rerender++
        }
      } else if (d.event === 'close-interface') {
        this.uxs = this.uxs.filter(function (x) {
          return x.uuid !== d.args[0];
        });
      } else if (d.event === 'modify-interface') {
        var ux = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (ux.length) {
          this.modify(ux[0], d.args[1]);
        }
      } else if (d.event === 'hide-interface') {
        var _ux = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (_ux.length) {
          _ux[0].hidden = true;
          this.modify(_ux[0], {
            hidden: true
          });
        }
      } else if (d.event === 'show-interface') {
        var _ux2 = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (_ux2.length) {
          this.modify(_ux2[0], {
            hidden: false
          });
        }
      } else {
        return d;
      }
    },
    modify: function modify(ux, obj) {
      if (obj === void 0) {
        obj = {};
      }

      for (var k in obj) {
        if (k in ux) {
          this.$set(ux, k, obj[k]);
        }
      }
    },
    // Remove all UXs for a given overlay id
    remove_all_ux: function remove_all_ux(id) {
      this.uxs = this.uxs.filter(function (x) {
        return x.overlay.id !== id;
      });
    }
  },
  data: function data() {
    return {
      uxs: []
    };
  }
});
;// CONCATENATED MODULE: ./src/components/js/crosshair.js



var Crosshair = /*#__PURE__*/function () {
  function Crosshair(comp) {
    classCallCheck_classCallCheck(this, Crosshair);

    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this._visible = false;
    this.locked = false;
    this.layout = this.$p.layout;
  }

  createClass_createClass(Crosshair, [{
    key: "draw",
    value: function draw(ctx) {
      // Update reference to the grid
      this.layout = this.$p.layout;
      var cursor = this.comp.$props.cursor;
      if (!this.visible && cursor.mode === 'explore') return;
      this.x = this.$p.cursor.x;
      this.y = this.$p.cursor.y;
      ctx.save();
      ctx.strokeStyle = this.$p.colors.cross;
      ctx.beginPath();
      ctx.setLineDash([5]); // H

      if (this.$p.cursor.grid_id === this.layout.id) {
        ctx.moveTo(0, this.y);
        ctx.lineTo(this.layout.width - 0.5, this.y);
      } // V


      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x, this.layout.height);
      ctx.stroke();
      ctx.restore();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.visible = false;
      this.x = undefined;
      this.y = undefined;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(val) {
      this._visible = val;
    }
  }]);

  return Crosshair;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Crosshair.vue?vue&type=script&lang=js&


/* harmony default export */ const Crosshairvue_type_script_lang_js_ = ({
  name: 'Crosshair',
  props: ['cursor', 'colors', 'layout', 'sub'],
  methods: {
    create: function create() {
      this.ch = new Crosshair(this); // New grid overlay-renderer descriptor.
      // Should implement draw() (see Spline.vue)

      this.$emit('new-grid-layer', {
        name: 'crosshair',
        renderer: this.ch
      });
    }
  },
  watch: {
    cursor: {
      handler: function handler() {
        if (!this.ch) this.create(); // Explore = default mode on mobile

        var cursor = this.$props.cursor;
        var explore = cursor.mode === 'explore';

        if (!cursor.x || !cursor.y) {
          this.ch.hide();
          this.$emit('redraw-grid');
          return;
        }

        this.ch.visible = !explore;
      },
      deep: true
    }
  },
  render: function render(h) {
    return h();
  }
});
;// CONCATENATED MODULE: ./src/components/Crosshair.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Crosshairvue_type_script_lang_js_ = (Crosshairvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

;// CONCATENATED MODULE: ./src/components/Crosshair.vue
var Crosshair_render, Crosshair_staticRenderFns
;



/* normalize component */
;
var component = normalizeComponent(
  components_Crosshairvue_type_script_lang_js_,
  Crosshair_render,
  Crosshair_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/Crosshair.vue"
/* harmony default export */ const components_Crosshair = (component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/KeyboardListener.vue?vue&type=script&lang=js&
//
//
//
//
/* harmony default export */ const KeyboardListenervue_type_script_lang_js_ = ({
  name: 'KeyboardListener',
  render: function render(h) {
    return h();
  },
  created: function created() {
    this.$emit('register-kb-listener', {
      id: this._uid,
      keydown: this.keydown,
      keyup: this.keyup,
      keypress: this.keypress
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.$emit('remove-kb-listener', {
      id: this._uid
    });
  },
  methods: {
    keydown: function keydown(event) {
      this.$emit('keydown', event);
    },
    keyup: function keyup(event) {
      this.$emit('keyup', event);
    },
    keypress: function keypress(event) {
      this.$emit('keypress', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/KeyboardListener.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_KeyboardListenervue_type_script_lang_js_ = (KeyboardListenervue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/KeyboardListener.vue
var KeyboardListener_render, KeyboardListener_staticRenderFns
;



/* normalize component */
;
var KeyboardListener_component = normalizeComponent(
  components_KeyboardListenervue_type_script_lang_js_,
  KeyboardListener_render,
  KeyboardListener_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KeyboardListener_api; }
KeyboardListener_component.options.__file = "src/components/KeyboardListener.vue"
/* harmony default export */ const KeyboardListener = (KeyboardListener_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxLayer.vue?vue&type=template&id=390ccf6e&
var UxLayervue_type_template_id_390ccf6e_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "span",
    { class: "trading-vue-grid-ux-" + _vm.id, style: _vm.style },
    _vm._l(_vm.uxs, function(ux) {
      return _c("ux-wrapper", {
        key: ux.uuid,
        attrs: {
          ux: ux,
          updater: _vm.updater,
          colors: _vm.colors,
          config: _vm.config
        },
        on: { "custom-event": _vm.on_custom_event }
      })
    }),
    1
  )
}
var UxLayervue_type_template_id_390ccf6e_staticRenderFns = []
UxLayervue_type_template_id_390ccf6e_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/UxLayer.vue?vue&type=template&id=390ccf6e&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=template&id=4bc32070&
var UxWrappervue_type_template_id_4bc32070_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.visible
    ? _c(
        "div",
        {
          staticClass: "trading-vue-ux-wrapper",
          style: _vm.style,
          attrs: { id: "tvjs-ux-wrapper-" + _vm.ux.uuid }
        },
        [
          _c(_vm.ux.component, {
            tag: "component",
            attrs: {
              ux: _vm.ux,
              updater: _vm.updater,
              wrapper: _vm.wrapper,
              colors: _vm.colors
            },
            on: { "custom-event": _vm.on_custom_event }
          }),
          _vm._v(" "),
          _vm.ux.show_pin
            ? _c("div", {
                staticClass: "tvjs-ux-wrapper-pin",
                style: _vm.pin_style
              })
            : _vm._e(),
          _vm._v(" "),
          _vm.ux.win_header !== false
            ? _c("div", { staticClass: "tvjs-ux-wrapper-head" }, [
                _c(
                  "div",
                  {
                    staticClass: "tvjs-ux-wrapper-close",
                    style: _vm.btn_style,
                    on: { click: _vm.close }
                  },
                  [_vm._v("×")]
                )
              ])
            : _vm._e()
        ],
        1
      )
    : _vm._e()
}
var UxWrappervue_type_template_id_4bc32070_staticRenderFns = []
UxWrappervue_type_template_id_4bc32070_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=template&id=4bc32070&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const UxWrappervue_type_script_lang_js_ = ({
  name: 'UxWrapper',
  props: ['ux', 'updater', 'colors', 'config'],
  mounted: function mounted() {
    this.self = document.getElementById(this.uuid);
    this.w = this.self.offsetWidth; // TODO: => width: "content"

    this.h = this.self.offsetHeight; // TODO: => height: "content"

    this.update_position();
  },
  created: function created() {
    this.mouse.on('mousemove', this.mousemove);
    this.mouse.on('mouseout', this.mouseout);
  },
  beforeDestroy: function beforeDestroy() {
    this.mouse.off('mousemove', this.mousemove);
    this.mouse.off('mouseout', this.mouseout);
  },
  methods: {
    update_position: function update_position() {
      if (this.uxr.hidden) return;
      var lw = this.layout.width;
      var lh = this.layout.height;
      var pin = this.uxr.pin;

      switch (pin[0]) {
        case 'cursor':
          var x = this.uxr.overlay.cursor.x;
          break;

        case 'mouse':
          x = this.mouse.x;
          break;

        default:
          if (typeof pin[0] === 'string') {
            x = this.parse_coord(pin[0], lw);
          } else {
            x = this.layout.t2screen(pin[0]);
          }

      }

      switch (pin[1]) {
        case 'cursor':
          var y = this.uxr.overlay.cursor.y;
          break;

        case 'mouse':
          y = this.mouse.y;
          break;

        default:
          if (typeof pin[1] === 'string') {
            y = this.parse_coord(pin[1], lh);
          } else {
            y = this.layout.$2screen(pin[1]);
          }

      }

      this.x = x + this.ox;
      this.y = y + this.oy;
    },
    parse_coord: function parse_coord(str, scale) {
      str = str.trim();
      if (str === '0' || str === '') return 0;
      var plus = str.split('+');

      if (plus.length === 2) {
        return this.parse_coord(plus[0], scale) + this.parse_coord(plus[1], scale);
      }

      var minus = str.split('-');

      if (minus.length === 2) {
        return this.parse_coord(minus[0], scale) - this.parse_coord(minus[1], scale);
      }

      var per = str.split('%');

      if (per.length === 2) {
        return scale * parseInt(per[0]) / 100;
      }

      var px = str.split('px');

      if (px.length === 2) {
        return parseInt(px[0]);
      }

      return undefined;
    },
    mousemove: function mousemove() {
      this.update_position();
      this.visible = true;
    },
    mouseout: function mouseout() {
      if (this.uxr.pin.includes('cursor') || this.uxr.pin.includes('mouse')) this.visible = false;
    },
    on_custom_event: function on_custom_event(event) {
      this.$emit('custom-event', event);

      if (event.event === 'modify-interface') {
        if (this.self) {
          this.w = this.self.offsetWidth;
          this.h = this.self.offsetHeight;
        }

        this.update_position();
      }
    },
    close: function close() {
      this.$emit('custom-event', {
        event: 'close-interface',
        args: [this.$props.ux.uuid]
      });
    }
  },
  computed: {
    uxr: function uxr() {
      return this.$props.ux; // just a ref
    },
    layout: function layout() {
      return this.$props.ux.overlay.layout;
    },
    settings: function settings() {
      return this.$props.ux.overlay.settings;
    },
    uuid: function uuid() {
      return "tvjs-ux-wrapper-".concat(this.uxr.uuid);
    },
    mouse: function mouse() {
      return this.uxr.overlay.mouse;
    },
    style: function style() {
      var st = {
        'display': this.uxr.hidden ? 'none' : undefined,
        'left': "".concat(this.x, "px"),
        'top': "".concat(this.y, "px"),
        'pointer-events': this.uxr.pointer_events || 'all',
        'z-index': this.z_index
      };
      if (this.uxr.win_styling !== false) st = Object.assign(st, {
        'border': "1px solid ".concat(this.$props.colors.grid),
        'border-radius': '3px',
        'background': "".concat(this.background)
      });
      return st;
    },
    pin_style: function pin_style() {
      return {
        'left': "".concat(-this.ox, "px"),
        'top': "".concat(-this.oy, "px"),
        'background-color': this.uxr.pin_color
      };
    },
    btn_style: function btn_style() {
      return {
        'background': "".concat(this.inactive_btn_color),
        'color': "".concat(this.inactive_btn_color)
      };
    },
    pin_pos: function pin_pos() {
      return this.uxr.pin_position ? this.uxr.pin_position.split(',') : ['0', '0'];
    },
    // Offset x
    ox: function ox() {
      if (this.pin_pos.length !== 2) return undefined;
      var x = this.parse_coord(this.pin_pos[0], this.w);
      return -x;
    },
    // Offset y
    oy: function oy() {
      if (this.pin_pos.length !== 2) return undefined;
      var y = this.parse_coord(this.pin_pos[1], this.h);
      return -y;
    },
    z_index: function z_index() {
      var base_index = this.settings['z-index'] || this.settings['zIndex'] || 0;
      var ux_index = this.uxr['z_index'] || 0;
      return base_index + ux_index;
    },
    background: function background() {
      var c = this.uxr.background || this.$props.colors.back;
      return utils.apply_opacity(c, this.uxr.background_opacity || this.$props.config.UX_OPACITY);
    },
    inactive_btn_color: function inactive_btn_color() {
      return this.uxr.inactive_btn_color || this.$props.colors.grid;
    },
    wrapper: function wrapper() {
      return {
        x: this.x,
        y: this.y,
        pin_x: this.x - this.ox,
        pin_y: this.y - this.oy
      };
    }
  },
  watch: {
    updater: function updater() {
      this.update_position();
    }
  },
  data: function data() {
    return {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      visible: true
    };
  }
});
;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_UxWrappervue_type_script_lang_js_ = (UxWrappervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=style&index=0&lang=css&
var UxWrappervue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(565);
;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/UxWrapper.vue



;


/* normalize component */

var UxWrapper_component = normalizeComponent(
  components_UxWrappervue_type_script_lang_js_,
  UxWrappervue_type_template_id_4bc32070_render,
  UxWrappervue_type_template_id_4bc32070_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var UxWrapper_api; }
UxWrapper_component.options.__file = "src/components/UxWrapper.vue"
/* harmony default export */ const UxWrapper = (UxWrapper_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxLayer.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const UxLayervue_type_script_lang_js_ = ({
  name: 'UxLayer',
  props: ['tv_id', 'id', 'uxs', 'updater', 'colors', 'config'],
  components: {
    UxWrapper: UxWrapper
  },
  created: function created() {},
  mounted: function mounted() {},
  beforeDestroy: function beforeDestroy() {},
  methods: {
    on_custom_event: function on_custom_event(event) {
      this.$emit('custom-event', event);
    }
  },
  computed: {
    style: function style() {
      return {
        'top': this.$props.id !== 0 ? '1px' : 0,
        'left': 0,
        'width': '100%',
        'height': 'calc(100% - 2px)',
        'position': 'absolute',
        'z-index': '1',
        'pointer-events': 'none',
        'overflow': 'hidden'
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/components/UxLayer.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_UxLayervue_type_script_lang_js_ = (UxLayervue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/UxLayer.vue





/* normalize component */
;
var UxLayer_component = normalizeComponent(
  components_UxLayervue_type_script_lang_js_,
  UxLayervue_type_template_id_390ccf6e_render,
  UxLayervue_type_template_id_390ccf6e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var UxLayer_api; }
UxLayer_component.options.__file = "src/components/UxLayer.vue"
/* harmony default export */ const UxLayer = (UxLayer_component.exports);
;// CONCATENATED MODULE: ./src/stuff/mouse.js



function mouse_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = mouse_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function mouse_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return mouse_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mouse_arrayLikeToArray(o, minLen); }

function mouse_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Mouse event handler for overlay
var Mouse = /*#__PURE__*/function () {
  function Mouse(comp) {
    classCallCheck_classCallCheck(this, Mouse);

    this.comp = comp;
    this.map = {};
    this.listeners = 0;
    this.pressed = false;
    this.x = comp.$props.cursor.x;
    this.y = comp.$props.cursor.y;
    this.t = comp.$props.cursor.t;
    this.y$ = comp.$props.cursor.y$;
  } // You can choose where to place the handler
  // (beginning or end of the queue)


  createClass_createClass(Mouse, [{
    key: "on",
    value: function on(name, handler, dir) {
      if (dir === void 0) {
        dir = "unshift";
      }

      if (!handler) return;
      this.map[name] = this.map[name] || [];
      this.map[name][dir](handler);
      this.listeners++;
    }
  }, {
    key: "off",
    value: function off(name, handler) {
      if (!this.map[name]) return;
      var i = this.map[name].indexOf(handler);
      if (i < 0) return;
      this.map[name].splice(i, 1);
      this.listeners--;
    } // Called by grid.js

  }, {
    key: "emit",
    value: function emit(name, event) {
      var l = this.comp.layout;

      if (name in this.map) {
        var _iterator = mouse_createForOfIteratorHelper(this.map[name]),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var f = _step.value;
            f(event);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (name === 'mousemove') {
        this.x = event.layerX;
        this.y = event.layerY;
        this.t = l.screen2t(this.x);
        this.y$ = l.screen2$(this.y);
      }

      if (name === 'mousedown') {
        this.pressed = true;
      }

      if (name === 'mouseup') {
        this.pressed = false;
      }
    }
  }]);

  return Mouse;
}();


;// CONCATENATED MODULE: ./src/mixins/overlay.js
// Usuful stuff for creating overlays. Include as mixin

/* harmony default export */ const overlay = ({
  props: ['id', 'num', 'interval', 'cursor', 'colors', 'layout', 'sub', 'data', 'settings', 'grid_id', 'font', 'config', 'meta', 'tf', 'i0', 'last'],
  mounted: function mounted() {
    // TODO(1): when hot reloading, dynamicaly changed mixins
    // dissapear (cuz it's a hack), the only way for now
    // is to reload the browser
    if (!this.draw) {
      this.draw = function (ctx) {
        var text = 'EARLY ADOPTER BUG: reload the browser & enjoy';
        console.warn(text);
      };
    } // Main chart?


    var main = this.$props.sub === this.$props.data;
    this.meta_info(); // TODO(1): quick fix for vue2, in vue3 we use 3rd party emit

    try {
      new Function('return ' + this.$emit)();
      this._$emit = this.$emit;
      this.$emit = this.custom_event;
    } catch (e) {
      return;
    }

    this._$emit('new-grid-layer', {
      name: this.$options.name,
      id: this.$props.id,
      renderer: this,
      display: 'display' in this.$props.settings ? this.$props.settings['display'] : true,
      z: this.$props.settings['z-index'] || this.$props.settings['zIndex'] || (main ? 0 : -1)
    }); // Overlay meta-props (adjusting behaviour)


    this._$emit('layer-meta-props', {
      grid_id: this.$props.grid_id,
      layer_id: this.$props.id,
      legend: this.legend,
      data_colors: this.data_colors,
      y_range: this.y_range
    });

    this.exec_script();
    this.mouse = new Mouse(this);
    if (this.init_tool) this.init_tool();
    if (this.init) this.init();
  },
  beforeDestroy: function beforeDestroy() {
    if (this.destroy) this.destroy();

    this._$emit('delete-grid-layer', this.$props.id);
  },
  methods: {
    use_for: function use_for() {
      /* override it (mandatory) */
      console.warn('use_for() should be implemented');
      console.warn("Format: use_for() {\n                  return ['type1', 'type2', ...]\n            }");
    },
    meta_info: function meta_info() {
      /* override it (optional) */
      var id = this.$props.id;
      console.warn("".concat(id, " meta_info() is req. for publishing"));
      console.warn("Format: meta_info() {\n                author: 'Satoshi Smith',\n                version: '1.0.0',\n                contact (opt) '<email>'\n                github: (opt) '<GitHub Page>',\n            }");
    },
    custom_event: function custom_event(event) {
      if (event.split(':')[0] === 'hook') return;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (event === 'change-settings' || event === 'object-selected' || event === 'new-shader' || event === 'new-interface' || event === 'remove-tool') {
        args.push(this.grid_id, this.id);

        if (this.$props.settings.$uuid) {
          args.push(this.$props.settings.$uuid);
        }
      }

      if (event === 'new-interface') {
        args[0].overlay = this;
        args[0].uuid = this.last_ux_id = "".concat(this.grid_id, "-").concat(this.id, "-").concat(this.uxs_count++);
      } // TODO: add a namespace to the event name
      // TODO(2): this prevents call overflow, but
      // the root of evil is in (1)


      if (event === 'custom-event') return;

      this._$emit('custom-event', {
        event: event,
        args: args
      });
    },
    // TODO: the event is not firing when the same
    // overlay type is added to the offchart[]
    exec_script: function exec_script() {
      if (this.calc) this.$emit('exec-script', {
        grid_id: this.$props.grid_id,
        layer_id: this.$props.id,
        src: this.calc(),
        use_for: this.use_for()
      });
    }
  },
  watch: {
    settings: {
      handler: function handler(n, p) {
        if (this.watch_uuid) this.watch_uuid(n, p);

        this._$emit('show-grid-layer', {
          id: this.$props.id,
          display: 'display' in this.$props.settings ? this.$props.settings['display'] : true
        });
      },
      deep: true
    }
  },
  data: function data() {
    return {
      uxs_count: 0,
      last_ux_id: null
    };
  },
  render: function render(h) {
    return h();
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Spline.vue?vue&type=script&lang=js&
// Spline renderer. (SMAs, EMAs, TEMAs...
// you know what I mean)
// TODO: make a real spline, not a bunch of lines...
// Adds all necessary stuff for you.

/* harmony default export */ const Splinevue_type_script_lang_js_ = ({
  name: 'Spline',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.2'
      };
    },
    // Here goes your code. You are provided with:
    // { All stuff is reactive }
    // $props.layout -> positions of all chart elements +
    //  some helper functions (see layout_fn.js)
    // $props.interval -> candlestick time interval
    // $props.sub -> current subset of candlestick data
    // $props.data -> your indicator's data subset.
    //  Comes "as is", should have the following format:
    //  [[<timestamp>, ... ], ... ]
    // $props.colors -> colors (see TradingVue.vue)
    // $props.cursor -> current position of crosshair
    // $props.settings -> indicator's custom settings
    //  E.g. colors, line thickness, etc. You define it.
    // $props.num -> indicator's layer number (of All
    // layers in the current grid)
    // $props.id -> indicator's id (e.g. EMA_0)
    // ~
    // Finally, let's make the canvas dirty!
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var i = this.data_index;
      var data = this.$props.data;

      if (!this.skip_nan) {
        for (var k = 0, n = data.length; k < n; k++) {
          var p = data[k];
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[i]);
          ctx.lineTo(x, y);
        }
      } else {
        var skip = false;

        for (var k = 0, n = data.length; k < n; k++) {
          var _p = data[k];

          var _x = layout.t2screen(_p[0]);

          var _y = layout.$2screen(_p[i]);

          if (_p[i] == null || _y !== _y) {
            skip = true;
          } else {
            if (skip) ctx.moveTo(_x, _y);
            ctx.lineTo(_x, _y);
            skip = false;
          }
        }
      }

      ctx.stroke();
    },
    // For all data with these types overlay will be
    // added to the renderer list. And '$props.data'
    // will have the corresponding values. If you want to
    // redefine the default behviour for a prticular
    // indicator (let's say EMA),
    // just create a new overlay with the same type:
    // e.g. use_for() { return ['EMA'] }.
    use_for: function use_for() {
      return ['Spline', 'EMA', 'SMA'];
    },
    // Colors for the legend, should have the
    // same dimention as a data point (excl. timestamp)
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    },
    data_index: function data_index() {
      return this.sett.dataIndex || 1;
    },
    // Don't connect separate parts if true
    skip_nan: function skip_nan() {
      return this.sett.skipNaN;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Spline.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splinevue_type_script_lang_js_ = (Splinevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Spline.vue
var Spline_render, Spline_staticRenderFns
;



/* normalize component */
;
var Spline_component = normalizeComponent(
  overlays_Splinevue_type_script_lang_js_,
  Spline_render,
  Spline_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Spline_api; }
Spline_component.options.__file = "src/components/overlays/Spline.vue"
/* harmony default export */ const Spline = (Spline_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Splines.vue?vue&type=script&lang=js&
// Channel renderer. (Keltner, Bollinger)

/* harmony default export */ const Splinesvue_type_script_lang_js_ = ({
  name: 'Splines',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    draw: function draw(ctx) {
      for (var i = 0; i < this.lines_num; i++) {
        var _i = i % this.clrx.length;

        ctx.strokeStyle = this.clrx[_i];
        ctx.lineWidth = this.widths[i] || this.line_width;
        ctx.beginPath();
        this.draw_spline(ctx, i);
        ctx.stroke();
      }
    },
    draw_spline: function draw_spline(ctx, i) {
      var layout = this.$props.layout;
      var data = this.$props.data;

      if (!this.skip_nan) {
        for (var k = 0, n = data.length; k < n; k++) {
          var p = data[k];
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[i + 1]);
          ctx.lineTo(x, y);
        }
      } else {
        var skip = false;

        for (var k = 0, n = data.length; k < n; k++) {
          var _p = data[k];

          var _x = layout.t2screen(_p[0]);

          var _y = layout.$2screen(_p[i + 1]);

          if (_p[i + 1] == null || _y !== _y) {
            skip = true;
          } else {
            if (skip) ctx.moveTo(_x, _y);
            ctx.lineTo(_x, _y);
            skip = false;
          }
        }
      }
    },
    use_for: function use_for() {
      return ['Splines', 'DMI'];
    },
    data_colors: function data_colors() {
      return this.clrx;
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    widths: function widths() {
      return this.sett.lineWidths || [];
    },
    clrx: function clrx() {
      var colors = this.sett.colors || [];
      var n = this.$props.num;

      if (!colors.length) {
        for (var i = 0; i < this.lines_num; i++) {
          colors.push(this.COLORS[(n + i) % 5]);
        }
      }

      return colors;
    },
    lines_num: function lines_num() {
      if (!this.$props.data[0]) return 0;
      return this.$props.data[0].length - 1;
    },
    // Don't connect separate parts if true
    skip_nan: function skip_nan() {
      return this.sett.skipNaN;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Splines.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splinesvue_type_script_lang_js_ = (Splinesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Splines.vue
var Splines_render, Splines_staticRenderFns
;



/* normalize component */
;
var Splines_component = normalizeComponent(
  overlays_Splinesvue_type_script_lang_js_,
  Splines_render,
  Splines_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Splines_api; }
Splines_component.options.__file = "src/components/overlays/Splines.vue"
/* harmony default export */ const Splines = (Splines_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Range.vue?vue&type=script&lang=js&
// R S I . Because we love it
// Adds all necessary stuff for you.

/* harmony default export */ const Rangevue_type_script_lang_js_ = ({
  name: 'Range',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },
    // Here goes your code. You are provided with:
    // { All stuff is reactive }
    // $props.layout -> positions of all chart elements +
    //  some helper functions (see layout_fn.js)
    // $props.interval -> candlestick time interval
    // $props.sub -> current subset of candlestick data
    // $props.data -> your indicator's data subset.
    //  Comes "as is", should have the following format:
    //  [[<timestamp>, ... ], ... ]
    // $props.colors -> colors (see TradingVue.vue)
    // $props.cursor -> current position of crosshair
    // $props.settings -> indicator's custom settings
    //  E.g. colors, line thickness, etc. You define it.
    // $props.num -> indicator's layer number (of All
    // layers in the current grid)
    // $props.id -> indicator's id (e.g. EMA_0)
    // ~
    // Finally, let's make the canvas dirty!
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var upper = layout.$2screen(this.sett.upper || 70);
      var lower = layout.$2screen(this.sett.lower || 30);
      var data = this.$props.data; // RSI values

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      for (var k = 0, n = data.length; k < n; k++) {
        var p = data[k];
        var x = layout.t2screen(p[0]);
        var y = layout.$2screen(p[1]);
        ctx.lineTo(x, y);
      }

      ctx.stroke();
      ctx.strokeStyle = this.band_color;
      ctx.setLineDash([5]); // Will be removed after draw()

      ctx.beginPath(); // Fill the area between the bands

      ctx.fillStyle = this.back_color;
      ctx.fillRect(0, upper, layout.width, lower - upper); // Upper band

      ctx.moveTo(0, upper);
      ctx.lineTo(layout.width, upper); // Lower band

      ctx.moveTo(0, lower);
      ctx.lineTo(layout.width, lower);
      ctx.stroke();
    },
    // For all data with these types overlay will be
    // added to the renderer list. And '$props.data'
    // will have the corresponding values. If you want to
    // redefine the default behviour for a prticular
    // indicator (let's say EMA),
    // just create a new overlay with the same type:
    // e.g. use_for() { return ['EMA'] }.
    use_for: function use_for() {
      return ['Range', 'RSI'];
    },
    // Colors for the legend, should have the
    // same dimention as a data point (excl. timestamp)
    data_colors: function data_colors() {
      return [this.color];
    },
    // Y-Range tansform. For example you need a fixed
    // Y-range for an indicator, you can do it here!
    // Gets estimated range, @return you favorite range
    y_range: function y_range(hi, lo) {
      return [Math.max(hi, this.sett.upper || 70), Math.min(lo, this.sett.lower || 30)];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      return this.sett.color || '#ec206e';
    },
    band_color: function band_color() {
      return this.sett.bandColor || '#ddd';
    },
    back_color: function back_color() {
      return this.sett.backColor || '#381e9c16';
    }
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Range.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Rangevue_type_script_lang_js_ = (Rangevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Range.vue
var Range_render, Range_staticRenderFns
;



/* normalize component */
;
var Range_component = normalizeComponent(
  overlays_Rangevue_type_script_lang_js_,
  Range_render,
  Range_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Range_api; }
Range_component.options.__file = "src/components/overlays/Range.vue"
/* harmony default export */ const Range = (Range_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Trades.vue?vue&type=script&lang=js&

/* harmony default export */ const Tradesvue_type_script_lang_js_ = ({
  name: 'Trades',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.2'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var data = this.$props.data;
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';

      for (var k = 0, n = data.length; k < n; k++) {
        var p = data[k];
        ctx.fillStyle = p[1] ? this.buy_color : this.sell_color;
        ctx.beginPath();
        var x = layout.t2screen(p[0]); // x - Mapping

        var y = layout.$2screen(p[2]); // y - Mapping

        ctx.arc(x, y, this.marker_size + 0.5, 0, Math.PI * 2, true);
        ctx.fill();
        ctx.stroke();

        if (this.show_label && p[3]) {
          this.draw_label(ctx, x, y, p);
        }
      }
    },
    draw_label: function draw_label(ctx, x, y, p) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(p[3], x, y - 25);
    },
    use_for: function use_for() {
      return ['Trades'];
    },
    // Defines legend format (values & colors)
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Sell';
          break;

        case 1:
          pos = 'Buy';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.text
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    buy_color: function buy_color() {
      return this.sett.buyColor || '#63df89';
    },
    sell_color: function sell_color() {
      return this.sett.sellColor || '#ec4662';
    },
    label_color: function label_color() {
      return this.sett.labelColor || '#999';
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Trades.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Tradesvue_type_script_lang_js_ = (Tradesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Trades.vue
var Trades_render, Trades_staticRenderFns
;



/* normalize component */
;
var Trades_component = normalizeComponent(
  overlays_Tradesvue_type_script_lang_js_,
  Trades_render,
  Trades_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Trades_api; }
Trades_component.options.__file = "src/components/overlays/Trades.vue"
/* harmony default export */ const Trades = (Trades_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Channel.vue?vue&type=script&lang=js&
// Channel renderer. (Keltner, Bollinger)
// TODO: allow color transparency
// TODO: improve performance: draw in one solid chunk

/* harmony default export */ const Channelvue_type_script_lang_js_ = ({
  name: 'Channel',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },

    /*draw(ctx) {
        ctx.lineWidth = this.line_width
        ctx.strokeStyle = this.color
        ctx.fillStyle = this.back_color
         for (var i = 0; i < this.$props.data.length - 1; i++) {
              let p1 = this.mapp(this.$props.data[i])
            let p2 = this.mapp(this.$props.data[i+1])
             if (!p2) continue
            if (p1.y1 !== p1.y1) continue // Fix NaN
             // Background
            ctx.beginPath()
            ctx.moveTo(p1.x, p1.y1)
            ctx.lineTo(p2.x + 0.1, p2.y1)
            ctx.lineTo(p2.x + 0.1, p2.y3)
            ctx.lineTo(p1.x, p1.y3)
            ctx.fill()
             // Lines
            ctx.beginPath()
            ctx.moveTo(p1.x, p1.y1)
            ctx.lineTo(p2.x, p2.y1)
            if (this.show_mid) {
                ctx.moveTo(p1.x, p1.y2)
                ctx.lineTo(p2.x, p2.y2)
            }
            ctx.moveTo(p1.x, p1.y3)
            ctx.lineTo(p2.x, p2.y3)
            ctx.stroke()
         }
    },*/
    draw: function draw(ctx) {
      // Background
      var data = this.data;
      var layout = this.layout;
      ctx.beginPath();
      ctx.fillStyle = this.back_color;

      for (var i = 0; i < data.length; i++) {
        var p = data[i];
        var x = layout.t2screen(p[0]);
        var y = layout.$2screen(p[1] || undefined);
        ctx.lineTo(x, y);
      }

      for (var i = data.length - 1; i >= 0; i--) {
        var _p = data[i];

        var _x = layout.t2screen(_p[0]);

        var _y = layout.$2screen(_p[3] || undefined);

        ctx.lineTo(_x, _y);
      }

      ctx.fill(); // Lines

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color; // Top line

      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p2 = data[i];

        var _x2 = layout.t2screen(_p2[0]);

        var _y2 = layout.$2screen(_p2[1] || undefined);

        ctx.lineTo(_x2, _y2);
      }

      ctx.stroke(); // Bottom line

      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p3 = data[i];

        var _x3 = layout.t2screen(_p3[0]);

        var _y3 = layout.$2screen(_p3[3] || undefined);

        ctx.lineTo(_x3, _y3);
      }

      ctx.stroke(); // Middle line

      if (!this.show_mid) return;
      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p4 = data[i];

        var _x4 = layout.t2screen(_p4[0]);

        var _y4 = layout.$2screen(_p4[2] || undefined);

        ctx.lineTo(_x4, _y4);
      }

      ctx.stroke();
    },
    mapp: function mapp(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        y1: layout.$2screen(p[1]),
        y2: layout.$2screen(p[2]),
        y3: layout.$2screen(p[3])
      };
    },
    use_for: function use_for() {
      return ['Channel', 'KC', 'BB'];
    },
    data_colors: function data_colors() {
      return [this.color, this.color, this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    },
    show_mid: function show_mid() {
      return 'showMid' in this.sett ? this.sett.showMid : true;
    },
    back_color: function back_color() {
      return this.sett.backColor || this.color + '11';
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Channel.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Channelvue_type_script_lang_js_ = (Channelvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Channel.vue
var Channel_render, Channel_staticRenderFns
;



/* normalize component */
;
var Channel_component = normalizeComponent(
  overlays_Channelvue_type_script_lang_js_,
  Channel_render,
  Channel_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Channel_api; }
Channel_component.options.__file = "src/components/overlays/Channel.vue"
/* harmony default export */ const Channel = (Channel_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Segment.vue?vue&type=script&lang=js&
// Segment renderer.

/* harmony default export */ const Segmentvue_type_script_lang_js_ = ({
  name: 'Segment',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.0'
      };
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var x1 = layout.t2screen(this.p1[0]);
      var y1 = layout.$2screen(this.p1[1]);
      ctx.moveTo(x1, y1);
      var x2 = layout.t2screen(this.p2[0]);
      var y2 = layout.$2screen(this.p2[1]);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Segment'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Segment.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Segmentvue_type_script_lang_js_ = (Segmentvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Segment.vue
var Segment_render, Segment_staticRenderFns
;



/* normalize component */
;
var Segment_component = normalizeComponent(
  overlays_Segmentvue_type_script_lang_js_,
  Segment_render,
  Segment_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Segment_api; }
Segment_component.options.__file = "src/components/overlays/Segment.vue"
/* harmony default export */ const Segment = (Segment_component.exports);
;// CONCATENATED MODULE: ./src/components/js/layout_cnv.js


// Claculates postions and sizes for candlestick
// and volume bars for the given subset of data

function layout_cnv(self) {
  var $p = self.$props;
  var sub = $p.data;
  var t2screen = $p.layout.t2screen;
  var layout = $p.layout;
  var candles = [];
  var volume = []; // The volume bar height is determined as a percentage of
  // the chart's height (VOLSCALE)

  var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
    return x[5];
  })));
  var vs = $p.config.VOLSCALE * layout.height / maxv;
  var x1,
      x2,
      w,
      avg_w,
      mid,
      prev = undefined; // Subset interval against main interval

  var _new_interval = new_interval(layout, $p, sub),
      _new_interval2 = _slicedToArray(_new_interval, 2),
      interval2 = _new_interval2[0],
      ratio = _new_interval2[1];

  var px_step2 = layout.px_step * ratio;
  var splitter = px_step2 > 5 ? 1 : 0; // A & B are current chart tranformations:
  // A === scale,  B === Y-axis shift

  for (var i = 0; i < sub.length; i++) {
    var p = sub[i];
    mid = t2screen(p[0]) + 1; // Clear volume bar if there is a time gap

    if (sub[i - 1] && p[0] - sub[i - 1][0] > interval2) {
      prev = null;
    }

    x1 = prev || Math.floor(mid - px_step2 * 0.5);
    x2 = Math.floor(mid + px_step2 * 0.5) - 0.5; // TODO: add log scale support

    candles.push({
      x: mid,
      w: layout.px_step * $p.config.CANDLEW * ratio,
      o: Math.floor(p[1] * layout.A + layout.B),
      h: Math.floor(p[2] * layout.A + layout.B),
      l: Math.floor(p[3] * layout.A + layout.B),
      c: Math.floor(p[4] * layout.A + layout.B),
      raw: p
    });
    volume.push({
      x1: x1,
      x2: x2,
      h: p[5] * vs,
      green: p[4] >= p[1],
      raw: p
    });
    prev = x2 + splitter;
  }

  return {
    candles: candles,
    volume: volume
  };
}
function layout_vol(self) {
  var $p = self.$props;
  var sub = $p.data;
  var t2screen = $p.layout.t2screen;
  var layout = $p.layout;
  var volume = []; // Detect data second dimention size:

  var dim = sub[0] ? sub[0].length : 0; // Support special volume data (see API book), or OHLCV
  // Data indices:

  self._i1 = dim < 6 ? 1 : 5;
  self._i2 = dim < 6 ? function (p) {
    return p[2];
  } : function (p) {
    return p[4] >= p[1];
  };
  var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
    return x[self._i1];
  })));
  var volscale = self.volscale || $p.config.VOLSCALE;
  var vs = volscale * layout.height / maxv;
  var x1,
      x2,
      mid,
      prev = undefined; // Subset interval against main interval

  var _new_interval3 = new_interval(layout, $p, sub),
      _new_interval4 = _slicedToArray(_new_interval3, 2),
      interval2 = _new_interval4[0],
      ratio = _new_interval4[1];

  var px_step2 = layout.px_step * ratio;
  var splitter = px_step2 > 5 ? 1 : 0; // A & B are current chart tranformations:
  // A === scale,  B === Y-axis shift

  for (var i = 0; i < sub.length; i++) {
    var p = sub[i];
    mid = t2screen(p[0]) + 1; // Clear volume bar if there is a time gap

    if (sub[i - 1] && p[0] - sub[i - 1][0] > interval2) {
      prev = null;
    }

    x1 = prev || Math.floor(mid - px_step2 * 0.5);
    x2 = Math.floor(mid + px_step2 * 0.5) - 0.5;
    volume.push({
      x1: x1,
      x2: x2,
      h: p[self._i1] * vs,
      green: self._i2(p),
      raw: p
    });
    prev = x2 + splitter;
  }

  return volume;
}

function new_interval(layout, $p, sub) {
  // Subset interval against main interval
  if (!layout.ti_map.ib) {
    var interval2 = $p.tf || utils.detect_interval(sub);
    var ratio = interval2 / $p.interval;
  } else {
    if ($p.tf) {
      var ratio = $p.tf / layout.ti_map.tf;
      var interval2 = ratio;
    } else {
      var interval2 = utils.detect_interval(sub);
      var ratio = interval2 / $p.interval;
    }
  }

  return [interval2, ratio];
}
;// CONCATENATED MODULE: ./src/components/primitives/candle.js



// Candle object for Candles overlay
var CandleExt = /*#__PURE__*/function () {
  function CandleExt(overlay, ctx, data) {
    classCallCheck_classCallCheck(this, CandleExt);

    this.ctx = ctx;
    this.self = overlay;
    this.style = data.raw[6] || this.self;
    this.draw(data);
  }

  createClass_createClass(CandleExt, [{
    key: "draw",
    value: function draw(data) {
      var green = data.raw[4] >= data.raw[1];
      var body_color = green ? this.style.colorCandleUp : this.style.colorCandleDw;
      var wick_color = green ? this.style.colorWickUp : this.style.colorWickDw;
      var w = Math.max(data.w, 1);
      var hw = Math.max(Math.floor(w * 0.5), 1);
      var h = Math.abs(data.o - data.c);
      var max_h = data.c === data.o ? 1 : 2;
      var x05 = Math.floor(data.x) - 0.5;
      this.ctx.strokeStyle = wick_color;
      this.ctx.beginPath();
      this.ctx.moveTo(x05, Math.floor(data.h));
      this.ctx.lineTo(x05, Math.floor(data.l));
      this.ctx.stroke();

      if (data.w > 1.5) {
        this.ctx.fillStyle = body_color; // TODO: Move common calculations to layout.js

        var s = green ? 1 : -1;
        this.ctx.fillRect(Math.floor(data.x - hw - 1), data.c, Math.floor(hw * 2 + 1), s * Math.max(h, max_h));
      } else {
        this.ctx.strokeStyle = body_color;
        this.ctx.beginPath();
        this.ctx.moveTo(x05, Math.floor(Math.min(data.o, data.c)));
        this.ctx.lineTo(x05, Math.floor(Math.max(data.o, data.c)) + (data.o === data.c ? 1 : 0));
        this.ctx.stroke();
      }
    }
  }]);

  return CandleExt;
}();


;// CONCATENATED MODULE: ./src/components/primitives/volbar.js



var VolbarExt = /*#__PURE__*/function () {
  function VolbarExt(overlay, ctx, data) {
    classCallCheck_classCallCheck(this, VolbarExt);

    this.ctx = ctx;
    this.$p = overlay.$props;
    this.self = overlay;
    this.style = data.raw[6] || this.self;
    this.draw(data);
  }

  createClass_createClass(VolbarExt, [{
    key: "draw",
    value: function draw(data) {
      var y0 = this.$p.layout.height;
      var w = data.x2 - data.x1;
      var h = Math.floor(data.h);
      this.ctx.fillStyle = data.green ? this.style.colorVolUp : this.style.colorVolDw;
      this.ctx.fillRect(Math.floor(data.x1), Math.floor(y0 - h - 0.5), Math.floor(w), Math.floor(h + 1));
    }
  }]);

  return VolbarExt;
}();


;// CONCATENATED MODULE: ./src/components/primitives/price.js



// Price bar & price line (shader)
var Price = /*#__PURE__*/function () {
  function Price(comp) {
    classCallCheck_classCallCheck(this, Price);

    this.comp = comp;
  } // Defines an inline shader (has access to both
  // target & overlay's contexts)


  createClass_createClass(Price, [{
    key: "init_shader",
    value: function init_shader() {
      var _this = this;

      var layout = this.comp.$props.layout;
      var config = this.comp.$props.config;
      var comp = this.comp;

      var last_bar = function last_bar() {
        return _this.last_bar();
      };

      this.comp.$emit('new-shader', {
        target: 'sidebar',
        draw: function draw(ctx) {
          var bar = last_bar();
          if (!bar) return;
          var w = ctx.canvas.width;
          var h = config.PANHEIGHT;
          var lbl = bar.price.toFixed(layout.prec);
          ctx.fillStyle = bar.color;
          var x = -0.5;
          var y = bar.y - h * 0.5 - 0.5;
          var a = 7;
          ctx.fillRect(x - 0.5, y, w + 1, h);
          ctx.fillStyle = comp.$props.colors.textHL;
          ctx.textAlign = 'left';
          ctx.fillText(lbl, a, y + 15);
        }
      });
      this.shader = true;
    } // Regular draw call for overaly

  }, {
    key: "draw",
    value: function draw(ctx) {
      if (!this.comp.$props.meta.last) return;
      if (!this.shader) this.init_shader();
      var layout = this.comp.$props.layout;
      var last = this.comp.$props.last;
      var dir = last[4] >= last[1];
      var color = dir ? this.green() : this.red();
      var y = layout.$2screen(last[4]) + (dir ? 1 : 0);
      ctx.strokeStyle = color;
      ctx.setLineDash([1, 1]);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(layout.width, y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }, {
    key: "last_bar",
    value: function last_bar() {
      if (!this.comp.data.length) return undefined;
      var layout = this.comp.$props.layout;
      var last = this.comp.data[this.comp.data.length - 1];
      var y = layout.$2screen(last[4]); //let cndl = layout.c_magnet(last[0])

      return {
        y: y,
        //Math.floor(cndl.c) - 0.5,
        price: last[4],
        color: last[4] >= last[1] ? this.green() : this.red()
      };
    }
  }, {
    key: "last_price",
    value: function last_price() {
      return this.comp.$props.meta.last ? this.comp.$props.meta.last[4] : undefined;
    }
  }, {
    key: "green",
    value: function green() {
      return this.comp.colorCandleUp;
    }
  }, {
    key: "red",
    value: function red() {
      return this.comp.colorCandleDw;
    }
  }]);

  return Price;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Candles.vue?vue&type=script&lang=js&
// Renedrer for candlesticks + volume (optional)
// It can be used as the main chart or an indicator





/* harmony default export */ const Candlesvue_type_script_lang_js_ = ({
  name: 'Candles',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.2.1'
      };
    },
    init: function init() {
      this.price = new Price(this);
    },
    draw: function draw(ctx) {
      // If data === main candlestick data
      // render as main chart:
      if (this.$props.sub === this.$props.data) {
        var cnv = {
          candles: this.$props.layout.candles,
          volume: this.$props.layout.volume
        }; // Else, as offchart / onchart indicator:
      } else {
        cnv = layout_cnv(this);
      }

      if (this.show_volume) {
        var cv = cnv.volume;

        for (var i = 0, n = cv.length; i < n; i++) {
          new VolbarExt(this, ctx, cv[i]);
        }
      }

      var cc = cnv.candles;

      for (var i = 0, n = cc.length; i < n; i++) {
        new CandleExt(this, ctx, cc[i]);
      }

      if (this.price_line) this.price.draw(ctx);
    },
    use_for: function use_for() {
      return ['Candles'];
    },
    // In case it's added as offchart overlay
    y_range: function y_range() {
      var hi = -Infinity,
          lo = Infinity;

      for (var i = 0, n = this.sub.length; i < n; i++) {
        var x = this.sub[i];
        if (x[2] > hi) hi = x[2];
        if (x[3] < lo) lo = x[3];
      }

      return [hi, lo];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    show_volume: function show_volume() {
      return 'showVolume' in this.sett ? this.sett.showVolume : true;
    },
    price_line: function price_line() {
      return 'priceLine' in this.sett ? this.sett.priceLine : true;
    },
    colorCandleUp: function colorCandleUp() {
      return this.sett.colorCandleUp || this.$props.colors.candleUp;
    },
    colorCandleDw: function colorCandleDw() {
      return this.sett.colorCandleDw || this.$props.colors.candleDw;
    },
    colorWickUp: function colorWickUp() {
      return this.sett.colorWickUp || this.$props.colors.wickUp;
    },
    colorWickDw: function colorWickDw() {
      return this.sett.colorWickDw || this.$props.colors.wickDw;
    },
    colorWickSm: function colorWickSm() {
      return this.sett.colorWickSm || this.$props.colors.wickSm;
    },
    colorVolUp: function colorVolUp() {
      return this.sett.colorVolUp || this.$props.colors.volUp;
    },
    colorVolDw: function colorVolDw() {
      return this.sett.colorVolDw || this.$props.colors.volDw;
    }
  },
  data: function data() {
    return {
      price: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Candles.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Candlesvue_type_script_lang_js_ = (Candlesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Candles.vue
var Candles_render, Candles_staticRenderFns
;



/* normalize component */
;
var Candles_component = normalizeComponent(
  overlays_Candlesvue_type_script_lang_js_,
  Candles_render,
  Candles_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Candles_api; }
Candles_component.options.__file = "src/components/overlays/Candles.vue"
/* harmony default export */ const Candles = (Candles_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Volume.vue?vue&type=script&lang=js&


function Volumevue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Volumevue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Volumevue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Volumevue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Volumevue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Volumevue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Standalone renedrer for the volume



/* harmony default export */ const Volumevue_type_script_lang_js_ = ({
  name: 'Volume',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    draw: function draw(ctx) {
      // TODO: volume average
      // TODO: Y-axis scaling
      var _iterator = Volumevue_type_script_lang_js_createForOfIteratorHelper(layout_vol(this)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var v = _step.value;
          new VolbarExt(this, ctx, v);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ['Volume'];
    },
    // Defines legend format (values & colors)
    // _i2 - detetected data index (see layout_cnv)
    legend: function legend(values) {
      var flag = this._i2 ? this._i2(values) : values[2];
      var color = flag ? this.colorVolUpLegend : this.colorVolDwLegend;
      return [{
        value: values[this._i1 || 1],
        color: color
      }];
    },
    // When added as offchart overlay
    // If data is OHLCV => recalc y-range
    // _i1 - detetected data index (see layout_cnv)
    y_range: function y_range(hi, lo) {
      var _this = this;

      if (this._i1 === 5) {
        var sub = this.$props.sub;
        return [Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
          return x[_this._i1];
        }))), Math.min.apply(Math, _toConsumableArray(sub.map(function (x) {
          return x[_this._i1];
        })))];
      } else {
        return [hi, lo];
      }
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    colorVolUp: function colorVolUp() {
      return this.sett.colorVolUp || this.$props.colors.volUp;
    },
    colorVolDw: function colorVolDw() {
      return this.sett.colorVolDw || this.$props.colors.volDw;
    },
    colorVolUpLegend: function colorVolUpLegend() {
      return this.sett.colorVolUpLegend || this.$props.colors.candleUp;
    },
    colorVolDwLegend: function colorVolDwLegend() {
      return this.sett.colorVolDwLegend || this.$props.colors.candleDw;
    },
    volscale: function volscale() {
      return this.sett.volscale || this.$props.grid_id > 0 ? 0.85 : this.$props.config.VOLSCALE;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Volume.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Volumevue_type_script_lang_js_ = (Volumevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Volume.vue
var Volume_render, Volume_staticRenderFns
;



/* normalize component */
;
var Volume_component = normalizeComponent(
  overlays_Volumevue_type_script_lang_js_,
  Volume_render,
  Volume_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Volume_api; }
Volume_component.options.__file = "src/components/overlays/Volume.vue"
/* harmony default export */ const Volume = (Volume_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Splitters.vue?vue&type=script&lang=js&
// Data section splitters (with labels)

/* harmony default export */ const Splittersvue_type_script_lang_js_ = ({
  name: 'Splitters',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },
    draw: function draw(ctx) {
      var _this = this;

      var layout = this.$props.layout;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.line_color;
      this.$props.data.forEach(function (p, i) {
        ctx.beginPath();
        var x = layout.t2screen(p[0]); // x - Mapping

        ctx.setLineDash([10, 10]);
        ctx.moveTo(x, 0);
        ctx.lineTo(x, _this.layout.height);
        ctx.stroke();
        if (p[1]) _this.draw_label(ctx, x, p);
      });
    },
    draw_label: function draw_label(ctx, x, p) {
      var side = p[2] ? 1 : -1;
      x += 2.5 * side;
      ctx.font = this.new_font;
      var pos = p[4] || this.y_position;
      var w = ctx.measureText(p[1]).width + 10;
      var y = this.layout.height * (1.0 - pos);
      y = Math.floor(y);
      ctx.fillStyle = p[3] || this.flag_color;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + 10 * side, y - 10 * side);
      ctx.lineTo(x + (w + 10) * side, y - 10 * side);
      ctx.lineTo(x + (w + 10) * side, y + 10 * side);
      ctx.lineTo(x + 10 * side, y + 10 * side);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = this.label_color;
      ctx.textAlign = side < 0 ? 'right' : 'left';
      ctx.fillText(p[1], x + 15 * side, y + 4);
    },
    use_for: function use_for() {
      return ['Splitters'];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    new_font: function new_font() {
      return this.sett.font || '12px ' + this.$props.font.split('px').pop();
    },
    flag_color: function flag_color() {
      return this.sett.flagColor || '#4285f4';
    },
    label_color: function label_color() {
      return this.sett.labelColor || '#fff';
    },
    line_color: function line_color() {
      return this.sett.lineColor || '#4285f4';
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 1.0;
    },
    y_position: function y_position() {
      return this.sett.yPosition || 0.9;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Splitters.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splittersvue_type_script_lang_js_ = (Splittersvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Splitters.vue
var Splitters_render, Splitters_staticRenderFns
;



/* normalize component */
;
var Splitters_component = normalizeComponent(
  overlays_Splittersvue_type_script_lang_js_,
  Splitters_render,
  Splitters_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Splitters_api; }
Splitters_component.options.__file = "src/components/overlays/Splitters.vue"
/* harmony default export */ const Splitters = (Splitters_component.exports);
;// CONCATENATED MODULE: ./src/stuff/keys.js



function keys_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = keys_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function keys_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return keys_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return keys_arrayLikeToArray(o, minLen); }

function keys_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Keyboard event handler for overlay
var Keys = /*#__PURE__*/function () {
  function Keys(comp) {
    classCallCheck_classCallCheck(this, Keys);

    this.comp = comp;
    this.map = {};
    this.listeners = 0;
    this.keymap = {};
  }

  createClass_createClass(Keys, [{
    key: "on",
    value: function on(name, handler) {
      if (!handler) return;
      this.map[name] = this.map[name] || [];
      this.map[name].push(handler);
      this.listeners++;
    } // Called by grid.js

  }, {
    key: "emit",
    value: function emit(name, event) {
      if (name in this.map) {
        var _iterator = keys_createForOfIteratorHelper(this.map[name]),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var f = _step.value;
            f(event);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (name === 'keydown') {
        if (!this.keymap[event.key]) {
          this.emit(event.key);
        }

        this.keymap[event.key] = true;
      }

      if (name === 'keyup') {
        this.keymap[event.key] = false;
      }
    }
  }, {
    key: "pressed",
    value: function pressed(key) {
      return this.keymap[key];
    }
  }]);

  return Keys;
}();


;// CONCATENATED MODULE: ./src/mixins/tool.js
function tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tool_arrayLikeToArray(o, minLen); }

function tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Usuful stuff for creating tools. Include as mixin


/* harmony default export */ const tool = ({
  methods: {
    init_tool: function init_tool() {
      var _this = this;

      // Collision functions (float, float) => bool,
      this.collisions = [];
      this.pins = [];
      this.mouse.on('mousemove', function (e) {
        if (_this.collisions.some(function (f) {
          return f(_this.mouse.x, _this.mouse.y);
        })) {
          _this.show_pins = true;
        } else {
          _this.show_pins = false;
        }

        if (_this.drag) _this.drag_update();
      });
      this.mouse.on('mousedown', function (e) {
        if (utils.default_prevented(e)) return;

        if (_this.collisions.some(function (f) {
          return f(_this.mouse.x, _this.mouse.y);
        })) {
          if (!_this.selected) {
            _this.$emit('object-selected');
          }

          _this.start_drag();

          e.preventDefault();

          _this.pins.forEach(function (x) {
            return x.mousedown(e, true);
          });
        }
      });
      this.mouse.on('mouseup', function (e) {
        _this.drag = null;

        _this.$emit('scroll-lock', false);
      });
      this.keys = new Keys(this);
      this.keys.on('Delete', this.remove_tool);
      this.keys.on('Backspace', this.remove_tool);
      this.show_pins = false;
      this.drag = null;
    },
    render_pins: function render_pins(ctx) {
      if (this.selected || this.show_pins) {
        this.pins.forEach(function (x) {
          return x.draw(ctx);
        });
      }
    },
    set_state: function set_state(name) {
      this.$emit('change-settings', {
        $state: name
      });
    },
    watch_uuid: function watch_uuid(n, p) {
      // If layer $uuid is changed, then re-init
      // pins & collisions
      if (n.$uuid !== p.$uuid) {
        var _iterator = tool_createForOfIteratorHelper(this.pins),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var p = _step.value;
            p.re_init();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.collisions = [];
        this.show_pins = false;
        this.drag = null;
      }
    },
    pre_draw: function pre_draw() {
      // Delete all collision functions before
      // the draw() call and let primitives set
      // them again
      this.collisions = [];
    },
    remove_tool: function remove_tool() {
      if (this.selected) this.$emit('remove-tool');
    },
    start_drag: function start_drag() {
      this.$emit('scroll-lock', true);
      var cursor = this.$props.cursor;
      this.drag = {
        t: cursor.t,
        y$: cursor.y$
      };
      this.pins.forEach(function (x) {
        return x.rec_position();
      });
    },
    drag_update: function drag_update() {
      var dt = this.$props.cursor.t - this.drag.t;
      var dy = this.$props.cursor.y$ - this.drag.y$;
      this.pins.forEach(function (x) {
        return x.update_from([x.t1 + dt, x.y$1 + dy], true);
      });
    }
  },
  computed: {
    // Settings starting with $ are reserved
    selected: function selected() {
      return this.$props.settings.$selected;
    },
    state: function state() {
      return this.$props.settings.$state;
    }
  }
});
;// CONCATENATED MODULE: ./src/stuff/icons.json
const icons_namespaceObject = JSON.parse('{"extended.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAANElEQVR4nGNggABGEMEEIlhABAeI+AASF0AlHmAqA4kzKAAx8wGQuAMKwd6AoYzBAWonAwAcLwTgNfJ3RQAAAABJRU5ErkJggg==","ray.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAMklEQVR4nGNgQAJMIIIFRHCACAEQoQAiHICYvQEkjkrwYypjAIkzwk2zAREuqIQFzD4AE3kE4BEmGggAAAAASUVORK5CYII=","segment.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAlQTFRFAAAATU1NJCQkCxcHIQAAAAN0Uk5TAP8SmutI5AAAACxJREFUeJxjYMACGAMgNAsLdpoVKi8AVe8A1QblQlWRKt0AoULw2w1zGxoAABdiAviQhF/mAAAAAElFTkSuQmCC","add.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAH5QTFRFAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoKBgYGGxsbKioqPz8/Pj4+BQUFCQkJAQEBZGRkh4eHAgICEBAQNjY2g4ODgYGBAAAAAwMDeXl5d3d3GBgYERERgICAgICANDQ0PDw8Y2NjCAgIhYWFGhoaJycnOjo6YWFhgICAdXV14Y16sQAAACp0Uk5TAAILDxIKESEnJiYoKCgTKSkpKCAnKSkFKCkpJiDl/ycpKSA2JyYpKSkpOkQ+xgAAARdJREFUeJzllNt2gyAQRTWiRsHLoDU0GpPYmMv//2BMS+sgl6Z9bM8bi73gnJkBz/sn8lcBIUHofwtG8TpJKUuTLI6cYF7QEqRKynP71VX9AkhNXVlsbMQrLLQVGyPZLsGHWgPrCxMJwHUPlXa79NBp2et5d9f3u3m1XxatQNn7SagOXCUjCjYUDuqxcWlHj4MSfw12FDJchFViRN8+1qcQoUH6lR1L1mEMEErofB6WzEUwylzomfzOQGiOJdXiWH7mQoUyMa4WXJQWOBvLFvPCGxt6FSr5kyH0qi0YddNG2/pgCsOjff4ZTizXPNwKIzl56OoGg9d9Z/+5cs6On+CFCfevFQ3ZaTycx1YMbvDdRvjkp/lHdAcPXzokxcwfDwAAAABJRU5ErkJggg==","cursor.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxQTFRFAAAATU1NTU1NTU1NwlMHHwAAAAR0Uk5TAOvhxbpPrUkAAAAkSURBVHicY2BgYHBggAByabxg1WoGBq2pRCk9AKUbcND43AEAufYHlSuusE4AAAAASUVORK5CYII=","display_off.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAU1QTFRFAAAAh4eHh4eHAAAAAAAAAAAAAwMDAAAAAAAAhoaGGBgYgYGBAAAAPz8/AgICg4ODCQkJhISEh4eHh4eHPj4+NjY2gYGBg4ODgYGBgYGBgoKCAQEBJycngoKChYWFEBAQg4ODCAgIKioqZGRkCgoKBQUFERERd3d3gYGBGxsbNDQ0hISEgYGBPDw8gYGBgYGBh4eHh4eHhYWFh4eHgoKChYWFgYGBgYGBg4ODhoaGg4ODYWFhgoKCBgYGdXV1goKCg4ODgYGBgICAgYGBAAAAg4ODhYWFhISEh4eHgoKChYWFOjo6goKCGhoah4eHh4eHh4eHgoKCh4eHeXl5hoaGgoKChISEgYGBgYGBgoKCY2NjgYGBgoKCh4eHgoKCgYGBhoaGg4ODhoaGhYWFh4eHgYGBhoaGhoaGhoaGg4ODgoKChISEgoKChYWFh4eHfKktUwAAAG90Uk5TACn/AhEFKA8SLCbxCigoVBNKUTYoJ/lh3PyAKSaTNiBtICYpISggKSkmJ0LEKef3lGxA8rn//+pcMSkpnCcptHPJKe0LUjnx5LzKKaMnX73hl64pLnhkzNSgKeLv17LQ+liIzaLe7PfTw5tFpz3K1fXR/gAAAgBJREFUeJzllNdXwjAUxknB0lIoCKVsGTIFQRAZ7r333nuv///R3LZ4mlDQZ/0ekp7b37n5bnITk+mfyDxv5Tir3fwjaElO5BIOKZFLJS1dQVfI0Y809TtEV+elo95RpFPWG+1go4fdQ5QybI8haaNBkM2ANbM09bnrwaPY7iFKrz7EMBdu7CHdVruXIt0M1hb+GKA3LTRKkp5lTA6Dg6xIkhaHhvQ1IlW/UCouQdJNJTRIpk1qO7+wUpcfpl537oBc7VNip3Gi/AmVPBAC1UrL6HXtSGVT+k2Yz0Focad07OMRf3P5BEbd63PFQx7HN+w61JoAm+uBlV48O/0jkLSMmtPCmQ8HwlYdykFV4/LJPp7e3hVyFdapHNehLk6PSjhSkBvwu/cFyJGIYvOyhoc1jjYQFGbygD4CWjoAMla/og3YoSw+KPhjPNoFcim4iFD+pFYA8zZ9WeYU5OBjZ3ORWyCfG03E+47kKpCIJTpGO4KP8XMgtw990xG/PBNTgmPEEXwf7P42oOdFIRAoBCtqTKL6Rcwq4Xsgh5xYC/mmSs6yJKk1YbnVeTq1NaEpmlHbmVn2EORkW2trF2ZzmHGTSUMGl1a9hp4ySRpdQ8yKGURpMmRIYg9pb1YPzg6kO79cLlE6bYFjEtv91bLEUxvhwbWwjY13BxUb9l8+mn9EX8x3Nki8ff5wAAAAAElFTkSuQmCC","display_on.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAR1QTFRFAAAAh4eHgYGBAAAAAAAAgYGBAAAAAwMDAAAAAAAAgYGBg4ODGBgYgYGBhISEAAAAPz8/AgIChoaGCQkJhYWFPj4+NjY2goKCgYGBAQEBJycngYGBgoKCEBAQCAgIhISEKioqZGRkCgoKBQUFERERd3d3gYGBg4ODgYGBGxsbNDQ0hISEgoKCgoKChYWFPDw8gYGBgYGBhoaGgoKCg4ODgoKCgYGBgoKCgoKCgoKCg4ODgoKChoaGgoKCgYGBhoaGg4ODYWFhBgYGdXV1gYGBg4ODgoKCgICAg4ODg4ODhISEAAAAg4ODOjo6gYGBGhoaeXl5goKCgYGBgoKChYWFgoKChISEgoKCY2NjgYGBg4ODgYGBgYGBg4ODgYGBo8n54AAAAF90Uk5TACn/AhH3BSgPEuhUJvFACigoLBM2KCeA6ykm+pMgIEkmKSEoICn9XCkmJ0u6nDop4sUypGuEzLZ6vmCYLZ/dLykpJynUYa8pcllCC1Ip2ycpisl1PadFsintbsPQZdi/bTW7AAAB4UlEQVR4nOWUZ1fCMBSGSSGWFiq0UDbIkr2XbBwMxS0b1P//M0xK9XSiftX7oel585zkvfcmMRj+SRhvzRRlthm/BU3Ry3TYzofTsajpIOjw2iNAjIiddehvHXSdA0mkXEEdG0fkE1DEKXmkSVqVIA6rBmsktUgAWLWHoGp30UNclbtLmwQgoyya91wPTbFy0mQXJ5zJQO6BgXRjfH0iSkX5stHIXr5r0bB/lu8syjR8rzsFbR2SpX+5J2eMP3csLtYsEY2K8BeTFuE2jaVCBw7bHOBuxq16AXmpbui3LtIfbRLUHMY2q4lcFo2WB4KA1SUAlWumNEKCzyxBKZxVHvYGaFguCBx1vM/x0IPzoqQoj5SdP4mns2cCGhBsrgj0uaeUBtzMyxQN8w4mYROTW8+r0oANp8W5mf6WQw5aCYJ2o7ymPaKMi2uVpmWM4TW6tdImgGo1bT4nK6DbbsCc0AZSdmLEFszzHrh6riVvRrNA3/9SE8QLWQu+Gjto9+gE9NBMwr9zi83gFeeFTe11zpm1CHE3HeyVCSknf3MIDcFTbfJKdbR1L4xX49L+/BoillV5uPJqkshD3JWSgpNMXP/lcrD8+hO84MnDr5YpFHv0Fe99VjJ0GBRs2H74aP6R+ACr+TFvZNAQ1wAAAABJRU5ErkJggg==","down.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAKVQTFRFAAAAg4ODgICAAAAAAAAAAAAACAgIAAAAAAAAAAAAAAAAOTk5hYWFEBAQfHx8ODg4dnZ2NDQ0XV1dGxsbKCgogICAFBQUIiIiZGRkgICAgICAFRUVAAAAgICAgICAgICAf39/Li4ugICAcHBwgoKCgICAgoKCgICAg4ODgYGBPj4+goKCgICAhISEgYGBgICAgoKCgICAgYGBgYGBf39/gICAgICAIdPQHAAAADd0Uk5TACn/KAIRIBMFDwooKyApKSknKSYmzCcmKfL7JRCUi2L3J7IpcLUrr0VbKXntNEnkMbxrUcG56CMpi50AAAFZSURBVHic5ZRpf4MgDIeFKFatWm/tfW091u7evv9Hm1Acoujm2y0vFPH5Jf+EEE37J6bblmlatv4jaBCI4rMfR0CMXtAEJ0fccgfM7tAkQHXzArdDxggmqGETGCnJWROkNlOwOqhIhKCtgbSicw1uK/dATSK0aRatIzytA8ik4XSiyJnLSm+VPxULgeyLI3uHRJH+qcB4WZGrKb4c20WwI7b3iUt74OS6XD+xZWrXUCtme0uKTvfcJ65CZFa9VOebqwXmft+oT8yF+/VymT4XeGB+Xx8L+j4gBcoFIDT+oMz6Qp93Y74pCeBpUXaLuW0rUk6r1iv3nP322ewYkgv2nZIvgpSPQDrY5wTjRJDNg9XAE/+uSXIVX812GdKEmtvR2rtWaw+5MAOuofJy79SXu9TgBl4d9DZdI0NjgyiswNCB/qk1J5Bmvp+lQOa9IJNhW4bxm6H5R+wLQYMSQXZNzbcAAAAASUVORK5CYII=","price_range.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAIUlEQVR4nGNggAPm/w9gTA4QIQMitECEJ1yMEgLNDiAAADfgBMRu78GgAAAAAElFTkSuQmCC","price_time.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAOklEQVR4nGNggAPm/w9gTA4QIQPEClpMQMITRHCACScQoQQihBgY9P//grKgYk5wdTACYhQHFjuAAABZFAlc4e1fcQAAAABJRU5ErkJggg==","remove.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAK5QTFRFAAAAh4eHgICAAAAAAAAAh4eHAAAAAwMDAAAAAAAAgICAGBgYAAAAPz8/AgICgICACQkJhoaGhoaGgICAPj4+NjY2gYGBg4ODgYGBAQEBJycngoKCEBAQgICAgICACAgIKioqZGRkCgoKBQUFERERd3d3gYGBGxsbNDQ0gICAPDw8YWFhBgYGdXV1gICAg4ODgICAAAAAOjo6GhoaeXl5gICAhYWFY2NjhYWFgICA9O0oCgAAADp0Uk5TACn/AhErBSgPEvEmCigowxMuMcgoJ7hWrCkmdCD6vSAmKSEoICkpJie6KSknKSkp0wspJynCMik11rrLte8AAAFwSURBVHic5ZTXkoIwFIZNAAPSpKkoRQV7Wcva3v/FFiRmEwise7t7bs7MP98k/ylJq/VPQjjKiiJrwo+gON0uxro7XiRTsRHs+voE4JjoRrf+6sD7AFTMvaDGRht9glLMUJtLqmUwD5XDCohHAmBUPQSV27GHtFK7xycBWJab5uPaR+Hlmue7GfZxHwyWFHVMQghXFgD2A8IOZtfssdNJIXcyFEaSfchzp9BuMVP+Fhvr5Qh0nGfqYTGhm3BcYFUaQBKOhMWzRqHyGFRY03ppQ5lCFZ30RloVZGQTaa3QqEt0OyrQnkSkk8I1YJkvAwPCMgY0UpbzXRZhVbosIWGbZTLNQszGMCM42FJEjWDDjIAMtp+xj6x2K+/DqNDc0r4Yc8yGl3uer2aIyT1iyd8sYSuY8cldZbVrH4zPebTvP8OMNSoedj6XzDyk3pwG98u0/ufqGu7tBW5c1PxriXFyHq5PQxXFzeDThvbmp/lH4gt6WxfZ03H8DwAAAABJRU5ErkJggg==","settings.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAW5QTFRFAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoKBgYGGxsbKioqQEBAPj4+BQUFCAgIAQEBPz8/ZWVlh4eHZGRkAgICCQkJDw8PNjY2g4ODgoKCNTU1EBAQAAAAAwMDeXl5d3d3AAAAGBgYAAAAERERioqKgoKCgoKCgoKCgYGBgoKChISEhoaGNDQ0g4ODgICAgICAgICAgYGBgYGBhYWFgICAgICAPT09AAAAgYGBgICAgICAgICAgICAY2NjCAgIgICAgICAhYWFhYWFgYGBHBwcgICAhYWFGhoagYGBgYGBg4ODhoaGJycnAAAAhISEgICAg4ODPDw8AAAAgoKCgICAhISEOjo6h4eHgoKCgYGBgICAf39/gYGBgoKCgICAGBgYgYGBg4ODg4ODgICACwsLgYGBgICAgYGBgYGBgYGBgICAgYGBYWFhf39/g4ODPj4+gYGBg4ODgICAhYWFgoKCgYGBgICAgYGBgoKCdXV1T0kC9QAAAHp0Uk5TAAILDxMKESEnJiYpKSgTKSgpKSkoEyAnKSknIAYoKSkFJQEgKl94jYVvVC4nU9f/+K8pOu71KBCi3NPq/ikg0e01Nokm1UUnsZVqQSYOT9lrKRJz5lIpK12jyu+sesgnhGVLxCG55a6Um+GaKfJCKKRgKUt8ocergymDQ9knAAABsElEQVR4nOWUV1vCMBSGg1AQpBZrcVdE3KJxo4LgnuCoe4F7orjHv7doTk3bgF7rd5OnX94nZ+SkCP0TWQqsNpuVs/wI2h2FTleR2+XkHfa8YLHgKRGJSj2SN3fosvIKkVJlVXWONGrkWtEgn1zHJP1GMCs/g7XILFIUpXoTWmaKTnIImGovh72Gxqbmlta2dvgOGpsmQO0dnfhTXd3E6JH0pN1DNnr7MFE/HDsQ0qEO6Pxg9sCh4XDkGx2J6sovBD+G8eiYuo5PxLTKeLoJBZNgT2EcnjY0YYajUKsL7Fk1gcjU3PwChcYTFGorAnsRqlpa1tAVhUbdmr+6RtjIOlgbCjMBUdzc2t7ZzbJ7zAQ4p6GSfRVNwkeKLsvCg31w2JBdjlT0GDxZNzEnpcQ+xWfnFxeXVyp6Tay07gq+L/YUOoBvbomV0V8skiq//DutWfeEfJD1JPLCED4+Pb8kX986tApNQ4iqfSJT76bRzvlgBPODQXW/foYqK5lyeBeYJEL1gaoeGnwIBhjRoQ9SZgTAdEbO/9cKRfmZ+MpGPCVHQ3nBzzS4hKIkuNyh/5g+ALiAXSSas9hwAAAAAElFTkSuQmCC","time_range.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAJElEQVR4nGNgwAsUGJhQCScQoQQihBgY9P//grKgYk4YOvACACOpBKG6Svj+AAAAAElFTkSuQmCC","trash.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAALUlEQVR4nGNgAIN6ENHQACX4//9gYBBgYIESYC4LkA0lPEkmGFAI5v8PILYCAHygDJxlK0RUAAAAAElFTkSuQmCC","up.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAMZQTFRFAAAAh4eHgICAAAAAAAAAAAAAAwMDAAAAAAAAGBgYAAAAPz8/AgICCQkJgICAh4eHPj4+NjY2AQEBJycnEBAQgICAgICACAgIKioqZGRkCgoKBQUFgYGBERERd3d3gYGBGxsbNDQ0gICAgYGBPDw8gYGBh4eHgICAYWFhBgYGgYGBdXV1goKCg4ODhYWFgICAgoKCAAAAhISEOjo6gICAGhoagYGBeXl5hoaGgICAY2Njg4ODgoKCgoKCgYGBgoKCg4ODgoKC64uw1gAAAEJ0Uk5TACn/AhEFKA8SJgooKBP7KignKSYg9c0gJikhKLQgKSkmJ7ywKY8s5SknlClxKTMpXwtFKe0neiku8ClKWmSbbFFjM5GHSgAAAW5JREFUeJzllGd/gjAQxk3AMFWWOHDvVa2rVbu//5cqhJWQQO3b9nkVjv/v7rnLKJX+iYS9JMuSKvwIiu3loKkZzYHXFgvBiqW1QKSWplfySzvmAyDUN50cG2X0DDLqoTKXVLJgIIXDCohHAqCzHhymeuShy/Ru8kkAhtmhWUTvW9fdEnPQaVLU0n8XF0L3kn5P6LTtZPKgNoK+RrUkcGtQ7S9TsgOxxinrkUPYD+LwLCIh7CTsWSVQqRmTuPqpitlZFLQlApXjrsYBc335wOw47ksmUSMMrgKi/gnAE/awCqNHmTUwDf5X34LlBuedsgbUsK15kPMxTIXzzvFSIdsSPBw7nGD1K+7bL3F9xStEnZhoCw71TbpL71GBBbUF1MZmZWTOi97PI3eIJn9zCEtOj0+umaOde2EszqW9/xr6rM54WFtc0vfQNak57Ibd/Jerohu3GFwYqPjVEhve2Z4cbQU1ikFsQ73z0fwj+ga3VBezGuggFQAAAABJRU5ErkJggg=="}');
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: ./src/components/primitives/pin.js



// Semi-automatic pin object. For stretching things.


var Pin = /*#__PURE__*/function () {
  // (Comp reference, a name in overlay settings,
  // pin parameters)
  function Pin(comp, name, params) {
    var _this = this;

    if (params === void 0) {
      params = {};
    }

    classCallCheck_classCallCheck(this, Pin);

    this.RADIUS = comp.$props.config.PIN_RADIUS || 5.5;
    this.RADIUS_SQ = Math.pow(this.RADIUS + 7, 2);

    if (utils.is_mobile) {
      this.RADIUS += 2;
      this.RADIUS_SQ *= 2.5;
    }

    this.COLOR_BACK = comp.$props.colors.back;
    this.COLOR_BR = comp.$props.colors.text;
    this.comp = comp;
    this.layout = comp.layout;
    this.mouse = comp.mouse;
    this.name = name;
    this.state = params.state || 'settled';
    this.hidden = params.hidden || false;
    this.mouse.on('mousemove', function (e) {
      return _this.mousemove(e);
    });
    this.mouse.on('mousedown', function (e) {
      return _this.mousedown(e);
    });
    this.mouse.on('mouseup', function (e) {
      return _this.mouseup(e);
    });

    if (comp.state === 'finished') {
      this.state = 'settled';
      this.update_from(comp.$props.settings[name]);
    } else {
      this.update();
    }

    if (this.state !== 'settled') {
      this.comp.$emit('scroll-lock', true);
    }
  }

  createClass_createClass(Pin, [{
    key: "re_init",
    value: function re_init() {
      this.update_from(this.comp.$props.settings[this.name]);
    }
  }, {
    key: "draw",
    value: function draw(ctx) {
      if (this.hidden) return;

      switch (this.state) {
        case 'tracking':
          break;

        case 'dragging':
          if (!this.moved) this.draw_circle(ctx);
          break;

        case 'settled':
          this.draw_circle(ctx);
          break;
      }
    }
  }, {
    key: "draw_circle",
    value: function draw_circle(ctx) {
      this.layout = this.comp.layout;

      if (this.comp.selected) {
        var r = this.RADIUS,
            lw = 1.5;
      } else {
        var r = this.RADIUS * 0.95,
            lw = 1;
      }

      ctx.lineWidth = lw;
      ctx.strokeStyle = this.COLOR_BR;
      ctx.fillStyle = this.COLOR_BACK;
      ctx.beginPath();
      ctx.arc(this.x = this.layout.t2screen(this.t), this.y = this.layout.$2screen(this.y$), r + 0.5, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.stroke();
    }
  }, {
    key: "update",
    value: function update() {
      this.y$ = this.comp.$props.cursor.y$;
      this.y = this.comp.$props.cursor.y;
      this.t = this.comp.$props.cursor.t;
      this.x = this.comp.$props.cursor.x; // Save pin as time in IB mode
      //if (this.layout.ti_map.ib) {
      //    this.t = this.layout.ti_map.i2t(this.t )
      //}
      // Reset the settings attahed to the pin (position)

      this.comp.$emit('change-settings', _defineProperty({}, this.name, [this.t, this.y$]));
    }
  }, {
    key: "update_from",
    value: function update_from(data, emit) {
      if (emit === void 0) {
        emit = false;
      }

      if (!data) return;
      this.layout = this.comp.layout;
      this.y$ = data[1];
      this.y = this.layout.$2screen(this.y$);
      this.t = data[0];
      this.x = this.layout.t2screen(this.t); // TODO: Save pin as time in IB mode
      //if (this.layout.ti_map.ib) {
      //    this.t = this.layout.ti_map.i2t(this.t )
      //}

      if (emit) this.comp.$emit('change-settings', _defineProperty({}, this.name, [this.t, this.y$]));
    }
  }, {
    key: "rec_position",
    value: function rec_position() {
      this.t1 = this.t;
      this.y$1 = this.y$;
    }
  }, {
    key: "mousemove",
    value: function mousemove(event) {
      switch (this.state) {
        case 'tracking':
        case 'dragging':
          this.moved = true;
          this.update();
          break;
      }
    }
  }, {
    key: "mousedown",
    value: function mousedown(event, force) {
      if (force === void 0) {
        force = false;
      }

      if (utils.default_prevented(event) && !force) return;

      switch (this.state) {
        case 'tracking':
          this.state = 'settled';
          if (this.on_settled) this.on_settled();
          this.comp.$emit('scroll-lock', false);
          break;

        case 'settled':
          if (this.hidden) return;

          if (this.hover()) {
            this.state = 'dragging';
            this.moved = false;
            this.comp.$emit('scroll-lock', true);
            this.comp.$emit('object-selected');
          }

          break;
      }

      if (this.hover()) {
        event.preventDefault();
      }
    }
  }, {
    key: "mouseup",
    value: function mouseup(event) {
      switch (this.state) {
        case 'dragging':
          this.state = 'settled';
          if (this.on_settled) this.on_settled();
          this.comp.$emit('scroll-lock', false);
          break;
      }
    }
  }, {
    key: "on",
    value: function on(name, handler) {
      switch (name) {
        case 'settled':
          this.on_settled = handler;
          break;
      }
    }
  }, {
    key: "hover",
    value: function hover() {
      var x = this.x;
      var y = this.y;
      return (x - this.mouse.x) * (x - this.mouse.x) + (y - this.mouse.y) * (y - this.mouse.y) < this.RADIUS_SQ;
    }
  }]);

  return Pin;
}();


;// CONCATENATED MODULE: ./src/components/primitives/seg.js


// Draws a segment, adds corresponding collision f-n



var Seg = /*#__PURE__*/function () {
  // Overlay ref, canvas ctx
  function Seg(overlay, ctx) {
    classCallCheck_classCallCheck(this, Seg);

    this.ctx = ctx;
    this.comp = overlay;
    this.T = overlay.$props.config.TOOL_COLL;
    if (utils.is_mobile) this.T *= 2;
  } // p1[t, $], p2[t, $] (time-price coordinates)


  createClass_createClass(Seg, [{
    key: "draw",
    value: function draw(p1, p2) {
      var layout = this.comp.$props.layout;
      var x1 = layout.t2screen(p1[0]);
      var y1 = layout.$2screen(p1[1]);
      var x2 = layout.t2screen(p2[0]);
      var y2 = layout.$2screen(p2[1]);
      this.ctx.moveTo(x1, y1);
      this.ctx.lineTo(x2, y2);
      this.comp.collisions.push(this.make([x1, y1], [x2, y2]));
    } // Collision function. x, y - mouse coord.

  }, {
    key: "make",
    value: function make(p1, p2) {
      var _this = this;

      return function (x, y) {
        return math.point2seg([x, y], p1, p2) < _this.T;
      };
    }
  }]);

  return Seg;
}();


;// CONCATENATED MODULE: ./src/components/primitives/line.js


// Draws a line, adds corresponding collision f-n



var Line = /*#__PURE__*/function () {
  // Overlay ref, canvas ctx
  function Line(overlay, ctx) {
    classCallCheck_classCallCheck(this, Line);

    this.ctx = ctx;
    this.comp = overlay;
    this.T = overlay.$props.config.TOOL_COLL;
    if (utils.is_mobile) this.T *= 2;
  } // p1[t, $], p2[t, $] (time-price coordinates)


  createClass_createClass(Line, [{
    key: "draw",
    value: function draw(p1, p2) {
      var layout = this.comp.$props.layout;
      var x1 = layout.t2screen(p1[0]);
      var y1 = layout.$2screen(p1[1]);
      var x2 = layout.t2screen(p2[0]);
      var y2 = layout.$2screen(p2[1]);
      this.ctx.moveTo(x1, y1);
      this.ctx.lineTo(x2, y2);
      var w = layout.width;
      var h = layout.height; // TODO: transform k (angle) to screen ratio
      // (this requires a new a2screen function)

      var k = (y2 - y1) / (x2 - x1);
      var s = Math.sign(x2 - x1 || y2 - y1);
      var dx = w * s * 2;
      var dy = w * k * s * 2;

      if (dy === Infinity) {
        dx = 0, dy = h * s;
      }

      this.ctx.moveTo(x2, y2);
      this.ctx.lineTo(x2 + dx, y2 + dy);

      if (!this.ray) {
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x1 - dx, y1 - dy);
      }

      this.comp.collisions.push(this.make([x1, y1], [x2, y2]));
    } // Collision function. x, y - mouse coord.

  }, {
    key: "make",
    value: function make(p1, p2) {
      var _this = this;

      var f = this.ray ? math.point2ray.bind(math) : math.point2line.bind(math);
      return function (x, y) {
        return f([x, y], p1, p2) < _this.T;
      };
    }
  }]);

  return Line;
}();


;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function typeof_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    typeof_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    typeof_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return typeof_typeof(obj);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(self, call) {
  if (call && (typeof_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
;// CONCATENATED MODULE: ./src/components/primitives/ray.js





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Draws a ray, adds corresponding collision f-n


var Ray = /*#__PURE__*/function (_Line) {
  _inherits(Ray, _Line);

  var _super = _createSuper(Ray);

  function Ray(overlay, ctx) {
    var _this;

    classCallCheck_classCallCheck(this, Ray);

    _this = _super.call(this, overlay, ctx);
    _this.ray = true;
    return _this;
  }

  return Ray;
}(Line);


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/LineTool.vue?vue&type=script&lang=js&
// Line drawing tool
// TODO: make an angle-snap when "Shift" is pressed







/* harmony default export */ const LineToolvue_type_script_lang_js_ = ({
  name: 'LineTool',
  mixins: [overlay, tool],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    tool: function tool() {
      return {
        // Descriptor for the tool
        group: 'Lines',
        icon: icons_namespaceObject["segment.png"],
        type: 'Segment',
        hint: 'This hint will be shown on hover',
        data: [],
        // Default data
        settings: {},
        // Default settings
        // Modifications
        mods: {
          'Extended': {
            // Rewrites the default setting fields
            settings: {
              extended: true
            },
            icon: icons_namespaceObject["extended.png"]
          },
          'Ray': {
            // Rewrites the default setting fields
            settings: {
              ray: true
            },
            icon: icons_namespaceObject["ray.png"]
          }
        }
      };
    },
    // Called after overlay mounted
    init: function init() {
      var _this = this;

      // First pin is settled at the mouse position
      this.pins.push(new Pin(this, 'p1')); // Second one is following mouse until it clicks

      this.pins.push(new Pin(this, 'p2', {
        state: 'tracking'
      }));
      this.pins[1].on('settled', function () {
        // Call when current tool drawing is finished
        // (Optionally) reset the mode back to 'Cursor'
        _this.set_state('finished');

        _this.$emit('drawing-mode-off');
      });
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      if (this.sett.ray) {
        new Ray(this, ctx).draw(this.p1, this.p2);
      } else if (this.sett.extended) {
        new Line(this, ctx).draw(this.p1, this.p2);
      } else {
        new Seg(this, ctx).draw(this.p1, this.p2);
      }

      ctx.stroke();
      this.render_pins(ctx);
    },
    use_for: function use_for() {
      return ['LineTool'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      return this.sett.color || '#42b28a';
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/LineTool.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_LineToolvue_type_script_lang_js_ = (LineToolvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/LineTool.vue
var LineTool_render, LineTool_staticRenderFns
;



/* normalize component */
;
var LineTool_component = normalizeComponent(
  overlays_LineToolvue_type_script_lang_js_,
  LineTool_render,
  LineTool_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LineTool_api; }
LineTool_component.options.__file = "src/components/overlays/LineTool.vue"
/* harmony default export */ const LineTool = (LineTool_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/RangeTool.vue?vue&type=script&lang=js&

// Price/Time measurment tool





/* harmony default export */ const RangeToolvue_type_script_lang_js_ = ({
  name: 'RangeTool',
  mixins: [overlay, tool],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '2.0.1'
      };
    },
    tool: function tool() {
      return {
        // Descriptor for the tool
        group: 'Measurements',
        icon: icons_namespaceObject["price_range.png"],
        type: 'Price',
        hint: 'Price Range',
        data: [],
        // Default data
        settings: {},
        // Default settings
        mods: {
          'Time': {
            // Rewrites the default setting fields
            icon: icons_namespaceObject["time_range.png"],
            settings: {
              price: false,
              time: true
            }
          },
          'PriceTime': {
            // Rewrites the default setting fields
            icon: icons_namespaceObject["price_time.png"],
            settings: {
              price: true,
              time: true
            }
          },
          'ShiftMode': {
            // Rewrites the default setting fields
            settings: {
              price: true,
              time: true,
              shiftMode: true
            },
            hidden: true
          }
        }
      };
    },
    // Called after overlay mounted
    init: function init() {
      var _this = this;

      // First pin is settled at the mouse position
      this.pins.push(new Pin(this, 'p1', {
        hidden: this.shift
      })); // Second one is following mouse until it clicks

      this.pins.push(new Pin(this, 'p2', {
        state: 'tracking',
        hidden: this.shift
      }));
      this.pins[1].on('settled', function () {
        // Call when current tool drawing is finished
        // (Optionally) reset the mode back to 'Cursor'
        _this.set_state('finished');

        _this.$emit('drawing-mode-off'); // Deselect the tool in shiftMode


        if (_this.shift) _this._$emit('custom-event', {
          event: 'object-selected',
          args: []
        });
      });
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      var dir = Math.sign(this.p2[1] - this.p1[1]);
      var layout = this.$props.layout;
      var xm = layout.t2screen((this.p1[0] + this.p2[0]) * 0.5);
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color; // Background

      ctx.fillStyle = this.back_color;
      var x1 = layout.t2screen(this.p1[0]);
      var y1 = layout.$2screen(this.p1[1]);
      var x2 = layout.t2screen(this.p2[0]);
      var y2 = layout.$2screen(this.p2[1]);
      ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      if (this.price) this.vertical(ctx, x1, y1, x2, y2, xm);
      if (this.time) this.horizontal(ctx, x1, y1, x2, y2, xm);
      this.draw_value(ctx, dir, xm, y2);
      this.render_pins(ctx);
    },
    vertical: function vertical(ctx, x1, y1, x2, y2, xm) {
      var layout = this.$props.layout;
      var dir = Math.sign(this.p2[1] - this.p1[1]);
      ctx.beginPath();

      if (!this.shift) {
        // Top
        new Seg(this, ctx).draw([this.p1[0], this.p2[1]], [this.p2[0], this.p2[1]]); // Bottom

        new Seg(this, ctx).draw([this.p1[0], this.p1[1]], [this.p2[0], this.p1[1]]);
      } // Vertical Arrow


      ctx.moveTo(xm - 4, y2 + 5 * dir);
      ctx.lineTo(xm, y2);
      ctx.lineTo(xm + 4, y2 + 5 * dir);
      ctx.stroke(); // Vertical Line

      ctx.beginPath();
      ctx.setLineDash([5, 5]);
      new Seg(this, ctx).draw([(this.p1[0] + this.p2[0]) * 0.5, this.p2[1]], [(this.p1[0] + this.p2[0]) * 0.5, this.p1[1]]);
      ctx.stroke();
      ctx.setLineDash([]);
    },
    horizontal: function horizontal(ctx, x1, y1, x2, y2, xm) {
      var layout = this.$props.layout;
      var xdir = Math.sign(this.p2[0] - this.p1[0]);
      var ym = (layout.$2screen(this.p1[1]) + layout.$2screen(this.p2[1])) / 2;
      ctx.beginPath();

      if (!this.shift) {
        // Left
        new Seg(this, ctx).draw([this.p1[0], this.p1[1]], [this.p1[0], this.p2[1]]); // Right

        new Seg(this, ctx).draw([this.p2[0], this.p1[1]], [this.p2[0], this.p2[1]]);
      } // Horizontal Arrow


      ctx.moveTo(x2 - 5 * xdir, ym - 4);
      ctx.lineTo(x2, ym);
      ctx.lineTo(x2 - 5 * xdir, ym + 4);
      ctx.stroke(); // Horizontal Line

      ctx.beginPath();
      ctx.setLineDash([5, 5]);
      ctx.moveTo(x1, ym);
      ctx.lineTo(x2, ym);
      ctx.stroke();
      ctx.setLineDash([]);
    },
    // WTF? I know dude, a lot of shitty code here
    draw_value: function draw_value(ctx, dir, xm, y) {
      var _this2 = this;

      ctx.font = this.new_font; // Price delta (anf percent)

      var d$ = (this.p2[1] - this.p1[1]).toFixed(this.prec);
      var p = (100 * (this.p2[1] / this.p1[1] - 1)).toFixed(this.prec); // Map interval to the actual tf (in ms)

      var f = function f(t) {
        return _this2.layout.ti_map.smth2t(t);
      };

      var dt = f(this.p2[0]) - f(this.p1[0]);
      var tf = this.layout.ti_map.tf; // Bars count (through the candle index)

      var f2 = function f2(t) {
        var c = _this2.layout.c_magnet(t);

        var cn = _this2.layout.candles || _this2.layout.master_grid.candles;
        return cn.indexOf(c);
      }; // Bars count (and handling the negative values)


      var b = f2(this.p2[0]) - f2(this.p1[0]); // Format time delta
      // Format time delta

      var dtstr = this.t2str(dt);
      var text = [];
      if (this.price) text.push("".concat(d$, "  (").concat(p, "%)"));
      if (this.time) text.push("".concat(b, " bars, ").concat(dtstr));
      text = text.join('\n'); // "Multiple" fillText

      var lines = text.split('\n');
      var w = Math.max.apply(Math, _toConsumableArray(lines.map(function (x) {
        return ctx.measureText(x).width + 20;
      })).concat([100]));
      var n = lines.length;
      var h = 20 * n;
      ctx.fillStyle = this.value_back;
      ctx.fillRect(xm - w * 0.5, y - (10 + h) * dir, w, h * dir);
      ctx.fillStyle = this.value_color;
      ctx.textAlign = 'center';
      lines.forEach(function (l, i) {
        ctx.fillText(l, xm, y + (dir > 0 ? 20 * i - 20 * n + 5 : 20 * i + 25));
      });
    },
    // Formats time from ms to `1D 12h` for example
    t2str: function t2str(t) {
      var sign = Math.sign(t);
      var abs = Math.abs(t);
      var tfs = [[1000, 's', 60], [60000, 'm', 60], [3600000, 'h', 24], [86400000, 'D', 7], [604800000, 'W', 4], [2592000000, 'M', 12], [31536000000, 'Y', Infinity], [Infinity, 'Eternity', Infinity]];

      for (var i = 0; i < tfs.length; i++) {
        tfs[i][0] = Math.floor(abs / tfs[i][0]);

        if (tfs[i][0] === 0) {
          var p1 = tfs[i - 1];
          var p2 = tfs[i - 2];
          var txt = sign < 0 ? '-' : '';

          if (p1) {
            txt += p1.slice(0, 2).join('');
          }

          var n2 = p2 ? p2[0] - p1[0] * p2[2] : 0;

          if (p2 && n2) {
            txt += ' ';
            txt += "".concat(n2).concat(p2[1]);
          }

          return txt;
        }
      }
    },
    use_for: function use_for() {
      return ['RangeTool'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      return this.sett.color || this.$props.colors.cross;
    },
    back_color: function back_color() {
      return this.sett.backColor || '#9b9ba316';
    },
    value_back: function value_back() {
      return this.sett.valueBack || '#9b9ba316';
    },
    value_color: function value_color() {
      return this.sett.valueColor || this.$props.colors.text;
    },
    prec: function prec() {
      return this.sett.precision || 2;
    },
    new_font: function new_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    price: function price() {
      return 'price' in this.sett ? this.sett.price : true;
    },
    time: function time() {
      return 'time' in this.sett ? this.sett.time : false;
    },
    shift: function shift() {
      return this.sett.shiftMode;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/RangeTool.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_RangeToolvue_type_script_lang_js_ = (RangeToolvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/RangeTool.vue
var RangeTool_render, RangeTool_staticRenderFns
;



/* normalize component */
;
var RangeTool_component = normalizeComponent(
  overlays_RangeToolvue_type_script_lang_js_,
  RangeTool_render,
  RangeTool_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var RangeTool_api; }
RangeTool_component.options.__file = "src/components/overlays/RangeTool.vue"
/* harmony default export */ const RangeTool = (RangeTool_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Grid.vue?vue&type=script&lang=js&
function Gridvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Gridvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Gridvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Gridvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Gridvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Gridvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Sets up all layers/overlays for the grid with 'grid_id'

















/* harmony default export */ const Gridvue_type_script_lang_js_ = ({
  name: 'Grid',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'overlays', 'width', 'height', 'data', 'grid_id', 'y_transform', 'font', 'tv_id', 'config', 'meta', 'shaders'],
  mixins: [canvas, uxlist],
  components: {
    Crosshair: components_Crosshair,
    KeyboardListener: KeyboardListener
  },
  created: function created() {
    var _this = this;

    // List of all possible overlays (builtin + custom)
    this._list = [Spline, Splines, Range, Trades, Channel, Segment, Candles, Volume, Splitters, LineTool, RangeTool].concat(this.$props.overlays);
    this._registry = {}; // We need to know which components we will use.
    // Custom overlay components overwrite built-ins:

    var tools = [];

    this._list.forEach(function (x, i) {
      var use_for = x.methods.use_for();
      if (x.methods.tool) tools.push({
        use_for: use_for,
        info: x.methods.tool()
      });
      use_for.forEach(function (indicator) {
        _this._registry[indicator] = i;
      });
    });

    this.$emit('custom-event', {
      event: 'register-tools',
      args: tools
    });
    this.$on('custom-event', function (e) {
      return _this.on_ux_event(e, 'grid');
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.renderer) this.renderer.destroy();
  },
  mounted: function mounted() {
    var _this2 = this;

    var el = this.$refs['canvas'];
    this.renderer = new Grid(el, this);
    this.setup();
    this.$nextTick(function () {
      return _this2.redraw();
    });
  },
  render: function render(h) {
    var id = this.$props.grid_id;
    var layout = this.$props.layout.grids[id];
    return this.create_canvas(h, "grid-".concat(id), {
      position: {
        x: 0,
        y: layout.offset || 0
      },
      attrs: {
        width: layout.width,
        height: layout.height,
        overflow: 'hidden'
      },
      style: {
        backgroundColor: this.$props.colors.back
      },
      hs: [h(components_Crosshair, {
        props: this.common_props(),
        on: this.layer_events
      }), h(KeyboardListener, {
        on: this.keyboard_events
      }), h(UxLayer, {
        props: {
          id: id,
          tv_id: this.$props.tv_id,
          uxs: this.uxs,
          colors: this.$props.colors,
          config: this.$props.config,
          updater: Math.random()
        },
        on: {
          'custom-event': this.emit_ux_event
        }
      })].concat(this.get_overlays(h))
    });
  },
  methods: {
    new_layer: function new_layer(layer) {
      var _this3 = this;

      this.$nextTick(function () {
        return _this3.renderer.new_layer(layer);
      });
    },
    del_layer: function del_layer(layer) {
      var _this4 = this;

      this.$nextTick(function () {
        return _this4.renderer.del_layer(layer);
      });
      var grid_id = this.$props.grid_id;
      this.$emit('custom-event', {
        event: 'remove-shaders',
        args: [grid_id, layer]
      }); // TODO: close all interfaces

      this.$emit('custom-event', {
        event: 'remove-layer-meta',
        args: [grid_id, layer]
      });
      this.remove_all_ux(layer);
    },
    get_overlays: function get_overlays(h) {
      var _this5 = this;

      // Distributes overlay data & settings according
      // to this._registry; returns compo list
      var comp_list = [],
          count = {};

      var _iterator = Gridvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var d = _step.value;
          var comp = this._list[this._registry[d.type]];

          if (comp) {
            if (comp.methods.calc) {
              comp = this.inject_renderer(comp);
            }

            comp_list.push({
              cls: comp,
              type: d.type,
              data: d.data,
              settings: d.settings,
              i0: d.i0,
              tf: d.tf,
              last: d.last
            });
            count[d.type] = 0;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return comp_list.map(function (x, i) {
        return h(x.cls, {
          on: _this5.layer_events,
          attrs: Object.assign(_this5.common_props(), {
            id: "".concat(x.type, "_").concat(count[x.type]++),
            type: x.type,
            data: x.data,
            settings: x.settings,
            i0: x.i0,
            tf: x.tf,
            num: i,
            grid_id: _this5.$props.grid_id,
            meta: _this5.$props.meta,
            last: x.last
          })
        });
      });
    },
    common_props: function common_props() {
      return {
        cursor: this.$props.cursor,
        colors: this.$props.colors,
        layout: this.$props.layout.grids[this.$props.grid_id],
        interval: this.$props.interval,
        sub: this.$props.sub,
        font: this.$props.font,
        config: this.$props.config
      };
    },
    emit_ux_event: function emit_ux_event(e) {
      var e_pass = this.on_ux_event(e, 'grid');
      if (e_pass) this.$emit('custom-event', e);
    },
    // Replace the current comp with 'renderer'
    inject_renderer: function inject_renderer(comp) {
      var src = comp.methods.calc();

      if (!src.conf || !src.conf.renderer || comp.__renderer__) {
        return comp;
      } // Search for an overlay with the target 'name'


      var f = this._list.find(function (x) {
        return x.name === src.conf.renderer;
      });

      if (!f) return comp;
      comp.mixins.push(f);
      comp.__renderer__ = src.conf.renderer;
      return comp;
    }
  },
  computed: {
    is_active: function is_active() {
      return this.$props.cursor.t !== undefined && this.$props.cursor.grid_id === this.$props.grid_id;
    }
  },
  watch: {
    range: {
      handler: function handler() {
        var _this6 = this;

        // TODO: Left-side render lag fix:
        // Overlay data is updated one tick later than
        // the main sub. Fast fix is to delay redraw()
        // call. It will be a solution until a better
        // one comes by.
        this.$nextTick(function () {
          return _this6.redraw();
        });
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        if (!this.$props.cursor.locked) this.redraw();
      },
      deep: true
    },
    overlays: {
      // Track changes in calc() functions
      handler: function handler(ovs) {
        var _iterator2 = Gridvue_type_script_lang_js_createForOfIteratorHelper(ovs),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var ov = _step2.value;

            var _iterator3 = Gridvue_type_script_lang_js_createForOfIteratorHelper(this.$children),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var comp = _step3.value;
                if (typeof comp.id !== 'string') continue;
                var tuple = comp.id.split('_');
                tuple.pop();

                if (tuple.join('_') === ov.name) {
                  comp.calc = ov.methods.calc;
                  if (!comp.calc) continue;
                  var calc = comp.calc.toString();

                  if (calc !== ov.__prevscript__) {
                    comp.exec_script();
                  }

                  ov.__prevscript__ = calc;
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      deep: true
    },
    // Redraw on the shader list change
    shaders: function shaders(n, p) {
      this.redraw();
    }
  },
  data: function data() {
    var _this7 = this;

    return {
      layer_events: {
        'new-grid-layer': this.new_layer,
        'delete-grid-layer': this.del_layer,
        'show-grid-layer': function showGridLayer(d) {
          _this7.renderer.show_hide_layer(d);

          _this7.redraw();
        },
        'redraw-grid': this.redraw,
        'layer-meta-props': function layerMetaProps(d) {
          return _this7.$emit('layer-meta-props', d);
        },
        'custom-event': function customEvent(d) {
          return _this7.$emit('custom-event', d);
        }
      },
      keyboard_events: {
        'register-kb-listener': function registerKbListener(event) {
          _this7.$emit('register-kb-listener', event);
        },
        'remove-kb-listener': function removeKbListener(event) {
          _this7.$emit('remove-kb-listener', event);
        },
        'keyup': function keyup(event) {
          if (!_this7.is_active) return;

          _this7.renderer.propagate('keyup', event);
        },
        'keydown': function keydown(event) {
          if (!_this7.is_active) return; // TODO: is this neeeded?

          _this7.renderer.propagate('keydown', event);
        },
        'keypress': function keypress(event) {
          if (!_this7.is_active) return;

          _this7.renderer.propagate('keypress', event);
        }
      }
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Grid.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Gridvue_type_script_lang_js_ = (Gridvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Grid.vue
var Grid_render, Grid_staticRenderFns
;



/* normalize component */
;
var Grid_component = normalizeComponent(
  components_Gridvue_type_script_lang_js_,
  Grid_render,
  Grid_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Grid_api; }
Grid_component.options.__file = "src/components/Grid.vue"
/* harmony default export */ const components_Grid = (Grid_component.exports);
;// CONCATENATED MODULE: ./src/components/js/sidebar.js



function sidebar_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = sidebar_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function sidebar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sidebar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sidebar_arrayLikeToArray(o, minLen); }

function sidebar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




var PANHEIGHT;

var Sidebar = /*#__PURE__*/function () {
  function Sidebar(canvas, comp, side) {
    if (side === void 0) {
      side = 'right';
    }

    classCallCheck_classCallCheck(this, Sidebar);

    PANHEIGHT = comp.config.PANHEIGHT;
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.id = this.$p.grid_id;
    this.layout = this.$p.layout.grids[this.id];
    this.side = side;
    this.listeners();
  }

  createClass_createClass(Sidebar, [{
    key: "listeners",
    value: function listeners() {
      var _this = this;

      var mc = this.mc = new hammer.Manager(this.canvas);
      mc.add(new hammer.Pan({
        direction: hammer.DIRECTION_VERTICAL,
        threshold: 0
      }));
      mc.add(new hammer.Tap({
        event: 'doubletap',
        taps: 2,
        posThreshold: 50
      }));
      mc.on('panstart', function (event) {
        if (_this.$p.y_transform) {
          _this.zoom = _this.$p.y_transform.zoom;
        } else {
          _this.zoom = 1.0;
        }

        _this.y_range = [_this.layout.$_hi, _this.layout.$_lo];
        _this.drug = {
          y: event.center.y,
          z: _this.zoom,
          mid: math.log_mid(_this.y_range, _this.layout.height),
          A: _this.layout.A,
          B: _this.layout.B
        };
      });
      mc.on('panmove', function (event) {
        if (_this.drug) {
          _this.zoom = _this.calc_zoom(event);

          _this.comp.$emit('sidebar-transform', {
            grid_id: _this.id,
            zoom: _this.zoom,
            auto: false,
            range: _this.calc_range(),
            drugging: true
          });

          _this.update();
        }
      });
      mc.on('panend', function () {
        _this.drug = null;

        _this.comp.$emit('sidebar-transform', {
          grid_id: _this.id,
          drugging: false
        });
      });
      mc.on('doubletap', function () {
        _this.comp.$emit('sidebar-transform', {
          grid_id: _this.id,
          zoom: 1.0,
          auto: true
        });

        _this.zoom = 1.0;

        _this.update();
      }); // TODO: Do later for mobile version
    }
  }, {
    key: "update",
    value: function update() {
      // Update reference to the grid
      this.layout = this.$p.layout.grids[this.id];
      var points = this.layout.ys;
      var x,
          y,
          w,
          h,
          side = this.side;
      var sb = this.layout.sb; //this.ctx.fillStyle = this.$p.colors.back

      this.ctx.font = this.$p.font;

      switch (side) {
        case 'left':
          x = 0;
          y = 0;
          w = Math.floor(sb);
          h = this.layout.height; //this.ctx.fillRect(x, y, w, h)

          this.ctx.clearRect(x, y, w, h);
          this.ctx.strokeStyle = this.$p.colors.scale;
          this.ctx.beginPath();
          this.ctx.moveTo(x + 0.5, 0);
          this.ctx.lineTo(x + 0.5, h);
          this.ctx.stroke();
          break;

        case 'right':
          x = 0;
          y = 0;
          w = Math.floor(sb);
          h = this.layout.height; //this.ctx.fillRect(x, y, w, h)

          this.ctx.clearRect(x, y, w, h);
          this.ctx.strokeStyle = this.$p.colors.scale;
          this.ctx.beginPath();
          this.ctx.moveTo(x + 0.5, 0);
          this.ctx.lineTo(x + 0.5, h);
          this.ctx.stroke();
          break;
      }

      this.ctx.fillStyle = this.$p.colors.text;
      this.ctx.beginPath();

      var _iterator = sidebar_createForOfIteratorHelper(points),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          if (p[0] > this.layout.height) continue;
          var x1 = side === 'left' ? w - 0.5 : x - 0.5;
          var x2 = side === 'left' ? x1 - 4.5 : x1 + 4.5;
          this.ctx.moveTo(x1, p[0] - 0.5);
          this.ctx.lineTo(x2, p[0] - 0.5);
          var offst = side === 'left' ? -10 : 10;
          this.ctx.textAlign = side === 'left' ? 'end' : 'start';
          var d = this.layout.prec;
          this.ctx.fillText(p[1].toFixed(d), x1 + offst, p[0] + 4);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.ctx.stroke();
      if (this.$p.grid_id) this.upper_border();
      this.apply_shaders();
      if (this.$p.cursor.y && this.$p.cursor.y$) this.panel();
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.$p.layout.grids[this.id];
      var props = {
        layout: layout,
        cursor: this.$p.cursor
      };

      var _iterator2 = sidebar_createForOfIteratorHelper(this.$p.shaders),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "upper_border",
    value: function upper_border() {
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(this.layout.width, 0.5);
      this.ctx.stroke();
    } // A gray bar behind the current price

  }, {
    key: "panel",
    value: function panel() {
      if (this.$p.cursor.grid_id !== this.layout.id) {
        return;
      }

      var lbl = this.$p.cursor.y$.toFixed(this.layout.prec);
      this.ctx.fillStyle = this.$p.colors.panel;
      var panwidth = this.layout.sb + 1;
      var x = -0.5;
      var y = this.$p.cursor.y - PANHEIGHT * 0.5 - 0.5;
      var a = 7;
      this.ctx.fillRect(x - 0.5, y, panwidth, PANHEIGHT);
      this.ctx.fillStyle = this.$p.colors.textHL;
      this.ctx.textAlign = 'left';
      this.ctx.fillText(lbl, a, y + 15);
    }
  }, {
    key: "calc_zoom",
    value: function calc_zoom(event) {
      var d = this.drug.y - event.center.y;
      var speed = d > 0 ? 3 : 1;
      var k = 1 + speed * d / this.layout.height;
      return utils.clamp(this.drug.z * k, 0.005, 100);
    } // Not the best place to calculate y-range but
    // this is the simplest solution I found up to
    // date

  }, {
    key: "calc_range",
    value: function calc_range(diff1, diff2) {
      var _this2 = this;

      if (diff1 === void 0) {
        diff1 = 1;
      }

      if (diff2 === void 0) {
        diff2 = 1;
      }

      var z = this.zoom / this.drug.z;
      var zk = (1 / z - 1) / 2;
      var range = this.y_range.slice();
      var delta = range[0] - range[1];

      if (!this.layout.grid.logScale) {
        range[0] = range[0] + delta * zk * diff1;
        range[1] = range[1] - delta * zk * diff2;
      } else {
        var px_mid = this.layout.height / 2;
        var new_hi = px_mid - px_mid * (1 / z);
        var new_lo = px_mid + px_mid * (1 / z); // Use old mapping to get a new range

        var f = function f(y) {
          return math.exp((y - _this2.drug.B) / _this2.drug.A);
        };

        var copy = range.slice();
        range[0] = f(new_hi);
        range[1] = f(new_lo);
      }

      return range;
    }
  }, {
    key: "rezoom_range",
    value: function rezoom_range(delta, diff1, diff2) {
      if (!this.$p.y_transform || this.$p.y_transform.auto) return;
      this.zoom = 1.0; // TODO: further work (improve scaling ratio)

      if (delta < 0) delta /= 3.75; // Btw, idk why 3.75, but it works

      delta *= 0.25;
      this.y_range = [this.layout.$_hi, this.layout.$_lo];
      this.drug = {
        y: 0,
        z: this.zoom,
        mid: math.log_mid(this.y_range, this.layout.height),
        A: this.layout.A,
        B: this.layout.B
      };
      this.zoom = this.calc_zoom({
        center: {
          y: delta * this.layout.height
        }
      });
      this.comp.$emit('sidebar-transform', {
        grid_id: this.id,
        zoom: this.zoom,
        auto: false,
        range: this.calc_range(diff1, diff2),
        drugging: true
      });
      this.drug = null;
      this.comp.$emit('sidebar-transform', {
        grid_id: this.id,
        drugging: false
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.mc) this.mc.destroy();
    }
  }, {
    key: "mousemove",
    value: function mousemove() {}
  }, {
    key: "mouseout",
    value: function mouseout() {}
  }, {
    key: "mouseup",
    value: function mouseup() {}
  }, {
    key: "mousedown",
    value: function mousedown() {}
  }]);

  return Sidebar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Sidebar.vue?vue&type=script&lang=js&
// The side bar (yep, that thing with a bunch of $$$)


/* harmony default export */ const Sidebarvue_type_script_lang_js_ = ({
  name: 'Sidebar',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'font', 'width', 'height', 'grid_id', 'rerender', 'y_transform', 'tv_id', 'config', 'shaders'],
  mixins: [canvas],
  mounted: function mounted() {
    var el = this.$refs['canvas'];
    this.renderer = new Sidebar(el, this);
    this.setup();
    this.redraw();
  },
  render: function render(h) {
    var id = this.$props.grid_id;
    var layout = this.$props.layout.grids[id];
    return this.create_canvas(h, "sidebar-".concat(id), {
      position: {
        x: layout.width,
        y: layout.offset || 0
      },
      attrs: {
        rerender: this.$props.rerender,
        width: this.$props.width,
        height: layout.height
      },
      style: {
        backgroundColor: this.$props.colors.back
      }
    });
  },
  watch: {
    range: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    rerender: function rerender() {
      var _this = this;

      this.$nextTick(function () {
        return _this.redraw();
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.renderer) this.renderer.destroy();
  }
});
;// CONCATENATED MODULE: ./src/components/Sidebar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Sidebarvue_type_script_lang_js_ = (Sidebarvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Sidebar.vue
var Sidebar_render, Sidebar_staticRenderFns
;



/* normalize component */
;
var Sidebar_component = normalizeComponent(
  components_Sidebarvue_type_script_lang_js_,
  Sidebar_render,
  Sidebar_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Sidebar_api; }
Sidebar_component.options.__file = "src/components/Sidebar.vue"
/* harmony default export */ const components_Sidebar = (Sidebar_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=template&id=34724886&
var Legendvue_type_template_id_34724886_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-legend", style: _vm.calc_style },
    [
      _vm.grid_id === 0
        ? _c(
            "div",
            {
              staticClass: "trading-vue-ohlcv",
              style: { "max-width": _vm.common.width + "px" }
            },
            [
              _c(
                "span",
                {
                  staticClass: "t-vue-title",
                  style: { color: _vm.common.colors.title }
                },
                [
                  _vm._v(
                    "\n              " +
                      _vm._s(_vm.common.title_txt) +
                      "\n        "
                  )
                ]
              ),
              _vm._v(" "),
              _vm.show_values
                ? _c("span", [
                    _vm._v("\n            O"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[0]))
                    ]),
                    _vm._v("\n            H"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[1]))
                    ]),
                    _vm._v("\n            L"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[2]))
                    ]),
                    _vm._v("\n            C"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[3]))
                    ]),
                    _vm._v("\n            V"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[4]))
                    ])
                  ])
                : _vm._e(),
              _vm._v(" "),
              !_vm.show_values
                ? _c(
                    "span",
                    {
                      staticClass: "t-vue-lspan",
                      style: { color: _vm.common.colors.text }
                    },
                    [
                      _vm._v(
                        "\n            " +
                          _vm._s((_vm.common.meta.last || [])[4]) +
                          "\n        "
                      )
                    ]
                  )
                : _vm._e()
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm._l(this.indicators, function(ind) {
        return _c(
          "div",
          { staticClass: "t-vue-ind" },
          [
            _c("span", { staticClass: "t-vue-iname" }, [
              _vm._v(_vm._s(ind.name))
            ]),
            _vm._v(" "),
            _c("button-group", {
              attrs: {
                buttons: _vm.common.buttons,
                config: _vm.common.config,
                ov_id: ind.id,
                grid_id: _vm.grid_id,
                index: ind.index,
                tv_id: _vm.common.tv_id,
                display: ind.v
              },
              on: { "legend-button-click": _vm.button_click }
            }),
            _vm._v(" "),
            ind.v
              ? _c(
                  "span",
                  { staticClass: "t-vue-ivalues" },
                  _vm._l(ind.values, function(v) {
                    return _vm.show_values
                      ? _c(
                          "span",
                          {
                            staticClass: "t-vue-lspan t-vue-ivalue",
                            style: { color: v.color }
                          },
                          [
                            _vm._v(
                              "\n                " +
                                _vm._s(v.value) +
                                "\n            "
                            )
                          ]
                        )
                      : _vm._e()
                  }),
                  0
                )
              : _vm._e(),
            _vm._v(" "),
            ind.unk
              ? _c("span", { staticClass: "t-vue-unknown" }, [
                  _vm._v("\n            (Unknown type)\n        ")
                ])
              : _vm._e(),
            _vm._v(" "),
            _c(
              "transition",
              { attrs: { name: "tvjs-appear" } },
              [
                ind.loading
                  ? _c("spinner", { attrs: { colors: _vm.common.colors } })
                  : _vm._e()
              ],
              1
            )
          ],
          1
        )
      })
    ],
    2
  )
}
var Legendvue_type_template_id_34724886_staticRenderFns = []
Legendvue_type_template_id_34724886_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=template&id=34724886&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=template&id=6f826426&
var ButtonGroupvue_type_template_id_6f826426_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "span",
    { staticClass: "t-vue-lbtn-grp" },
    _vm._l(_vm.buttons, function(b, i) {
      return _c("legend-button", {
        key: i,
        attrs: {
          id: b.name || b,
          tv_id: _vm.tv_id,
          ov_id: _vm.ov_id,
          grid_id: _vm.grid_id,
          index: _vm.index,
          display: _vm.display,
          icon: b.icon,
          config: _vm.config
        },
        on: { "legend-button-click": _vm.button_click }
      })
    }),
    1
  )
}
var ButtonGroupvue_type_template_id_6f826426_staticRenderFns = []
ButtonGroupvue_type_template_id_6f826426_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=template&id=6f826426&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=template&id=1ad87362&
var LegendButtonvue_type_template_id_1ad87362_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("img", {
    staticClass: "t-vue-lbtn",
    style: {
      width: _vm.config.L_BTN_SIZE + "px",
      height: _vm.config.L_BTN_SIZE + "px",
      margin: _vm.config.L_BTN_MARGIN
    },
    attrs: { src: _vm.base64, id: _vm.uuid },
    on: { click: _vm.onclick }
  })
}
var LegendButtonvue_type_template_id_1ad87362_staticRenderFns = []
LegendButtonvue_type_template_id_1ad87362_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=template&id=1ad87362&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//

/* harmony default export */ const LegendButtonvue_type_script_lang_js_ = ({
  name: 'LegendButton',
  props: ['id', 'tv_id', 'grid_id', 'ov_id', 'index', 'display', 'icon', 'config'],
  mounted: function mounted() {},
  computed: {
    base64: function base64() {
      return this.icon || icons_namespaceObject[this.file_name];
    },
    file_name: function file_name() {
      var id = this.$props.id;

      if (this.$props.id === 'display') {
        id = this.$props.display ? 'display_on' : 'display_off';
      }

      return id + '.png';
    },
    uuid: function uuid() {
      var tv = this.$props.tv_id;
      var gr = this.$props.grid_id;
      var ov = this.$props.ov_id;
      return "".concat(tv, "-btn-g").concat(gr, "-").concat(ov);
    },
    data_type: function data_type() {
      return this.$props.grid_id === 0 ? "onchart" : "offchart";
    },
    data_index: function data_index() {
      return this.$props.index;
    }
  },
  methods: {
    onclick: function onclick() {
      this.$emit('legend-button-click', {
        button: this.$props.id,
        type: this.data_type,
        dataIndex: this.data_index,
        grid: this.$props.grid_id,
        overlay: this.$props.ov_id
      });
    }
  }
});
;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_LegendButtonvue_type_script_lang_js_ = (LegendButtonvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=style&index=0&lang=css&
var LegendButtonvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(169);
;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/LegendButton.vue



;


/* normalize component */

var LegendButton_component = normalizeComponent(
  components_LegendButtonvue_type_script_lang_js_,
  LegendButtonvue_type_template_id_1ad87362_render,
  LegendButtonvue_type_template_id_1ad87362_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LegendButton_api; }
LegendButton_component.options.__file = "src/components/LegendButton.vue"
/* harmony default export */ const LegendButton = (LegendButton_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const ButtonGroupvue_type_script_lang_js_ = ({
  name: 'ButtonGroup',
  props: ['buttons', 'tv_id', 'ov_id', 'grid_id', 'index', 'display', 'config'],
  components: {
    LegendButton: LegendButton
  },
  methods: {
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ButtonGroupvue_type_script_lang_js_ = (ButtonGroupvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=style&index=0&lang=css&
var ButtonGroupvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(886);
;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue



;


/* normalize component */

var ButtonGroup_component = normalizeComponent(
  components_ButtonGroupvue_type_script_lang_js_,
  ButtonGroupvue_type_template_id_6f826426_render,
  ButtonGroupvue_type_template_id_6f826426_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ButtonGroup_api; }
ButtonGroup_component.options.__file = "src/components/ButtonGroup.vue"
/* harmony default export */ const ButtonGroup = (ButtonGroup_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=template&id=39432f99&
var Spinnervue_type_template_id_39432f99_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "tvjs-spinner" },
    _vm._l(4, function(i) {
      return _c("div", { key: i, style: { background: _vm.colors.text } })
    }),
    0
  )
}
var Spinnervue_type_template_id_39432f99_staticRenderFns = []
Spinnervue_type_template_id_39432f99_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=template&id=39432f99&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=script&lang=js&
//
//
//
//
//
//
/* harmony default export */ const Spinnervue_type_script_lang_js_ = ({
  name: 'Spinner',
  props: ['colors']
});
;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Spinnervue_type_script_lang_js_ = (Spinnervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=style&index=0&lang=css&
var Spinnervue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(372);
;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Spinner.vue



;


/* normalize component */

var Spinner_component = normalizeComponent(
  components_Spinnervue_type_script_lang_js_,
  Spinnervue_type_template_id_39432f99_render,
  Spinnervue_type_template_id_39432f99_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Spinner_api; }
Spinner_component.options.__file = "src/components/Spinner.vue"
/* harmony default export */ const Spinner = (Spinner_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const Legendvue_type_script_lang_js_ = ({
  name: 'ChartLegend',
  props: ['common', 'values', 'grid_id', 'meta_props'],
  components: {
    ButtonGroup: ButtonGroup,
    Spinner: Spinner
  },
  computed: {
    ohlcv: function ohlcv() {
      if (!this.$props.values || !this.$props.values.ohlcv) {
        return Array(6).fill('n/a');
      }

      var prec = this.layout.prec; // TODO: main the main legend more customizable

      var id = this.main_type + '_0';
      var meta = this.$props.meta_props[id] || {};

      if (meta.legend) {
        return (meta.legend() || []).map(function (x) {
          return x.value;
        });
      }

      return [this.$props.values.ohlcv[1].toFixed(prec), this.$props.values.ohlcv[2].toFixed(prec), this.$props.values.ohlcv[3].toFixed(prec), this.$props.values.ohlcv[4].toFixed(prec), this.$props.values.ohlcv[5] ? this.$props.values.ohlcv[5].toFixed(2) : 'n/a'];
    },
    // TODO: add support for { grid: { id : N }}
    indicators: function indicators() {
      var _this = this;

      var values = this.$props.values;
      var f = this.format;
      var types = {};
      return this.json_data.filter(function (x) {
        return x.settings.legend !== false && !x.main;
      }).map(function (x) {
        if (!(x.type in types)) types[x.type] = 0;
        var id = x.type + "_".concat(types[x.type]++);
        return {
          v: 'display' in x.settings ? x.settings.display : true,
          name: x.name || id,
          index: (_this.off_data || _this.json_data).indexOf(x),
          id: id,
          values: values ? f(id, values) : _this.n_a(1),
          unk: !(id in (_this.$props.meta_props || {})),
          loading: x.loading
        };
      });
    },
    calc_style: function calc_style() {
      var top = this.layout.height > 150 ? 10 : 5;
      var grids = this.$props.common.layout.grids;
      var w = grids[0] ? grids[0].width : undefined;
      return {
        top: "".concat(this.layout.offset + top, "px"),
        width: "".concat(w - 20, "px")
      };
    },
    layout: function layout() {
      var id = this.$props.grid_id;
      return this.$props.common.layout.grids[id];
    },
    json_data: function json_data() {
      return this.$props.common.data;
    },
    off_data: function off_data() {
      return this.$props.common.offchart;
    },
    main_type: function main_type() {
      var f = this.common.data.find(function (x) {
        return x.main;
      });
      return f ? f.type : undefined;
    },
    show_values: function show_values() {
      return this.common.cursor.mode !== 'explore';
    }
  },
  methods: {
    format: function format(id, values) {
      var meta = this.$props.meta_props[id] || {}; // Matches Overlay.data_colors with the data values
      // (see Spline.vue)

      if (!values[id]) return this.n_a(1); // Custom formatter

      if (meta.legend) return meta.legend(values[id]);
      return values[id].slice(1).map(function (x, i) {
        var cs = meta.data_colors ? meta.data_colors() : [];

        if (typeof x == 'number') {
          // Show 8 digits for small values
          x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
        }

        return {
          value: x,
          color: cs ? cs[i % cs.length] : undefined
        };
      });
    },
    n_a: function n_a(len) {
      return Array(len).fill({
        value: 'n/a'
      });
    },
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Legendvue_type_script_lang_js_ = (Legendvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=style&index=0&lang=css&
var Legendvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(600);
;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Legend.vue



;


/* normalize component */

var Legend_component = normalizeComponent(
  components_Legendvue_type_script_lang_js_,
  Legendvue_type_template_id_34724886_render,
  Legendvue_type_template_id_34724886_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Legend_api; }
Legend_component.options.__file = "src/components/Legend.vue"
/* harmony default export */ const Legend = (Legend_component.exports);
;// CONCATENATED MODULE: ./src/mixins/shaders.js
function shaders_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = shaders_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function shaders_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return shaders_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return shaders_arrayLikeToArray(o, minLen); }

function shaders_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Parser for shader events
/* harmony default export */ const shaders = ({
  methods: {
    // Init shaders from extensions
    init_shaders: function init_shaders(skin, prev) {
      if (skin !== prev) {
        if (prev) this.shaders = this.shaders.filter(function (x) {
          return x.owner !== prev.id;
        });

        var _iterator = shaders_createForOfIteratorHelper(skin.shaders),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var Shader = _step.value;
            var shader = new Shader();
            shader.owner = skin.id;
            this.shaders.push(shader);
          } // TODO: Sort by zIndex

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    },
    on_shader_event: function on_shader_event(d, target) {
      if (d.event === 'new-shader') {
        if (d.args[0].target === target) {
          d.args[0].id = "".concat(d.args[1], "-").concat(d.args[2]);
          this.shaders.push(d.args[0]);
          this.rerender++;
        }
      }

      if (d.event === 'remove-shaders') {
        var id = d.args.join('-');
        this.shaders = this.shaders.filter(function (x) {
          return x.id !== id;
        });
      }
    }
  },
  watch: {
    skin: function skin(n, p) {
      this.init_shaders(n, p);
    }
  },
  data: function data() {
    return {
      shaders: []
    };
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=script&lang=js&

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ const Sectionvue_type_script_lang_js_ = ({
  name: 'GridSection',
  props: ['common', 'grid_id'],
  mixins: [shaders],
  components: {
    Grid: components_Grid,
    Sidebar: components_Sidebar,
    ChartLegend: Legend
  },
  mounted: function mounted() {
    this.init_shaders(this.$props.common.skin);
  },
  methods: {
    range_changed: function range_changed(r) {
      this.$emit('range-changed', r);
    },
    cursor_changed: function cursor_changed(c) {
      c.grid_id = this.$props.grid_id;
      this.$emit('cursor-changed', c);
    },
    cursor_locked: function cursor_locked(state) {
      this.$emit('cursor-locked', state);
    },
    sidebar_transform: function sidebar_transform(s) {
      this.$emit('sidebar-transform', s);
    },
    emit_meta_props: function emit_meta_props(d) {
      this.$set(this.meta_props, d.layer_id, d);
      this.$emit('layer-meta-props', d);
    },
    emit_custom_event: function emit_custom_event(d) {
      this.on_shader_event(d, 'sidebar');
      this.$emit('custom-event', d);
    },
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    },
    register_kb: function register_kb(event) {
      this.$emit('register-kb-listener', event);
    },
    remove_kb: function remove_kb(event) {
      this.$emit('remove-kb-listener', event);
    },
    rezoom_range: function rezoom_range(event) {
      var id = 'sb-' + event.grid_id;

      if (this.$refs[id]) {
        this.$refs[id].renderer.rezoom_range(event.z, event.diff1, event.diff2);
      }
    },
    ghash: function ghash(val) {
      // Measures grid heights configuration
      var hs = val.layout.grids.map(function (x) {
        return x.height;
      });
      return hs.reduce(function (a, b) {
        return a + b;
      }, '');
    }
  },
  computed: {
    // Component-specific props subsets:
    grid_props: function grid_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common); // Split offchart data between offchart grids

      if (id > 0) {
        var _p$data;

        var all = p.data;
        p.data = [p.data[id - 1]]; // Merge offchart overlays with custom ids with
        // the existing onse (by comparing the grid ids)

        (_p$data = p.data).push.apply(_p$data, _toConsumableArray(all.filter(function (x) {
          return x.grid && x.grid.id === id;
        })));
      }

      p.width = p.layout.grids[id].width;
      p.height = p.layout.grids[id].height;
      p.y_transform = p.y_ts[id];
      p.shaders = this.grid_shaders;
      return p;
    },
    sidebar_props: function sidebar_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common);
      p.width = p.layout.grids[id].sb;
      p.height = p.layout.grids[id].height;
      p.y_transform = p.y_ts[id];
      p.shaders = this.sb_shaders;
      return p;
    },
    section_values: function section_values() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common);
      p.width = p.layout.grids[id].width;
      return p.cursor.values[id];
    },
    legend_props: function legend_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common); // Split offchart data between offchart grids

      if (id > 0) {
        var _p$data2;

        var all = p.data;
        p.offchart = all;
        p.data = [p.data[id - 1]];

        (_p$data2 = p.data).push.apply(_p$data2, _toConsumableArray(all.filter(function (x) {
          return x.grid && x.grid.id === id;
        })));
      }

      return p;
    },
    get_meta_props: function get_meta_props() {
      return this.meta_props;
    },
    grid_shaders: function grid_shaders() {
      return this.shaders.filter(function (x) {
        return x.target === 'grid';
      });
    },
    sb_shaders: function sb_shaders() {
      return this.shaders.filter(function (x) {
        return x.target === 'sidebar';
      });
    }
  },
  watch: {
    common: {
      handler: function handler(val, old_val) {
        var newhash = this.ghash(val);

        if (newhash !== this.last_ghash) {
          this.rerender++;
        }

        if (val.data.length !== old_val.data.length) {
          // Look at this nasty trick!
          this.rerender++;
        }

        this.last_ghash = newhash;
      },
      deep: true
    }
  },
  data: function data() {
    return {
      meta_props: {},
      rerender: 0,
      last_ghash: ''
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Sectionvue_type_script_lang_js_ = (Sectionvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=style&index=0&lang=css&
var Sectionvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(11);
;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Section.vue



;


/* normalize component */

var Section_component = normalizeComponent(
  components_Sectionvue_type_script_lang_js_,
  Sectionvue_type_template_id_8fbe9336_render,
  Sectionvue_type_template_id_8fbe9336_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Section_api; }
Section_component.options.__file = "src/components/Section.vue"
/* harmony default export */ const Section = (Section_component.exports);
;// CONCATENATED MODULE: ./src/components/js/botbar.js



function botbar_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = botbar_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function botbar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return botbar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return botbar_arrayLikeToArray(o, minLen); }

function botbar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



var botbar_MINUTE15 = constants.MINUTE15,
    botbar_MINUTE = constants.MINUTE,
    botbar_HOUR = constants.HOUR,
    botbar_DAY = constants.DAY,
    botbar_WEEK = constants.WEEK,
    botbar_MONTH = constants.MONTH,
    botbar_YEAR = constants.YEAR,
    botbar_MONTHMAP = constants.MONTHMAP;

var Botbar = /*#__PURE__*/function () {
  function Botbar(canvas, comp) {
    classCallCheck_classCallCheck(this, Botbar);

    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.layout = this.$p.layout;
  }

  createClass_createClass(Botbar, [{
    key: "update",
    value: function update() {
      this.grid_0 = this.layout.grids[0];
      var width = this.layout.botbar.width;
      var height = this.layout.botbar.height;
      var sb = this.layout.grids[0].sb; //this.ctx.fillStyle = this.$p.colors.back

      this.ctx.font = this.$p.font; //this.ctx.fillRect(0, 0, width, height)

      this.ctx.clearRect(0, 0, width, height);
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(Math.floor(width + 1), 0.5);
      this.ctx.stroke();
      this.ctx.fillStyle = this.$p.colors.text;
      this.ctx.beginPath();

      var _iterator = botbar_createForOfIteratorHelper(this.layout.botbar.xs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var lbl = this.format_date(p);
          if (p[0] > width - sb) continue;
          this.ctx.moveTo(p[0] - 0.5, 0);
          this.ctx.lineTo(p[0] - 0.5, 4.5);

          if (!this.lbl_highlight(p[1][0])) {
            this.ctx.globalAlpha = 0.85;
          }

          this.ctx.textAlign = 'center';
          this.ctx.fillText(lbl, p[0], 18);
          this.ctx.globalAlpha = 1;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.ctx.stroke();
      this.apply_shaders();
      if (this.$p.cursor.x && this.$p.cursor.t !== undefined) this.panel();
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.layout.grids[0];
      var props = {
        layout: layout,
        cursor: this.$p.cursor
      };

      var _iterator2 = botbar_createForOfIteratorHelper(this.comp.bot_shaders),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "panel",
    value: function panel() {
      var lbl = this.format_cursor_x();
      this.ctx.fillStyle = this.$p.colors.panel;
      var measure = this.ctx.measureText(lbl + '    ');
      var panwidth = Math.floor(measure.width);
      var cursor = this.$p.cursor.x;
      var x = Math.floor(cursor - panwidth * 0.5);
      var y = -0.5;
      var panheight = this.comp.config.PANHEIGHT;
      this.ctx.fillRect(x, y, panwidth, panheight + 0.5);
      this.ctx.fillStyle = this.$p.colors.textHL;
      this.ctx.textAlign = 'center';
      this.ctx.fillText(lbl, cursor, y + 16);
    }
  }, {
    key: "format_date",
    value: function format_date(p) {
      var t = p[1][0];
      t = this.grid_0.ti_map.i2t(t);
      var ti = this.$p.layout.grids[0].ti_map.tf; // Enable timezones only for tf < 1D

      var k = ti < botbar_DAY ? 1 : 0;
      var tZ = t + k * this.$p.timezone * botbar_HOUR; //t += new Date(t).getTimezoneOffset() * MINUTE

      var d = new Date(tZ);

      if (p[2] === botbar_YEAR || utils.year_start(t) === t) {
        return d.getUTCFullYear();
      }

      if (p[2] === botbar_MONTH || utils.month_start(t) === t) {
        return botbar_MONTHMAP[d.getUTCMonth()];
      } // TODO(*) see grid_maker.js


      if (utils.day_start(tZ) === tZ) return d.getUTCDate();
      var h = utils.add_zero(d.getUTCHours());
      var m = utils.add_zero(d.getUTCMinutes());
      return h + ":" + m;
    }
  }, {
    key: "format_cursor_x",
    value: function format_cursor_x() {
      var t = this.$p.cursor.t;
      t = this.grid_0.ti_map.i2t(t); //let ti = this.$p.interval

      var ti = this.$p.layout.grids[0].ti_map.tf; // Enable timezones only for tf < 1D

      var k = ti < botbar_DAY ? 1 : 0; //t += new Date(t).getTimezoneOffset() * MINUTE

      var d = new Date(t + k * this.$p.timezone * botbar_HOUR);

      if (ti === botbar_YEAR) {
        return d.getUTCFullYear();
      }

      if (ti < botbar_YEAR) {
        var yr = '`' + "".concat(d.getUTCFullYear()).slice(-2);
        var mo = botbar_MONTHMAP[d.getUTCMonth()];
        var dd = '01';
      }

      if (ti <= botbar_WEEK) dd = d.getUTCDate();
      var date = "".concat(dd, " ").concat(mo, " ").concat(yr);
      var time = '';

      if (ti < botbar_DAY) {
        var h = utils.add_zero(d.getUTCHours());
        var m = utils.add_zero(d.getUTCMinutes());
        time = h + ":" + m;
      }

      return "".concat(date, "  ").concat(time);
    } // Highlights the begining of a time interval
    // TODO: improve. Problem: let's say we have a new month,
    // but if there is no grid line in place, there
    // will be no month name on t-axis. Sad.
    // Solution: manipulate the grid, skew it, you know

  }, {
    key: "lbl_highlight",
    value: function lbl_highlight(t) {
      var ti = this.$p.interval;
      if (t === 0) return true;
      if (utils.month_start(t) === t) return true;
      if (utils.day_start(t) === t) return true;
      if (ti <= botbar_MINUTE15 && t % botbar_HOUR === 0) return true;
      return false;
    }
  }, {
    key: "mousemove",
    value: function mousemove() {}
  }, {
    key: "mouseout",
    value: function mouseout() {}
  }, {
    key: "mouseup",
    value: function mouseup() {}
  }, {
    key: "mousedown",
    value: function mousedown() {}
  }]);

  return Botbar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Botbar.vue?vue&type=script&lang=js&
// The bottom bar (yep, that thing with a bunch of dates)


/* harmony default export */ const Botbarvue_type_script_lang_js_ = ({
  name: 'Botbar',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'font', 'width', 'height', 'rerender', 'tv_id', 'config', 'shaders', 'timezone'],
  mixins: [canvas],
  mounted: function mounted() {
    var el = this.$refs['canvas'];
    this.renderer = new Botbar(el, this);
    this.setup();
    this.redraw();
  },
  render: function render(h) {
    var sett = this.$props.layout.botbar;
    return this.create_canvas(h, 'botbar', {
      position: {
        x: 0,
        y: sett.offset || 0
      },
      attrs: {
        rerender: this.$props.rerender,
        width: sett.width,
        height: sett.height
      },
      style: {
        backgroundColor: this.$props.colors.back
      }
    });
  },
  computed: {
    bot_shaders: function bot_shaders() {
      return this.$props.shaders.filter(function (x) {
        return x.target === 'botbar';
      });
    }
  },
  watch: {
    range: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    rerender: function rerender() {
      var _this = this;

      this.$nextTick(function () {
        return _this.redraw();
      });
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Botbar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Botbarvue_type_script_lang_js_ = (Botbarvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Botbar.vue?vue&type=style&index=0&lang=css&
var Botbarvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(124);
;// CONCATENATED MODULE: ./src/components/Botbar.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Botbar.vue
var Botbar_render, Botbar_staticRenderFns
;

;


/* normalize component */

var Botbar_component = normalizeComponent(
  components_Botbarvue_type_script_lang_js_,
  Botbar_render,
  Botbar_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Botbar_api; }
Botbar_component.options.__file = "src/components/Botbar.vue"
/* harmony default export */ const components_Botbar = (Botbar_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Keyboard.vue?vue&type=script&lang=js&
//
//
//
//
/* harmony default export */ const Keyboardvue_type_script_lang_js_ = ({
  name: 'Keyboard',
  created: function created() {
    window.addEventListener('keydown', this.keydown);
    window.addEventListener('keyup', this.keyup);
    window.addEventListener('keypress', this.keypress);
    this._listeners = {};
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('keydown', this.keydown);
    window.removeEventListener('keyup', this.keyup);
    window.removeEventListener('keypress', this.keypress);
  },
  render: function render(h) {
    return h();
  },
  methods: {
    keydown: function keydown(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keydown) {
          l.keydown(event);
        } else {
          console.warn("No 'keydown' listener for ".concat(id));
        }
      }
    },
    keyup: function keyup(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keyup) {
          l.keyup(event);
        } else {
          console.warn("No 'keyup' listener for ".concat(id));
        }
      }
    },
    keypress: function keypress(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keypress) {
          l.keypress(event);
        } else {
          console.warn("No 'keypress' listener for ".concat(id));
        }
      }
    },
    register: function register(listener) {
      this._listeners[listener.id] = listener;
    },
    remove: function remove(listener) {
      delete this._listeners[listener.id];
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Keyboard.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Keyboardvue_type_script_lang_js_ = (Keyboardvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Keyboard.vue
var Keyboard_render, Keyboard_staticRenderFns
;



/* normalize component */
;
var Keyboard_component = normalizeComponent(
  components_Keyboardvue_type_script_lang_js_,
  Keyboard_render,
  Keyboard_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Keyboard_api; }
Keyboard_component.options.__file = "src/components/Keyboard.vue"
/* harmony default export */ const Keyboard = (Keyboard_component.exports);
;// CONCATENATED MODULE: ./src/mixins/datatrack.js
// Data tracker/watcher

/* harmony default export */ const datatrack = ({
  methods: {
    data_changed: function data_changed() {
      var n = this.ohlcv;
      var changed = false;

      if (this._data_n0 !== n[0] && this._data_len !== n.length) {
        changed = true;
      }

      this.check_all_data(changed);

      if (this.ti_map.ib) {
        this.reindex_delta(n[0], this._data_n0);
      }

      this._data_n0 = n[0];
      this._data_len = n.length;
      this.save_data_t();
      return changed;
    },
    check_all_data: function check_all_data(changed) {
      // If length of data in the Structure changed by > 1 point
      // emit a special event for DC to recalc the scripts
      // TODO: check overlays data too
      var len = this._data_len || 0;

      if (Math.abs(this.ohlcv.length - len) > 1 || this._data_n0 !== this.ohlcv[0]) {
        this.$emit('custom-event', {
          event: 'data-len-changed',
          args: []
        });
      }
    },
    reindex_delta: function reindex_delta(n, p) {
      n = n || [[0]];
      p = p || [[0]];
      var dt = n[0] - p[0];

      if (dt !== 0 && this._data_t) {
        // Convert t back to index
        try {
          // More precise method first
          var nt = this._data_t + 0.01; // fix for the filter lib

          var res = utils.fast_nearest(this.ohlcv, nt);
          var cndl = this.ohlcv[res[0]];
          var off = (nt - cndl[0]) / this.interval_ms;
          this["goto"](res[0] + off);
        } catch (e) {
          this["goto"](this.ti_map.t2i(this._data_t));
        }
      }
    },
    save_data_t: function save_data_t() {
      this._data_t = this.ti_map.i2t(this.range[1]); // save as t
    }
  },
  data: function data() {
    return {
      _data_n0: null,
      _data_len: 0,
      _data_t: 0
    };
  }
});
;// CONCATENATED MODULE: ./src/components/js/ti_mapping.js




// Time-index mapping (for non-linear t-axis)

var MAX_ARR = Math.pow(2, 32); // 3 MODES of index calculation for overlays/subcharts:
// ::: indexSrc :::
// * "map"      -> use TI mapping functions to detect index
//                 (slowest, for stocks only. DEFAULT)
//
// * "calc"     -> calculate shift between sub & data
//                 (faster, but overlay data should be perfectly
//                  align with the main chart,
//                  1-1 candle/data point. Supports Renko)
//
// * "data"     -> overlay data should come with candle index
//                 (fastest, supports Renko)

var TI = /*#__PURE__*/function () {
  function TI() {
    classCallCheck_classCallCheck(this, TI);

    this.ib = false;
  }

  createClass_createClass(TI, [{
    key: "init",
    value: function init(params, res) {
      var sub = params.sub,
          interval = params.interval,
          meta = params.meta,
          $p = params.$props,
          interval_ms = params.interval_ms,
          sub_start = params.sub_start,
          ib = params.ib;
      this.ti_map = [];
      this.it_map = [];
      this.sub_i = [];
      this.ib = ib;
      this.sub = res;
      this.ss = sub_start;
      this.tf = interval_ms;
      var start = meta.sub_start; // Skip mapping for the regular mode

      if (this.ib) {
        this.map_sub(res);
      }
    } // Make maps for the main subset

  }, {
    key: "map_sub",
    value: function map_sub(res) {
      for (var i = 0; i < res.length; i++) {
        var t = res[i][0];

        var _i = this.ss + i;

        this.ti_map[t] = _i;
        this.it_map[_i] = t; // Overwrite t with i

        var copy = _toConsumableArray(res[i]);

        copy[0] = _i;
        this.sub_i.push(copy);
      }
    } // Map overlay data
    // TODO: parse() called 3 times instead of 2 for 'spx_sample.json'

  }, {
    key: "parse",
    value: function parse(data, mode) {
      if (!this.ib || !this.sub[0] || mode === 'data') return data;
      var res = [];
      var k = 0; // Candlestick index

      if (mode === 'calc') {
        var shift = utils.index_shift(this.sub, data);

        for (var i = 0; i < data.length; i++) {
          var _i = this.ss + i;

          var copy = _toConsumableArray(data[i]);

          copy[0] = _i + shift;
          res.push(copy);
        }

        return res;
      } // If indicator data starts after ohlcv, calc the first index


      if (data.length) {
        try {
          var k1 = utils.fast_nearest(this.sub, data[0][0])[0];
          if (k1 !== null && k1 >= 0) k = k1;
        } catch (e) {}
      }

      var t0 = this.sub[0][0];
      var tN = this.sub[this.sub.length - 1][0];

      for (var i = 0; i < data.length; i++) {
        var _copy = _toConsumableArray(data[i]);

        var tk = this.sub[k][0];
        var t = data[i][0];
        var index = this.ti_map[t];

        if (index === undefined) {
          // Linear extrapolation
          if (t < t0 || t > tN) {
            index = this.ss + k - (tk - t) / this.tf;
            t = data[i + 1] ? data[i + 1][0] : undefined;
          } // Linear interpolation
          else {
              var tk2 = this.sub[k + 1][0];
              index = tk === tk2 ? this.ss + k : this.ss + k + (t - tk) / (tk2 - tk);
              t = data[i + 1] ? data[i + 1][0] : undefined;
            }
        } // Race of data points & sub points (ohlcv)
        // (like turn based increments)


        while (k + 1 < this.sub.length - 1 && t > this.sub[k + 1][0]) {
          k++;
          tk = this.sub[k][0];
        }

        _copy[0] = index;
        res.push(_copy);
      }

      return res;
    } // index => time

  }, {
    key: "i2t",
    value: function i2t(i) {
      if (!this.ib || !this.sub.length) return i; // Regular mode
      // Discrete mapping

      var res = this.it_map[i];
      if (res !== undefined) return res; // Linear extrapolation
      else if (i >= this.ss + this.sub_i.length) {
          var di = i - (this.ss + this.sub_i.length) + 1;
          var last = this.sub[this.sub.length - 1];
          return last[0] + di * this.tf;
        } else if (i < this.ss) {
          var _di = i - this.ss;

          return this.sub[0][0] + _di * this.tf;
        } // Linear Interpolation

      var i1 = Math.floor(i) - this.ss;
      var i2 = i1 + 1;
      var len = this.sub.length;
      if (i2 >= len) i2 = len - 1;
      var sub1 = this.sub[i1];
      var sub2 = this.sub[i2];

      if (sub1 && sub2) {
        var t1 = sub1[0];
        var t2 = sub2[0];
        return t1 + (t2 - t1) * (i - i1 - this.ss);
      }

      return undefined;
    } // Map or bypass depending on the mode

  }, {
    key: "i2t_mode",
    value: function i2t_mode(i, mode) {
      return mode === 'data' ? i : this.i2t(i);
    } // time => index
    // TODO: when switch from IB mode to regular tools
    // disappear (bc there is no more mapping)

  }, {
    key: "t2i",
    value: function t2i(t) {
      if (!this.sub.length) return undefined; // Discrete mapping

      var res = this.ti_map[t];
      if (res !== undefined) return res;
      var t0 = this.sub[0][0];
      var tN = this.sub[this.sub.length - 1][0]; // Linear extrapolation

      if (t < t0) {
        return this.ss - (t0 - t) / this.tf;
      } else if (t > tN) {
        var k = this.sub.length - 1;
        return this.ss + k - (tN - t) / this.tf;
      }

      try {
        // Linear Interpolation
        var i = utils.fast_nearest(this.sub, t);
        var tk = this.sub[i[0]][0];
        var tk2 = this.sub[i[1]][0];

        var _k = (t - tk) / (tk2 - tk);

        return this.ss + i[0] + _k * (i[1] - i[0]);
      } catch (e) {}

      return undefined;
    } // Auto detect: is it time or index?
    // Assuming that index-based mode is ON

  }, {
    key: "smth2i",
    value: function smth2i(smth) {
      if (smth > MAX_ARR) {
        return this.t2i(smth); // it was time
      } else {
          return smth; // it was an index
        }
    }
  }, {
    key: "smth2t",
    value: function smth2t(smth) {
      if (smth < MAX_ARR) {
        return this.i2t(smth); // it was an index
      } else {
          return smth; // it was time
        }
    } // Global Time => Index (uses all data, approx. method)
    // Used by tv.goto()

  }, {
    key: "gt2i",
    value: function gt2i(smth, ohlcv) {
      if (smth > MAX_ARR) {
        var E = 0.1; // Fixes the arrayslicer bug

        var _Utils$fast_nearest = utils.fast_nearest(ohlcv, smth + E),
            _Utils$fast_nearest2 = _slicedToArray(_Utils$fast_nearest, 2),
            i1 = _Utils$fast_nearest2[0],
            i2 = _Utils$fast_nearest2[1];

        if (typeof i1 === 'number') {
          return i1;
        } else {
          return this.t2i(smth); // fallback
        }
      } else {
          return smth; // it was an index
        }
    }
  }]);

  return TI;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Chart.vue?vue&type=script&lang=js&


//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//











/* harmony default export */ const Chartvue_type_script_lang_js_ = ({
  name: 'Chart',
  props: ['title_txt', 'data', 'width', 'height', 'font', 'colors', 'overlays', 'tv_id', 'config', 'buttons', 'toolbar', 'ib', 'skin', 'timezone'],
  mixins: [shaders, datatrack],
  components: {
    GridSection: Section,
    Botbar: components_Botbar,
    Keyboard: Keyboard
  },
  created: function created() {
    // Context for text measurements
    this.ctx = new context(this.$props); // Initial layout (All measurments for the chart)

    this.init_range();
    this.sub = this.subset();
    utils.overwrite(this.range, this.range); // Fix for IB mode

    this._layout = new layout(this); // Updates current cursor values

    this.updater = new updater(this);
    this.update_last_values();
    this.init_shaders(this.skin);
  },
  methods: {
    range_changed: function range_changed(r) {
      // Overwite & keep the original references
      // Quick fix for IB mode (switch 2 next lines)
      // TODO: wtf?
      var sub = this.subset(r);
      utils.overwrite(this.range, r);
      utils.overwrite(this.sub, sub);
      this.update_layout();
      this.$emit('range-changed', r);
      if (this.$props.ib) this.save_data_t();
    },
    "goto": function goto(t) {
      var dt = this.range[1] - this.range[0];
      this.range_changed([t - dt, t]);
    },
    setRange: function setRange(t1, t2) {
      this.range_changed([t1, t2]);
    },
    cursor_changed: function cursor_changed(e) {
      if (e.mode) this.cursor.mode = e.mode;

      if (this.cursor.mode !== 'explore') {
        this.updater.sync(e);
      }

      if (this._hook_xchanged) this.ce('?x-changed', e);
    },
    cursor_locked: function cursor_locked(state) {
      if (this.cursor.scroll_lock && state) return;
      this.cursor.locked = state;
      if (this._hook_xlocked) this.ce('?x-locked', state);
    },
    calc_interval: function calc_interval() {
      var _this = this;

      var tf = utils.parse_tf(this.forced_tf);
      if (this.ohlcv.length < 2 && !tf) return;
      this.interval_ms = tf || utils.detect_interval(this.ohlcv);
      this.interval = this.$props.ib ? 1 : this.interval_ms;
      utils.warn(function () {
        return _this.$props.ib && !_this.chart.tf;
      }, constants.IB_TF_WARN, constants.SECOND);
    },
    set_ytransform: function set_ytransform(s) {
      var obj = this.y_transforms[s.grid_id] || {};
      Object.assign(obj, s);
      this.$set(this.y_transforms, s.grid_id, obj);
      this.update_layout();
      utils.overwrite(this.range, this.range);
    },
    default_range: function default_range() {
      var dl = this.$props.config.DEFAULT_LEN;
      var ml = this.$props.config.MINIMUM_LEN + 0.5;
      var l = this.ohlcv.length - 1;
      if (this.ohlcv.length < 2) return;

      if (this.ohlcv.length <= dl) {
        var s = 0,
            d = ml;
      } else {
        s = l - dl, d = 0.5;
      }

      if (!this.$props.ib) {
        utils.overwrite(this.range, [this.ohlcv[s][0] - this.interval * d, this.ohlcv[l][0] + this.interval * ml]);
      } else {
        utils.overwrite(this.range, [s - this.interval * d, l + this.interval * ml]);
      }
    },
    subset: function subset(range) {
      if (range === void 0) {
        range = this.range;
      }

      var _this$filter = this.filter(this.ohlcv, range[0] - this.interval, range[1]),
          _this$filter2 = _slicedToArray(_this$filter, 2),
          res = _this$filter2[0],
          index = _this$filter2[1];

      this.ti_map = new TI();

      if (res) {
        this.sub_start = index;
        this.ti_map.init(this, res);
        if (!this.$props.ib) return res || [];
        return this.ti_map.sub_i;
      }

      return [];
    },
    common_props: function common_props() {
      return {
        title_txt: this.chart.name || this.$props.title_txt,
        layout: this._layout,
        sub: this.sub,
        range: this.range,
        interval: this.interval,
        cursor: this.cursor,
        colors: this.$props.colors,
        font: this.$props.font,
        y_ts: this.y_transforms,
        tv_id: this.$props.tv_id,
        config: this.$props.config,
        buttons: this.$props.buttons,
        meta: this.meta,
        skin: this.$props.skin
      };
    },
    overlay_subset: function overlay_subset(source, side) {
      var _this2 = this;

      return source.map(function (d, i) {
        var res = utils.fast_filter(d.data, _this2.ti_map.i2t_mode(_this2.range[0] - _this2.interval, d.indexSrc), _this2.ti_map.i2t_mode(_this2.range[1], d.indexSrc));
        return {
          type: d.type,
          name: utils.format_name(d),
          data: _this2.ti_map.parse(res[0] || [], d.indexSrc || 'map'),
          settings: d.settings || _this2.settings_ov,
          grid: d.grid || {},
          tf: utils.parse_tf(d.tf),
          i0: res[1],
          loading: d.loading,
          last: (_this2.last_values[side] || [])[i]
        };
      });
    },
    section_props: function section_props(i) {
      return i === 0 ? this.main_section : this.sub_section;
    },
    init_range: function init_range() {
      this.calc_interval();
      this.default_range();
    },
    layer_meta_props: function layer_meta_props(d) {
      // TODO: check reactivity when layout is changed
      if (!(d.grid_id in this.layers_meta)) {
        this.$set(this.layers_meta, d.grid_id, {});
      }

      this.$set(this.layers_meta[d.grid_id], d.layer_id, d); // Rerender

      this.update_layout();
    },
    remove_meta_props: function remove_meta_props(grid_id, layer_id) {
      if (grid_id in this.layers_meta) {
        this.$delete(this.layers_meta[grid_id], layer_id);
      }
    },
    emit_custom_event: function emit_custom_event(d) {
      this.on_shader_event(d, 'botbar');
      this.$emit('custom-event', d);

      if (d.event === 'remove-layer-meta') {
        this.remove_meta_props.apply(this, _toConsumableArray(d.args));
      }
    },
    update_layout: function update_layout(clac_tf) {
      if (clac_tf) this.calc_interval();
      var lay = new layout(this);
      utils.copy_layout(this._layout, lay);
      if (this._hook_update) this.ce('?chart-update', lay);
    },
    legend_button_click: function legend_button_click(event) {
      this.$emit('legend-button-click', event);
    },
    register_kb: function register_kb(event) {
      if (!this.$refs.keyboard) return;
      this.$refs.keyboard.register(event);
    },
    remove_kb: function remove_kb(event) {
      if (!this.$refs.keyboard) return;
      this.$refs.keyboard.remove(event);
    },
    update_last_values: function update_last_values() {
      var _this3 = this;

      this.last_candle = this.ohlcv ? this.ohlcv[this.ohlcv.length - 1] : undefined;
      this.last_values = {
        onchart: [],
        offchart: []
      };
      this.onchart.forEach(function (x, i) {
        var d = x.data || [];
        _this3.last_values.onchart[i] = d[d.length - 1];
      });
      this.offchart.forEach(function (x, i) {
        var d = x.data || [];
        _this3.last_values.offchart[i] = d[d.length - 1];
      });
    },
    // Hook events for extensions
    ce: function ce(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.emit_custom_event({
        event: event,
        args: args
      });
    },
    // Set hooks list (called from an extension)
    hooks: function hooks() {
      var _this4 = this;

      for (var _len2 = arguments.length, list = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        list[_key2] = arguments[_key2];
      }

      list.forEach(function (x) {
        return _this4["_hook_".concat(x)] = true;
      });
    }
  },
  computed: {
    // Component-specific props subsets:
    main_section: function main_section() {
      var p = Object.assign({}, this.common_props());
      p.data = this.overlay_subset(this.onchart, 'onchart');
      p.data.push({
        type: this.chart.type || 'Candles',
        main: true,
        data: this.sub,
        i0: this.sub_start,
        settings: this.chart.settings || this.settings_ohlcv,
        grid: this.chart.grid || {},
        last: this.last_candle
      });
      p.overlays = this.$props.overlays;
      return p;
    },
    sub_section: function sub_section() {
      var p = Object.assign({}, this.common_props());
      p.data = this.overlay_subset(this.offchart, 'offchart');
      p.overlays = this.$props.overlays;
      return p;
    },
    botbar_props: function botbar_props() {
      var p = Object.assign({}, this.common_props());
      p.width = p.layout.botbar.width;
      p.height = p.layout.botbar.height;
      p.rerender = this.rerender;
      return p;
    },
    offsub: function offsub() {
      return this.overlay_subset(this.offchart, 'offchart');
    },
    // Datasets: candles, onchart, offchart indicators
    ohlcv: function ohlcv() {
      return this.$props.data.ohlcv || this.chart.data || [];
    },
    chart: function chart() {
      return this.$props.data.chart || {
        grid: {}
      };
    },
    onchart: function onchart() {
      return this.$props.data.onchart || [];
    },
    offchart: function offchart() {
      return this.$props.data.offchart || [];
    },
    filter: function filter() {
      return this.$props.ib ? utils.fast_filter_i : utils.fast_filter;
    },
    styles: function styles() {
      var w = this.$props.toolbar ? this.$props.config.TOOLBAR : 0;
      return {
        'margin-left': "".concat(w, "px")
      };
    },
    meta: function meta() {
      return {
        last: this.last_candle,
        sub_start: this.sub_start,
        activated: this.activated
      };
    },
    forced_tf: function forced_tf() {
      return this.chart.tf;
    }
  },
  data: function data() {
    return {
      // Current data slice
      sub: [],
      // Time range
      range: [],
      // Candlestick interval
      interval: 0,
      // Crosshair states
      cursor: {
        x: null,
        y: null,
        t: null,
        y$: null,
        grid_id: null,
        locked: false,
        values: {},
        scroll_lock: false,
        mode: utils.xmode()
      },
      // A trick to re-render botbar
      rerender: 0,
      // Layers meta-props (changing behaviour)
      layers_meta: {},
      // Y-transforms (for y-zoom and -shift)
      y_transforms: {},
      // Default OHLCV settings (when using DataStructure v1.0)
      settings_ohlcv: {},
      // Default overlay settings
      settings_ov: {},
      // Meta data
      last_candle: [],
      last_values: {},
      sub_start: undefined,
      activated: false
    };
  },
  watch: {
    width: function width() {
      this.update_layout();
      if (this._hook_resize) this.ce('?chart-resize');
    },
    height: function height() {
      this.update_layout();
      if (this._hook_resize) this.ce('?chart-resize');
    },
    ib: function ib(nw) {
      if (!nw) {
        // Change range index => time
        var t1 = this.ti_map.i2t(this.range[0]);
        var t2 = this.ti_map.i2t(this.range[1]);
        utils.overwrite(this.range, [t1, t2]);
        this.interval = this.interval_ms;
      } else {
        this.init_range(); // TODO: calc index range instead

        utils.overwrite(this.range, this.range);
        this.interval = 1;
      }

      var sub = this.subset();
      utils.overwrite(this.sub, sub);
      this.update_layout();
    },
    timezone: function timezone() {
      this.update_layout();
    },
    colors: function colors() {
      utils.overwrite(this.range, this.range);
    },
    forced_tf: function forced_tf(n, p) {
      this.update_layout(true);
      this.ce('exec-all-scripts');
    },
    data: {
      handler: function handler(n, p) {
        if (!this.sub.length) this.init_range();
        var sub = this.subset(); // Fixes Infinite loop warn, when the subset is empty
        // TODO: Consider removing 'sub' from data entirely

        if (this.sub.length || sub.length) {
          utils.overwrite(this.sub, sub);
        }

        var nw = this.data_changed();
        this.update_layout(nw);
        utils.overwrite(this.range, this.range);
        this.cursor.scroll_lock = !!n.scrollLock;

        if (n.scrollLock && this.cursor.locked) {
          this.cursor.locked = false;
        }

        if (this._hook_data) this.ce('?chart-data', nw);
        this.update_last_values(); // TODO: update legend values for overalys

        this.rerender++;
      },
      deep: true
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Chart.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Chartvue_type_script_lang_js_ = (Chartvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Chart.vue





/* normalize component */
;
var Chart_component = normalizeComponent(
  components_Chartvue_type_script_lang_js_,
  Chartvue_type_template_id_4d06a4de_render,
  Chartvue_type_template_id_4d06a4de_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Chart_api; }
Chart_component.options.__file = "src/components/Chart.vue"
/* harmony default export */ const Chart = (Chart_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=template&id=021887fb&
var Toolbarvue_type_template_id_021887fb_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      key: _vm.tool_count,
      staticClass: "trading-vue-toolbar",
      style: _vm.styles
    },
    _vm._l(_vm.groups, function(tool, i) {
      return tool.icon && !tool.hidden
        ? _c("toolbar-item", {
            key: i,
            attrs: {
              data: tool,
              subs: _vm.sub_map,
              dc: _vm.data,
              config: _vm.config,
              colors: _vm.colors,
              selected: _vm.is_selected(tool)
            },
            on: { "item-selected": _vm.selected }
          })
        : _vm._e()
    }),
    1
  )
}
var Toolbarvue_type_template_id_021887fb_staticRenderFns = []
Toolbarvue_type_template_id_021887fb_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=template&id=021887fb&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=template&id=227b3c2e&
var ToolbarItemvue_type_template_id_227b3c2e_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      class: ["trading-vue-tbitem", _vm.selected ? "selected-item" : ""],
      style: _vm.item_style,
      on: {
        click: function($event) {
          return _vm.emit_selected("click")
        },
        mousedown: _vm.mousedown,
        touchstart: _vm.mousedown,
        touchend: function($event) {
          return _vm.emit_selected("touch")
        }
      }
    },
    [
      _c("div", {
        staticClass: "trading-vue-tbicon tvjs-pixelated",
        style: _vm.icon_style
      }),
      _vm._v(" "),
      _vm.data.group
        ? _c(
            "div",
            {
              staticClass: "trading-vue-tbitem-exp",
              style: _vm.exp_style,
              on: {
                click: _vm.exp_click,
                mousedown: _vm.expmousedown,
                mouseover: _vm.expmouseover,
                mouseleave: _vm.expmouseleave
              }
            },
            [_vm._v("\n        ᐳ\n    ")]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.show_exp_list
        ? _c("item-list", {
            attrs: {
              config: _vm.config,
              items: _vm.data.items,
              colors: _vm.colors,
              dc: _vm.dc
            },
            on: {
              "close-list": _vm.close_list,
              "item-selected": _vm.emit_selected_sub
            }
          })
        : _vm._e()
    ],
    1
  )
}
var ToolbarItemvue_type_template_id_227b3c2e_staticRenderFns = []
ToolbarItemvue_type_template_id_227b3c2e_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=template&id=227b3c2e&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=template&id=c50b23fe&
var ItemListvue_type_template_id_c50b23fe_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "tvjs-item-list",
      style: _vm.list_style(),
      on: { mousedown: _vm.thismousedown }
    },
    _vm._l(_vm.items, function(item) {
      return !item.hidden
        ? _c(
            "div",
            {
              class: _vm.item_class(item),
              style: _vm.item_style(item),
              on: {
                click: function(e) {
                  return _vm.item_click(e, item)
                }
              }
            },
            [
              _c("div", {
                staticClass: "trading-vue-tbicon tvjs-pixelated",
                style: _vm.icon_style(item)
              }),
              _vm._v(" "),
              _c("div", [_vm._v(_vm._s(item.type))])
            ]
          )
        : _vm._e()
    }),
    0
  )
}
var ItemListvue_type_template_id_c50b23fe_staticRenderFns = []
ItemListvue_type_template_id_c50b23fe_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=template&id=c50b23fe&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const ItemListvue_type_script_lang_js_ = ({
  name: 'ItemList',
  props: ['config', 'items', 'colors', 'dc'],
  mounted: function mounted() {
    window.addEventListener('mousedown', this.onmousedown);
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('mousedown', this.onmousedown);
  },
  methods: {
    list_style: function list_style() {
      var conf = this.$props.config;
      var w = conf.TOOLBAR;
      var brd = this.colors.tbListBorder || this.colors.grid;
      var bstl = "1px solid ".concat(brd);
      return {
        left: "".concat(w, "px"),
        background: this.colors.back,
        borderTop: bstl,
        borderRight: bstl,
        borderBottom: bstl
      };
    },
    item_class: function item_class(item) {
      if (this.dc.tool === item.type) {
        return "tvjs-item-list-item selected-item";
      }

      return "tvjs-item-list-item";
    },
    item_style: function item_style(item) {
      var conf = this.$props.config;
      var h = conf.TB_ICON + conf.TB_ITEM_M * 2 + 8;
      var sel = this.dc.tool === item.type;
      return {
        height: "".concat(h, "px"),
        color: sel ? undefined : "#888888"
      };
    },
    icon_style: function icon_style(data) {
      var conf = this.$props.config;
      var br = conf.TB_ICON_BRI;
      var im = conf.TB_ITEM_M;
      return {
        'background-image': "url(".concat(data.icon, ")"),
        'width': '25px',
        'height': '25px',
        'margin': "".concat(im, "px"),
        'filter': "brightness(".concat(br, ")")
      };
    },
    item_click: function item_click(e, item) {
      e.cancelBubble = true;
      this.$emit('item-selected', item);
      this.$emit('close-list');
    },
    onmousedown: function onmousedown() {
      this.$emit('close-list');
    },
    thismousedown: function thismousedown(e) {
      e.stopPropagation();
    }
  },
  computed: {},
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ItemListvue_type_script_lang_js_ = (ItemListvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=style&index=0&lang=css&
var ItemListvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(807);
;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ItemList.vue



;


/* normalize component */

var ItemList_component = normalizeComponent(
  components_ItemListvue_type_script_lang_js_,
  ItemListvue_type_template_id_c50b23fe_render,
  ItemListvue_type_template_id_c50b23fe_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ItemList_api; }
ItemList_component.options.__file = "src/components/ItemList.vue"
/* harmony default export */ const ItemList = (ItemList_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const ToolbarItemvue_type_script_lang_js_ = ({
  name: 'ToolbarItem',
  props: ['data', 'selected', 'colors', 'tv_id', 'config', 'dc', 'subs'],
  components: {
    ItemList: ItemList
  },
  mounted: function mounted() {
    if (this.data.group) {
      var type = this.subs[this.data.group];
      var item = this.data.items.find(function (x) {
        return x.type === type;
      });
      if (item) this.sub_item = item;
    }
  },
  methods: {
    mousedown: function mousedown(e) {
      var _this = this;

      this.click_start = utils.now();
      this.click_id = setTimeout(function () {
        _this.show_exp_list = true;
      }, this.config.TB_ICON_HOLD);
    },
    expmouseover: function expmouseover() {
      this.exp_hover = true;
    },
    expmouseleave: function expmouseleave() {
      this.exp_hover = false;
    },
    expmousedown: function expmousedown(e) {
      if (this.show_exp_list) e.stopPropagation();
    },
    emit_selected: function emit_selected(src) {
      if (utils.now() - this.click_start > this.config.TB_ICON_HOLD) return;
      clearTimeout(this.click_id); //if (Utils.is_mobile && src === 'click') return
      // TODO: double firing

      if (!this.data.group) {
        this.$emit('item-selected', this.data);
      } else {
        var item = this.sub_item || this.data.items[0];
        this.$emit('item-selected', item);
      }
    },
    emit_selected_sub: function emit_selected_sub(item) {
      this.$emit('item-selected', item);
      this.sub_item = item;
    },
    exp_click: function exp_click(e) {
      if (!this.data.group) return;
      e.cancelBubble = true;
      this.show_exp_list = !this.show_exp_list;
    },
    close_list: function close_list() {
      this.show_exp_list = false;
    }
  },
  computed: {
    item_style: function item_style() {
      if (this.$props.data.type === 'System:Splitter') {
        return this.splitter;
      }

      var conf = this.$props.config;
      var im = conf.TB_ITEM_M;
      var m = (conf.TOOLBAR - conf.TB_ICON) * 0.5 - im;
      var s = conf.TB_ICON + im * 2;
      var b = this.exp_hover ? 0 : 3;
      return {
        'width': "".concat(s, "px"),
        'height': "".concat(s, "px"),
        'margin': "8px ".concat(m, "px 0px ").concat(m, "px"),
        'border-radius': "3px ".concat(b, "px ").concat(b, "px 3px")
      };
    },
    icon_style: function icon_style() {
      if (this.$props.data.type === 'System:Splitter') {
        return {};
      }

      var conf = this.$props.config;
      var br = conf.TB_ICON_BRI;
      var sz = conf.TB_ICON;
      var im = conf.TB_ITEM_M;
      var ic = this.sub_item ? this.sub_item.icon : this.$props.data.icon;
      return {
        'background-image': "url(".concat(ic, ")"),
        'width': "".concat(sz, "px"),
        'height': "".concat(sz, "px"),
        'margin': "".concat(im, "px"),
        'filter': "brightness(".concat(br, ")")
      };
    },
    exp_style: function exp_style() {
      var conf = this.$props.config;
      var im = conf.TB_ITEM_M;
      var s = conf.TB_ICON * 0.5 + im;
      var p = (conf.TOOLBAR - s * 2) / 4;
      return {
        padding: "".concat(s, "px ").concat(p, "px"),
        transform: this.show_exp_list ? "scale(-0.6, 1)" : "scaleX(0.6)"
      };
    },
    splitter: function splitter() {
      var conf = this.$props.config;
      var colors = this.$props.colors;
      var c = colors.grid;
      var im = conf.TB_ITEM_M;
      var m = (conf.TOOLBAR - conf.TB_ICON) * 0.5 - im;
      var s = conf.TB_ICON + im * 2;
      return {
        'width': "".concat(s, "px"),
        'height': '1px',
        'margin': "8px ".concat(m, "px 8px ").concat(m, "px"),
        'background-color': c
      };
    }
  },
  data: function data() {
    return {
      exp_hover: false,
      show_exp_list: false,
      sub_item: null
    };
  }
});
;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ToolbarItemvue_type_script_lang_js_ = (ToolbarItemvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=style&index=0&lang=css&
var ToolbarItemvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(501);
;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue



;


/* normalize component */

var ToolbarItem_component = normalizeComponent(
  components_ToolbarItemvue_type_script_lang_js_,
  ToolbarItemvue_type_template_id_227b3c2e_render,
  ToolbarItemvue_type_template_id_227b3c2e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ToolbarItem_api; }
ToolbarItem_component.options.__file = "src/components/ToolbarItem.vue"
/* harmony default export */ const ToolbarItem = (ToolbarItem_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=script&lang=js&
function Toolbarvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Toolbarvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Toolbarvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Toolbarvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Toolbarvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Toolbarvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const Toolbarvue_type_script_lang_js_ = ({
  name: 'Toolbar',
  props: ['data', 'height', 'colors', 'tv_id', 'config'],
  components: {
    ToolbarItem: ToolbarItem
  },
  mounted: function mounted() {},
  methods: {
    selected: function selected(tool) {
      this.$emit('custom-event', {
        event: 'tool-selected',
        args: [tool.type]
      });

      if (tool.group) {
        // TODO: emit the sub map to DC (save)
        this.sub_map[tool.group] = tool.type;
      }
    },
    is_selected: function is_selected(tool) {
      var _this = this;

      if (tool.group) {
        return !!tool.items.find(function (x) {
          return x.type === _this.data.tool;
        });
      }

      return tool.type === this.data.tool;
    }
  },
  computed: {
    styles: function styles() {
      var colors = this.$props.colors;
      var b = this.$props.config.TB_BORDER;
      var w = this.$props.config.TOOLBAR - b;
      var c = colors.grid;
      var cb = colors.tbBack || colors.back;
      var brd = colors.tbBorder || colors.scale;
      var st = this.$props.config.TB_B_STYLE;
      return {
        'width': "".concat(w, "px"),
        'height': "".concat(this.$props.height - 3, "px"),
        'background-color': cb,
        'border-right': "".concat(b, "px ").concat(st, " ").concat(brd)
      };
    },
    groups: function groups() {
      var arr = [];

      var _iterator = Toolbarvue_type_script_lang_js_createForOfIteratorHelper(this.data.tools || []),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tool = _step.value;

          if (!tool.group) {
            arr.push(tool);
            continue;
          }

          var g = arr.find(function (x) {
            return x.group === tool.group;
          });

          if (!g) {
            arr.push({
              group: tool.group,
              icon: tool.icon,
              items: [tool]
            });
          } else {
            g.items.push(tool);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return arr;
    }
  },
  watch: {
    data: {
      handler: function handler(n) {
        // For some reason Vue.js doesn't want to
        // update 'tools' automatically when new item
        // is pushed/removed. Yo, Vue, I herd you
        // you want more dirty tricks?
        if (n.tools) this.tool_count = n.tools.length;
      },
      deep: true
    }
  },
  data: function data() {
    return {
      tool_count: 0,
      sub_map: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Toolbarvue_type_script_lang_js_ = (Toolbarvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=style&index=0&lang=css&
var Toolbarvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(153);
;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Toolbar.vue



;


/* normalize component */

var Toolbar_component = normalizeComponent(
  components_Toolbarvue_type_script_lang_js_,
  Toolbarvue_type_template_id_021887fb_render,
  Toolbarvue_type_template_id_021887fb_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Toolbar_api; }
Toolbar_component.options.__file = "src/components/Toolbar.vue"
/* harmony default export */ const Toolbar = (Toolbar_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=template&id=5fe4312f&
var Widgetsvue_type_template_id_5fe4312f_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "tvjs-widgets",
      style: { width: _vm.width + "px", height: _vm.height + "px" }
    },
    _vm._l(Object.keys(_vm.map), function(id) {
      return _c(_vm.initw(id), {
        key: id,
        tag: "component",
        attrs: {
          id: id,
          main: _vm.map[id].ctrl,
          data: _vm.map[id].data,
          tv: _vm.tv,
          dc: _vm.dc
        }
      })
    }),
    1
  )
}
var Widgetsvue_type_template_id_5fe4312f_staticRenderFns = []
Widgetsvue_type_template_id_5fe4312f_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=template&id=5fe4312f&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const Widgetsvue_type_script_lang_js_ = ({
  name: 'Widgets',
  props: ['width', 'height', 'map', 'tv', 'dc'],
  methods: {
    initw: function initw(id) {
      return this.$props.map[id].cls;
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Widgetsvue_type_script_lang_js_ = (Widgetsvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=style&index=0&lang=css&
var Widgetsvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(5);
;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Widgets.vue



;


/* normalize component */

var Widgets_component = normalizeComponent(
  components_Widgetsvue_type_script_lang_js_,
  Widgetsvue_type_template_id_5fe4312f_render,
  Widgetsvue_type_template_id_5fe4312f_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Widgets_api; }
Widgets_component.options.__file = "src/components/Widgets.vue"
/* harmony default export */ const Widgets = (Widgets_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=template&id=2c1770cc&
var TheTipvue_type_template_id_2c1770cc_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", {
    staticClass: "tvjs-the-tip",
    style: _vm.style,
    domProps: { innerHTML: _vm._s(_vm.data.text) },
    on: {
      mousedown: function($event) {
        return _vm.$emit("remove-me")
      }
    }
  })
}
var TheTipvue_type_template_id_2c1770cc_staticRenderFns = []
TheTipvue_type_template_id_2c1770cc_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=template&id=2c1770cc&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=script&lang=js&
//
//
//
//
//
//
/* harmony default export */ const TheTipvue_type_script_lang_js_ = ({
  name: 'TheTip',
  props: ['data'],
  mounted: function mounted() {
    var _this = this;

    setTimeout(function () {
      return _this.$emit('remove-me');
    }, 3000);
  },
  computed: {
    style: function style() {
      return {
        background: this.data.color
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_TheTipvue_type_script_lang_js_ = (TheTipvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=style&index=0&lang=css&
var TheTipvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(477);
;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/TheTip.vue



;


/* normalize component */

var TheTip_component = normalizeComponent(
  components_TheTipvue_type_script_lang_js_,
  TheTipvue_type_template_id_2c1770cc_render,
  TheTipvue_type_template_id_2c1770cc_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TheTip_api; }
TheTip_component.options.__file = "src/components/TheTip.vue"
/* harmony default export */ const TheTip = (TheTip_component.exports);
;// CONCATENATED MODULE: ./src/mixins/xcontrol.js
function xcontrol_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = xcontrol_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function xcontrol_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return xcontrol_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return xcontrol_arrayLikeToArray(o, minLen); }

function xcontrol_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// extensions control
/* harmony default export */ const xcontrol = ({
  mounted: function mounted() {
    this.ctrllist();
    this.skin_styles();
  },
  methods: {
    // Build / rebuild component list
    ctrllist: function ctrllist() {
      this.ctrl_destroy();
      this.controllers = [];

      var _iterator = xcontrol_createForOfIteratorHelper(this.$props.extensions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var x = _step.value;
          var name = x.Main.__name__;

          if (!this.xSettings[name]) {
            this.$set(this.xSettings, name, {});
          }

          var nc = new x.Main(this, // tv inst
          this.data, // dc
          this.xSettings[name] // settings
          );
          nc.name = name;
          this.controllers.push(nc);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return this.controllers;
    },
    // TODO: preventDefault
    pre_dc: function pre_dc(e) {
      var _iterator2 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ctrl = _step2.value;

          if (ctrl.update) {
            ctrl.update(e);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    post_dc: function post_dc(e) {
      var _iterator3 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var ctrl = _step3.value;

          if (ctrl.post_update) {
            ctrl.post_update(e);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    },
    ctrl_destroy: function ctrl_destroy() {
      var _iterator4 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var ctrl = _step4.value;
          if (ctrl.destroy) ctrl.destroy();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    },
    skin_styles: function skin_styles() {
      var id = 'tvjs-skin-styles';
      var stbr = document.getElementById(id);

      if (stbr) {
        var parent = stbr.parentNode;
        parent.removeChild(stbr);
      }

      if (this.skin_proto && this.skin_proto.styles) {
        var sheet = document.createElement('style');
        sheet.setAttribute("id", id);
        sheet.innerHTML = this.skin_proto.styles;
        this.$el.appendChild(sheet);
      }
    }
  },
  computed: {
    ws: function ws() {
      var ws = {};

      var _iterator5 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ctrl = _step5.value;

          if (ctrl.widgets) {
            for (var id in ctrl.widgets) {
              ws[id] = ctrl.widgets[id];
              ws[id].ctrl = ctrl;
            }
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return ws;
    },
    skins: function skins() {
      var sks = {};

      var _iterator6 = xcontrol_createForOfIteratorHelper(this.$props.extensions),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var x = _step6.value;

          for (var id in x.skins || {}) {
            sks[id] = x.skins[id];
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return sks;
    },
    skin_proto: function skin_proto() {
      return this.skins[this.$props.skin];
    },
    colorpack: function colorpack() {
      var sel = this.skins[this.$props.skin];
      return sel ? sel.colors : undefined;
    }
  },
  watch: {
    // TODO: This is fast & dirty fix, need
    // to fix the actual reactivity problem
    skin: function skin(n, p) {
      if (n !== p) this.resetChart();
      this.skin_styles();
    },
    extensions: function extensions() {
      this.ctrllist();
    },
    xSettings: {
      handler: function handler(n, p) {
        var _iterator7 = xcontrol_createForOfIteratorHelper(this.controllers),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var ctrl = _step7.value;

            if (ctrl.onsettings) {
              ctrl.onsettings(n, p);
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      },
      deep: true
    }
  },
  data: function data() {
    return {
      controllers: []
    };
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=script&lang=js&


function TradingVuevue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = TradingVuevue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function TradingVuevue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TradingVuevue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TradingVuevue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function TradingVuevue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ const TradingVuevue_type_script_lang_js_ = ({
  name: 'TradingVue',
  components: {
    Chart: Chart,
    Toolbar: Toolbar,
    Widgets: Widgets,
    TheTip: TheTip
  },
  mixins: [xcontrol],
  props: {
    titleTxt: {
      type: String,
      "default": 'TradingVue.js'
    },
    id: {
      type: String,
      "default": 'trading-vue-js'
    },
    width: {
      type: Number,
      "default": 800
    },
    height: {
      type: Number,
      "default": 421
    },
    colorTitle: {
      type: String,
      "default": '#42b883'
    },
    colorBack: {
      type: String,
      "default": '#121826'
    },
    colorGrid: {
      type: String,
      "default": '#2f3240'
    },
    colorText: {
      type: String,
      "default": '#dedddd'
    },
    colorTextHL: {
      type: String,
      "default": '#fff'
    },
    colorScale: {
      type: String,
      "default": '#838383'
    },
    colorCross: {
      type: String,
      "default": '#8091a0'
    },
    colorCandleUp: {
      type: String,
      "default": '#23a776'
    },
    colorCandleDw: {
      type: String,
      "default": '#e54150'
    },
    colorWickUp: {
      type: String,
      "default": '#23a77688'
    },
    colorWickDw: {
      type: String,
      "default": '#e5415088'
    },
    colorWickSm: {
      type: String,
      "default": 'transparent' // deprecated

    },
    colorVolUp: {
      type: String,
      "default": '#79999e42'
    },
    colorVolDw: {
      type: String,
      "default": '#ef535042'
    },
    colorPanel: {
      type: String,
      "default": '#565c68'
    },
    colorTbBack: {
      type: String
    },
    colorTbBorder: {
      type: String,
      "default": '#8282827d'
    },
    colors: {
      type: Object
    },
    font: {
      type: String,
      "default": constants.ChartConfig.FONT
    },
    toolbar: {
      type: Boolean,
      "default": false
    },
    data: {
      type: Object,
      required: true
    },
    // Your overlay classes here
    overlays: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    // Overwrites ChartConfig values,
    // see constants.js
    chartConfig: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    legendButtons: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    indexBased: {
      type: Boolean,
      "default": false
    },
    extensions: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    xSettings: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    skin: {
      type: String // Skin Name

    },
    timezone: {
      type: Number,
      "default": 0
    }
  },
  computed: {
    // Copy a subset of TradingVue props
    chart_props: function chart_props() {
      var offset = this.$props.toolbar ? this.chart_config.TOOLBAR : 0;
      var chart_props = {
        title_txt: this.$props.titleTxt,
        overlays: this.$props.overlays.concat(this.mod_ovs),
        data: this.decubed,
        width: this.$props.width - offset,
        height: this.$props.height,
        font: this.font_comp,
        buttons: this.$props.legendButtons,
        toolbar: this.$props.toolbar,
        ib: this.$props.indexBased || this.index_based || false,
        colors: Object.assign({}, this.$props.colors || this.colorpack),
        skin: this.skin_proto,
        timezone: this.$props.timezone
      };
      this.parse_colors(chart_props.colors);
      return chart_props;
    },
    chart_config: function chart_config() {
      return Object.assign({}, constants.ChartConfig, this.$props.chartConfig);
    },
    decubed: function decubed() {
      var data = this.$props.data;

      if (data.data !== undefined) {
        // DataCube detected
        data.init_tvjs(this);
        return data.data;
      } else {
        return data;
      }
    },
    index_based: function index_based() {
      var base = this.$props.data;

      if (base.chart) {
        return base.chart.indexBased;
      } else if (base.data) {
        return base.data.chart.indexBased;
      }

      return false;
    },
    mod_ovs: function mod_ovs() {
      var arr = [];

      var _iterator = TradingVuevue_type_script_lang_js_createForOfIteratorHelper(this.$props.extensions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var x = _step.value;
          arr.push.apply(arr, _toConsumableArray(Object.values(x.overlays)));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return arr;
    },
    font_comp: function font_comp() {
      return this.skin_proto && this.skin_proto.font ? this.skin_proto.font : this.font;
    }
  },
  data: function data() {
    return {
      reset: 0,
      tip: null
    };
  },
  beforeDestroy: function beforeDestroy() {
    this.custom_event({
      event: 'before-destroy'
    });
    this.ctrl_destroy();
  },
  methods: {
    // TODO: reset extensions?
    resetChart: function resetChart(resetRange) {
      var _this = this;

      if (resetRange === void 0) {
        resetRange = true;
      }

      this.reset++;
      var range = this.getRange();

      if (!resetRange && range[0] && range[1]) {
        this.$nextTick(function () {
          return _this.setRange.apply(_this, _toConsumableArray(range));
        });
      }

      this.$nextTick(function () {
        return _this.custom_event({
          event: 'chart-reset',
          args: []
        });
      });
    },
    "goto": function goto(t) {
      // TODO: limit goto & setRange (out of data error)
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        t = ti_map.gt2i(t, this.$refs.chart.ohlcv);
      }

      this.$refs.chart["goto"](t);
    },
    setRange: function setRange(t1, t2) {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        var ohlcv = this.$refs.chart.ohlcv;
        t1 = ti_map.gt2i(t1, ohlcv);
        t2 = ti_map.gt2i(t2, ohlcv);
      }

      this.$refs.chart.setRange(t1, t2);
    },
    getRange: function getRange() {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map; // Time range => index range

        return this.$refs.chart.range.map(function (x) {
          return ti_map.i2t(x);
        });
      }

      return this.$refs.chart.range;
    },
    getCursor: function getCursor() {
      var cursor = this.$refs.chart.cursor;

      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        var copy = Object.assign({}, cursor);
        copy.i = copy.t;
        copy.t = ti_map.i2t(copy.t);
        return copy;
      }

      return cursor;
    },
    showTheTip: function showTheTip(text, color) {
      if (color === void 0) {
        color = "orange";
      }

      this.tip = {
        text: text,
        color: color
      };
    },
    legend_button: function legend_button(event) {
      this.custom_event({
        event: 'legend-button-click',
        args: [event]
      });
    },
    custom_event: function custom_event(d) {
      if ('args' in d) {
        this.$emit.apply(this, [d.event].concat(_toConsumableArray(d.args)));
      } else {
        this.$emit(d.event);
      }

      var data = this.$props.data;
      var ctrl = this.controllers.length !== 0;
      if (ctrl) this.pre_dc(d);

      if (data.tv) {
        // If the data object is DataCube
        data.on_custom_event(d.event, d.args);
      }

      if (ctrl) this.post_dc(d);
    },
    range_changed: function range_changed(r) {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        r = r.map(function (x) {
          return ti_map.i2t(x);
        });
      }

      this.$emit('range-changed', r);
      this.custom_event({
        event: 'range-changed',
        args: [r]
      });
      if (this.onrange) this.onrange(r);
    },
    set_loader: function set_loader(dc) {
      var _this2 = this;

      this.onrange = function (r) {
        var pf = _this2.chart_props.ib ? '_ms' : '';
        var tf = _this2.$refs.chart['interval' + pf];
        dc.range_changed(r, tf);
      };
    },
    parse_colors: function parse_colors(colors) {
      for (var k in this.$props) {
        if (k.indexOf('color') === 0 && k !== 'colors') {
          var k2 = k.replace('color', '');
          k2 = k2[0].toLowerCase() + k2.slice(1);
          if (colors[k2]) continue;
          colors[k2] = this.$props[k];
        }
      }
    },
    mousedown: function mousedown() {
      this.$refs.chart.activated = true;
    },
    mouseleave: function mouseleave() {
      this.$refs.chart.activated = false;
    }
  }
});
;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=script&lang=js&
 /* harmony default export */ const src_TradingVuevue_type_script_lang_js_ = (TradingVuevue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=style&index=0&lang=css&
var TradingVuevue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(863);
;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/TradingVue.vue



;


/* normalize component */

var TradingVue_component = normalizeComponent(
  src_TradingVuevue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TradingVue_api; }
TradingVue_component.options.__file = "src/TradingVue.vue"
/* harmony default export */ const TradingVue = (TradingVue_component.exports);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __nested_webpack_require_9759__(757);
var regenerator_default = /*#__PURE__*/__nested_webpack_require_9759__.n(regenerator);
;// CONCATENATED MODULE: ./src/helpers/tmp/ww$$$.json
const ww$$$_namespaceObject = JSON.parse('["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"]');
// EXTERNAL MODULE: ./node_modules/lz-string/libs/lz-string.js
var lz_string = __nested_webpack_require_9759__(961);
var lz_string_default = /*#__PURE__*/__nested_webpack_require_9759__.n(lz_string);
;// CONCATENATED MODULE: ./src/helpers/script_ww_api.js




// Webworker interface
// Compiled webworker (see webpack/ww_plugin.js)



 // For webworker-loader to find the ww

var WebWork = /*#__PURE__*/function () {
  function WebWork(dc) {
    classCallCheck_classCallCheck(this, WebWork);

    this.dc = dc;
    this.tasks = {};

    this.onevent = function () {};

    this.start();
  }

  createClass_createClass(WebWork, [{
    key: "start",
    value: function start() {
      var _this = this;

      if (this.worker) this.worker.terminate(); // URL.createObjectURL

      window.URL = window.URL || window.webkitURL;
      var data = lz_string_default().decompressFromBase64(ww$$$_namespaceObject[0]);
      var blob;

      try {
        blob = new Blob([data], {
          type: 'application/javascript'
        });
      } catch (e) {
        // Backwards-compatibility
        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(data);
        blob = blob.getBlob();
      }

      this.worker = new Worker(URL.createObjectURL(blob));

      this.worker.onmessage = function (e) {
        return _this.onmessage(e);
      };
    }
  }, {
    key: "start_socket",
    value: function start_socket() {
      var _this2 = this;

      if (!this.dc.sett.node_url) return;
      this.socket = new WebSocket(this.dc.sett.node_url);
      this.socket.addEventListener('message', function (e) {
        _this2.onmessage({
          data: JSON.parse(e.data)
        });
      });
      this.msg_queue = [];
    }
  }, {
    key: "send",
    value: function send(msg, tx_keys) {
      if (this.dc.sett.node_url) {
        return this.send_node(msg, tx_keys);
      }

      if (tx_keys) {
        var tx_objs = tx_keys.map(function (k) {
          return msg.data[k];
        });
        this.worker.postMessage(msg, tx_objs);
      } else {
        this.worker.postMessage(msg);
      }
    } // Send to node.js via websocket

  }, {
    key: "send_node",
    value: function send_node(msg, tx_keys) {
      if (!this.socket) this.start_socket();

      if (this.socket && this.socket.readyState) {
        // Send the old messages first
        while (this.msg_queue.length) {
          var m = this.msg_queue.shift();
          this.socket.send(JSON.stringify(m));
        }

        this.socket.send(JSON.stringify(msg));
      } else {
        this.msg_queue.push(msg);
      }
    }
  }, {
    key: "onmessage",
    value: function onmessage(e) {
      if (e.data.id in this.tasks) {
        this.tasks[e.data.id](e.data.data);
        delete this.tasks[e.data.id];
      } else {
        this.onevent(e);
      }
    } // Execute a task

  }, {
    key: "exec",
    value: function () {
      var _exec = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee(type, data, tx_keys) {
        var _this3 = this;

        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (rs, rj) {
                  var id = utils.uuid();

                  _this3.send({
                    type: type,
                    id: id,
                    data: data
                  }, tx_keys);

                  _this3.tasks[id] = function (res) {
                    rs(res);
                  };
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function exec(_x, _x2, _x3) {
        return _exec.apply(this, arguments);
      }

      return exec;
    }() // Execute a task, but just fucking do it,
    // do not wait for the result

  }, {
    key: "just",
    value: function just(type, data, tx_keys) {
      var id = utils.uuid();
      this.send({
        type: type,
        id: id,
        data: data
      }, tx_keys);
    } // Relay an event from iframe postMessage
    // (for the future)

  }, {
    key: "relay",
    value: function () {
      var _relay = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee2(event, just) {
        var _this4 = this;

        return regenerator_default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (just === void 0) {
                  just = false;
                }

                return _context2.abrupt("return", new Promise(function (rs, rj) {
                  _this4.send(event, event.tx_keys);

                  if (!just) {
                    _this4.tasks[event.id] = function (res) {
                      rs(res);
                    };
                  }
                }));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function relay(_x4, _x5) {
        return _relay.apply(this, arguments);
      }

      return relay;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.worker) this.worker.terminate();
    }
  }]);

  return WebWork;
}();

/* harmony default export */ const script_ww_api = (WebWork);
;// CONCATENATED MODULE: ./src/helpers/script_utils.js


var FDEFS = /(function |)([$A-Z_][0-9A-Z_$\.]*)[\s]*?\((.*?)\)/gmi;
var SBRACKETS = /([$A-Z_][0-9A-Z_$\.]*)[\s]*?\[([^"^\[^\]]+?)\]/gmi;
var TFSTR = /(\d+)(\w*)/gm;
var BUF_INC = 5;
var tf_cache = {};
function f_args(src) {
  FDEFS.lastIndex = 0;
  var m = FDEFS.exec(src);

  if (m) {
    var fkeyword = m[1].trim();
    var fname = m[2].trim();
    var fargs = m[3].trim();
    return fargs.split(',').map(function (x) {
      return x.trim();
    });
  }

  return [];
}
function f_body(src) {
  return src.slice(src.indexOf("{") + 1, src.lastIndexOf("}"));
}
function wrap_idxs(src, pre) {
  if (pre === void 0) {
    pre = '';
  }

  SBRACKETS.lastIndex = 0;
  var changed = false;

  do {
    var m = SBRACKETS.exec(src);

    if (m) {
      var vname = m[1].trim();
      var vindex = m[2].trim();

      if (vindex === '0' || parseInt(vindex) < BUF_INC) {
        continue;
      }

      switch (vname) {
        case 'let':
        case 'var':
        case 'return':
          continue;
      } //let wrap = `${pre}_v(${vname}, ${vindex})[${vindex}]`


      var wrap = "".concat(vname, "[").concat(pre, "_i(").concat(vindex, ", ").concat(vname, ")]");
      src = src.replace(m[0], wrap);
      changed = true;
    }
  } while (m);

  return changed ? src : src;
} // Get all module helper classes

function make_module_lib(mod) {
  var lib = {};

  for (var k in mod) {
    if (k === 'main' || k === 'id') continue;
    var a = f_args(mod[k]);
    lib[k] = new Function(a, f_body(mod[k]));
  }

  return lib;
}
function get_raw_src(f) {
  if (typeof f === 'string') return f;
  var src = f.toString();
  return src.slice(src.indexOf("{") + 1, src.lastIndexOf("}"));
} // Get tf in ms from pairs such (`15`, `m`)

function tf_from_pair(num, pf) {
  var mult = 1;

  switch (pf) {
    case 's':
      mult = Const.SECOND;
      break;

    case 'm':
      mult = Const.MINUTE;
      break;

    case 'H':
      mult = Const.HOUR;
      break;

    case 'D':
      mult = Const.DAY;
      break;

    case 'W':
      mult = Const.WEEK;
      break;

    case 'M':
      mult = Const.MONTH;
      break;

    case 'Y':
      mult = Const.YEAR;
      break;
  }

  return parseInt(num) * mult;
}
function tf_from_str(str) {
  if (typeof str === 'number') return str;
  if (tf_cache[str]) return tf_cache[str];
  TFSTR.lastIndex = 0;
  var m = TFSTR.exec(str);

  if (m) {
    tf_cache[str] = tf_from_pair(m[1], m[2]);
    return tf_cache[str];
  }

  return undefined;
}
function get_fn_id(pre, id) {
  return pre + '-' + id.split('<-').pop();
} // Apply filter for all new overlays

function ovf(obj, f) {
  var nw = {};

  for (var id in obj) {
    nw[id] = {};

    for (var k in obj[id]) {
      if (k === 'data') continue;
      nw[id][k] = obj[id][k];
    }

    nw[id].data = f(obj[id].data);
  }

  return nw;
} // Return index of the next element in
// dataset (since t). Impl: simple binary search
// TODO: optimize (remember the penultimate
// iteration and start from there)

function nextt(data, t, ti) {
  if (ti === void 0) {
    ti = 0;
  }

  var i0 = 0;
  var iN = data.length - 1;

  while (i0 <= iN) {
    var mid = Math.floor((i0 + iN) / 2);

    if (data[mid][ti] === t) {
      return mid;
    } else if (data[mid][ti] < t) {
      i0 = mid + 1;
    } else {
      iN = mid - 1;
    }
  }

  return t < data[mid][ti] ? mid : mid + 1;
} // Estimated size of datasets

function size_of_dss(data) {
  var bytes = 0;

  for (var id in data) {
    if (data[id].data && data[id].data[0]) {
      var s0 = size_of(data[id].data[0]);
      bytes += s0 * data[id].data.length;
    }
  }

  return bytes;
} // Used to measure the size of dataset

function size_of(object) {
  var list = [],
      stack = [object],
      bytes = 0;

  while (stack.length) {
    var value = stack.pop();

    var type = _typeof(value);

    if (type === 'boolean') {
      bytes += 4;
    } else if (type === 'string') {
      bytes += value.length * 2;
    } else if (type === 'number') {
      bytes += 8;
    } else if (type === 'object' && list.indexOf(value) === -1) {
      list.push(value);

      for (var i in value) {
        stack.push(value[i]);
      }
    }
  }

  return bytes;
} // Update onchart/offchart

function update(data, val) {
  var i = data.length - 1;
  var last = data[i];

  if (!last || val[0] > last[0]) {
    data.push(val);
  } else {
    data[i] = val;
  }
}
function script_utils_now() {
  return new Date().getTime();
}
;// CONCATENATED MODULE: ./src/helpers/dataset.js





function dataset_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dataset_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dataset_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataset_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataset_arrayLikeToArray(o, minLen); }

function dataset_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


// Dataset proxy between vuejs & WebWorker


var Dataset = /*#__PURE__*/function () {
  function Dataset(dc, desc) {
    classCallCheck_classCallCheck(this, Dataset);

    // TODO: dataset url arrow fn tells WW
    // to load the ds directly from web
    this.type = desc.type;
    this.id = desc.id;
    this.dc = dc; // Send the data to WW

    if (desc.data) {
      this.dc.ww.just('upload-data', _defineProperty({}, this.id, desc)); // Remove the data from the descriptor

      delete desc.data;
    }

    var proto = Object.getPrototypeOf(this);
    Object.setPrototypeOf(desc, proto);
    Object.defineProperty(desc, 'dc', {
      get: function get() {
        return dc;
      }
    });
  } // Watch for the changes of descriptors


  createClass_createClass(Dataset, [{
    key: "set",
    value: // Set data (overwrite the whole dataset)
    function set(data, exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'set',
        data: data,
        exec: exec
      });
    } // Update with new data (array of data points)

  }, {
    key: "update",
    value: function update(arr) {
      this.dc.ww.just('update-data', _defineProperty({}, this.id, arr));
    } // Send WW a chunk to merge. The merge algo
    // here is simpler than in DC. It just adds
    // data at the beginning or/and the end of ds

  }, {
    key: "merge",
    value: function merge(data, exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'mrg',
        data: data,
        exec: exec
      });
    } // Remove the ds from WW

  }, {
    key: "remove",
    value: function remove(exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.del("datasets.".concat(this.id));
      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'del',
        exec: exec
      });
      delete this.dc.dss[this.id];
    } // Fetch data from WW

  }, {
    key: "data",
    value: function () {
      var _data = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {
        var ds;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.dc.ww.exec('get-dataset', this.id);

              case 2:
                ds = _context.sent;

                if (ds) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return");

              case 5:
                return _context.abrupt("return", ds.data);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function data() {
        return _data.apply(this, arguments);
      }

      return data;
    }()
  }], [{
    key: "watcher",
    value: function watcher(n, p) {
      var nids = n.map(function (x) {
        return x.id;
      });
      var pids = p.map(function (x) {
        return x.id;
      });

      var _iterator = dataset_createForOfIteratorHelper(nids),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var id = _step.value;

          if (!pids.includes(id)) {
            var ds = n.filter(function (x) {
              return x.id === id;
            })[0];
            this.dss[id] = new Dataset(this, ds);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = dataset_createForOfIteratorHelper(pids),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var id = _step2.value;

          if (!nids.includes(id) && this.dss[id]) {
            this.dss[id].remove();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } // Make an object for data transfer

  }, {
    key: "make_tx",
    value: function make_tx(dc, types) {
      var main = dc.data.chart.data;
      var base = {};

      if (types.find(function (x) {
        return x.type === 'OHLCV';
      })) {
        base = {
          ohlcv: main
        };
      } // TODO: add more sophisticated search
      // (using 'script.datasets' paramerter)

      /*for (var req of types) {
          let ds = Object.values(dc.dss || {})
              .find(x => x.type === req.type)
          if (ds && ds.data) {
              base[ds.id] = {
                  id: ds.id,
                  type: ds.type,
                  data: ds.data
              }
          }
      }*/
      // TODO: Data request callback ?


      return base;
    }
  }]);

  return Dataset;
}(); // Dataset reciever (created on WW)



var DatasetWW = /*#__PURE__*/(/* unused pure expression or super */ null && (0));
;// CONCATENATED MODULE: ./src/helpers/dc_events.js





function dc_events_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dc_events_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dc_events_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dc_events_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dc_events_arrayLikeToArray(o, minLen); }

function dc_events_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// DataCube event handlers





var DCEvents = /*#__PURE__*/function () {
  function DCEvents() {
    var _this = this;

    classCallCheck_classCallCheck(this, DCEvents);

    this.ww = new script_ww_api(this); // Listen to the web-worker events

    this.ww.onevent = function (e) {
      var _iterator = dc_events_createForOfIteratorHelper(_this.tv.controllers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ctrl = _step.value;
          if (ctrl.ww) ctrl.ww(e.data);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      switch (e.data.type) {
        case 'request-data':
          // TODO: DataTunnel class for smarter data transfer
          if (_this.ww._data_uploading) break;
          var data = Dataset.make_tx(_this, e.data.data);

          _this.send_meta_2_ww();

          _this.ww.just('upload-data', data);

          _this.ww._data_uploading = true;
          break;

        case 'overlay-data':
          _this.on_overlay_data(e.data.data);

          break;

        case 'overlay-update':
          _this.on_overlay_update(e.data.data);

          break;

        case 'data-uploaded':
          _this.ww._data_uploading = false;
          break;

        case 'engine-state':
          _this.se_state = Object.assign(_this.se_state || {}, e.data.data);
          break;

        case 'modify-overlay':
          _this.modify_overlay(e.data.data);

          break;

        case 'script-signal':
          _this.tv.$emit('signal', e.data.data);

          break;
      }

      var _iterator2 = dc_events_createForOfIteratorHelper(_this.tv.controllers),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ctrl = _step2.value;
          if (ctrl.post_ww) ctrl.post_ww(e.data);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    };
  } // Called when overalay/tv emits 'custom-event'


  createClass_createClass(DCEvents, [{
    key: "on_custom_event",
    value: function on_custom_event(event, args) {
      switch (event) {
        case 'register-tools':
          this.register_tools(args);
          break;

        case 'exec-script':
          this.exec_script(args);
          break;

        case 'exec-all-scripts':
          this.exec_all_scripts();
          break;

        case 'data-len-changed':
          this.data_changed(args);
          break;

        case 'tool-selected':
          if (!args[0]) break; // TODO: Quick fix, investigate

          if (args[0].split(':')[0] === 'System') {
            this.system_tool(args[0].split(':')[1]);
            break;
          }

          this.tv.$set(this.data, 'tool', args[0]);

          if (args[0] === 'Cursor') {
            this.drawing_mode_off();
          }

          break;

        case 'grid-mousedown':
          this.grid_mousedown(args);
          break;

        case 'drawing-mode-off':
          this.drawing_mode_off();
          break;

        case 'change-settings':
          this.change_settings(args);
          break;

        case 'range-changed':
          this.scripts_onrange.apply(this, _toConsumableArray(args));
          break;

        case 'scroll-lock':
          this.on_scroll_lock(args[0]);
          break;

        case 'object-selected':
          this.object_selected(args);
          break;

        case 'remove-tool':
          this.system_tool('Remove');
          break;

        case 'before-destroy':
          this.before_destroy();
          break;
      }
    } // Triggered when one or multiple settings are changed
    // We select only the changed ones & re-exec them on the
    // web worker

  }, {
    key: "on_settings",
    value: function on_settings(values, prev) {
      var _this2 = this;

      if (!this.sett.scripts) return;
      var delta = {};
      var changed = false;

      var _loop = function _loop() {
        var n = values[i];
        var arr = prev.filter(function (x) {
          return x.v === n.v;
        });

        if (!arr.length && n.p.settings.$props) {
          var id = n.p.settings.$uuid;

          if (utils.is_scr_props_upd(n, prev) && utils.delayed_exec(n.p)) {
            delta[id] = n.v;
            changed = true;

            _this2.tv.$set(n.p, 'loading', true);
          }
        }
      };

      for (var i = 0; i < values.length; i++) {
        _loop();
      }

      if (changed && Object.keys(delta).length) {
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();
        this.ww.just('update-ov-settings', {
          delta: delta,
          tf: tf,
          range: range
        });
      }
    } // When the set of $uuids is changed

  }, {
    key: "on_ids_changed",
    value: function on_ids_changed(values, prev) {
      var rem = prev.filter(function (x) {
        return x !== undefined && !values.includes(x);
      });

      if (rem.length) {
        this.ww.just('remove-scripts', rem);
      }
    } // Combine all tools and their mods

  }, {
    key: "register_tools",
    value: function register_tools(tools) {
      var preset = {};

      var _iterator3 = dc_events_createForOfIteratorHelper(this.data.tools || []),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tool = _step3.value;
          preset[tool.type] = tool;
          delete tool.type;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.tv.$set(this.data, 'tools', []);
      var list = [{
        type: 'Cursor',
        icon: icons_namespaceObject["cursor.png"]
      }];

      var _iterator4 = dc_events_createForOfIteratorHelper(tools),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var tool = _step4.value;
          var proto = Object.assign({}, tool.info);
          var type = tool.info.type || 'Default';
          proto.type = "".concat(tool.use_for, ":").concat(type);
          this.merge_presets(proto, preset[tool.use_for]);
          this.merge_presets(proto, preset[proto.type]);
          delete proto.mods;
          list.push(proto);

          for (var mod in tool.info.mods) {
            var mp = Object.assign({}, proto);
            mp = Object.assign(mp, tool.info.mods[mod]);
            mp.type = "".concat(tool.use_for, ":").concat(mod);
            this.merge_presets(mp, preset[tool.use_for]);
            this.merge_presets(mp, preset[mp.type]);
            list.push(mp);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      this.tv.$set(this.data, 'tools', list);
      this.tv.$set(this.data, 'tool', 'Cursor');
    }
  }, {
    key: "exec_script",
    value: function exec_script(args) {
      if (args.length && this.sett.scripts) {
        var obj = this.get_overlay(args[0]);
        if (!obj || obj.scripts === false) return;

        if (obj.script && obj.script.src) {
          args[0].src = obj.script.src; // opt, override the src
        } // Parse script props & get the values from the ov
        // TODO: remove unnecessary script initializations


        var s = obj.settings;
        var props = args[0].src.props || {};
        if (!s.$uuid) s.$uuid = "".concat(obj.type, "-").concat(utils.uuid2());
        args[0].uuid = s.$uuid;
        args[0].sett = s;

        for (var k in props || {}) {
          var proto = props[k];

          if (s[k] !== undefined) {
            proto.val = s[k]; // use the existing val

            continue;
          }

          if (proto.def === undefined) {
            // TODO: add support of info / errors to the legend
            console.error("Overlay ".concat(obj.id, ": script prop '").concat(k, "' ") + "doesn't have a default value");
            return;
          }

          s[k] = proto.val = proto.def; // set the default
        } // Remove old props (dropped by the current exec)


        if (s.$props) {
          for (var k in s) {
            if (s.$props.includes(k) && !(k in props)) {
              delete s[k];
            }
          }
        }

        s.$props = Object.keys(args[0].src.props || {});
        this.tv.$set(obj, 'loading', true);
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();

        if (obj.script && obj.script.output != null) {
          args[0].output = obj.script.output;
        }

        this.ww.just('exec-script', {
          s: args[0],
          tf: tf,
          range: range
        });
      }
    }
  }, {
    key: "exec_all_scripts",
    value: function exec_all_scripts() {
      if (!this.sett.scripts) return;
      this.set_loading(true);
      var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
      var range = this.tv.getRange();
      this.ww.just('exec-all-scripts', {
        tf: tf,
        range: range
      });
    }
  }, {
    key: "scripts_onrange",
    value: function scripts_onrange(r) {
      if (!this.sett.scripts) return;
      var delta = {};
      this.get('.').forEach(function (v) {
        if (v.script && v.script.execOnRange && v.settings.$uuid) {
          // TODO: execInterrupt flag?
          if (utils.delayed_exec(v)) {
            delta[v.settings.$uuid] = v.settings;
          }
        }
      });

      if (Object.keys(delta).length) {
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();
        this.ww.just('update-ov-settings', {
          delta: delta,
          tf: tf,
          range: range
        });
      }
    } // Overlay modification from WW

  }, {
    key: "modify_overlay",
    value: function modify_overlay(upd) {
      var obj = this.get_overlay(upd);

      if (obj) {
        for (var k in upd.fields || {}) {
          if (typeof_typeof(obj[k]) === 'object') {
            this.merge("".concat(upd.uuid, ".").concat(k), upd.fields[k]);
          } else {
            this.tv.$set(obj, k, upd.fields[k]);
          }
        }
      }
    }
  }, {
    key: "data_changed",
    value: function data_changed(args) {
      if (!this.sett.scripts) return;
      if (this.sett.data_change_exec === false) return;
      var main = this.data.chart.data;
      if (this.ww._data_uploading) return;
      if (!this.se_state.scripts) return;
      this.send_meta_2_ww();
      this.ww.just('upload-data', {
        ohlcv: main
      });
      this.ww._data_uploading = true;
      this.set_loading(true);
    }
  }, {
    key: "set_loading",
    value: function set_loading(flag) {
      var skrr = this.get('.').filter(function (x) {
        return x.settings.$props;
      });

      var _iterator5 = dc_events_createForOfIteratorHelper(skrr),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var s = _step5.value;
          this.merge("".concat(s.id), {
            loading: flag
          });
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  }, {
    key: "send_meta_2_ww",
    value: function send_meta_2_ww() {
      var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
      var range = this.tv.getRange();
      this.ww.just('send-meta-info', {
        tf: tf,
        range: range
      });
    }
  }, {
    key: "merge_presets",
    value: function merge_presets(proto, preset) {
      if (!preset) return;

      for (var k in preset) {
        if (k === 'settings') {
          Object.assign(proto[k], preset[k]);
        } else {
          proto[k] = preset[k];
        }
      }
    }
  }, {
    key: "grid_mousedown",
    value: function grid_mousedown(args) {
      var _this3 = this;

      // TODO: tool state finished?
      this.object_selected([]); // Remove the previous RangeTool

      var rem = function rem() {
        return _this3.get('RangeTool').filter(function (x) {
          return x.settings.shiftMode;
        }).forEach(function (x) {
          return _this3.del(x.id);
        });
      };

      if (this.data.tool && this.data.tool !== 'Cursor' && !this.data.drawingMode) {
        // Prevent from "null" tools (tool created with HODL)
        if (args[1].type !== 'tap') {
          this.tv.$set(this.data, 'drawingMode', true);
          this.build_tool(args[0]);
        } else {
          this.tv.showTheTip("<b>Hodl</b>+<b>Drug</b> to create, " + "<b>Tap</b> to finish a tool");
        }
      } else if (this.sett.shift_measure && args[1].shiftKey) {
        rem();
        this.tv.$nextTick(function () {
          return _this3.build_tool(args[0], 'RangeTool:ShiftMode');
        });
      } else {
        rem();
      }
    }
  }, {
    key: "drawing_mode_off",
    value: function drawing_mode_off() {
      this.tv.$set(this.data, 'drawingMode', false);
      this.tv.$set(this.data, 'tool', 'Cursor');
    } // Place a new tool

  }, {
    key: "build_tool",
    value: function build_tool(grid_id, type) {
      var list = this.data.tools;
      type = type || this.data.tool;
      var proto = list.find(function (x) {
        return x.type === type;
      });
      if (!proto) return;
      var sett = Object.assign({}, proto.settings || {});
      var data = (proto.data || []).slice();
      if (!('legend' in sett)) sett.legend = false;
      if (!('z-index' in sett)) sett['z-index'] = 100;
      sett.$selected = true;
      sett.$state = 'wip';
      var side = grid_id ? 'offchart' : 'onchart';
      var id = this.add(side, {
        name: proto.name,
        type: type.split(':')[0],
        settings: sett,
        data: data,
        grid: {
          id: grid_id
        }
      });
      sett.$uuid = "".concat(id, "-").concat(utils.now());
      this.tv.$set(this.data, 'selected', sett.$uuid);
      this.add_trash_icon();
    } // Remove selected / Remove all, etc

  }, {
    key: "system_tool",
    value: function system_tool(type) {
      switch (type) {
        case 'Remove':
          if (this.data.selected) {
            this.del(this.data.selected);
            this.remove_trash_icon();
            this.drawing_mode_off();
            this.on_scroll_lock(false);
          }

          break;
      }
    } // Apply new overlay settings

  }, {
    key: "change_settings",
    value: function change_settings(args) {
      var settings = args[0];
      delete settings.id;
      var grid_id = args[1];
      this.merge("".concat(args[3], ".settings"), settings);
    } // Lock the scrolling mechanism

  }, {
    key: "on_scroll_lock",
    value: function on_scroll_lock(flag) {
      this.tv.$set(this.data, 'scrollLock', flag);
    } // When new object is selected / unselected

  }, {
    key: "object_selected",
    value: function object_selected(args) {
      var q = this.data.selected;

      if (q) {
        // Check if current drawing is finished
        //let res = this.get_one(`${q}.settings`)
        //if (res && res.$state !== 'finished') return
        this.merge("".concat(q, ".settings"), {
          $selected: false
        });
        this.remove_trash_icon();
      }

      this.tv.$set(this.data, 'selected', null);
      if (!args.length) return;
      this.tv.$set(this.data, 'selected', args[2]);
      this.merge("".concat(args[2], ".settings"), {
        $selected: true
      });
      this.add_trash_icon();
    }
  }, {
    key: "add_trash_icon",
    value: function add_trash_icon() {
      var type = 'System:Remove';

      if (this.data.tools.find(function (x) {
        return x.type === type;
      })) {
        return;
      }

      this.data.tools.push({
        type: type,
        icon: icons_namespaceObject["trash.png"]
      });
    }
  }, {
    key: "remove_trash_icon",
    value: function remove_trash_icon() {
      // TODO: Does not call Toolbar render (distr version)
      var type = 'System:Remove';
      utils.overwrite(this.data.tools, this.data.tools.filter(function (x) {
        return x.type !== type;
      }));
    } // Set overlay data from the web-worker

  }, {
    key: "on_overlay_data",
    value: function on_overlay_data(data) {
      var _this4 = this;

      this.get('.').forEach(function (x) {
        if (x.settings.$synth) _this4.del("".concat(x.id));
      });

      var _iterator6 = dc_events_createForOfIteratorHelper(data),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var ov = _step6.value;
          var obj = this.get_one("".concat(ov.id));

          if (obj) {
            this.tv.$set(obj, 'loading', false);
            if (!ov.data) continue;
            obj.data = ov.data;
          }

          if (!ov.new_ovs) continue;

          for (var id in ov.new_ovs.onchart) {
            if (!this.get_one("onchart.".concat(id))) {
              this.add('onchart', ov.new_ovs.onchart[id]);
            }
          }

          for (var id in ov.new_ovs.offchart) {
            if (!this.get_one("offchart.".concat(id))) {
              this.add('offchart', ov.new_ovs.offchart[id]);
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    } // Push overlay updates from the web-worker

  }, {
    key: "on_overlay_update",
    value: function on_overlay_update(data) {
      var _iterator7 = dc_events_createForOfIteratorHelper(data),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var ov = _step7.value;
          if (!ov.data) continue;
          var obj = this.get_one("".concat(ov.id));

          if (obj) {
            this.fast_merge(obj.data, ov.data, false);
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    } // Clean-up unfinished business (tools)

  }, {
    key: "before_destroy",
    value: function before_destroy() {
      var f = function f(x) {
        return !x.settings.$state || x.settings.$state === 'finished';
      };

      this.data.onchart = this.data.onchart.filter(f);
      this.data.offchart = this.data.offchart.filter(f);
      this.drawing_mode_off();
      this.on_scroll_lock(false);
      this.object_selected([]);
      this.ww.destroy();
    } // Get overlay by grid-layer id

  }, {
    key: "get_overlay",
    value: function get_overlay(obj) {
      var id = obj.id || "g".concat(obj.grid_id, "_").concat(obj.layer_id);
      var dcid = obj.uuid || this.gldc[id];
      return this.get_one("".concat(dcid));
    }
  }]);

  return DCEvents;
}();


;// CONCATENATED MODULE: ./src/helpers/dc_core.js









function dc_core_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dc_core_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dc_core_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dc_core_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dc_core_arrayLikeToArray(o, minLen); }

function dc_core_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function dc_core_createSuper(Derived) { var hasNativeReflectConstruct = dc_core_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function dc_core_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// DataCube "private" methods




var DCCore = /*#__PURE__*/function (_DCEvents) {
  _inherits(DCCore, _DCEvents);

  var _super = dc_core_createSuper(DCCore);

  function DCCore() {
    classCallCheck_classCallCheck(this, DCCore);

    return _super.apply(this, arguments);
  }

  createClass_createClass(DCCore, [{
    key: "init_tvjs",
    value: // Set TV instance (once). Called by TradingVue itself
    function init_tvjs($root) {
      var _this = this;

      if (!this.tv) {
        this.tv = $root;
        this.init_data();
        this.update_ids(); // Listen to all setting changes
        // TODO: works only with merge()

        this.tv.$watch(function () {
          return _this.get_by_query('.settings');
        }, function (n, p) {
          return _this.on_settings(n, p);
        }); // Listen to all indices changes

        this.tv.$watch(function () {
          return _this.get('.').map(function (x) {
            return x.settings.$uuid;
          });
        }, function (n, p) {
          return _this.on_ids_changed(n, p);
        }); // Watch for all 'datasets' changes

        this.tv.$watch(function () {
          return _this.get('datasets');
        }, Dataset.watcher.bind(this));
      }
    } // Init Data Structure v1.1

  }, {
    key: "init_data",
    value: function init_data($root) {
      if (!('chart' in this.data)) {
        this.tv.$set(this.data, 'chart', {
          type: 'Candles',
          data: this.data.ohlcv || []
        });
      }

      if (!('onchart' in this.data)) {
        this.tv.$set(this.data, 'onchart', []);
      }

      if (!('offchart' in this.data)) {
        this.tv.$set(this.data, 'offchart', []);
      }

      if (!this.data.chart.settings) {
        this.tv.$set(this.data.chart, 'settings', {});
      } // Remove ohlcv cuz we have Data v1.1^


      delete this.data.ohlcv;

      if (!('datasets' in this.data)) {
        this.tv.$set(this.data, 'datasets', []);
      } // Init dataset proxies


      var _iterator = dc_core_createForOfIteratorHelper(this.data.datasets),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ds = _step.value;
          if (!this.dss) this.dss = {};
          this.dss[ds.id] = new Dataset(this, ds);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } // Range change callback (called by TradingVue)
    // TODO: improve (reliablity + chunk with limited size)

  }, {
    key: "range_changed",
    value: function () {
      var _range_changed = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee(range, tf, check) {
        var _this2 = this;

        var first, prom;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (check === void 0) {
                  check = false;
                }

                if (this.loader) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                if (this.loading) {
                  _context.next = 19;
                  break;
                }

                first = this.data.chart.data[0][0];

                if (!(range[0] < first)) {
                  _context.next = 19;
                  break;
                }

                this.loading = true;
                _context.next = 9;
                return utils.pause(250);

              case 9:
                // Load bigger chunks
                range = range.slice(); // copy

                range[0] = Math.floor(range[0]);
                range[1] = Math.floor(first);
                prom = this.loader(range, tf, function (d) {
                  // Callback way
                  _this2.chunk_loaded(d);
                });

                if (!(prom && prom.then)) {
                  _context.next = 19;
                  break;
                }

                _context.t0 = this;
                _context.next = 17;
                return prom;

              case 17:
                _context.t1 = _context.sent;

                _context.t0.chunk_loaded.call(_context.t0, _context.t1);

              case 19:
                if (!check) this.last_chunk = [range, tf];

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function range_changed(_x, _x2, _x3) {
        return _range_changed.apply(this, arguments);
      }

      return range_changed;
    }() // A new chunk of data is loaded
    // TODO: bulletproof fetch

  }, {
    key: "chunk_loaded",
    value: function chunk_loaded(data) {
      // Updates only candlestick data, or
      if (Array.isArray(data)) {
        this.merge('chart.data', data);
      } else {
        // Bunch of overlays, including chart.data
        for (var k in data) {
          this.merge(k, data[k]);
        }
      }

      this.loading = false;

      if (this.last_chunk) {
        this.range_changed.apply(this, _toConsumableArray(this.last_chunk).concat([true]));
        this.last_chunk = null;
      }
    } // Update ids for all overlays

  }, {
    key: "update_ids",
    value: function update_ids() {
      this.data.chart.id = "chart.".concat(this.data.chart.type);
      var count = {}; // grid_id,layer_id => DC id mapping

      this.gldc = {}, this.dcgl = {};

      var _iterator2 = dc_core_createForOfIteratorHelper(this.data.onchart),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ov = _step2.value;

          if (count[ov.type] === undefined) {
            count[ov.type] = 0;
          }

          var i = count[ov.type]++;
          ov.id = "onchart.".concat(ov.type).concat(i);
          if (!ov.name) ov.name = ov.type + " ".concat(i);
          if (!ov.settings) this.tv.$set(ov, 'settings', {}); // grid_id,layer_id => DC id mapping

          this.gldc["g0_".concat(ov.type, "_").concat(i)] = ov.id;
          this.dcgl[ov.id] = "g0_".concat(ov.type, "_").concat(i);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      count = {};
      var grids = [{}];
      var gid = 0;

      var _iterator3 = dc_core_createForOfIteratorHelper(this.data.offchart),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var ov = _step3.value;

          if (count[ov.type] === undefined) {
            count[ov.type] = 0;
          }

          var _i = count[ov.type]++;

          ov.id = "offchart.".concat(ov.type).concat(_i);
          if (!ov.name) ov.name = ov.type + " ".concat(_i);
          if (!ov.settings) this.tv.$set(ov, 'settings', {}); // grid_id,layer_id => DC id mapping

          gid++;
          var rgid = (ov.grid || {}).id || gid; // real grid_id
          // When we merge grid, skip ++

          if ((ov.grid || {}).id) gid--;
          if (!grids[rgid]) grids[rgid] = {};

          if (grids[rgid][ov.type] === undefined) {
            grids[rgid][ov.type] = 0;
          }

          var ri = grids[rgid][ov.type]++;
          this.gldc["g".concat(rgid, "_").concat(ov.type, "_").concat(ri)] = ov.id;
          this.dcgl[ov.id] = "g".concat(rgid, "_").concat(ov.type, "_").concat(ri);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    } // TODO: chart refine (from the exchange chart)

  }, {
    key: "update_candle",
    value: function update_candle(data) {
      var ohlcv = this.data.chart.data;
      var last = ohlcv[ohlcv.length - 1];
      var candle = data['candle'];
      var tf = this.tv.$refs.chart.interval_ms;
      var t_next = last[0] + tf;
      var now = data.t || utils.now();
      var t = now >= t_next ? now - now % tf : last[0]; // Update the entire candle

      if (candle.length >= 6) {
        t = candle[0];
      } else {
        candle = [t].concat(_toConsumableArray(candle));
      }

      this.agg.push('ohlcv', candle);
      this.update_overlays(data, t, tf);
      return t >= t_next;
    }
  }, {
    key: "update_tick",
    value: function update_tick(data) {
      var ohlcv = this.data.chart.data;
      var last = ohlcv[ohlcv.length - 1];
      var tick = data['price'];
      var volume = data['volume'] || 0;
      var tf = this.tv.$refs.chart.interval_ms;

      if (!tf) {
        return console.warn('Define the main timeframe');
      }

      var now = data.t || utils.now();
      if (!last) last = [now - now % tf];
      var t_next = last[0] + tf;
      var t = now >= t_next ? now - now % tf : last[0];

      if ((t >= t_next || !ohlcv.length) && tick !== undefined) {
        // And new zero-height candle
        var nc = [t, tick, tick, tick, tick, volume];
        this.agg.push('ohlcv', nc, tf);
        ohlcv.push(nc);
        this.scroll_to(t);
      } else if (tick !== undefined) {
        // Update an existing one
        // TODO: make a separate class Sampler
        last[2] = Math.max(tick, last[2]);
        last[3] = Math.min(tick, last[3]);
        last[4] = tick;
        last[5] += volume;
        this.agg.push('ohlcv', last, tf);
      }

      this.update_overlays(data, t, tf);
      return t >= t_next;
    } // Updates all overlays with given values.

  }, {
    key: "update_overlays",
    value: function update_overlays(data, t, tf) {
      for (var k in data) {
        if (k === 'price' || k === 'volume' || k === 'candle' || k === 't') {
          continue;
        }

        if (k.includes('datasets.')) {
          this.agg.push(k, data[k], tf);
          continue;
        }

        if (!Array.isArray(data[k])) {
          var val = [data[k]];
        } else {
          val = data[k];
        }

        if (!k.includes('.data')) k += '.data';
        this.agg.push(k, [t].concat(_toConsumableArray(val)), tf);
      }
    } // Returns array of objects matching query.
    // Object contains { parent, index, value }
    // TODO: query caching

  }, {
    key: "get_by_query",
    value: function get_by_query(query, chuck) {
      var tuple = query.split('.');

      switch (tuple[0]) {
        case 'chart':
          var result = this.chart_as_piv(tuple);
          break;

        case 'onchart':
        case 'offchart':
          result = this.query_search(query, tuple);
          break;

        case 'datasets':
          result = this.query_search(query, tuple);

          var _iterator4 = dc_core_createForOfIteratorHelper(result),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var r = _step4.value;

              if (r.i === 'data') {
                r.v = this.dss[r.p.id].data();
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          break;

        default:
          /* Should get('.') return also the chart? */

          /*let ch = this.chart_as_query([
              'chart',
              tuple[1]
          ])*/
          var on = this.query_search(query, ['onchart', tuple[0], tuple[1]]);
          var off = this.query_search(query, ['offchart', tuple[0], tuple[1]]);
          result = [].concat(_toConsumableArray(on), _toConsumableArray(off));
          break;
      }

      return result.filter(function (x) {
        return !(x.v || {}).locked || chuck;
      });
    }
  }, {
    key: "chart_as_piv",
    value: function chart_as_piv(tuple) {
      var field = tuple[1];
      if (field) return [{
        p: this.data.chart,
        i: field,
        v: this.data.chart[field]
      }];else return [{
        p: this.data,
        i: 'chart',
        v: this.data.chart
      }];
    }
  }, {
    key: "query_search",
    value: function query_search(query, tuple) {
      var _this3 = this;

      var side = tuple[0];
      var path = tuple[1] || '';
      var field = tuple[2];
      var arr = this.data[side].filter(function (x) {
        return x.id === query || x.id && x.id.includes(path) || x.name === query || x.name && x.name.includes(path) || query.includes((x.settings || {}).$uuid);
      });

      if (field) {
        return arr.map(function (x) {
          return {
            p: x,
            i: field,
            v: x[field]
          };
        });
      }

      return arr.map(function (x, i) {
        return {
          p: _this3.data[side],
          i: _this3.data[side].indexOf(x),
          v: x
        };
      });
    }
  }, {
    key: "merge_objects",
    value: function merge_objects(obj, data, new_obj) {
      if (new_obj === void 0) {
        new_obj = {};
      }

      // The only way to get Vue to update all stuff
      // reactively is to create a brand new object.
      // TODO: Is there a simpler approach?
      Object.assign(new_obj, obj.v);
      Object.assign(new_obj, data);
      this.tv.$set(obj.p, obj.i, new_obj);
    } // Merge overlapping time series

  }, {
    key: "merge_ts",
    value: function merge_ts(obj, data) {
      // Assume that both arrays are pre-sorted
      if (!data.length) return obj.v;
      var r1 = [obj.v[0][0], obj.v[obj.v.length - 1][0]];
      var r2 = [data[0][0], data[data.length - 1][0]]; // Overlap

      var o = [Math.max(r1[0], r2[0]), Math.min(r1[1], r2[1])];

      if (o[1] >= o[0]) {
        var _obj$v, _data;

        var _this$ts_overlap = this.ts_overlap(obj.v, data, o),
            od = _this$ts_overlap.od,
            d1 = _this$ts_overlap.d1,
            d2 = _this$ts_overlap.d2;

        (_obj$v = obj.v).splice.apply(_obj$v, _toConsumableArray(d1));

        (_data = data).splice.apply(_data, _toConsumableArray(d2)); // Dst === Overlap === Src


        if (!obj.v.length && !data.length) {
          this.tv.$set(obj.p, obj.i, od);
          return obj.v;
        } // If src is totally contained in dst


        if (!data.length) {
          data = obj.v.splice(d1[0]);
        } // If dst is totally contained in src


        if (!obj.v.length) {
          obj.v = data.splice(d2[0]);
        }

        this.tv.$set(obj.p, obj.i, this.combine(obj.v, od, data));
      } else {
        this.tv.$set(obj.p, obj.i, this.combine(obj.v, [], data));
      }

      return obj.v;
    } // TODO: review performance, move to worker

  }, {
    key: "ts_overlap",
    value: function ts_overlap(arr1, arr2, range) {
      var t1 = range[0];
      var t2 = range[1];
      var ts = {}; // timestamp map

      var a1 = arr1.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      });
      var a2 = arr2.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }); // Indices of segments

      var id11 = arr1.indexOf(a1[0]);
      var id12 = arr1.indexOf(a1[a1.length - 1]);
      var id21 = arr2.indexOf(a2[0]);
      var id22 = arr2.indexOf(a2[a2.length - 1]);

      for (var i = 0; i < a1.length; i++) {
        ts[a1[i][0]] = a1[i];
      }

      for (var i = 0; i < a2.length; i++) {
        ts[a2[i][0]] = a2[i];
      }

      var ts_sorted = Object.keys(ts).sort();
      return {
        od: ts_sorted.map(function (x) {
          return ts[x];
        }),
        d1: [id11, id12 - id11 + 1],
        d2: [id21, id22 - id21 + 1]
      };
    } // Combine parts together:
    // (destination, overlap, source)

  }, {
    key: "combine",
    value: function combine(dst, o, src) {
      function last(arr) {
        return arr[arr.length - 1][0];
      }

      if (!dst.length) {
        dst = o;
        o = [];
      }

      if (!src.length) {
        src = o;
        o = [];
      } // The overlap right in the middle


      if (src[0][0] >= dst[0][0] && last(src) <= last(dst)) {
        return Object.assign(dst, o); // The overlap is on the right
      } else if (last(src) > last(dst)) {
        // Psh(...) is faster but can overflow the stack
        if (o.length < 100000 && src.length < 100000) {
          var _dst;

          (_dst = dst).push.apply(_dst, _toConsumableArray(o).concat(_toConsumableArray(src)));

          return dst;
        } else {
          return dst.concat(o, src);
        } // The overlap is on the left

      } else if (src[0][0] < dst[0][0]) {
        // Push(...) is faster but can overflow the stack
        if (o.length < 100000 && src.length < 100000) {
          var _src;

          (_src = src).push.apply(_src, _toConsumableArray(o).concat(_toConsumableArray(dst)));

          return src;
        } else {
          return src.concat(o, dst);
        }
      } else {
        return [];
      }
    } // Simple data-point merge (faster)

  }, {
    key: "fast_merge",
    value: function fast_merge(data, point, main) {
      if (main === void 0) {
        main = true;
      }

      if (!data) return;
      var last_t = (data[data.length - 1] || [])[0];
      var upd_t = point[0];

      if (!data.length || upd_t > last_t) {
        data.push(point);

        if (main && this.sett.auto_scroll) {
          this.scroll_to(upd_t);
        }
      } else if (upd_t === last_t) {
        if (main) {
          this.tv.$set(data, data.length - 1, point);
        } else {
          data[data.length - 1] = point;
        }
      }
    }
  }, {
    key: "scroll_to",
    value: function scroll_to(t) {
      if (this.tv.$refs.chart.cursor.locked) return;
      var last = this.tv.$refs.chart.last_candle;
      if (!last) return;
      var tl = last[0];
      var d = this.tv.getRange()[1] - tl;
      if (d > 0) this.tv["goto"](t + d);
    }
  }]);

  return DCCore;
}(DCEvents);


;// CONCATENATED MODULE: ./src/helpers/sett_proxy.js
// Sends all dc.sett changes to the web-worker
/* harmony default export */ function sett_proxy(sett, ww) {
  var h = {
    get: function get(sett, k) {
      return sett[k];
    },
    set: function set(sett, k, v) {
      sett[k] = v;
      ww.just('update-dc-settings', sett);
      return true;
    }
  };
  ww.just('update-dc-settings', sett);
  return new Proxy(sett, h);
}
;// CONCATENATED MODULE: ./src/helpers/agg_tool.js


// Tick aggregation


var AggTool = /*#__PURE__*/function () {
  function AggTool(dc, _int) {
    if (_int === void 0) {
      _int = 100;
    }

    classCallCheck_classCallCheck(this, AggTool);

    this.symbols = {};
    this["int"] = _int; // Itarval in ms

    this.dc = dc;
    this.st_id = null;
    this.data_changed = false;
  }

  createClass_createClass(AggTool, [{
    key: "push",
    value: function push(sym, upd, tf) {
      var _this = this;

      // Start auto updates
      if (!this.st_id) {
        this.st_id = setTimeout(function () {
          return _this.update();
        });
      }

      tf = parseInt(tf);
      var old = this.symbols[sym];
      var t = utils.now();
      var isds = sym.includes('datasets.');
      this.data_changed = true;

      if (!old) {
        this.symbols[sym] = {
          upd: upd,
          t: t,
          data: []
        };
      } else if (upd[0] >= old.upd[0] + tf && !isds) {
        // Refine the previous data point
        this.refine(sym, old.upd.slice());
        this.symbols[sym] = {
          upd: upd,
          t: t,
          data: []
        };
      } else {
        // Tick updates the current
        this.symbols[sym].upd = upd;
        this.symbols[sym].t = t;
      }

      if (isds) {
        this.symbols[sym].data.push(upd);
      }
    }
  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      var out = {};

      for (var sym in this.symbols) {
        var upd = this.symbols[sym].upd;

        switch (sym) {
          case 'ohlcv':
            var data = this.dc.data.chart.data;
            this.dc.fast_merge(data, upd);
            out.ohlcv = data.slice(-2);
            break;

          default:
            if (sym.includes('datasets.')) {
              this.update_ds(sym, out);
              continue;
            }

            var data = this.dc.get_one("".concat(sym));
            if (!data) continue;
            this.dc.fast_merge(data, upd, false);
            break;
        }
      } // TODO: fill gaps


      if (this.data_changed) {
        this.dc.ww.just('update-data', out);
        this.data_changed = false;
      }

      setTimeout(function () {
        return _this2.update();
      }, this["int"]);
    }
  }, {
    key: "refine",
    value: function refine(sym, upd) {
      if (sym === 'ohlcv') {
        var data = this.dc.data.chart.data;
        this.dc.fast_merge(data, upd);
      } else {
        var data = this.dc.get_one("".concat(sym));
        if (!data) return;
        this.dc.fast_merge(data, upd, false);
      }
    }
  }, {
    key: "update_ds",
    value: function update_ds(sym, out) {
      var data = this.symbols[sym].data;

      if (data.length) {
        out[sym] = data;
        this.symbols[sym].data = [];
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.symbols = {};
    }
  }]);

  return AggTool;
}();


;// CONCATENATED MODULE: ./src/helpers/datacube.js








function datacube_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = datacube_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function datacube_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return datacube_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return datacube_arrayLikeToArray(o, minLen); }

function datacube_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function datacube_createSuper(Derived) { var hasNativeReflectConstruct = datacube_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function datacube_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Main DataHelper class. A container for data,
// which works as a proxy and CRUD interface



 // Interface methods. Private methods in dc_core.js

var DataCube = /*#__PURE__*/function (_DCCore) {
  _inherits(DataCube, _DCCore);

  var _super = datacube_createSuper(DataCube);

  function DataCube(data, sett) {
    var _this;

    if (data === void 0) {
      data = {};
    }

    if (sett === void 0) {
      sett = {};
    }

    classCallCheck_classCallCheck(this, DataCube);

    var def_sett = {
      aggregation: 100,
      // Update aggregation interval
      script_depth: 0,
      // 0 === Exec on all data
      auto_scroll: true,
      // Auto scroll to a new candle
      scripts: true,
      // Enable overlays scripts,
      ww_ram_limit: 0,
      // WebWorker RAM limit (MB)
      node_url: null,
      // Use node.js instead of WW
      shift_measure: true // Draw measurment shift+click

    };
    sett = Object.assign(def_sett, sett);
    _this = _super.call(this);
    _this.sett = sett;
    _this.data = data;
    _this.sett = sett_proxy(sett, _this.ww);
    _this.agg = new AggTool(_assertThisInitialized(_this), sett.aggregation);
    _this.se_state = {}; //this.agg.update = this.agg_update.bind(this)

    return _this;
  } // Add new overlay


  createClass_createClass(DataCube, [{
    key: "add",
    value: function add(side, overlay) {
      if (side !== 'onchart' && side !== 'offchart' && side !== 'datasets') {
        return;
      }

      this.data[side].push(overlay);
      this.update_ids();
      return overlay.id;
    } // Get all objects matching the query

  }, {
    key: "get",
    value: function get(query) {
      return this.get_by_query(query).map(function (x) {
        return x.v;
      });
    } // Get first object matching the query

  }, {
    key: "get_one",
    value: function get_one(query) {
      return this.get_by_query(query).map(function (x) {
        return x.v;
      })[0];
    } // Set data (reactively)

  }, {
    key: "set",
    value: function set(query, data) {
      var objects = this.get_by_query(query);

      var _iterator = datacube_createForOfIteratorHelper(objects),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var obj = _step.value;
          var i = obj.i !== undefined ? obj.i : obj.p.indexOf(obj.v);

          if (i !== -1) {
            this.tv.$set(obj.p, i, data);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.update_ids();
    } // Merge object or array (reactively)

  }, {
    key: "merge",
    value: function merge(query, data) {
      var objects = this.get_by_query(query);

      var _iterator2 = datacube_createForOfIteratorHelper(objects),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var obj = _step2.value;

          if (Array.isArray(obj.v)) {
            if (!Array.isArray(data)) continue; // If array is a timeseries, merge it by timestamp
            // else merge by item index

            if (obj.v[0] && obj.v[0].length >= 2) {
              this.merge_ts(obj, data);
            } else {
              this.merge_objects(obj, data, []);
            }
          } else if (typeof_typeof(obj.v) === 'object') {
            this.merge_objects(obj, data);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.update_ids();
    } // Remove an overlay by query (id/type/name/...)

  }, {
    key: "del",
    value: function del(query) {
      var objects = this.get_by_query(query);

      var _iterator3 = datacube_createForOfIteratorHelper(objects),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var obj = _step3.value;
          // Find current index of the field (if not defined)
          var i = typeof obj.i !== 'number' ? obj.i : obj.p.indexOf(obj.v);

          if (i !== -1) {
            this.tv.$delete(obj.p, i);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.update_ids();
    } // Update/append data point, depending on timestamp

  }, {
    key: "update",
    value: function update(data) {
      if (data['candle']) {
        return this.update_candle(data);
      } else {
        return this.update_tick(data);
      }
    } // Lock overlays from being pulled by query_search
    // TODO: subject to review

  }, {
    key: "lock",
    value: function lock(query) {
      var objects = this.get_by_query(query);
      objects.forEach(function (x) {
        if (x.v && x.v.id && x.v.type) {
          x.v.locked = true;
        }
      });
    } // Unlock overlays from being pulled by query_search
    //

  }, {
    key: "unlock",
    value: function unlock(query) {
      var objects = this.get_by_query(query, true);
      objects.forEach(function (x) {
        if (x.v && x.v.id && x.v.type) {
          x.v.locked = false;
        }
      });
    } // Show indicator

  }, {
    key: "show",
    value: function show(query) {
      if (query === 'offchart' || query === 'onchart') {
        query += '.';
      } else if (query === '.') {
        query = '';
      }

      this.merge(query + '.settings', {
        display: true
      });
    } // Hide indicator

  }, {
    key: "hide",
    value: function hide(query) {
      if (query === 'offchart' || query === 'onchart') {
        query += '.';
      } else if (query === '.') {
        query = '';
      }

      this.merge(query + '.settings', {
        display: false
      });
    } // Set data loader callback

  }, {
    key: "onrange",
    value: function onrange(callback) {
      var _this2 = this;

      this.loader = callback;
      setTimeout(function () {
        return _this2.tv.set_loader(callback ? _this2 : null);
      }, 0);
    }
  }]);

  return DataCube;
}(DCCore);


;// CONCATENATED MODULE: ./src/mixins/interface.js
// Html interface, shown on top of the grid.
// Can be static (a tooltip) or interactive,
// e.g. a control panel.
/* harmony default export */ const mixins_interface = ({
  props: ['ux', 'updater', 'colors', 'wrapper'],
  mounted: function mounted() {
    this._$emit = this.$emit;
    this.$emit = this.custom_event;
    if (this.init) this.init();
  },
  methods: {
    close: function close() {
      this.$emit('custom-event', {
        event: 'close-interface',
        args: [this.$props.ux.uuid]
      });
    },
    // TODO: emit all the way to the uxlist
    // add apply the changes there
    modify: function modify(obj) {
      this.$emit('custom-event', {
        event: 'modify-interface',
        args: [this.$props.ux.uuid, obj]
      });
    },
    custom_event: function custom_event(event) {
      if (event.split(':')[0] === 'hook') return;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this._$emit('custom-event', {
        event: event,
        args: args
      });
    }
  },
  computed: {
    overlay: function overlay() {
      return this.$props.ux.overlay;
    },
    layout: function layout() {
      return this.overlay.layout;
    },
    uxr: function uxr() {
      return this.$props.ux;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/index.js















var primitives = {
  Candle: CandleExt,
  Volbar: VolbarExt,
  Line: Line,
  Pin: Pin,
  Price: Price,
  Ray: Ray,
  Seg: Seg
};

TradingVue.install = function (Vue) {
  Vue.component(TradingVue.name, TradingVue);
};

if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(TradingVue);
  window.TradingVueLib = {
    TradingVue: TradingVue,
    Overlay: overlay,
    Utils: utils,
    Constants: constants,
    Candle: CandleExt,
    Volbar: VolbarExt,
    layout_cnv: layout_cnv,
    layout_vol: layout_vol,
    DataCube: DataCube,
    Tool: tool,
    Interface: mixins_interface,
    primitives: primitives
  };
}

/* harmony default export */ const src = (TradingVue);


/***/ }),

/***/ 418:
/***/ ((module, exports, __nested_webpack_require_449538__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_449538__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* Anit-boostrap tactix */\n.trading-vue *, ::after, ::before {\n    box-sizing: content-box;\n}\n.trading-vue img {\n    vertical-align: initial;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 976:
/***/ ((module, exports, __nested_webpack_require_450696__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_450696__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-botbar {\n    position: relative !important;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 449:
/***/ ((module, exports, __nested_webpack_require_451035__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_451035__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.t-vue-lbtn-grp {\n    margin-left: 0.5em;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 108:
/***/ ((module, exports, __nested_webpack_require_451359__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_451359__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-item-list {\n    position: absolute;\n    user-select: none;\n    margin-top: -5px;\n}\n.tvjs-item-list-item {\n    display: flex;\n    align-items: center;\n    padding-right: 20px;\n    font-size: 1.15em;\n    letter-spacing: 0.05em;\n}\n.tvjs-item-list-item:hover {\n    background-color: #76878319;\n}\n.tvjs-item-list-item * {\n    position: relative !important;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 988:
/***/ ((module, exports, __nested_webpack_require_452014__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_452014__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-legend {\n    position: relative;\n    z-index: 100;\n    font-size: 1.25em;\n    margin-left: 10px;\n    pointer-events: none;\n    text-align: left;\n    user-select: none;\n    font-weight: 300;\n}\n@media (min-resolution: 2x) {\n.trading-vue-legend {\n        font-weight: 400;\n}\n}\n.trading-vue-ohlcv {\n    pointer-events: none;\n    margin-bottom: 0.5em;\n}\n.t-vue-lspan {\n    font-variant-numeric: tabular-nums;\n    font-size: 0.95em;\n    color: #999999; /* TODO: move => params */\n    margin-left: 0.1em;\n    margin-right: 0.2em;\n}\n.t-vue-title {\n    margin-right: 0.25em;\n    font-size: 1.45em;\n}\n.t-vue-ind {\n    margin-left: 0.2em;\n    margin-bottom: 0.5em;\n    font-size: 1.0em;\n    margin-top: 0.3em;\n}\n.t-vue-ivalue {\n    margin-left: 0.5em;\n}\n.t-vue-unknown {\n    color: #999999; /* TODO: move => params */\n}\n.tvjs-appear-enter-active,\n.tvjs-appear-leave-active\n{\n    transition: all .25s ease;\n}\n.tvjs-appear-enter, .tvjs-appear-leave-to\n{\n    opacity: 0;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 423:
/***/ ((module, exports, __nested_webpack_require_453314__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_453314__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.t-vue-lbtn {\n    z-index: 100;\n    pointer-events: all;\n    cursor: pointer;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 661:
/***/ ((module, exports, __nested_webpack_require_453676__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_453676__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-section {\n    height: 0;\n    position: absolute;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 168:
/***/ ((module, exports, __nested_webpack_require_454021__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_454021__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-spinner {\n    display: inline-block;\n    position: relative;\n    width: 20px;\n    height: 16px;\n    margin: -4px 0px -1px 0px;\n    opacity: 0.7;\n}\n.tvjs-spinner div {\n    position: absolute;\n    top: 8px;\n    width: 4px;\n    height: 4px;\n    border-radius: 50%;\n    animation-timing-function: cubic-bezier(1, 1, 1, 1);\n}\n.tvjs-spinner div:nth-child(1) {\n    left: 2px;\n    animation: tvjs-spinner1 0.6s infinite;\n    opacity: 0.9;\n}\n.tvjs-spinner div:nth-child(2) {\n    left: 2px;\n    animation: tvjs-spinner2 0.6s infinite;\n}\n.tvjs-spinner div:nth-child(3) {\n    left: 9px;\n    animation: tvjs-spinner2 0.6s infinite;\n}\n.tvjs-spinner div:nth-child(4) {\n    left: 16px;\n    animation: tvjs-spinner3 0.6s infinite;\n    opacity: 0.9;\n}\n@keyframes tvjs-spinner1 {\n0% {\n        transform: scale(0);\n}\n100% {\n        transform: scale(1);\n}\n}\n@keyframes tvjs-spinner3 {\n0% {\n        transform: scale(1);\n}\n100% {\n        transform: scale(0);\n}\n}\n@keyframes tvjs-spinner2 {\n0% {\n        transform: translate(0, 0);\n}\n100% {\n        transform: translate(7px, 0);\n}\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 29:
/***/ ((module, exports, __nested_webpack_require_455420__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_455420__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-drift-enter-active {\n    transition: all .3s ease;\n}\n.tvjs-drift-leave-active {\n    transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.tvjs-drift-enter, .tvjs-drift-leave-to\n{\n    transform: translateX(10px);\n    opacity: 0;\n}\n.tvjs-the-tip {\n    position: absolute;\n    width: 200px;\n    text-align: center;\n    z-index: 10001;\n    color: #ffffff;\n    font-size: 1.5em;\n    line-height: 1.15em;\n    padding: 10px;\n    border-radius: 3px;\n    right: 70px;\n    top: 10px;\n    text-shadow: 1px 1px black;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 935:
/***/ ((module, exports, __nested_webpack_require_456239__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_456239__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-toolbar {\n    position: absolute;\n    border-right: 1px solid black;\n    z-index: 101;\n    padding-top: 3px;\n    user-select: none;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 379:
/***/ ((module, exports, __nested_webpack_require_456670__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_456670__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-tbitem {\n}\n.trading-vue-tbitem:hover {\n    background-color: #76878319;\n}\n.trading-vue-tbitem-exp {\n    position: absolute;\n    right: -3px;\n    padding: 18.5px 5px;\n    font-stretch: extra-condensed;\n    transform: scaleX(0.6);\n    font-size: 0.6em;\n    opacity: 0.0;\n    user-select: none;\n    line-height: 0;\n}\n.trading-vue-tbitem:hover\n.trading-vue-tbitem-exp {\n    opacity: 0.5;\n}\n.trading-vue-tbitem-exp:hover {\n    background-color: #76878330;\n    opacity: 0.9 !important;\n}\n.trading-vue-tbicon {\n    position: absolute;\n}\n.trading-vue-tbitem.selected-item > .trading-vue-tbicon,\n.tvjs-item-list-item.selected-item > .trading-vue-tbicon {\n     filter: brightness(1.45) sepia(1) hue-rotate(90deg) saturate(4.5) !important;\n}\n.tvjs-pixelated {\n    -ms-interpolation-mode: nearest-neighbor;\n    image-rendering: -webkit-optimize-contrast;\n    image-rendering: -webkit-crisp-edges;\n    image-rendering: -moz-crisp-edges;\n    image-rendering: -o-crisp-edges;\n    image-rendering: pixelated;\n}\n\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 72:
/***/ ((module, exports, __nested_webpack_require_457995__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_457995__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-ux-wrapper {\n    position: absolute;\n    display: flex;\n}\n.tvjs-ux-wrapper-pin {\n    position: absolute;\n    width: 9px;\n    height: 9px;\n    z-index: 100;\n    background-color: #23a776;\n    border-radius: 10px;\n    margin-left: -6px;\n    margin-top: -6px;\n    pointer-events: none;\n}\n.tvjs-ux-wrapper-head {\n    position: absolute;\n    height: 23px;\n    width: 100%;\n}\n.tvjs-ux-wrapper-close {\n    position: absolute;\n    width: 11px;\n    height: 11px;\n    font-size: 1.5em;\n    line-height: 0.5em;\n    padding: 1px 1px 1px 1px;\n    border-radius: 10px;\n    right: 5px;\n    top: 5px;\n    user-select: none;\n    text-align: center;\n    z-index: 100;\n}\n.tvjs-ux-wrapper-close-hb {\n}\n.tvjs-ux-wrapper-close:hover {\n    background-color: #FF605C !important;\n    color: #692324 !important;\n}\n.tvjs-ux-wrapper-full {\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 983:
/***/ ((module, exports, __nested_webpack_require_459141__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_459141__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-widgets {\n    position: absolute;\n    z-index: 1000;\n    pointer-events: none;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 645:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ 840:
/***/ ((module, exports, __nested_webpack_require_462074__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Hammer;
    }).call(exports, __nested_webpack_require_462074__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

})(window, document, 'Hammer');


/***/ }),

/***/ 981:
/***/ ((module) => {

/*
 * Hamster.js v1.1.2
 * (c) 2013 Monospaced http://monospaced.com
 * License: MIT
 */

(function(window, document){
'use strict';

/**
 * Hamster
 * use this to create instances
 * @returns {Hamster.Instance}
 * @constructor
 */
var Hamster = function(element) {
  return new Hamster.Instance(element);
};

// default event name
Hamster.SUPPORT = 'wheel';

// default DOM methods
Hamster.ADD_EVENT = 'addEventListener';
Hamster.REMOVE_EVENT = 'removeEventListener';
Hamster.PREFIX = '';

// until browser inconsistencies have been fixed...
Hamster.READY = false;

Hamster.Instance = function(element){
  if (!Hamster.READY) {
    // fix browser inconsistencies
    Hamster.normalise.browser();

    // Hamster is ready...!
    Hamster.READY = true;
  }

  this.element = element;

  // store attached event handlers
  this.handlers = [];

  // return instance
  return this;
};

/**
 * create new hamster instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @returns {Hamster.Instance}
 * @constructor
 */
Hamster.Instance.prototype = {
  /**
   * bind events to the instance
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   * @returns {Hamster.Instance}
   */
  wheel: function onEvent(handler, useCapture){
    Hamster.event.add(this, Hamster.SUPPORT, handler, useCapture);

    // handle MozMousePixelScroll in older Firefox
    if (Hamster.SUPPORT === 'DOMMouseScroll') {
      Hamster.event.add(this, 'MozMousePixelScroll', handler, useCapture);
    }

    return this;
  },

  /**
   * unbind events to the instance
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   * @returns {Hamster.Instance}
   */
  unwheel: function offEvent(handler, useCapture){
    // if no handler argument,
    // unbind the last bound handler (if exists)
    if (handler === undefined && (handler = this.handlers.slice(-1)[0])) {
      handler = handler.original;
    }

    Hamster.event.remove(this, Hamster.SUPPORT, handler, useCapture);

    // handle MozMousePixelScroll in older Firefox
    if (Hamster.SUPPORT === 'DOMMouseScroll') {
      Hamster.event.remove(this, 'MozMousePixelScroll', handler, useCapture);
    }

    return this;
  }
};

Hamster.event = {
  /**
   * cross-browser 'addWheelListener'
   * @param   {Instance}    hamster
   * @param   {String}      eventName
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   */
  add: function add(hamster, eventName, handler, useCapture){
    // store the original handler
    var originalHandler = handler;

    // redefine the handler
    handler = function(originalEvent){

      if (!originalEvent) {
        originalEvent = window.event;
      }

      // create a normalised event object,
      // and normalise "deltas" of the mouse wheel
      var event = Hamster.normalise.event(originalEvent),
          delta = Hamster.normalise.delta(originalEvent);

      // fire the original handler with normalised arguments
      return originalHandler(event, delta[0], delta[1], delta[2]);

    };

    // cross-browser addEventListener
    hamster.element[Hamster.ADD_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);

    // store original and normalised handlers on the instance
    hamster.handlers.push({
      original: originalHandler,
      normalised: handler
    });
  },

  /**
   * removeWheelListener
   * @param   {Instance}    hamster
   * @param   {String}      eventName
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   */
  remove: function remove(hamster, eventName, handler, useCapture){
    // find the normalised handler on the instance
    var originalHandler = handler,
        lookup = {},
        handlers;
    for (var i = 0, len = hamster.handlers.length; i < len; ++i) {
      lookup[hamster.handlers[i].original] = hamster.handlers[i];
    }
    handlers = lookup[originalHandler];
    handler = handlers.normalised;

    // cross-browser removeEventListener
    hamster.element[Hamster.REMOVE_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);

    // remove original and normalised handlers from the instance
    for (var h in hamster.handlers) {
      if (hamster.handlers[h] == handlers) {
        hamster.handlers.splice(h, 1);
        break;
      }
    }
  }
};

/**
 * these hold the lowest deltas,
 * used to normalise the delta values
 * @type {Number}
 */
var lowestDelta,
    lowestDeltaXY;

Hamster.normalise = {
  /**
   * fix browser inconsistencies
   */
  browser: function normaliseBrowser(){
    // detect deprecated wheel events
    if (!('onwheel' in document || document.documentMode >= 9)) {
      Hamster.SUPPORT = document.onmousewheel !== undefined ?
                        'mousewheel' : // webkit and IE < 9 support at least "mousewheel"
                        'DOMMouseScroll'; // assume remaining browsers are older Firefox
    }

    // detect deprecated event model
    if (!window.addEventListener) {
      // assume IE < 9
      Hamster.ADD_EVENT = 'attachEvent';
      Hamster.REMOVE_EVENT = 'detachEvent';
      Hamster.PREFIX = 'on';
    }

  },

  /**
   * create a normalised event object
   * @param   {Function}    originalEvent
   * @returns {Object}      event
   */
   event: function normaliseEvent(originalEvent){
    var event = {
          // keep a reference to the original event object
          originalEvent: originalEvent,
          target: originalEvent.target || originalEvent.srcElement,
          type: 'wheel',
          deltaMode: originalEvent.type === 'MozMousePixelScroll' ? 0 : 1,
          deltaX: 0,
          deltaZ: 0,
          preventDefault: function(){
            if (originalEvent.preventDefault) {
              originalEvent.preventDefault();
            } else {
              originalEvent.returnValue = false;
            }
          },
          stopPropagation: function(){
            if (originalEvent.stopPropagation) {
              originalEvent.stopPropagation();
            } else {
              originalEvent.cancelBubble = false;
            }
          }
        };

    // calculate deltaY (and deltaX) according to the event

    // 'mousewheel'
    if (originalEvent.wheelDelta) {
      event.deltaY = - 1/40 * originalEvent.wheelDelta;
    }
    // webkit
    if (originalEvent.wheelDeltaX) {
      event.deltaX = - 1/40 * originalEvent.wheelDeltaX;
    }

    // 'DomMouseScroll'
    if (originalEvent.detail) {
      event.deltaY = originalEvent.detail;
    }

    return event;
  },

  /**
   * normalise 'deltas' of the mouse wheel
   * @param   {Function}    originalEvent
   * @returns {Array}       deltas
   */
  delta: function normaliseDelta(originalEvent){
    var delta = 0,
      deltaX = 0,
      deltaY = 0,
      absDelta = 0,
      absDeltaXY = 0,
      fn;

    // normalise deltas according to the event

    // 'wheel' event
    if (originalEvent.deltaY) {
      deltaY = originalEvent.deltaY * -1;
      delta  = deltaY;
    }
    if (originalEvent.deltaX) {
      deltaX = originalEvent.deltaX;
      delta  = deltaX * -1;
    }

    // 'mousewheel' event
    if (originalEvent.wheelDelta) {
      delta = originalEvent.wheelDelta;
    }
    // webkit
    if (originalEvent.wheelDeltaY) {
      deltaY = originalEvent.wheelDeltaY;
    }
    if (originalEvent.wheelDeltaX) {
      deltaX = originalEvent.wheelDeltaX * -1;
    }

    // 'DomMouseScroll' event
    if (originalEvent.detail) {
      delta = originalEvent.detail * -1;
    }

    // Don't return NaN
    if (delta === 0) {
      return [0, 0, 0];
    }

    // look for lowest delta to normalize the delta values
    absDelta = Math.abs(delta);
    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta;
    }
    absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
    if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
      lowestDeltaXY = absDeltaXY;
    }

    // convert deltas to whole numbers
    fn = delta > 0 ? 'floor' : 'ceil';
    delta  = Math[fn](delta / lowestDelta);
    deltaX = Math[fn](deltaX / lowestDeltaXY);
    deltaY = Math[fn](deltaY / lowestDeltaXY);

    return [delta, deltaX, deltaY];
  }
};

if (typeof window.define === 'function' && window.define.amd) {
  // AMD
  window.define('hamster', [], function(){
    return Hamster;
  });
} else if (true) {
  // CommonJS
  module.exports = Hamster;
} else {}

})(window, window.document);


/***/ }),

/***/ 961:
/***/ ((module, exports, __nested_webpack_require_544513__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

// private property
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  compressToBase64 : function (input) {
    if (input == null) return "";
    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
    switch (res.length % 4) { // To produce valid Base64
    default: // When could this happen ?
    case 0 : return res;
    case 1 : return res+"===";
    case 2 : return res+"==";
    case 3 : return res+"=";
    }
  },

  decompressFromBase64 : function (input) {
    if (input == null) return "";
    if (input == "") return null;
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  },

  compressToUTF16 : function (input) {
    if (input == null) return "";
    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  },

  decompressFromUTF16: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  },

  //compress into uint8array (UCS-2 big endian format)
  compressToUint8Array: function (uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      var current_value = compressed.charCodeAt(i);
      buf[i*2] = current_value >>> 8;
      buf[i*2+1] = current_value % 256;
    }
    return buf;
  },

  //decompress from uint8array (UCS-2 big endian format)
  decompressFromUint8Array:function (compressed) {
    if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
    } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

    }

  },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();

if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __nested_webpack_require_544513__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


/***/ }),

/***/ 666:
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
    true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ 863:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_585176__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_585176__(418);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_585176__(346)/* .default */ .Z
var update = add("550b47ab", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 124:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_585736__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_585736__(976);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_585736__(346)/* .default */ .Z
var update = add("1b34bfeb", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 886:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_586296__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_586296__(449);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_586296__(346)/* .default */ .Z
var update = add("9895d3a6", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 807:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_586856__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_586856__(108);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_586856__(346)/* .default */ .Z
var update = add("8139036a", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 600:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_587416__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_587416__(988);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_587416__(346)/* .default */ .Z
var update = add("1db01c0b", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 169:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_587976__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_587976__(423);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_587976__(346)/* .default */ .Z
var update = add("68f243ea", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 11:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_588535__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_588535__(661);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_588535__(346)/* .default */ .Z
var update = add("12d2309d", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 372:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_589095__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_589095__(168);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_589095__(346)/* .default */ .Z
var update = add("5b620605", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 477:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_589655__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_589655__(29);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_589655__(346)/* .default */ .Z
var update = add("143dffab", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 153:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_590214__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_590214__(935);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_590214__(346)/* .default */ .Z
var update = add("f32fd36e", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 501:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_590774__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_590774__(379);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_590774__(346)/* .default */ .Z
var update = add("604bf5ef", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 565:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_591334__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_591334__(72);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_591334__(346)/* .default */ .Z
var update = add("21fde573", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 5:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_591891__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_591891__(983);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_591891__(346)/* .default */ .Z
var update = add("fd83689e", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 346:
/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_592463__) => {

"use strict";

// EXPORTS
__nested_webpack_require_592463__.d(__webpack_exports__, {
  "Z": () => (/* binding */ addStylesClient)
});

;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}

;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_599798__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_599798__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_599798__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__nested_webpack_require_599798__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_599798__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_599798__.o(definition, key) && !__nested_webpack_require_599798__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_599798__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_599798__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module doesn't tell about it's top-level declarations so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_599798__(851);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=trading-vue.js.map

/***/ }),

/***/ "./node_modules/tvjs-overlays/dist/tvjs-overlays.js":
/*!**********************************************************!*\
  !*** ./node_modules/tvjs-overlays/dist/tvjs-overlays.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * TVJS Overlays - v0.5.0 - Fri Jul 09 2021
 *     https://github.com/tvjsx/trading-vue-js
 *     Copyright (c) 2020 c451 Code's All Right;
 *     Licensed under the MIT license
 */
(function webpackUniversalModuleDefinition(root, factory) {
    if (!root['trading-vue-js']) {
        root['trading-vue-js'] = root['TradingVueJs']
    }
	if(true)
		module.exports = factory(__webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js"));
	else {}
})(self, function(__WEBPACK_EXTERNAL_MODULE__954__) {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 954:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__954__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_1194__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_1194__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_1194__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_1194__.o(definition, key) && !__nested_webpack_require_1194__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_1194__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_1194__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
// ESM COMPAT FLAG
__nested_webpack_require_1194__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_1194__.d(__webpack_exports__, {
  "ALMA": () => (/* reexport */ ALMA),
  "ATR": () => (/* reexport */ ATR),
  "ATRp": () => (/* reexport */ ATRp),
  "Area51": () => (/* reexport */ Area51),
  "BB": () => (/* reexport */ BB),
  "BBW": () => (/* reexport */ BBW),
  "CCI": () => (/* reexport */ CCI),
  "CMO": () => (/* reexport */ CMO),
  "COG": () => (/* reexport */ COG),
  "DHistogram": () => (/* reexport */ DHistogram),
  "DMI": () => (/* reexport */ DMI),
  "EMA": () => (/* reexport */ EMA),
  "HMA": () => (/* reexport */ HMA),
  "Histogram": () => (/* reexport */ Histogram),
  "Ichi": () => (/* reexport */ Ichi),
  "Ichimoku": () => (/* reexport */ Ichimoku),
  "KC": () => (/* reexport */ KC),
  "KCW": () => (/* reexport */ KCW),
  "LongShortTrades": () => (/* reexport */ LongShortTrades),
  "MACD": () => (/* reexport */ MACD),
  "MFI": () => (/* reexport */ MFI),
  "MOM": () => (/* reexport */ MOM),
  "Markers": () => (/* reexport */ Markers),
  "PlotCross": () => (/* reexport */ PlotCross),
  "ROC": () => (/* reexport */ ROC),
  "RSI": () => (/* reexport */ RSI),
  "Ribbon": () => (/* reexport */ Ribbon),
  "SAR": () => (/* reexport */ SAR),
  "SMA": () => (/* reexport */ SMA),
  "SWMA": () => (/* reexport */ SWMA),
  "Stoch": () => (/* reexport */ Stoch),
  "TSI": () => (/* reexport */ TSI),
  "TradesPlus": () => (/* reexport */ TradesPlus),
  "VWMA": () => (/* reexport */ VWMA),
  "WilliamsR": () => (/* reexport */ WilliamsR),
  "XOhlcBars": () => (/* reexport */ XOhlcBars),
  "default": () => (/* binding */ index_prod)
});

// EXTERNAL MODULE: external "trading-vue-js"
var external_trading_vue_js_ = __nested_webpack_require_1194__(954);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ALMA/ALMA.vue?vue&type=script&lang=js&

/* harmony default export */ const ALMAvue_type_script_lang_js_ = ({
  name: 'ALMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Arnaud Legoux Moving Average',
        preset: {
          name: 'ALMA $length $offset $sigma',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ALMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          },
          offset: {
            def: 0.9,
            text: 'Offset'
          },
          sigma: {
            def: 5,
            text: 'Sigma'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return alma(close, length, offset, sigma)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ALMA/ALMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const ALMA_ALMAvue_type_script_lang_js_ = (ALMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

;// CONCATENATED MODULE: ./src/overlays/ALMA/ALMA.vue
var render, staticRenderFns
;



/* normalize component */
;
var component = normalizeComponent(
  ALMA_ALMAvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/overlays/ALMA/ALMA.vue"
/* harmony default export */ const ALMA = (component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ATR/ATR.vue?vue&type=script&lang=js&

/* harmony default export */ const ATRvue_type_script_lang_js_ = ({
  name: 'ATR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Average True Range',
        preset: {
          name: 'ATR $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#e52468'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ATR'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return atr(length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ATR/ATR.vue?vue&type=script&lang=js&
 /* harmony default export */ const ATR_ATRvue_type_script_lang_js_ = (ATRvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ATR/ATR.vue
var ATR_render, ATR_staticRenderFns
;



/* normalize component */
;
var ATR_component = normalizeComponent(
  ATR_ATRvue_type_script_lang_js_,
  ATR_render,
  ATR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ATR_api; }
ATR_component.options.__file = "src/overlays/ATR/ATR.vue"
/* harmony default export */ const ATR = (ATR_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ATRp/ATRp.vue?vue&type=script&lang=js&

/* harmony default export */ const ATRpvue_type_script_lang_js_ = ({
  name: 'ATRp',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Average True Range, %',
        preset: {
          name: 'ATR% $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#f44336'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ATRp'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return 100 * atr(length)[0] / close[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ATRp/ATRp.vue?vue&type=script&lang=js&
 /* harmony default export */ const ATRp_ATRpvue_type_script_lang_js_ = (ATRpvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ATRp/ATRp.vue
var ATRp_render, ATRp_staticRenderFns
;



/* normalize component */
;
var ATRp_component = normalizeComponent(
  ATRp_ATRpvue_type_script_lang_js_,
  ATRp_render,
  ATRp_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ATRp_api; }
ATRp_component.options.__file = "src/overlays/ATRp/ATRp.vue"
/* harmony default export */ const ATRp = (ATRp_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Area51/Area51.vue?vue&type=script&lang=js&
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Area51vue_type_script_lang_js_ = ({
  name: 'Area51',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: '👽',
        version: '1.0.0',
        desc: 'Gradient area chart'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var data = this.$props.data;
      var grd = ctx.createLinearGradient(0, 0, 0, layout.height);
      grd.addColorStop(0, this.back1);
      grd.addColorStop(1, this.back2); // Line

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      var _iterator = _createForOfIteratorHelper(data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[1]);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke(); // Area

      ctx.fillStyle = grd;
      ctx.beginPath();
      var p0 = (data[0] || [])[0];
      var pN = (data[data.length - 1] || [])[0];
      ctx.lineTo(layout.t2screen(p0), layout.height);

      var _iterator2 = _createForOfIteratorHelper(data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[1]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.lineTo(layout.t2screen(pN), layout.height);
      ctx.fill();
    },
    use_for: function use_for() {
      return ['Area51'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 1.25;
    },
    color: function color() {
      return this.sett.color || '#2fd68f';
    },
    back1: function back1() {
      return this.sett.back1 || this.color + '15';
    },
    back2: function back2() {
      return this.sett.back2 || this.color + '01';
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/overlays/Area51/Area51.vue?vue&type=script&lang=js&
 /* harmony default export */ const Area51_Area51vue_type_script_lang_js_ = (Area51vue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Area51/Area51.vue
var Area51_render, Area51_staticRenderFns
;



/* normalize component */
;
var Area51_component = normalizeComponent(
  Area51_Area51vue_type_script_lang_js_,
  Area51_render,
  Area51_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Area51_api; }
Area51_component.options.__file = "src/overlays/Area51/Area51.vue"
/* harmony default export */ const Area51 = (Area51_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/BB/BB.vue?vue&type=script&lang=js&

/* harmony default export */ const BBvue_type_script_lang_js_ = ({
  name: 'BB',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Bollinger Bands',
        preset: {
          name: 'BB $length $stddev',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#2cc6c9ab',
            showMid: true,
            backColor: '#2cc6c90a'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['BB'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          },
          stddev: {
            def: 2,
            text: 'StdDev'
          }
        },
        conf: {
          renderer: 'Channel'
        },
        update: "\n                    let [m, h, l] = bb(close, length, stddev)\n                    return [h[0], m[0], l[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/BB/BB.vue?vue&type=script&lang=js&
 /* harmony default export */ const BB_BBvue_type_script_lang_js_ = (BBvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/BB/BB.vue
var BB_render, BB_staticRenderFns
;



/* normalize component */
;
var BB_component = normalizeComponent(
  BB_BBvue_type_script_lang_js_,
  BB_render,
  BB_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var BB_api; }
BB_component.options.__file = "src/overlays/BB/BB.vue"
/* harmony default export */ const BB = (BB_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/BBW/BBW.vue?vue&type=script&lang=js&

/* harmony default export */ const BBWvue_type_script_lang_js_ = ({
  name: 'BBW',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Bollinger Bands Width',
        preset: {
          name: 'BBW $length $stddev',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#2cc6c9ab'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['BBW'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          },
          stddev: {
            def: 2,
            text: 'StdDev'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return bbw(close, length, stddev)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/BBW/BBW.vue?vue&type=script&lang=js&
 /* harmony default export */ const BBW_BBWvue_type_script_lang_js_ = (BBWvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/BBW/BBW.vue
var BBW_render, BBW_staticRenderFns
;



/* normalize component */
;
var BBW_component = normalizeComponent(
  BBW_BBWvue_type_script_lang_js_,
  BBW_render,
  BBW_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var BBW_api; }
BBW_component.options.__file = "src/overlays/BBW/BBW.vue"
/* harmony default export */ const BBW = (BBW_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/CCI/CCI.vue?vue&type=script&lang=js&

/* harmony default export */ const CCIvue_type_script_lang_js_ = ({
  name: 'CCI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Commodity Channel Index',
        preset: {
          name: 'CCI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#e28a3dee',
            backColor: '#e28a3d11',
            bandColor: '#aaaaaa',
            upper: 100,
            lower: -100
          }
        }
      };
    },
    use_for: function use_for() {
      return ['CCI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "return cci(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/CCI/CCI.vue?vue&type=script&lang=js&
 /* harmony default export */ const CCI_CCIvue_type_script_lang_js_ = (CCIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/CCI/CCI.vue
var CCI_render, CCI_staticRenderFns
;



/* normalize component */
;
var CCI_component = normalizeComponent(
  CCI_CCIvue_type_script_lang_js_,
  CCI_render,
  CCI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var CCI_api; }
CCI_component.options.__file = "src/overlays/CCI/CCI.vue"
/* harmony default export */ const CCI = (CCI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/CMO/CMO.vue?vue&type=script&lang=js&

/* harmony default export */ const CMOvue_type_script_lang_js_ = ({
  name: 'CMO',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Chande Momentum Oscillator',
        preset: {
          name: 'CMO $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['CMO'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "return cmo(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/CMO/CMO.vue?vue&type=script&lang=js&
 /* harmony default export */ const CMO_CMOvue_type_script_lang_js_ = (CMOvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/CMO/CMO.vue
var CMO_render, CMO_staticRenderFns
;



/* normalize component */
;
var CMO_component = normalizeComponent(
  CMO_CMOvue_type_script_lang_js_,
  CMO_render,
  CMO_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var CMO_api; }
CMO_component.options.__file = "src/overlays/CMO/CMO.vue"
/* harmony default export */ const CMO = (CMO_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/COG/COG.vue?vue&type=script&lang=js&

/* harmony default export */ const COGvue_type_script_lang_js_ = ({
  name: 'COG',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Center of Gravity',
        preset: {
          name: 'COG $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['COG'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "return cog(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/COG/COG.vue?vue&type=script&lang=js&
 /* harmony default export */ const COG_COGvue_type_script_lang_js_ = (COGvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/COG/COG.vue
var COG_render, COG_staticRenderFns
;



/* normalize component */
;
var COG_component = normalizeComponent(
  COG_COGvue_type_script_lang_js_,
  COG_render,
  COG_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var COG_api; }
COG_component.options.__file = "src/overlays/COG/COG.vue"
/* harmony default export */ const COG = (COG_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/DHistogram/DHistogram.vue?vue&type=script&lang=js&
function DHistogramvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = DHistogramvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function DHistogramvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return DHistogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return DHistogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function DHistogramvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const DHistogramvue_type_script_lang_js_ = ({
  name: "DHistogram",
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: "Acid3croco",
        version: "1.0.0",
        desc: "Double Histogram Plot",
        preset: {
          name: "DHistogram",
          side: "offchart",
          settings: {
            histWidth: 4,
            thresholdSize: 0,
            posColor: "#35a776",
            negColor: "#e54150"
          }
        }
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.hist_width;
      ctx.strokeStyle = this.color;
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.hist_width % 2 ? 0 : 0.5; // Color changed

      var changed = false;

      var _iterator = DHistogramvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var pos_value = p[1];
          var neg_value = p[2];
          var x = layout.t2screen(p[0]) - off;
          var y1 = layout.$2screen(pos_value) - 0.5;
          var y2 = layout.$2screen(neg_value) - 0.5;

          if (pos_value > this.threshold_size) {
            ctx.strokeStyle = this.pos_color;
            ctx.beginPath();
            ctx.moveTo(x, base);
            ctx.lineTo(x, y1);
            ctx.stroke();
          }

          if (neg_value < -this.threshold_size) {
            ctx.strokeStyle = this.neg_color;
            ctx.beginPath();
            ctx.moveTo(x, base);
            ctx.lineTo(x, y2);
            ctx.stroke();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ["DHistogram"];
    },
    legend: function legend(values) {
      var xs = values.slice(1, 3).map(function (x) {
        return x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      });
      return [{
        value: xs[0],
        color: this.pos_color
      }, {
        value: xs[1],
        color: this.neg_color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    hist_width: function hist_width() {
      return this.sett.histWidth || 4;
    },
    threshold_size: function threshold_size() {
      return this.sett.thresholdSize || 0;
    },
    pos_color: function pos_color() {
      return this.sett.posColor || "#35a776";
    },
    neg_color: function neg_color() {
      return this.sett.negColor || "#e54150";
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/overlays/DHistogram/DHistogram.vue?vue&type=script&lang=js&
 /* harmony default export */ const DHistogram_DHistogramvue_type_script_lang_js_ = (DHistogramvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/DHistogram/DHistogram.vue
var DHistogram_render, DHistogram_staticRenderFns
;



/* normalize component */
;
var DHistogram_component = normalizeComponent(
  DHistogram_DHistogramvue_type_script_lang_js_,
  DHistogram_render,
  DHistogram_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var DHistogram_api; }
DHistogram_component.options.__file = "src/overlays/DHistogram/DHistogram.vue"
/* harmony default export */ const DHistogram = (DHistogram_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/DMI/DMI.vue?vue&type=script&lang=js&

/* harmony default export */ const DMIvue_type_script_lang_js_ = ({
  name: 'DMI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Directional Movement Index',
        preset: {
          name: 'DMI $length $smooth',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#ef1360", "#3782f2", "#f48709"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['DMI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'DI Length'
          },
          smooth: {
            def: 15,
            text: 'ADX Smothing'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    let [adx, dp, dn] = dmi(length, smooth)\n                    return [adx[0], dp[0], dn[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/DMI/DMI.vue?vue&type=script&lang=js&
 /* harmony default export */ const DMI_DMIvue_type_script_lang_js_ = (DMIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/DMI/DMI.vue
var DMI_render, DMI_staticRenderFns
;



/* normalize component */
;
var DMI_component = normalizeComponent(
  DMI_DMIvue_type_script_lang_js_,
  DMI_render,
  DMI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var DMI_api; }
DMI_component.options.__file = "src/overlays/DMI/DMI.vue"
/* harmony default export */ const DMI = (DMI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/EMA/EMA.vue?vue&type=script&lang=js&

/* harmony default export */ const EMAvue_type_script_lang_js_ = ({
  name: 'EMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Exponential Moving Average',
        preset: {
          name: 'EMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#f7890c'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['EMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 12,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return ema(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/EMA/EMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const EMA_EMAvue_type_script_lang_js_ = (EMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/EMA/EMA.vue
var EMA_render, EMA_staticRenderFns
;



/* normalize component */
;
var EMA_component = normalizeComponent(
  EMA_EMAvue_type_script_lang_js_,
  EMA_render,
  EMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var EMA_api; }
EMA_component.options.__file = "src/overlays/EMA/EMA.vue"
/* harmony default export */ const EMA = (EMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/HMA/HMA.vue?vue&type=script&lang=js&

/* harmony default export */ const HMAvue_type_script_lang_js_ = ({
  name: 'HMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Hull Moving Average',
        preset: {
          name: 'HMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#3af475'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['HMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return hma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/HMA/HMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const HMA_HMAvue_type_script_lang_js_ = (HMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/HMA/HMA.vue
var HMA_render, HMA_staticRenderFns
;



/* normalize component */
;
var HMA_component = normalizeComponent(
  HMA_HMAvue_type_script_lang_js_,
  HMA_render,
  HMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var HMA_api; }
HMA_component.options.__file = "src/overlays/HMA/HMA.vue"
/* harmony default export */ const HMA = (HMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Histogram/Histogram.vue?vue&type=script&lang=js&
function Histogramvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Histogramvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Histogramvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Histogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Histogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Histogramvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Histogramvue_type_script_lang_js_ = ({
  name: 'Histogram',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Histogram plot'
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.line_width % 2 ? 0 : 0.5; // Color changed

      var changed = false;

      var _iterator = Histogramvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - 0.5;
          var _changed = false;

          if (p[2]) {
            if (ctx.strokeStyle !== p[2]) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = p[2];
          } else {
            if (ctx.strokeStyle !== this.color) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = this.color;
          }

          if (_changed) ctx.beginPath();
          ctx.moveTo(x, base);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Histogram'];
    },
    legend: function legend(values) {
      var x = values[1];

      if (typeof x === "number") {
        x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      }

      return [{
        value: x,
        color: values[2] || this.color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 2;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#888888', '#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Histogram/Histogram.vue?vue&type=script&lang=js&
 /* harmony default export */ const Histogram_Histogramvue_type_script_lang_js_ = (Histogramvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Histogram/Histogram.vue
var Histogram_render, Histogram_staticRenderFns
;



/* normalize component */
;
var Histogram_component = normalizeComponent(
  Histogram_Histogramvue_type_script_lang_js_,
  Histogram_render,
  Histogram_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Histogram_api; }
Histogram_component.options.__file = "src/overlays/Histogram/Histogram.vue"
/* harmony default export */ const Histogram = (Histogram_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ichi/Ichi.vue?vue&type=script&lang=js&
// Cloud renderer. (Ichimoku)

/* harmony default export */ const Ichivue_type_script_lang_js_ = ({
  name: 'Ichi',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.0',
        desc: 'Ichimoku Cloud based on scripts'
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;

      for (var i = 0; i < this.$props.data.length - 1; i++) {
        var p1 = this.mapp(this.$props.data[i]);
        var p2 = this.mapp(this.$props.data[i + 1]);
        if (!p2) continue;
        if (p1.y1 !== p1.y1) continue; // Fix NaN
        // Background

        ctx.beginPath();
        ctx.fillStyle = p1.y1 < p1.y2 ? this.back1 : this.back2;
        ctx.moveTo(p1.x, p1.y1);
        ctx.lineTo(p2.x + 0.1, p2.y1);
        ctx.lineTo(p2.x + 0.1, p2.y2);
        ctx.lineTo(p1.x, p1.y2);
        ctx.fill(); // Lines

        if (!this.draw_lines) continue;
        ctx.beginPath();
        ctx.strokeStyle = this.color1;
        ctx.moveTo(p1.x, p1.y1);
        ctx.lineTo(p2.x, p2.y1);
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = this.color2;
        ctx.moveTo(p1.x, p1.y2);
        ctx.lineTo(p2.x, p2.y2);
        ctx.stroke();
      }
    },
    mapp: function mapp(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        y1: layout.$2screen(p[1]),
        y2: layout.$2screen(p[2])
      };
    },
    use_for: function use_for() {
      return ['Ichi'];
    },
    data_colors: function data_colors() {
      return [this.color1, this.color2];
    },
    calc: function calc() {
      return {
        props: {
          CP: {
            def: 9,
            text: 'Conversion Line Length'
          },
          BP: {
            def: 26,
            text: 'Base Line Length'
          },
          LSP: {
            def: 52,
            text: 'Lagging Span 2 Length'
          },
          DIZ: {
            def: 26,
            text: 'Displacement'
          },
          baseColor: {
            def: 'brown',
            text: 'Base Line Color'
          },
          conversionColor: {
            def: 'lightblue',
            text: 'Conversion Line Color'
          },
          laggingColor: {
            def: '#66CC66',
            text: 'Lagging Span Color'
          }
        },
        update: "\n                    let donchian = (len, id) => ts(\n                        avg(lowest(low, len)[0], highest(high, len)[0]), id\n                    )\n                    let conversionLine = donchian(CP, 1)\n                    let baseLine = donchian(BP, 2)\n                    let leadLine1 = ts(avg(conversionLine[0], baseLine[0]))\n                    let leadLine2 = donchian(LSP, 3)\n                    let lagging = ts(close[0])\n\n\n                    offset(this, DIZ - 1)\n                    offset(lagging, -DIZ + 1)\n                    onchart([conversionLine, baseLine], 'Base Lines', {\n                        colors: [conversionColor, baseColor]\n                    })\n                    onchart(lagging, 'Lagging Span', {\n                        color: laggingColor\n                    })\n                    return [leadLine1[0], leadLine2[0]]\n                "
      };
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color1: function color1() {
      return this.sett.color1 || 'lightgreen';
    },
    color2: function color2() {
      return this.sett.color2 || 'orange';
    },
    back1: function back1() {
      return this.sett.back1 || '#79ff9e22';
    },
    back2: function back2() {
      return this.sett.back2 || '#ef535022';
    },
    draw_lines: function draw_lines() {
      return this.sett.drawLines;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ichi/Ichi.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ichi_Ichivue_type_script_lang_js_ = (Ichivue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ichi/Ichi.vue
var Ichi_render, Ichi_staticRenderFns
;



/* normalize component */
;
var Ichi_component = normalizeComponent(
  Ichi_Ichivue_type_script_lang_js_,
  Ichi_render,
  Ichi_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ichi_api; }
Ichi_component.options.__file = "src/overlays/Ichi/Ichi.vue"
/* harmony default export */ const Ichi = (Ichi_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ichimoku/Ichimoku.vue?vue&type=script&lang=js&
function Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Ichimokuvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Ichimokuvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Ichimokuvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ichimokuvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Ichimokuvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//Ichimoku Indicator Overlay. Expected Format: [ <timestamp>, <ConversionLine>, <BaseLine>, <Lead1>, <Lead2>, <Lagging> ]

/* harmony default export */ const Ichimokuvue_type_script_lang_js_ = ({
  name: "Ichimoku",
  mixins: [external_trading_vue_js_.Overlay],
  data: function data() {
    return {
      ctxTenkan: {},
      ctxKijun: {},
      ctxSenkouSpanA: {},
      ctxSenkouSpanB: {},
      ctxChinkou: {},
      ctxFillKumo: {},
      tenkan: [],
      kijun: [],
      senkouSpanA: [],
      senkouSpanB: [],
      chinkou: [],
      offset: 26,
      tenkanLineWidth: 1,
      kijunLineWidth: 1,
      senkouSpanALineWidth: 1,
      senkouSpanBLineWidth: 1,
      chinkouLineWidth: 1,
      colorTenkan: "#52A634",
      colorKijun: "#52A59D",
      colorSenkouSpanA: "#438625",
      colorSenkouSpanB: "#bd003c",
      colorChinkou: "#BF2A64",
      colorKumoUp: "#063f0f",
      colorKumoDown: "#391c19",
      showTenkan: true,
      showKijun: true,
      showSenkouSpanA: true,
      showSenkouSpanB: true,
      showChinkou: true,
      showFillKumo: true
    };
  },
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    tenkan_color: function tenkan_color() {
      return this.sett['tenkan-color'] || this.colorTenkan;
    },
    kijun_color: function kijun_color() {
      return this.sett['kijun-color'] || this.colorKijun;
    },
    senkou_spanA_color: function senkou_spanA_color() {
      return this.sett['senkou_spanA_color'] || this.colorSenkouSpanA;
    },
    senkou_spanB_color: function senkou_spanB_color() {
      return this.sett['senkou_spanB_color'] || this.colorSenkouSpanB;
    },
    chinkou_color: function chinkou_color() {
      return this.sett['chinkou_color'] || this.colorChinkou;
    },
    kumo_up_color: function kumo_up_color() {
      return this.sett['kumo_up_color'] || this.colorKumoUp;
    },
    kumo_down_color: function kumo_down_color() {
      return this.sett['kumo_down_color'] || this.colorKumoDown;
    },
    tenkan_line_width: function tenkan_line_width() {
      return this.sett['tenkan_line_width'] || this.tenkanLineWidth;
    },
    kijun_line_width: function kijun_line_width() {
      return this.sett['kijun_line_width'] || this.kijunLineWidth;
    },
    senkou_spanA_line_width: function senkou_spanA_line_width() {
      return this.sett['senkou_spanA_line_width'] || this.senkouSpanALineWidth;
    },
    senkou_spanB_line_width: function senkou_spanB_line_width() {
      return this.sett['senkou_spanB_line_width'] || this.senkouSpanBLineWidth;
    },
    chinkou_line_width: function chinkou_line_width() {
      return this.sett['chinkou_line_width'] || this.chinkouLineWidth;
    }
  },
  methods: {
    meta_info: function meta_info() {
      return {
        author: "Sudeep Batra",
        version: "1.0.0"
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var propsSub = this.$props.sub;
      this.ctxTenkan = ctx;
      this.ctxKijun = ctx;
      this.ctxSenkouSpanA = ctx;
      this.ctxSenkouSpanB = ctx;
      this.ctxChinkou = ctx;
      this.ctxFillKumo = ctx;
      var subdata = this.$props.data.slice(0, propsSub.length);
      var subdataSenkouSpan = this.$props.data.slice(0, propsSub.length + this.offset);
      var subdataChinkou = this.$props.data.slice(0, propsSub.length - this.offset);

      if (this.showFillKumo) {
        this.ctxFillKumo.beginPath();
        var ind = 0;

        var _iterator = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var currItem = _step.value;

            if (ind > 1) {
              var p1 = this.map_senkou_span_values(subdataSenkouSpan[ind - 1]);
              var p2 = this.map_senkou_span_values(currItem);
              this.ctxSenkouSpanB.beginPath();
              this.ctxSenkouSpanB.moveTo(p1.x, p1.senkouSpanA);
              this.ctxSenkouSpanB.lineTo(p2.x + 0.1, p2.senkouSpanA);
              this.ctxSenkouSpanB.lineTo(p2.x + 0.1, p2.senkouSpanB);
              this.ctxSenkouSpanB.lineTo(p1.x, p1.senkouSpanB);

              if (p1.senkouSpanA >= p1.senkouSpanB) {
                this.ctxSenkouSpanB.fillStyle = this.kumo_down_color;
              } else {
                this.ctxSenkouSpanB.fillStyle = this.kumo_up_color;
              }

              this.ctxSenkouSpanB.fill();
            }

            ind++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.ctxSenkouSpanB.stroke();
      }

      if (this.showTenkan) {
        this.ctxTenkan.beginPath();

        var _iterator2 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdata),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var pTenkan = _step2.value;
            this.ctxTenkan.strokeStyle = this.tenkan_color;
            this.ctxTenkan.lineWidth = this.tenkan_line_width;
            this.ctxTenkan.lineTo(layout.t2screen(pTenkan[0]), layout.$2screen(pTenkan[1]));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        this.ctxTenkan.stroke();
      }

      if (this.showKijun) {
        this.ctxKijun.beginPath();

        var _iterator3 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdata),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var pKijun = _step3.value;
            this.ctxKijun.strokeStyle = this.kijun_color;
            this.ctxKijun.lineWidth = this.kijun_line_width;
            this.ctxKijun.lineTo(layout.t2screen(pKijun[0]), layout.$2screen(pKijun[2]));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        this.ctxKijun.stroke();
      }

      if (this.showSenkouSpanA) {
        this.ctxSenkouSpanA.beginPath();

        var _iterator4 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var pSenkouSpanA = _step4.value;
            this.ctxSenkouSpanA.strokeStyle = this.senkou_spanA_color;
            this.ctxSenkouSpanA.lineWidth = this.senkou_spanA_line_width;
            this.ctxSenkouSpanA.lineTo(layout.t2screen(pSenkouSpanA[0]), layout.$2screen(pSenkouSpanA[3]));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        this.ctxSenkouSpanA.stroke();
      }

      if (this.colorSenkouSpanB) {
        this.ctxSenkouSpanB.beginPath();

        var _iterator5 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var pSenkouSpanB = _step5.value;
            this.ctxSenkouSpanB.strokeStyle = this.senkou_spanB_color;
            this.ctxSenkouSpanB.lineWidth = this.senkou_spanB_line_width;
            this.ctxSenkouSpanB.lineTo(layout.t2screen(pSenkouSpanB[0]), layout.$2screen(pSenkouSpanB[4]));
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        this.ctxSenkouSpanB.stroke();
      }

      if (this.showChinkou) {
        this.ctxChinkou.beginPath();

        var _iterator6 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataChinkou),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var pChikou = _step6.value;
            this.ctxChinkou.strokeStyle = this.chinkou_color;
            this.ctxChinkou.lineWidth = this.chinkou_line_width;
            this.ctxChinkou.lineTo(layout.t2screen(pChikou[0]), layout.$2screen(pChikou[5]));
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        this.ctxChinkou.stroke();
      }
    },
    map_senkou_span_values: function map_senkou_span_values(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        senkouSpanA: layout.$2screen(p[3]),
        senkouSpanB: layout.$2screen(p[4])
      };
    },
    use_for: function use_for() {
      return ["Ichimoku"];
    },
    data_colors: function data_colors() {
      var colors = [];
      colors.push(this.tenkan_color);
      colors.push(this.kijun_color);
      colors.push(this.senkou_spanA_color);
      colors.push(this.senkou_spanB_color);
      colors.push(this.chinkou_color);
      return colors;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ichimoku/Ichimoku.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ichimoku_Ichimokuvue_type_script_lang_js_ = (Ichimokuvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ichimoku/Ichimoku.vue
var Ichimoku_render, Ichimoku_staticRenderFns
;



/* normalize component */
;
var Ichimoku_component = normalizeComponent(
  Ichimoku_Ichimokuvue_type_script_lang_js_,
  Ichimoku_render,
  Ichimoku_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ichimoku_api; }
Ichimoku_component.options.__file = "src/overlays/Ichimoku/Ichimoku.vue"
/* harmony default export */ const Ichimoku = (Ichimoku_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/KC/KC.vue?vue&type=script&lang=js&

/* harmony default export */ const KCvue_type_script_lang_js_ = ({
  name: 'KC',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Keltner Channels',
        preset: {
          name: 'KC $length $mult',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#4c8dffab',
            showMid: true,
            backColor: '#4c8dff0a'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['KC'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          },
          mult: {
            def: 1,
            text: 'Multiplier'
          },
          use_tr: {
            def: true,
            text: 'Use True Range'
          }
        },
        conf: {
          renderer: 'Channel'
        },
        update: "\n                    let [m, h, l] = kc(close, length, mult, use_tr)\n                    return [h[0], m[0], l[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/KC/KC.vue?vue&type=script&lang=js&
 /* harmony default export */ const KC_KCvue_type_script_lang_js_ = (KCvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/KC/KC.vue
var KC_render, KC_staticRenderFns
;



/* normalize component */
;
var KC_component = normalizeComponent(
  KC_KCvue_type_script_lang_js_,
  KC_render,
  KC_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KC_api; }
KC_component.options.__file = "src/overlays/KC/KC.vue"
/* harmony default export */ const KC = (KC_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/KCW/KCW.vue?vue&type=script&lang=js&

/* harmony default export */ const KCWvue_type_script_lang_js_ = ({
  name: 'KCW',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Keltner Channels Width',
        preset: {
          name: 'KCW $length $mult',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#4c8dffab'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['KCW'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          },
          mult: {
            def: 1,
            text: 'Multiplier'
          },
          use_tr: {
            def: true,
            text: 'Use True Range'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return kcw(close, length, mult, use_tr)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/KCW/KCW.vue?vue&type=script&lang=js&
 /* harmony default export */ const KCW_KCWvue_type_script_lang_js_ = (KCWvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/KCW/KCW.vue
var KCW_render, KCW_staticRenderFns
;



/* normalize component */
;
var KCW_component = normalizeComponent(
  KCW_KCWvue_type_script_lang_js_,
  KCW_render,
  KCW_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KCW_api; }
KCW_component.options.__file = "src/overlays/KCW/KCW.vue"
/* harmony default export */ const KCW = (KCW_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/LongShortTrades/LongShortTrades.vue?vue&type=script&lang=js&
function LongShortTradesvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = LongShortTradesvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function LongShortTradesvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LongShortTradesvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LongShortTradesvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function LongShortTradesvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//Long Short Overlay. Expected Format: [ <timestamp>, <Short:0 Long:1 ShortCover: 2 LongCover:3>, <Price Change>, <Percent Price Change>, <Open Price>, <High Price>, <Low Price>, <Close Price> ]

/* harmony default export */ const LongShortTradesvue_type_script_lang_js_ = ({
  name: 'LongShortTrades',
  mixins: [external_trading_vue_js_.Overlay],
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    currency_symbol: function currency_symbol() {
      return this.sett.currency || '₹';
    },
    long_color: function long_color() {
      return this.sett.longColor || '#63df89';
    },
    short_color: function short_color() {
      return this.sett.shortColor || '#ffd581';
    },
    long_cover_color: function long_cover_color() {
      return this.sett.longCoverColor || '#fc7e2f';
    },
    short_cover_color: function short_cover_color() {
      return this.sett.shortCoverColor || '#ff6bd6';
    },
    label_color: function label_color() {
      return '#4BECF9';
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  },
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'Sudeep Batra',
        version: '1.0.1'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';

      var _iterator = LongShortTradesvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var tradeTime = p[0];
          var longShortEntryExit = p[1];
          var priceChange = p[2];
          var percentPriceChange = p[3];
          var openPrice = p[4];
          var highPrice = p[5];
          var lowPrice = p[6];
          var closePrice = p[7];
          var x = layout.t2screen(tradeTime);
          var lowPriceY = layout.$2screen(lowPrice);
          var highPriceY = layout.$2screen(highPrice);

          switch (longShortEntryExit) {
            case 0:
              this.filledArrowDownFilledBottom(ctx, x, highPriceY - 25, 5, 5, 3, 20, this.short_color);
              this.draw_label(ctx, x + 30, highPriceY - 35, this.currency_symbol + closePrice);
              break;

            case 1:
              this.filledArrowUpFilledBottom(ctx, x, lowPriceY + 20, 5, 5, 3, 20, this.long_color);
              this.draw_label(ctx, x + 30, lowPriceY + 40, this.currency_symbol + closePrice);
              break;

            case 2:
              this.upTriangle(ctx, x, lowPriceY + 25, 5, 7, this.short_cover_color);

              if (this.show_label && priceChange) {
                this.draw_label(ctx, x, lowPriceY + 50, priceChange + " (" + percentPriceChange + ")");
              }

              break;

            case 3:
              this.downTriangle(ctx, x, highPriceY - 25, 5, 7, this.long_cover_color);

              if (this.show_label && priceChange) {
                this.draw_label(ctx, x, highPriceY - 45, priceChange + " (" + percentPriceChange + ")");
              }

              break;

            default:
              ctx.fillStyle = 'black';
          } // this.simpleArrowUp(ctx, x, z - 25, '#84e5b1')
          // this.simpleArrowDown(ctx, x, z - 25, '#84e5b1')
          // this.filledArrowUp(ctx, x, z - 25, 5, 5, 20, '#84e5b1')
          // this.filledDownArrow(ctx, x, z - 25, 5, 5, 20, '#84e5b1')
          // this.filledArrowUpFilledBottom(ctx, x, z - 25, 5, 5, 3, 20, '#84e5b1')
          // this.filledArrowDownFilledBottom(ctx, x, z - 25, 5, 5, 3, 20, '#84e5b1')
          // this.upTriangle(ctx, x, z-60, 5, 7, '#84e5b1')
          // this.downTriangle(ctx, x, z - 25, 5, 7, '#84e5b1')

        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    draw_label: function draw_label(ctx, x, y, labelText) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(labelText, x, y);
    },
    use_for: function use_for() {
      return ['LongShortTrades'];
    },
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Short';
          break;

        case 1:
          pos = 'Long';
          break;

        case 2:
          pos = 'Short Cover';
          break;

        case 3:
          pos = 'Long Cover';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.colorText
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    },
    simpleArrowUp: function simpleArrowUp(ctx, x, y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - 5, y + 5);
      ctx.lineTo(x, y);
      ctx.lineTo(x + 5, y + 5);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + 15);
      ctx.stroke();
      ctx.closePath();
    },
    simpleArrowDown: function simpleArrowDown(ctx, x, y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - 5, y - 5);
      ctx.lineTo(x, y);
      ctx.lineTo(x + 5, y - 5);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - 15);
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowUp: function filledArrowUp(ctx, x, y, width, height, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledDownArrow: function filledDownArrow(ctx, x, y, width, height, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowUpFilledBottom: function filledArrowUpFilledBottom(ctx, x, y, width, height, bottom, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.moveTo(x, y);
      ctx.rect(x - bottom / 2, y + height, bottom, depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowDownFilledBottom: function filledArrowDownFilledBottom(ctx, x, y, width, height, bottom, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.moveTo(x, y);
      ctx.rect(x - bottom / 2, y - height - depth, bottom, depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    upTriangle: function upTriangle(ctx, x, y, width, height, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    downTriangle: function downTriangle(ctx, x, y, width, height, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/LongShortTrades/LongShortTrades.vue?vue&type=script&lang=js&
 /* harmony default export */ const LongShortTrades_LongShortTradesvue_type_script_lang_js_ = (LongShortTradesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/LongShortTrades/LongShortTrades.vue
var LongShortTrades_render, LongShortTrades_staticRenderFns
;



/* normalize component */
;
var LongShortTrades_component = normalizeComponent(
  LongShortTrades_LongShortTradesvue_type_script_lang_js_,
  LongShortTrades_render,
  LongShortTrades_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LongShortTrades_api; }
LongShortTrades_component.options.__file = "src/overlays/LongShortTrades/LongShortTrades.vue"
/* harmony default export */ const LongShortTrades = (LongShortTrades_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MACD/MACD.vue?vue&type=script&lang=js&
function MACDvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = MACDvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function MACDvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return MACDvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return MACDvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function MACDvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// TODO: pass colors from settings to the script
// TODO: hist lines => recangles (like in volbar.js)

/* harmony default export */ const MACDvue_type_script_lang_js_ = ({
  name: 'MACD',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.2',
        desc: 'Moving Average Convergence/Divergence',
        preset: {
          name: 'MACD $fast $slow $smooth',
          side: 'offchart',
          settings: {
            histWidth: 4,
            macdWidth: 1,
            signalWidth: 1,
            defColor: "#42b28a",
            macdColor: "#3782f2",
            signalColor: "#f48709",
            histColors: ["#35a776", "#79e0b3", "#e54150", "#ea969e"]
          }
        }
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout; // HISTOGRAM

      var base = layout.$2screen(0) + 0.5;
      var off = this.hist_width % 2 ? 0 : 0.5;
      ctx.lineWidth = this.hist_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      var _iterator = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - 0.5;
          ctx.strokeStyle = this.sett.histColors[p[4]];
          ctx.beginPath();
          ctx.moveTo(x, base);
          ctx.lineTo(x, y);
          ctx.stroke();
        } // MACD LINE

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.beginPath();
      ctx.lineWidth = this.macd_width;
      ctx.strokeStyle = this.macd_color;

      var _iterator2 = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[2]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.stroke(); // SIGNAL LINE

      ctx.beginPath();
      ctx.lineWidth = this.signal_width;
      ctx.strokeStyle = this.signal_color;

      var _iterator3 = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var p = _step3.value;

          var _x2 = layout.t2screen(p[0]);

          var _y2 = layout.$2screen(p[3]);

          ctx.lineTo(_x2, _y2);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['MACD'];
    },
    legend: function legend(values) {
      var xs = values.slice(1, 4).map(function (x) {
        return x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      });
      return [{
        value: xs[0],
        color: this.hist_colors[values[4]]
      }, {
        value: xs[1],
        color: this.macd_color
      }, {
        value: xs[2],
        color: this.signal_color
      }];
    },
    calc: function calc() {
      return {
        props: {
          fast: {
            def: 12,
            text: 'Fast Length'
          },
          slow: {
            def: 26,
            text: 'Slow Length'
          },
          smooth: {
            def: 9,
            text: 'Signal EMA'
          }
        },
        update: "\n                    let [macd, signal, hist] =\n                        macd(close, fast, slow, smooth)\n\n                    if (hist[0] >= 0) {\n                         var color = 0\n                         if (hist[0] < hist[1]) color = 1\n                    } else {\n                        color = 2\n                        if (hist[0] > hist[1]) color = 3\n                    }\n\n                    return [hist[0], macd[0], signal[0], color]\n                "
      };
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    hist_width: function hist_width() {
      return this.sett.histWidth || 4;
    },
    macd_width: function macd_width() {
      return this.sett.macdWidth || 1;
    },
    signal_width: function signal_width() {
      return this.sett.signalWidth || 1;
    },
    color: function color() {
      return this.sett.defColor || "#42b28a";
    },
    macd_color: function macd_color() {
      return this.sett.macdColor || "#3782f2";
    },
    signal_color: function signal_color() {
      return this.sett.signalColor || "#f48709";
    },
    hist_colors: function hist_colors() {
      return this.sett.histColors;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MACD/MACD.vue?vue&type=script&lang=js&
 /* harmony default export */ const MACD_MACDvue_type_script_lang_js_ = (MACDvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MACD/MACD.vue
var MACD_render, MACD_staticRenderFns
;



/* normalize component */
;
var MACD_component = normalizeComponent(
  MACD_MACDvue_type_script_lang_js_,
  MACD_render,
  MACD_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MACD_api; }
MACD_component.options.__file = "src/overlays/MACD/MACD.vue"
/* harmony default export */ const MACD = (MACD_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MFI/MFI.vue?vue&type=script&lang=js&

/* harmony default export */ const MFIvue_type_script_lang_js_ = ({
  name: 'MFI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Money Flow Index',
        preset: {
          name: 'MFI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#85c427ee',
            bandColor: '#aaaaaa',
            backColor: '#85c42711',
            upper: 80,
            lower: 20
          }
        }
      };
    },
    use_for: function use_for() {
      return ['MFI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "\n                    let hlc3 = ts((high[0] + low[0] + close[0]) / 3)\n                    return mfi(hlc3, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MFI/MFI.vue?vue&type=script&lang=js&
 /* harmony default export */ const MFI_MFIvue_type_script_lang_js_ = (MFIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MFI/MFI.vue
var MFI_render, MFI_staticRenderFns
;



/* normalize component */
;
var MFI_component = normalizeComponent(
  MFI_MFIvue_type_script_lang_js_,
  MFI_render,
  MFI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MFI_api; }
MFI_component.options.__file = "src/overlays/MFI/MFI.vue"
/* harmony default export */ const MFI = (MFI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MOM/MOM.vue?vue&type=script&lang=js&

/* harmony default export */ const MOMvue_type_script_lang_js_ = ({
  name: 'MOM',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Momentum',
        preset: {
          name: 'MOM $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#bcc427ee'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['MOM'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 11,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return mom(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MOM/MOM.vue?vue&type=script&lang=js&
 /* harmony default export */ const MOM_MOMvue_type_script_lang_js_ = (MOMvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MOM/MOM.vue
var MOM_render, MOM_staticRenderFns
;



/* normalize component */
;
var MOM_component = normalizeComponent(
  MOM_MOMvue_type_script_lang_js_,
  MOM_render,
  MOM_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MOM_api; }
MOM_component.options.__file = "src/overlays/MOM/MOM.vue"
/* harmony default export */ const MOM = (MOM_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Markers/Markers.vue?vue&type=script&lang=js&
function Markersvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Markersvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Markersvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Markersvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Markersvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Markersvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Markersvue_type_script_lang_js_ = ({
  name: 'Markers',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1',
        desc: 'Interactive markers'
      };
    },
    init: function init() {
      this.mouse.on('mousemove', function () {});
    },
    draw: function draw(ctx) {
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';
      document.body.style.cursor = 'auto';
      this.selected = null;

      var _iterator = Markersvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          this.draw_point(ctx, p);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var f = this.data.find(function (x) {
        return x[1].sel;
      });

      if (f) {
        this.draw_point(ctx, f);
      }
    },
    draw_point: function draw_point(ctx, p) {
      var layout = this.$props.layout;
      var stroke = this.colors.back;
      var fill = p[1].color || 'orange';
      var radius = 2;
      var height = p[1].sel ? 20 : 14;
      var width = p[1].sel ? 17 : 13;
      var x = layout.t2screen(p[0]) - width * 0.5;
      var y = layout.$2screen(p[1].$) - (p[1].sel ? 27 : 20); // Collisions

      if (this.mouse.x > x && this.mouse.x < x + width && this.mouse.y > y && this.mouse.y < y + height) {
        document.body.style.cursor = 'pointer';
        this.selected = p;
        stroke = this.colors.text;
      }

      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + width * 1 / 2, y + height + height / 5);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.lineWidth = 1;
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.fill();
      ctx.stroke();
      ctx.textAlign = 'center';
      ctx.fillStyle = p[1].textColor || this.colors.back;
      ctx.font = "".concat(p[1].sel ? 15 : 11, "px Arial");
      ctx.fillText(p[1].text || '$', x + width / 2, y + height * 0.8);
    },
    use_for: function use_for() {
      return ['Markers'];
    },
    legend: function legend() {
      return [];
    },
    mousedown: function mousedown() {
      this.$emit('marker-selected', this.selected);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  },
  data: function data() {
    return {
      selected: null
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Markers/Markers.vue?vue&type=script&lang=js&
 /* harmony default export */ const Markers_Markersvue_type_script_lang_js_ = (Markersvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Markers/Markers.vue
var Markers_render, Markers_staticRenderFns
;



/* normalize component */
;
var Markers_component = normalizeComponent(
  Markers_Markersvue_type_script_lang_js_,
  Markers_render,
  Markers_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Markers_api; }
Markers_component.options.__file = "src/overlays/Markers/Markers.vue"
/* harmony default export */ const Markers = (Markers_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/PlotCross/PlotCross.vue?vue&type=script&lang=js&
function PlotCrossvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = PlotCrossvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function PlotCrossvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return PlotCrossvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PlotCrossvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function PlotCrossvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const PlotCrossvue_type_script_lang_js_ = ({
  name: 'PlotCross',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Plot line with crosses'
      };
    },
    draw: function draw(ctx) {
      var w = ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.line_width % 2 ? 0 : 0.5;
      var off2 = this.line_width % 2 ? 0.5 : 1; // Color changed

      var changed = false;

      var _iterator = PlotCrossvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - off;
          var _changed = false;

          if (p[2]) {
            if (ctx.strokeStyle !== p[2]) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = p[2];
          } else {
            if (ctx.strokeStyle !== this.color) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = this.color;
          }

          if (_changed) ctx.beginPath();
          ctx.moveTo(x, y - w * 2 + off2);
          ctx.lineTo(x, y + w * 2 - off2);
          ctx.moveTo(x - w * 2 + off2, y);
          ctx.lineTo(x + w * 2 - off2, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['PlotCross'];
    },
    legend: function legend(values) {
      var x = values[1];

      if (typeof x === "number") {
        x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      }

      return [{
        value: x,
        color: values[2] || this.color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 2;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#888888', '#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/PlotCross/PlotCross.vue?vue&type=script&lang=js&
 /* harmony default export */ const PlotCross_PlotCrossvue_type_script_lang_js_ = (PlotCrossvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/PlotCross/PlotCross.vue
var PlotCross_render, PlotCross_staticRenderFns
;



/* normalize component */
;
var PlotCross_component = normalizeComponent(
  PlotCross_PlotCrossvue_type_script_lang_js_,
  PlotCross_render,
  PlotCross_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var PlotCross_api; }
PlotCross_component.options.__file = "src/overlays/PlotCross/PlotCross.vue"
/* harmony default export */ const PlotCross = (PlotCross_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ROC/ROC.vue?vue&type=script&lang=js&

/* harmony default export */ const ROCvue_type_script_lang_js_ = ({
  name: 'ROC',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Rate of Change',
        preset: {
          name: 'ROC $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#279fc4'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ROC'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 9,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return roc(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ROC/ROC.vue?vue&type=script&lang=js&
 /* harmony default export */ const ROC_ROCvue_type_script_lang_js_ = (ROCvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ROC/ROC.vue
var ROC_render, ROC_staticRenderFns
;



/* normalize component */
;
var ROC_component = normalizeComponent(
  ROC_ROCvue_type_script_lang_js_,
  ROC_render,
  ROC_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ROC_api; }
ROC_component.options.__file = "src/overlays/ROC/ROC.vue"
/* harmony default export */ const ROC = (ROC_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/RSI/RSI.vue?vue&type=script&lang=js&

/* harmony default export */ const RSIvue_type_script_lang_js_ = ({
  name: 'RSI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Relative Strength Index',
        preset: {
          name: 'RSI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#ec206e',
            bandColor: '#aaa',
            backColor: '#9b9ba316'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['RSI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "return rsi(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/RSI/RSI.vue?vue&type=script&lang=js&
 /* harmony default export */ const RSI_RSIvue_type_script_lang_js_ = (RSIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/RSI/RSI.vue
var RSI_render, RSI_staticRenderFns
;



/* normalize component */
;
var RSI_component = normalizeComponent(
  RSI_RSIvue_type_script_lang_js_,
  RSI_render,
  RSI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var RSI_api; }
RSI_component.options.__file = "src/overlays/RSI/RSI.vue"
/* harmony default export */ const RSI = (RSI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ribbon/Ribbon.vue?vue&type=script&lang=js&

/* harmony default export */ const Ribbonvue_type_script_lang_js_ = ({
  name: 'Ribbon',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Moving Average Ribbon',
        preset: {
          name: 'EMA x $number',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#3aaaf4ee"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['Ribbon'];
    },
    calc: function calc() {
      return {
        props: {
          start: {
            def: 10,
            text: 'Start Length'
          },
          number: {
            def: 5,
            text: 'Number of Lines'
          },
          step: {
            def: 10,
            text: 'Length Step'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    this[0] = []\n                    for (var i = 0; i < number; i++) {\n                        let l = start + i * step\n                        this[0].push(ema(close, l)[0])\n                    }\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ribbon/Ribbon.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ribbon_Ribbonvue_type_script_lang_js_ = (Ribbonvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ribbon/Ribbon.vue
var Ribbon_render, Ribbon_staticRenderFns
;



/* normalize component */
;
var Ribbon_component = normalizeComponent(
  Ribbon_Ribbonvue_type_script_lang_js_,
  Ribbon_render,
  Ribbon_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ribbon_api; }
Ribbon_component.options.__file = "src/overlays/Ribbon/Ribbon.vue"
/* harmony default export */ const Ribbon = (Ribbon_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SAR/SAR.vue?vue&type=script&lang=js&

/* harmony default export */ const SARvue_type_script_lang_js_ = ({
  name: 'SAR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Parabolic SAR',
        preset: {
          name: 'SAR $start $inc $max',
          side: 'onchart',
          settings: {
            lineWidth: 2,
            color: '#35a9c6'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SAR'];
    },
    calc: function calc() {
      return {
        props: {
          start: {
            def: 0.02,
            text: 'Start'
          },
          inc: {
            def: 0.02,
            text: 'Increment'
          },
          max: {
            def: 0.2,
            text: 'Maximum'
          }
        },
        conf: {
          renderer: 'PlotCross'
        },
        update: "\n                    return sar(start, inc, max)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SAR/SAR.vue?vue&type=script&lang=js&
 /* harmony default export */ const SAR_SARvue_type_script_lang_js_ = (SARvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SAR/SAR.vue
var SAR_render, SAR_staticRenderFns
;



/* normalize component */
;
var SAR_component = normalizeComponent(
  SAR_SARvue_type_script_lang_js_,
  SAR_render,
  SAR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SAR_api; }
SAR_component.options.__file = "src/overlays/SAR/SAR.vue"
/* harmony default export */ const SAR = (SAR_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SMA/SMA.vue?vue&type=script&lang=js&

/* harmony default export */ const SMAvue_type_script_lang_js_ = ({
  name: 'SMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Simple Moving Average',
        preset: {
          name: 'SMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#d1385c'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 25,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return sma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SMA/SMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const SMA_SMAvue_type_script_lang_js_ = (SMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SMA/SMA.vue
var SMA_render, SMA_staticRenderFns
;



/* normalize component */
;
var SMA_component = normalizeComponent(
  SMA_SMAvue_type_script_lang_js_,
  SMA_render,
  SMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SMA_api; }
SMA_component.options.__file = "src/overlays/SMA/SMA.vue"
/* harmony default export */ const SMA = (SMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SWMA/SWMA.vue?vue&type=script&lang=js&

/* harmony default export */ const SWMAvue_type_script_lang_js_ = ({
  name: 'SWMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Symmetrically Weighted Moving Average',
        preset: {
          name: 'SWMA',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#e57440'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SWMA'];
    },
    calc: function calc() {
      return {
        props: {},
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return swma(close)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SWMA/SWMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const SWMA_SWMAvue_type_script_lang_js_ = (SWMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SWMA/SWMA.vue
var SWMA_render, SWMA_staticRenderFns
;



/* normalize component */
;
var SWMA_component = normalizeComponent(
  SWMA_SWMAvue_type_script_lang_js_,
  SWMA_render,
  SWMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SWMA_api; }
SWMA_component.options.__file = "src/overlays/SWMA/SWMA.vue"
/* harmony default export */ const SWMA = (SWMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Stoch/Stoch.vue?vue&type=script&lang=js&
function Stochvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Stochvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Stochvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Stochvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Stochvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Stochvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Stochvue_type_script_lang_js_ = ({
  name: 'Stoch',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Stochastic',
        preset: {
          name: 'Stoch $param_k $param_d $smooth',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            kColor: '#3782f2',
            dColor: '#f48709',
            bandColor: '#ddd',
            backColor: '#381e9c16'
          }
        }
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var upper = layout.$2screen(this.sett.upper || 80);
      var lower = layout.$2screen(this.sett.lower || 20); // K

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.k_color;
      ctx.beginPath();

      var _iterator = Stochvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[1]);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke(); // D

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.d_color;
      ctx.beginPath();

      var _iterator2 = Stochvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[2]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.stroke();
      ctx.strokeStyle = this.band_color;
      ctx.setLineDash([5]); // Will be removed after draw()

      ctx.beginPath(); // Fill the area between the bands

      ctx.fillStyle = this.back_color;
      ctx.fillRect(0, upper, layout.width, lower - upper); // Upper band

      ctx.moveTo(0, upper);
      ctx.lineTo(layout.width, upper); // Lower band

      ctx.moveTo(0, lower);
      ctx.lineTo(layout.width, lower);
      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Stoch'];
    },
    data_colors: function data_colors() {
      return [this.color];
    },
    y_range: function y_range(hi, lo) {
      return [Math.max(hi, this.sett.upper || 80), Math.min(lo, this.sett.lower || 20)];
    },
    calc: function calc() {
      return {
        props: {
          param_k: {
            def: 14,
            text: 'K'
          },
          param_d: {
            def: 3,
            text: 'D'
          },
          smooth: {
            def: 3,
            text: 'Smooth'
          }
        },
        update: "\n                    let k = sma(stoch(close, high, low, param_k), smooth)\n                    let d = sma(k, param_d)\n                    return [k[0], d[0]]\n                "
      };
    }
  },
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    k_color: function k_color() {
      return this.sett.kColor || '#3782f2';
    },
    d_color: function d_color() {
      return this.sett.dColor || '#f48709';
    },
    band_color: function band_color() {
      return this.sett.bandColor || '#ddd';
    },
    back_color: function back_color() {
      return this.sett.backColor || '#381e9c16';
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Stoch/Stoch.vue?vue&type=script&lang=js&
 /* harmony default export */ const Stoch_Stochvue_type_script_lang_js_ = (Stochvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Stoch/Stoch.vue
var Stoch_render, Stoch_staticRenderFns
;



/* normalize component */
;
var Stoch_component = normalizeComponent(
  Stoch_Stochvue_type_script_lang_js_,
  Stoch_render,
  Stoch_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Stoch_api; }
Stoch_component.options.__file = "src/overlays/Stoch/Stoch.vue"
/* harmony default export */ const Stoch = (Stoch_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/TSI/TSI.vue?vue&type=script&lang=js&

/* harmony default export */ const TSIvue_type_script_lang_js_ = ({
  name: 'TSI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'True Strength Index',
        preset: {
          name: 'TSI $long $short $signal',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#3bb3e4", "#f7046d"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['TSI'];
    },
    calc: function calc() {
      return {
        props: {
          "long": {
            def: 25,
            text: 'Long Length'
          },
          "short": {
            def: 13,
            text: 'Short Length'
          },
          signal: {
            def: 13,
            text: 'Signal Length'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    let val = tsi(close, short, long)\n                    let sig = ema(val, signal)\n                    return [val[0] * 100, sig[0] * 100]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/TSI/TSI.vue?vue&type=script&lang=js&
 /* harmony default export */ const TSI_TSIvue_type_script_lang_js_ = (TSIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/TSI/TSI.vue
var TSI_render, TSI_staticRenderFns
;



/* normalize component */
;
var TSI_component = normalizeComponent(
  TSI_TSIvue_type_script_lang_js_,
  TSI_render,
  TSI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TSI_api; }
TSI_component.options.__file = "src/overlays/TSI/TSI.vue"
/* harmony default export */ const TSI = (TSI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/TradesPlus/TradesPlus.vue?vue&type=script&lang=js&
function TradesPlusvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = TradesPlusvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function TradesPlusvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TradesPlusvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TradesPlusvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function TradesPlusvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


var CROSS = "m512.001 84.853-84.853-84.853-171.147 171.147-171.148-171.147-84.853\n84.853 171.148 171.147-171.148 171.148 84.853 84.853 171.148-171.147\n171.147 171.147 84.853-84.853-171.148-171.148z";
/* harmony default export */ const TradesPlusvue_type_script_lang_js_ = ({
  name: 'TradesPlus',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1',
        desc: 'Trades overlay with stops'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      ctx.strokeStyle = 'black';

      var _iterator = TradesPlusvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          ctx.fillStyle = p[1] ? this.buy_color : this.sell_color;
          var x = layout.t2screen(p[0]); // x - Mapping

          var y = layout.$2screen(p[2]); // y - Mapping

          if (p[3] === 'Stop') {
            this.draw_cross(ctx, x, y);
          } else {
            this.draw_circle(ctx, x, y);
          }

          if (this.show_label && p[3] && p[3] !== 'Stop') {
            this.draw_label(ctx, x, y, p);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    draw_label: function draw_label(ctx, x, y, p) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(p[3], x, y - 25);
    },
    draw_circle: function draw_circle(ctx, x, y) {
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x, y, this.marker_size + 0.5, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.stroke();
    },
    draw_cross: function draw_cross(ctx, x, y) {
      ctx.save();
      var p = new Path2D(CROSS);
      ctx.lineWidth = 150;
      ctx.translate(x - 5, y - 5);
      ctx.scale(0.0175, 0.0175);
      ctx.stroke(p);
      ctx.fill(p);
      ctx.scale(1, 1);
      ctx.restore();
    },
    use_for: function use_for() {
      return ['TradesPlus'];
    },
    // Defines legend format (values & colors)
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Sell';
          break;

        case 1:
          pos = 'Buy';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.colorText
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    buy_color: function buy_color() {
      return this.sett.buyColor || '#63df89';
    },
    sell_color: function sell_color() {
      return this.sett.sellColor || '#ec4662';
    },
    label_color: function label_color() {
      return this.sett.labelColor || this.colors.text;
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/TradesPlus/TradesPlus.vue?vue&type=script&lang=js&
 /* harmony default export */ const TradesPlus_TradesPlusvue_type_script_lang_js_ = (TradesPlusvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/TradesPlus/TradesPlus.vue
var TradesPlus_render, TradesPlus_staticRenderFns
;



/* normalize component */
;
var TradesPlus_component = normalizeComponent(
  TradesPlus_TradesPlusvue_type_script_lang_js_,
  TradesPlus_render,
  TradesPlus_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TradesPlus_api; }
TradesPlus_component.options.__file = "src/overlays/TradesPlus/TradesPlus.vue"
/* harmony default export */ const TradesPlus = (TradesPlus_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/VWMA/VWMA.vue?vue&type=script&lang=js&

/* harmony default export */ const VWMAvue_type_script_lang_js_ = ({
  name: 'VWMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Volume Weighted Moving Average',
        preset: {
          name: 'VWMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#db0670'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['VWMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return vwma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/VWMA/VWMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const VWMA_VWMAvue_type_script_lang_js_ = (VWMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/VWMA/VWMA.vue
var VWMA_render, VWMA_staticRenderFns
;



/* normalize component */
;
var VWMA_component = normalizeComponent(
  VWMA_VWMAvue_type_script_lang_js_,
  VWMA_render,
  VWMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var VWMA_api; }
VWMA_component.options.__file = "src/overlays/VWMA/VWMA.vue"
/* harmony default export */ const VWMA = (VWMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/WilliamsR/WilliamsR.vue?vue&type=script&lang=js&

/* harmony default export */ const WilliamsRvue_type_script_lang_js_ = ({
  name: 'WilliamsR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Williams %R',
        preset: {
          name: '%R $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#0980e8',
            bandColor: '#aaa',
            backColor: '#9b9ba316',
            upper: -20,
            lower: -80
          }
        }
      };
    },
    use_for: function use_for() {
      return ['WilliamsR'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "\n                    return wpr(length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/WilliamsR/WilliamsR.vue?vue&type=script&lang=js&
 /* harmony default export */ const WilliamsR_WilliamsRvue_type_script_lang_js_ = (WilliamsRvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/WilliamsR/WilliamsR.vue
var WilliamsR_render, WilliamsR_staticRenderFns
;



/* normalize component */
;
var WilliamsR_component = normalizeComponent(
  WilliamsR_WilliamsRvue_type_script_lang_js_,
  WilliamsR_render,
  WilliamsR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var WilliamsR_api; }
WilliamsR_component.options.__file = "src/overlays/WilliamsR/WilliamsR.vue"
/* harmony default export */ const WilliamsR = (WilliamsR_component.exports);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function arrayLikeToArray_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray_arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function unsupportedIterableToArray_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray_arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || unsupportedIterableToArray_unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/primitives/xohlcbar.js



// Ohlc object for Ohlcs overlay
var XOhlcBar = /*#__PURE__*/function () {
  function XOhlcBar(overlay, ctx, data) {
    _classCallCheck(this, XOhlcBar);

    this.ctx = ctx;
    this.self = overlay;
    this.style = data.raw[6] || this.self;

    this._draw(data);
  }

  _createClass(XOhlcBar, [{
    key: "_draw",
    value: function _draw(data) {
      var line_width = this.style.lineWidth;
      var hlc_only = this.style.chartType == "HLC";
      var line_width_half = line_width / 2; // Bar color

      var bar_color = data.c <= data.o ? this.style.upBarColor : this.style.downBarColor;
      var width = Math.max(data.w, 1);
      var halfwidth = Math.max(Math.floor(width * 0.5), 1);
      var height = Math.abs(data.o - data.c);
      var max_h = data.c === data.o ? 1 : 2;
      var s = line_width % 2 === 0 ? 0 : 0.5; // Draw the line from low to high and open and close also

      this.ctx.strokeStyle = bar_color;
      this.ctx.lineWidth = line_width;
      this.ctx.beginPath(); // Draw high to low

      this.ctx.moveTo(Math.floor(data.x - line_width_half) + s, Math.floor(data.h));
      this.ctx.lineTo(Math.floor(data.x - line_width_half) + s, Math.floor(data.l));

      if (width > 1) {
        // Draw open notch
        if (hlc_only) {
          // No open price in consideration
          // Draw open notch with close price
          this.ctx.moveTo(Math.floor(data.x - halfwidth - line_width_half - 1), Math.floor(data.c) - s);
          this.ctx.lineTo(Math.floor(data.x - line_width_half), Math.floor(data.c) - s);
        } else {
          // Draw open notch with open price
          this.ctx.moveTo(Math.floor(data.x - halfwidth - line_width_half - 1), Math.floor(data.o) - s);
          this.ctx.lineTo(Math.floor(data.x - line_width_half), Math.floor(data.o) - s);
        } // Draw close notch


        this.ctx.moveTo(Math.floor(data.x - line_width_half), Math.floor(data.c) - s);
        this.ctx.lineTo(Math.floor(data.x + halfwidth - line_width_half + 1), Math.floor(data.c) - s);
      }

      this.ctx.stroke();
    }
  }]);

  return XOhlcBar;
}();


;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/primitives/xvolbar.js



var XVolbar = /*#__PURE__*/function () {
  function XVolbar(overlay, ctx, data, barData, thinVolumeBar) {
    _classCallCheck(this, XVolbar);

    this.ctx = ctx;
    this.$p = overlay.$props;
    this.self = overlay;
    this.style = data.raw[6] || this.self;

    this._draw(data, barData, thinVolumeBar);
  }

  _createClass(XVolbar, [{
    key: "_draw",
    value: function _draw(data, barData, thinVolumeBar) {
      if (thinVolumeBar) {
        // Thin Volume Bar
        var bar_color = data.green ? this.style.upVolBarColor : this.style.downVolBarColor;
        var line_width = this.style.volBarWidth;
        var line_width_half = line_width / 2;
        var y0 = this.$p.layout.height;
        var w = data.x2 - data.x1;
        var h = Math.floor(data.h);
        this.ctx.strokeStyle = bar_color;
        this.ctx.lineWidth = line_width;
        this.ctx.beginPath(); // Draw high to low

        this.ctx.moveTo(Math.floor(barData.x - line_width_half), Math.floor(y0 - h - 0.5));
        this.ctx.lineTo(Math.floor(barData.x - line_width_half), Math.floor(y0 + 0.5));
        this.ctx.stroke();
      } else {
        // Thick Volume Bar
        var _y = this.$p.layout.height;

        var _w = data.x2 - data.x1;

        var _h = Math.floor(data.h);

        this.ctx.fillStyle = data.green ? this.style.upVolBarColor : this.style.downVolBarColor;
        this.ctx.fillRect(Math.floor(data.x1), Math.floor(_y - _h - 0.5), Math.floor(_w), Math.floor(_h + 1));
      }
    }
  }]);

  return XVolbar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/XOhlcBars/XOhlcBars.vue?vue&type=script&lang=js&


function XOhlcBarsvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = XOhlcBarsvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function XOhlcBarsvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Renedrer for ohlcbar + volume (optional)
// It can be used as the main chart or an indicator



/* harmony default export */ const XOhlcBarsvue_type_script_lang_js_ = ({
  name: 'XOhlcBars',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'X',
        version: '1.3.0',
        desc: 'Bar Chart'
      };
    },
    init: function init() {//this.price = new Price(this) // TODO:
    },
    draw: function draw(ctx) {
      //console.log("XOhlcBar.draw() called. this.$props.data.length = " + this.$props.data.length)
      // render as main chart:
      if (this.$props.sub === this.$props.data) {
        var cnv = {
          ohlcbars: this.$props.layout.candles,
          volume: this.$props.layout.volume
        }; // Else, as offchart / onchart indicator:
      } else {
        cnv = (0,external_trading_vue_js_.layout_cnv)(this);
      }

      if (this.show_volume) {
        for (var i = 0; i < cnv.volume.length; i++) {
          var volumeData = cnv.volume[i];
          var _barData = cnv.ohlcbars[i];
          new XVolbar(this, ctx, volumeData, _barData);
        }
      }

      var _iterator = XOhlcBarsvue_type_script_lang_js_createForOfIteratorHelper(cnv.ohlcbars),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var barData = _step.value;
          new XOhlcBar(this, ctx, barData);
        } //if (this.price_line) this.price.draw(ctx)  // TODO:

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ['XOhlcBars'];
    },
    // When added as offchart overlay
    y_range: function y_range() {
      return [Math.max.apply(Math, _toConsumableArray(this.$props.sub.map(function (x) {
        return x[2];
      }))), Math.min.apply(Math, _toConsumableArray(this.$props.sub.map(function (x) {
        return x[3];
      })))];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    show_volume: function show_volume() {
      return 'showVolume' in this.sett ? this.sett.showVolume : true;
    },
    price_line: function price_line() {
      return 'priceLine' in this.sett ? this.sett.priceLine : true;
    },
    upVolBarColor: function upVolBarColor() {
      return this.sett.upBarColor || "#23a77655";
    },
    downVolBarColor: function downVolBarColor() {
      return this.sett.downBarColor || "#e5415055";
    },
    volBarWidth: function volBarWidth() {
      return this.sett.barWidth || 2;
    },
    upBarColor: function upBarColor() {
      return this.sett.upBarColor || "#23a776";
    },
    downBarColor: function downBarColor() {
      return this.sett.downBarColor || "#e54150";
    },
    barWidth: function barWidth() {
      return this.sett.barWidth || 1;
    },
    hlcOnly: function hlcOnly() {
      return this.sett.hlcOnly || false;
    },
    lineWidth: function lineWidth() {
      return this.sett.lineWidth || 1;
    }
  },
  data: function data() {
    return {
      price: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/XOhlcBars.vue?vue&type=script&lang=js&
 /* harmony default export */ const XOhlcBars_XOhlcBarsvue_type_script_lang_js_ = (XOhlcBarsvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/XOhlcBars.vue
var XOhlcBars_render, XOhlcBars_staticRenderFns
;



/* normalize component */
;
var XOhlcBars_component = normalizeComponent(
  XOhlcBars_XOhlcBarsvue_type_script_lang_js_,
  XOhlcBars_render,
  XOhlcBars_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var XOhlcBars_api; }
XOhlcBars_component.options.__file = "src/overlays/XOhlcBars/XOhlcBars.vue"
/* harmony default export */ const XOhlcBars = (XOhlcBars_component.exports);
;// CONCATENATED MODULE: ./src/index_prod.js
// -------- Production overlay index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// Do not commit this file, the final index is
// compiled by the repo owner, use index_dev.js to
// experiment: 'npm run compile'




































var Pack = {
  ALMA: ALMA,
  ATR: ATR,
  ATRp: ATRp,
  Area51: Area51,
  BB: BB,
  BBW: BBW,
  CCI: CCI,
  CMO: CMO,
  COG: COG,
  DHistogram: DHistogram,
  DMI: DMI,
  EMA: EMA,
  HMA: HMA,
  Histogram: Histogram,
  Ichi: Ichi,
  Ichimoku: Ichimoku,
  KC: KC,
  KCW: KCW,
  LongShortTrades: LongShortTrades,
  MACD: MACD,
  MFI: MFI,
  MOM: MOM,
  Markers: Markers,
  PlotCross: PlotCross,
  ROC: ROC,
  RSI: RSI,
  Ribbon: Ribbon,
  SAR: SAR,
  SMA: SMA,
  SWMA: SWMA,
  Stoch: Stoch,
  TSI: TSI,
  TradesPlus: TradesPlus,
  VWMA: VWMA,
  WilliamsR: WilliamsR,
  XOhlcBars: XOhlcBars
};

if (typeof window !== 'undefined' && window.Vue) {
  window.TvjsOverlays = Pack;
}

/* harmony default export */ const index_prod = (Pack);

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./src/MainM.vue":
/*!***********************!*\
  !*** ./src/MainM.vue ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MainM_vue_vue_type_template_id_7e13d8ea___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainM.vue?vue&type=template&id=7e13d8ea& */ "./src/MainM.vue?vue&type=template&id=7e13d8ea&");
/* harmony import */ var _MainM_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MainM.vue?vue&type=script&lang=js& */ "./src/MainM.vue?vue&type=script&lang=js&");
/* harmony import */ var _MainM_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainM.vue?vue&type=style&index=0&lang=css& */ "./src/MainM.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _MainM_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _MainM_vue_vue_type_template_id_7e13d8ea___WEBPACK_IMPORTED_MODULE_0__.render,
  _MainM_vue_vue_type_template_id_7e13d8ea___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/MainM.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/StdInput.vue":
/*!*************************************!*\
  !*** ./src/components/StdInput.vue ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StdInput.vue?vue&type=template&id=5e1f1c17& */ "./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&");
/* harmony import */ var _StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StdInput.vue?vue&type=script&lang=js& */ "./src/components/StdInput.vue?vue&type=script&lang=js&");
/* harmony import */ var _StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StdInput.vue?vue&type=style&index=0&lang=css& */ "./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.render,
  _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/StdInput.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/Window.vue":
/*!***********************************!*\
  !*** ./src/components/Window.vue ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Window.vue?vue&type=template&id=5b030a20& */ "./src/components/Window.vue?vue&type=template&id=5b030a20&");
/* harmony import */ var _Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Window.vue?vue&type=script&lang=js& */ "./src/components/Window.vue?vue&type=script&lang=js&");
/* harmony import */ var _Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Window.vue?vue&type=style&index=0&lang=css& */ "./src/components/Window.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.render,
  _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/Window.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue":
/*!*************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Splitter.vue?vue&type=template&id=189fccad&scoped=true& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&");
/* harmony import */ var _Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Splitter.vue?vue&type=script&lang=js& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&");
/* harmony import */ var _Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "189fccad",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/grid-resize/Splitter.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue":
/*!**************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AddWin.vue?vue&type=template&id=53408ac7&scoped=true& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&");
/* harmony import */ var _AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddWin.vue?vue&type=script&lang=js& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&");
/* harmony import */ var _AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "53408ac7",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/legend-buttons/AddWin.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue":
/*!*****************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&");
/* harmony import */ var _SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=script&lang=js& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&");
/* harmony import */ var _SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "5d223b0e",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/settings-win/SettingsWin.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/MainM.vue?vue&type=script&lang=js&":
/*!************************************************!*\
  !*** ./src/MainM.vue?vue&type=script&lang=js& ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./MainM.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=script&lang=js&":
/*!**************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=script&lang=js& ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/Window.vue?vue&type=script&lang=js&":
/*!************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=script&lang=js& ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&":
/*!**************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js& ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&":
/*!***************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js& ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&":
/*!******************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js& ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/MainM.vue?vue&type=style&index=0&lang=css&":
/*!********************************************************!*\
  !*** ./src/MainM.vue?vue&type=style&index=0&lang=css& ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/style-loader/dist/cjs.js!../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./MainM.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!**********************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!********************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!**********************************************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");


/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!***********************************************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");


/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!**************************************************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");


/***/ }),

/***/ "./src/MainM.vue?vue&type=template&id=7e13d8ea&":
/*!******************************************************!*\
  !*** ./src/MainM.vue?vue&type=template&id=7e13d8ea& ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_template_id_7e13d8ea___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_template_id_7e13d8ea___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_MainM_vue_vue_type_template_id_7e13d8ea___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../node_modules/vue-loader/lib/index.js??vue-loader-options!./MainM.vue?vue&type=template&id=7e13d8ea& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=template&id=7e13d8ea&");


/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&":
/*!********************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=template&id=5e1f1c17& ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=template&id=5e1f1c17& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&");


/***/ }),

/***/ "./src/components/Window.vue?vue&type=template&id=5b030a20&":
/*!******************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=template&id=5b030a20& ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=template&id=5b030a20& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20&");


/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&":
/*!********************************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true& ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=template&id=189fccad&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&");


/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&":
/*!*********************************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true& ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=template&id=53408ac7&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&");


/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&":
/*!************************************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=template&id=7e13d8ea&":
/*!*********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/MainM.vue?vue&type=template&id=7e13d8ea& ***!
  \*********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass:
        "flex-start col-10 col-xll-10 col-xl-10 col-lg-10 col-md-9 col-sm-12",
    },
    [
      _c("div", { attrs: { id: "tvjs-header" } }, [
        _vm._m(0),
        _vm._v(" "),
        _c("a", [
          _c(
            "span",
            {
              staticClass: "me-1 badge bg-light-secondary",
              on: { click: _vm.candles },
            },
            [
              _c("i", { staticClass: "bi bi-bar-chart" }),
              _c("div", { staticClass: "d-md-inline d-none" }, [
                _vm._v("  Candles"),
              ]),
            ]
          ),
        ]),
        _vm._v(" "),
        _c("a", [
          _c(
            "span",
            {
              staticClass: "me-1 badge bg-light-secondary",
              on: { click: _vm.spline },
            },
            [
              _c("i", { staticClass: "bi bi-graph-up" }),
              _c("div", { staticClass: "d-md-inline d-none" }, [
                _vm._v("  Spline"),
              ]),
            ]
          ),
        ]),
        _vm._v(" "),
        _vm._m(1),
        _vm._v(" "),
        _vm._m(2),
        _vm._v(" "),
        _vm._m(3),
      ]),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass:
            "collapse col-lg-4 col-md-5 col-sm-6 position-absolute sticky-top card-110 ",
          attrs: { id: "collapseInfos" },
        },
        [
          _c(
            "div",
            {
              staticClass: "card",
              staticStyle: {
                background: "#131722e6!important",
                "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
              },
            },
            [
              _c("div", { staticClass: "card-header" }, [
                _c("div", { staticClass: "col-md-8" }, [
                  _c("h4", { staticClass: "card-title" }, [
                    _vm._v(
                      "\n                        " +
                        _vm._s(_vm.symbol) +
                        "\n                    "
                    ),
                  ]),
                ]),
              ]),
              _vm._v(" "),
              _vm._m(4),
            ]
          ),
        ]
      ),
      _vm._v(" "),
      _vm._m(5),
      _vm._v(" "),
      _vm._m(6),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "app-container", staticStyle: { "margin-top": "40px" } },
        [
          _c("trading-vue", {
            key: _vm.resetkey,
            ref: "tvjs",
            attrs: {
              data: _vm.dc,
              width: _vm.width,
              height: _vm.height,
              "title-txt": _vm.title,
              "color-title": "#ff9f43",
              "legend-buttons": [
                "display",
                "settings",
                "up",
                "down",
                "add",
                "remove",
              ],
              "chart-config": { DEFAULT_LEN: 30, MIN_ZOOM: 1 },
              "color-back": _vm.colors.colorBack,
              "color-grid": _vm.colors.colorGrid,
              "color-text": _vm.colors.colorText,
              extensions: _vm.ext,
              overlays: _vm.ovs,
              night: _vm.night,
              resetkey: _vm.resetkey,
              "x-settings": _vm.xsett,
              timezone: _vm.timezone,
            },
          }),
        ],
        1
      ),
    ]
  )
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-info",
          attrs: {
            id: "toggleContracts",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseContracts",
            "aria-expanded": "false",
            "aria-controls": "collapseContracts",
          },
        },
        [
          _c("i", { staticClass: "bi bi-briefcase" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [
            _vm._v(" Contracts"),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-info",
          attrs: {
            id: "toggleInfo",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseInfos",
            "aria-expanded": "false",
            "aria-controls": "collapseInfos",
          },
        },
        [
          _c("i", { staticClass: "bi bi-info-circle" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [_vm._v("  Info")]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-primary ",
          attrs: {
            id: "toggleDepth",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseDepth",
            "aria-expanded": "false",
            "aria-controls": "collapseDepth",
          },
        },
        [
          _c("i", { staticClass: "bi bi-kanban" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [
            _vm._v("  Depth View"),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-warning ",
          attrs: {
            id: "toggleOrders",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseOrders",
            "aria-expanded": "false",
            "aria-controls": "collapseOrders",
          },
        },
        [
          _c("i", { staticClass: "bi bi-file-bar-graph" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [
            _vm._v("  Order Book"),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "card-content" }, [
      _c("div", { staticClass: "card-body" }, [
        _c("div", { staticClass: "row" }, [
          _c("div", { staticClass: "col-8" }, [
            _c(
              "div",
              { staticClass: "text-start fs-1", attrs: { id: "show_b" } },
              [
                _vm._v(
                  "\n                                ...\n                            "
                ),
              ]
            ),
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "col-4" }, [
            _c(
              "div",
              {
                staticClass: "text-end",
                staticStyle: { "font-size": "14px" },
                attrs: { id: "show_p" },
              },
              [
                _vm._v(
                  "\n                                ...\n                            "
                ),
              ]
            ),
            _vm._v(" "),
            _c(
              "div",
              {
                staticClass: "text-end",
                staticStyle: { "font-size": "14px" },
                attrs: { id: "show_P" },
              },
              [
                _vm._v(
                  "\n                                ...\n                            "
                ),
              ]
            ),
          ]),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row mt-1" }, [
          _c(
            "div",
            { staticClass: "progress", attrs: { id: "myRangeColor" } },
            [
              _c("div", {
                staticClass:
                  "progress-bar progress-bar-striped progress-bar-animated",
                staticStyle: { width: "80%" },
                attrs: {
                  id: "myRange",
                  role: "progressbar",
                  "aria-valuenow": "50",
                  "aria-valuemin": "0",
                  "aria-valuemax": "100",
                },
              }),
            ]
          ),
        ]),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass:
              "row d-flex justify-content-between align-items-center",
          },
          [
            _c("div", {
              staticClass: "col text-start text-danger",
              staticStyle: { "font-size": "10px" },
              attrs: { id: "show_l" },
            }),
            _vm._v(" "),
            _c(
              "div",
              {
                staticClass: "col text-dark text-center",
                staticStyle: { "font-size": "10px" },
              },
              [
                _vm._v(
                  "\n                            Day Range\n                        "
                ),
              ]
            ),
            _vm._v(" "),
            _c("div", {
              staticClass: "col text-end text-success",
              staticStyle: { "font-size": "10px" },
              attrs: { id: "show_h" },
            }),
          ]
        ),
        _vm._v(" "),
        _c("div", { staticClass: "row mt-1" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Volume 24H"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_v" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Market Cap"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_mc" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Total Supply"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_ts" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
      ]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      {
        staticClass:
          "collapse col-lg-6 col-md-10 col-sm-12 col-12 position-absolute sticky-top card-110 ",
        attrs: { id: "collapseDepth" },
      },
      [
        _c(
          "div",
          {
            staticClass: "card",
            staticStyle: {
              background: "#131722e6!important",
              "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
            },
          },
          [
            _c("div", { staticClass: "card-content" }, [
              _c("div", { attrs: { id: "chartdiv" } }),
            ]),
          ]
        ),
      ]
    )
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      {
        staticClass:
          "collapse col-lg-4 col-md-4 col-sm-6 col-12 position-absolute sticky-top card-110",
        staticStyle: { "max-width": "280px" },
        attrs: { id: "collapseOrders" },
      },
      [
        _c(
          "div",
          {
            staticClass: "card",
            staticStyle: {
              background: "#131722e6!important",
              "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
            },
          },
          [
            _c("div", { staticClass: "card-content my-1" }, [
              _c("div", { staticClass: "box" }, [
                _c("table", [
                  _c("thead", [
                    _c("tr", { staticClass: "mb-1" }, [
                      _c("th", { staticClass: "text-start ps-1 text-dark" }, [
                        _vm._v(
                          "\n                                    Price\n                                "
                        ),
                      ]),
                      _vm._v(" "),
                      _c("th", { staticClass: "text-center ps-1 text-dark" }, [
                        _vm._v(
                          "\n                                    Quantity\n                                "
                        ),
                      ]),
                      _vm._v(" "),
                      _c("th", { staticClass: "text-end pe-1 text-dark" }, [
                        _vm._v(
                          "\n                                    Total\n                                "
                        ),
                      ]),
                    ]),
                  ]),
                ]),
                _vm._v(" "),
                _c("table", { staticClass: "asks" }),
                _vm._v(" "),
                _c("div", { staticClass: "newest" }),
                _vm._v(" "),
                _c("table", { staticClass: "bids" }),
              ]),
            ]),
          ]
        ),
      ]
    )
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17& ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("span", [
    _vm.type === "text" || !_vm.type
      ? _c("input", {
          staticClass: "tvjs-std-input",
          style: _vm.style,
          attrs: { placeholder: _vm.name },
          domProps: { value: _vm.value },
          on: {
            change: function ($event) {
              return _vm.$emit("change", $event.target.value)
            },
            input: function ($event) {
              return _vm.$emit("input", $event.target.value)
            },
          },
        })
      : _vm.type === "select"
      ? _c(
          "select",
          {
            staticClass: "tvjs-std-input",
            style: _vm.style,
            domProps: { value: _vm.value },
            on: {
              input: function ($event) {
                return _vm.$emit("input", $event.target.value)
              },
            },
          },
          _vm._l(_vm.list, function (opt) {
            return _c("option", [_vm._v(_vm._s(opt))])
          }),
          0
        )
      : _vm._e(),
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20&":
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20& ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { ref: "win", staticClass: "tvjs-x-window", style: _vm.style },
    [
      _c("div", { staticClass: "tvjs-x-window-head" }, [
        _c(
          "div",
          {
            staticClass: "tvjs-x-window-title",
            on: { mousedown: _vm.onMouseDown },
          },
          [_vm._v("\n                " + _vm._s(_vm.title) + "\n            ")]
        ),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass: "tvjs-x-window-close",
            on: {
              click: function ($event) {
                return _vm.$emit("close")
              },
            },
          },
          [_vm._v("\n                ╳\n            ")]
        ),
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "tvjs-x-window-body" }, [_vm._t("default")], 2),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&":
/*!***********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true& ***!
  \***********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("span", {
    staticClass: "h-splitter",
    style: _vm.hs_style,
    on: { mousedown: _vm.hs_mousedown },
  })
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "window",
    {
      staticClass: "add-win",
      attrs: { title: "Add Indicator", tv: _vm.tv },
      on: { close: _vm.on_close },
    },
    [
      _c(
        "div",
        { staticClass: "add-win-list" },
        _vm._l(_vm.ovs, function (ov) {
          return _c(
            "div",
            {
              staticClass: "add-win-item",
              on: {
                click: function ($event) {
                  return _vm.on_click(ov.name)
                },
              },
            },
            [
              _c("span", [_vm._v(_vm._s(ov.name))]),
              _vm._v(" "),
              _c("span", { staticClass: "add-win-item-desc" }, [
                _vm._v(
                  "\n                " +
                    _vm._s(ov.methods.meta_info().desc) +
                    "\n            "
                ),
              ]),
            ]
          )
        }),
        0
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&":
/*!***************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& ***!
  \***************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "window",
    {
      staticClass: "sett-win",
      attrs: { title: _vm.data.ov.name, tv: _vm.tv },
      on: { close: _vm.on_close },
    },
    [
      _vm._l(_vm.settlist, function (k) {
        return _c(
          "div",
          { staticClass: "sett-win-item" },
          [
            _c("label", [_vm._v(_vm._s(_vm.s2d(k)))]),
            _vm._v(" "),
            _c("std-input", {
              attrs: { value: _vm.sett[k] },
              on: {
                input: function ($event) {
                  return _vm.update_sett(k, $event)
                },
              },
            }),
          ],
          1
        )
      }),
      _vm._v(" "),
      !_vm.settlist.length
        ? _c("span", { staticClass: "sett-win-empty" }, [
            _c("i", [_vm._v("No script settings")]),
          ])
        : _vm._e(),
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeComponent)
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ( true && customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ( true && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    true
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ( true && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i], vm);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
  if (!valid && haveExpectedTypes) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;

function assertType (value, type, vm) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    try {
      valid = value instanceof type;
    } catch (e) {
      warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
      valid = false;
    }
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

var functionTypeCheckRE = /^\s*function (\w+)/;

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  // check if we need to specify expected value
  if (
    expectedTypes.length === 1 &&
    isExplicable(expectedType) &&
    isExplicable(typeof value) &&
    !isBoolean(expectedType, receivedType)
  ) {
    message += " with value " + (styleValue(value, expectedType));
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + (styleValue(value, receivedType)) + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable (value) {
  return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals. ' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       true && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    var vnode = res && res[0];
    return res && (
      !vnode ||
      (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallbackRender,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes =
      scopedSlotFn(props) ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  } else {
    nodes =
      this.$slots[name] ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
  return eventKeyCode === undefined
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       true && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  // we know it's MountedComponentVNode but flow doesn't
  vnode,
  // activeInstance in lifecycle state
  parent
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     true && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ( true &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
        warn(
          ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
          context
        );
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       true && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : 0
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
    (!newScopedSlots && vm.$scopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : 0;
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       true && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        var info = "callback for watcher \"" + (this.expression) + "\"";
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {}
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     true && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
       true && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ( true && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn(("The computed property \"" + key + "\" is already defined as a method."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if ( true &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      var info = "callback for immediate watcher \"" + (watcher.expression) + "\"";
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {}
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if ( true &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */





function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var entry = cache[key];
    if (entry) {
      var name = entry.name;
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var entry = cache[key];
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  methods: {
    cacheVNode: function cacheVNode() {
      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var vnodeToCache = ref.vnodeToCache;
      var keyToCache = ref.keyToCache;
      if (vnodeToCache) {
        var tag = vnodeToCache.tag;
        var componentInstance = vnodeToCache.componentInstance;
        var componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: getComponentName(componentOptions),
          tag: tag,
          componentInstance: componentInstance,
        };
        keys.push(keyToCache);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
        this.vnodeToCache = null;
      }
    }
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.cacheVNode();
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  updated: function updated () {
    this.cacheVNode();
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        // delay setting the cache until update
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.14';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
       true && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key &&
    a.asyncFactory === b.asyncFactory && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (true) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
  }
}

/*  */



/* eslint-disable no-unused-vars */
function baseWarn (msg, range) {
  console.error(("[Vue compiler]: " + msg));
}
/* eslint-enable no-unused-vars */

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

function addAttr (el, name, value, range, dynamic) {
  var attrs = dynamic
    ? (el.dynamicAttrs || (el.dynamicAttrs = []))
    : (el.attrs || (el.attrs = []));
  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr (el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  isDynamicArg,
  modifiers,
  range
) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker (symbol, name, dynamic) {
  return dynamic
    ? ("_p(" + name + ",\"" + symbol + "\")")
    : symbol + name // mark the event as captured
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn,
  range,
  dynamic
) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
     true && warn &&
    modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.',
      range
    );
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr (
  el,
  name
) {
  return el.rawAttrsMap[':' + name] ||
    el.rawAttrsMap['v-bind:' + name] ||
    el.rawAttrsMap[name]
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

function getAndRemoveAttrByRegex (
  el,
  name
) {
  var list = el.attrsList;
  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];
    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr
    }
  }
}

function rangeSetItem (
  item,
  range
) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }
    if (range.end != null) {
      item.end = range.end;
    }
  }
  return item
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
      "? " + baseValueExpression + ".trim()" +
      ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: JSON.stringify(value),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len, str, chr, index$1, expressionPos, expressionEndPos;



function parseModel (val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead.",
        el.rawAttrsMap['v-model']
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (true) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.',
      el.rawAttrsMap['v-model']
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
    "?_i(" + value + "," + valueBinding + ")>-1" + (
      trueValueBinding === 'true'
        ? (":(" + value + ")")
        : (":_q(" + value + "," + trueValueBinding + ")")
    )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
      "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  if (true) {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(
        binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
        'because the latter already expands to a value binding internally',
        el.rawAttrsMap[binding]
      );
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecessary `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
     true && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if ( true && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if ( true &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        true
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if ( true &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});



function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ( true && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.',
        el.rawAttrsMap['class']
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.',
          el.rawAttrsMap['style']
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being passed as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ( true && !stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
      if ( true && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    // Find the closest opened tag of the same type
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag."),
            { start: stack[i].start, end: stack[i].end }
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;

var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

var slotRE = /^v-slot(:|$)|^#/;

var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /[ \f\t\r\n]+/g;

var invalidAttributeRE = /[\s"'<>\/=]/;

var decodeHTMLCached = cached(he.decode);

var emptySlotScopeToken = "_empty_";

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;
  maybeComponent = function (el) { return !!(
    el.component ||
    el.attrsMap[':is'] ||
    el.attrsMap['v-bind:is'] ||
    !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag))
  ); };
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement (element) {
    trimEndingWhitespace(element);
    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    }
    // tree management
    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (true) {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (true) {
        warnOnce(
          "Component template should contain exactly one root element. " +
          "If you are using v-if on multiple elements, " +
          "use v-else-if to chain them instead.",
          { start: element.start }
        );
      }
    }
    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"'
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }
        currentParent.children.push(element);
        element.parent = currentParent;
      }
    }

    // final children cleanup
    // filter out scoped slots
    element.children = element.children.filter(function (c) { return !(c).slotScope; });
    // remove trailing whitespace node again
    trimEndingWhitespace(element);

    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace (el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;
      while (
        (lastNode = el.children[el.children.length - 1]) &&
        lastNode.type === 3 &&
        lastNode.text === ' '
      ) {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints (el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce(
        "Cannot use <" + (el.tag) + "> as component root element because it may " +
        'contain multiple nodes.',
        { start: el.start }
      );
    }
    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce(
        'Cannot use v-for on stateful component root element because ' +
        'it renders multiple elements.',
        el.rawAttrsMap['v-for']
      );
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start (tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (true) {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated
          }, {});
        }
        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2(
              "Invalid dynamic argument expression: attribute names cannot contain " +
              "spaces, quotes, <, >, / or =.",
              {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
              }
            );
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
         true && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.',
          { start: element.start }
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        if (true) {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end (tag, start, end$1) {
      var element = stack[stack.length - 1];
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      if ( true && options.outputSourceRange) {
        element.end = end$1;
      }
      closeElement(element);
    },

    chars: function chars (text, start, end) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start: start }
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored."),
              { start: start }
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }
      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }
        var res;
        var child;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }
        if (child) {
          if ( true && options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          children.push(child);
        }
      }
    },
    comment: function comment (text, start, end) {
      // adding anything as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };
        if ( true && options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }
        currentParent.children.push(child);
      }
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var list = el.attrsList;
  var len = list.length;
  if (len) {
    var attrs = el.attrs = new Array(len);
    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };
      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (
  element,
  options
) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = (
    !element.key &&
    !element.scopedSlots &&
    !element.attrsList.length
  );

  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
  return element
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (true) {
      if (el.tag === 'template') {
        warn$2(
          "<template> cannot be keyed. Place the key on real elements instead.",
          getRawBindingAttr(el, 'key')
        );
      }
      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;
        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2(
            "Do not use v-for index as key on <transition-group> children, " +
            "this is the same as not using keys.",
            getRawBindingAttr(el, 'key'),
            true /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else if (true) {
      warn$2(
        ("Invalid v-for expression: " + exp),
        el.rawAttrsMap['v-for']
      );
    }
  }
}



function parseFor (exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) { return }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if.",
      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if ( true && children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored.",
          children[i]
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent (el) {
  var slotScope;
  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */
    if ( true && slotScope) {
      warn$2(
        "the \"scope\" attribute for scoped slots have been deprecated and " +
        "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
        "can also be used on plain elements in addition to <template> to " +
        "denote scoped slots.",
        el.rawAttrsMap['scope'],
        true
      );
    }
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
    /* istanbul ignore if */
    if ( true && el.attrsMap['v-for']) {
      warn$2(
        "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
        "(v-for takes higher priority). Use a wrapper <template> for the " +
        "scoped slot to make it clearer.",
        el.rawAttrsMap['slot-scope'],
        true
      );
    }
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }

  // 2.6 v-slot syntax
  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding) {
        if (true) {
          if (el.slotTarget || el.slotScope) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.parent && !maybeComponent(el.parent)) {
            warn$2(
              "<template v-slot> can only appear at the root level inside " +
              "the receiving component",
              el
            );
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding$1) {
        if (true) {
          if (!maybeComponent(el)) {
            warn$2(
              "v-slot can only be used on components or <template>.",
              slotBinding$1
            );
          }
          if (el.slotScope || el.slotTarget) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.scopedSlots) {
            warn$2(
              "To avoid scope ambiguity, the default slot should also use " +
              "<template> syntax when there are other named slots.",
              slotBinding$1
            );
          }
        }
        // add the component's children to its default slot
        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
        // remove children as they are returned from scopedSlots now
        el.children = [];
        // mark el non-plain so data gets generated
        el.plain = false;
      }
    }
  }
}

function getSlotName (binding) {
  var name = binding.name.replace(slotRE, '');
  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (true) {
      warn$2(
        "v-slot shorthand syntax requires a slot name.",
        binding
      );
    }
  }
  return dynamicArgRE.test(name)
    // dynamic [name]
    ? { name: name.slice(1, -1), dynamic: true }
    // static name
    : { name: ("\"" + name + "\""), dynamic: false }
}

// handle <slot/> outlets
function processSlotOutlet (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ( true && el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead.",
        getRawBindingAttr(el, 'key')
      );
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name.replace(dirRE, ''));
      // support .foo shorthand syntax for the .prop modifier
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        if (
           true &&
          value.trim().length === 0
        ) {
          warn$2(
            ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
          );
        }
        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");
            if (!isDynamic) {
              addHandler(
                el,
                ("update:" + (camelize(name))),
                syncGen,
                null,
                false,
                warn$2,
                list[i]
              );
              if (hyphenate(name) !== camelize(name)) {
                addHandler(
                  el,
                  ("update:" + (hyphenate(name))),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i]
                );
              }
            } else {
              // handler w/ dynamic event name
              addHandler(
                el,
                ("\"update:\"+(" + name + ")"),
                syncGen,
                null,
                false,
                warn$2,
                list[i],
                true // dynamic
              );
            }
          }
        }
        if ((modifiers && modifiers.prop) || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
        if ( true && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.',
            list[i]
          );
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]);
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
       true &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead.",
        el.rawAttrsMap['v-model']
      );
    }
    _el = _el.parent;
  }
}

/*  */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + (map['v-bind']) + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

var model$1 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$1
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative
) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";
  for (var name in events) {
    var handlerCode = genHandler(events[name]);
    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }
  staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
  } else {
    return prefix + staticHandlers
  }
}

function genHandler (handler) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value
    }
    return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? ("return " + (handler.value) + ".apply(null, arguments)")
      : isFunctionExpression
        ? ("return (" + (handler.value) + ").apply(null, arguments)")
        : isFunctionInvocation
          ? ("return " + (handler.value))
          : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" +
    (keys.map(genFilterCode).join('&&')) + ")return null;"
  )
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(keyCode)) + "," +
    "$event.key," +
    "" + (JSON.stringify(keyName)) +
    ")"
  )
}

/*  */

function on (el, dir) {
  if ( true && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */





var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  // fix #11483, Root level <script> tags should not be rendered.
  var code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.
  var originalPreState = state.pre;
  if (el.pre) {
    state.pre = el.pre;
  }
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  state.pre = originalPreState;
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
       true && state.warn(
        "v-once can only be used inside v-for that is keyed. ",
        el.rawAttrsMap['v-once']
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if ( true &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      el.rawAttrsMap['v-for'],
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:" + (genProps(el.attrs)) + ",";
  }
  // DOM props
  if (el.props) {
    data += "domProps:" + (genProps(el.props)) + ",";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.
  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
  }
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if ( true && (
    el.children.length !== 1 || ast.type !== 1
  )) {
    state.warn(
      'Inline-template components must have exactly one child element.',
      { start: el.start }
    );
  }
  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  el,
  slots,
  state
) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return (
      slot.slotTargetDynamic ||
      slot.if ||
      slot.for ||
      containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    )
  });

  // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.
  var needsKey = !!el.if;

  // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.
  if (!needsForceUpdate) {
    var parent = el.parent;
    while (parent) {
      if (
        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
        parent.for
      ) {
        needsForceUpdate = true;
        break
      }
      if (parent.if) {
        needsKey = true;
      }
      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots)
    .map(function (key) { return genScopedSlot(slots[key], state); })
    .join(',');

  return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
}

function hash(str) {
  var hash = 5381;
  var i = str.length;
  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }
  return hash >>> 0
}

function containsSlotChild (el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true
    }
    return el.children.some(containsSlotChild)
  }
  return false
}

function genScopedSlot (
  el,
  state
) {
  var isLegacySyntax = el.attrsMap['slot-scope'];
  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null")
  }
  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot)
  }
  var slotScope = el.slotScope === emptySlotScopeToken
    ? ""
    : String(el.slotScope);
  var fn = "function(" + slotScope + "){" +
    "return " + (el.tag === 'template'
      ? el.if && isLegacySyntax
        ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  // reverse proxy v-slot without scope on this.$slots
  var reverseProxy = slotScope ? "" : ",proxy:true";
  return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      var normalizationType = checkSkip
        ? state.maybeComponent(el$1) ? ",1" : ",0"
        : "";
      return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
    }
    var normalizationType$1 = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } else if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? (",function(){return " + children + "}") : '');
  var attrs = el.attrs || el.dynamicAttrs
    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      }); }))
    : null;
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var staticProps = "";
  var dynamicProps = "";
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);
    if (prop.dynamic) {
      dynamicProps += (prop.name) + "," + value + ",";
    } else {
      staticProps += "\"" + (prop.name) + "\":" + value + ",";
    }
  }
  staticProps = "{" + (staticProps.slice(0, -1)) + "}";
  if (dynamicProps) {
    return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
  } else {
    return staticProps
  }
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */



// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode (node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          var range = node.rawAttrsMap[name];
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), warn, range);
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, (name + "=\"" + value + "\""), warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), warn, range);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), warn, range);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent (exp, text, warn, range) {
  var stripped = exp.replace(stripStringRE, '');
  var keywordMatch = stripped.match(unaryOperatorsRE);
  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim()),
      range
    );
  }
  checkExpression(exp, text, warn, range);
}

function checkFor (node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier (
  ident,
  type,
  text,
  warn,
  range
) {
  if (typeof ident === 'string') {
    try {
      new Function(("var " + ident + "=_"));
    } catch (e) {
      warn(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())), range);
    }
  }
}

function checkExpression (exp, text, warn, range) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      warn(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
        range
      );
    } else {
      warn(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n",
        range
      );
    }
  }
}

function checkFunctionParameterExpression (exp, text, warn, range) {
  try {
    new Function(exp, '');
  } catch (e) {
    warn(
      "invalid function parameter expression: " + (e.message) + " in\n\n" +
      "    " + exp + "\n\n" +
      "  Raw expression: " + (text.trim()) + "\n",
      range
    );
  }
}

/*  */

var range = 2;

function generateCodeFrame (
  source,
  start,
  end
) {
  if ( start === void 0 ) start = 0;
  if ( end === void 0 ) end = source.length;

  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];
  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) { continue }
        res.push(("" + (j + 1) + (repeat$1(" ", 3 - String(j + 1).length)) + "|  " + (lines[j])));
        var lineLength = lines[j].length;
        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }
          count += lineLength + 1;
        }
      }
      break
    }
  }
  return res.join('\n')
}

function repeat$1 (str, n) {
  var result = '';
  if (n > 0) {
    while (true) { // eslint-disable-line
      if (n & 1) { result += str; }
      n >>>= 1;
      if (n <= 0) { break }
      str += str;
    }
  }
  return result
}

/*  */



function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (true) {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1(
              "Error compiling template:\n\n" + (e.msg) + "\n\n" +
              generateCodeFrame(template, e.start, e.end),
              vm
            );
          });
        } else {
          warn$$1(
            "Error compiling template:\n\n" + template + "\n\n" +
            compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
            vm
          );
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
        } else {
          compiled.tips.forEach(function (msg) { return tip(msg, vm); });
        }
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if ( true && options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = { msg: msg };
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }
            (tip ? tips : errors).push(data);
          };
        }
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;

      var compiled = baseCompile(template.trim(), finalOptions);
      if (true) {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
     true && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ( true && !template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);


/***/ }),

/***/ "./resources/data/data.json":
/*!**********************************!*\
  !*** ./resources/data/data.json ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ohlcv":[],"offchart":[{"name":"MACD","type":"MACD","data":[],"settings":{"histColors":["#35a776","#79e0b3","#e54150","#ea969e"]}}],"tools":[{"type":"Cursor","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxQTFRFAAAATU1NTU1NTU1NwlMHHwAAAAR0Uk5TAOvhxbpPrUkAAAAkSURBVHicY2BgYHBggAByabxg1WoGBq2pRCk9AKUbcND43AEAufYHlSuusE4AAAAASUVORK5CYII="},{"type":"LineToolSegment","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAlQTFRFAAAATU1NJCQkCxcHIQAAAAN0Uk5TAP8SmutI5AAAACxJREFUeJxjYMACGAMgNAsLdpoVKi8AVe8A1QblQlWRKt0AoULw2w1zGxoAABdiAviQhF/mAAAAAElFTkSuQmCC"},{"type":"LineToolExtended","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAANElEQVR4nGNggABGEMEEIlhABAeI+AASF0AlHmAqA4kzKAAx8wGQuAMKwd6AoYzBAWonAwAcLwTgNfJ3RQAAAABJRU5ErkJggg=="}],"tool":"Cursor"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/mainM.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _MainM_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainM.vue */ "./src/MainM.vue");


new vue__WEBPACK_IMPORTED_MODULE_1__["default"]({
  el: '#appM',
  render: function render(h) {
    return h(_MainM_vue__WEBPACK_IMPORTED_MODULE_0__["default"]);
  }
});
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL2pzL21haW5NLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLGdIQUErQzs7Ozs7Ozs7Ozs7QUNBL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHNEQUFRO0FBQzNCLFVBQVUsbUJBQU8sQ0FBQyxrRUFBVztBQUM3QixVQUFVLG1CQUFPLENBQUMsd0VBQWlCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pOQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7Ozs7Ozs7Ozs7O0FDdkRyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLG9CQUFv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UUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNB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QUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnREFBZ0QsK0JBQW1CO0FBQ25FLENBQUM7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7QUFHRCxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FB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O0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUEscUVBQXFFO0FBQ3JFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7QUFHRCxDQUFDOzs7QUFHRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7QUFHRCxDQUFDOzs7QUFHRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7QUFNRCxpQ0FBaUMsNkRBQTZELHlDQUF5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QSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QixvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1Qjs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFD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QTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0EsK0NBQStDLCtCQUFtQjtBQUNsRSxDQUFDOztBQUVELENBQUM7Ozs7QUFJRDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCwrQkFBbUI7QUFDckUsQ0FBQzs7QUFFRCxDQUFDOzs7O0FBSUQ7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsd0JBQXdCO0FBQ25DO0FBQ0E7QUFD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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0EsaURB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TTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7Ozs7Ozs7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RU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLElBQUk7QUFDdkIsV0FBVyxRQUFRLElBQUk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFVBQVU7QUFDVixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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YTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FB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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFD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QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxzQ0FBc0M7QUFDbEgsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELElBQUksSUFBSTtBQUNSLG1EQUFtRCxrQkFBa0IsZ0JBQWdCLGlDQUFtQjtBQUN4RztBQUNBLEVBQUUsS0FBSyxFQUFFOzs7QUFHVCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLFlBQVk7QUFDdkI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRTc4QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7O0FBR3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsZUFBZTtBQUMxQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFD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QVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxlQUFlO0FBQzFCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsQ0FBQztBQUNELCtGQUErRixpRkFBaUYsV0FBVyw4SkFBOEosZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHNCQUFzQixXQUFXLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLGlFQUFpRSxVQUFVOztBQUV6aEMsd0ZBQXdGLGdCQUFnQixzR0FBc0csd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRXpYLDZFQUE2RSx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRS9NOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtB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SjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQW9COztBQUVyQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQW9COztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFNO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQU0sZUFBZSxxQkFBTTtBQUM3QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsd0NBQXdDLHlCQUF5QjtBQUNqRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixTQUFTOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFFUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUssNENBQTRDLCtCQUErQjs7QUFFaEY7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFxQztBQUNyRDtBQUNBLG9CQUFvQixDQUFJO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzND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QUNBO0FBQ0E7O0FBRUEsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBcUM7QUFDekQ7QUFDQSxNQUFNLENBQUU7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJO0FBQ0oseUJBQXlCO0FBQ3pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU0sS0FBSyxFQUVOO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsSUFBcUM7QUFDcEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwrQkFBK0I7QUFDL0IsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0EsTUFBTSxLQUFLLEVBRU47QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkMsNkJBQTZCO0FBQ3hFLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNB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O0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTLElBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakYsNEJBQTRCO0FBQzVCO0FBQ0EsMkJBQTJCO0FBQzNCLHdCQUF3QixpRUFBaUU7QUFDekYsWUFBWSwwRkFBMEY7QUFDdEcsTUFBTSxLQUFLLDBDQUEwQztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Qsc0JBQXNCLCtDQUErQztBQUNyRSxpREFBaUQ7O0FBRWpEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQStDO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNkJBQTZCO0FBQ2xGLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdDQUFnQztBQUNyRixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFB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QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLFNBQVM7QUFDVCxRQUFRO0FBQ1IsUUFBUTtBQUNSLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQSwyQ0FBMkM7QUFDM0MsOERBQThEOztBQUU5RDtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFFQSxJQUFJeUksMkNBQUosQ0FBUTtBQUNKekcsRUFBQUEsRUFBRSxFQUFFLE9BREE7QUFFSnVYLEVBQUFBLE1BQU0sRUFBRSxnQkFBQXJQLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUNvUCxrREFBRCxDQUFMO0FBQUE7QUFGTCxDQUFSLEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5c2xpY2VyL2xpYi9jb21wYXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheXNsaWNlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5c2xpY2VyL2xpYi9zZWFyY2gvYmluYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheXNsaWNlci9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9idWlsZC9jaGFydC1saW5rL2NoYXJ0LWxpbmstZGV2LmpzIiwid2VicGFjazovLy8uL2J1aWxkL2dyaWQtcmVzaXplL2dyaWQtcmVzaXplLWRldi5qcyIsIndlYnBhY2s6Ly8vLi9idWlsZC9sZWdlbmQtYnV0dG9ucy9sZWdlbmQtYnV0dG9ucy1kZXYuanMiLCJ3ZWJwYWNrOi8vLy4vYnVpbGQvc2V0dGluZ3Mtd2luL3NldHRpbmdzLXdpbi1kZXYuanMiLCJ3ZWJwYWNrOi8vL3NyYy9NYWluTS52dWUiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZSIsIndlYnBhY2s6Ly8vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlIiwid2VicGFjazovLy9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9BZGRXaW4udnVlIiwid2VicGFjazovLy9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2RyYWdnLmpzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2NoYXJ0LWxpbmsvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9jaGFydC1saW5rL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9jaGFydC1saW5rL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4X2Rldi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RyZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHVmZi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0dWZmL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9NYWluTS52dWU/NjVkZCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWU/ODNiNSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlP2U5NzciLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlPzIzNDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZT8yOTYyIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWU/ZjM5ZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTWFpbk0udnVlPzY5MzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlPzRjYzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZT8wYzEwIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL1NwbGl0dGVyLnZ1ZT82YTEzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWU/MjI2NSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlP2FjNTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90cmFkaW5nLXZ1ZS1qcy9kaXN0L3RyYWRpbmctdnVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dmpzLW92ZXJsYXlzL2Rpc3QvdHZqcy1vdmVybGF5cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTWFpbk0udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL1NwbGl0dGVyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9BZGRXaW4udnVlIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL01haW5NLnZ1ZT9hMzJkIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZT80ZmJiIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1dpbmRvdy52dWU/ODMyNyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS9TcGxpdHRlci52dWU/ZGM2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9BZGRXaW4udnVlPzA5MWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvc2V0dGluZ3Mtd2luL1NldHRpbmdzV2luLnZ1ZT8yYTA4Iiwid2VicGFjazovLy8uL3NyYy9NYWluTS52dWU/NTNmYSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWU/ZGZlYSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlPzRiYzAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlPzFkNDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZT84YThlIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWU/ODUzMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmpzIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbk0uanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIi8qKlxuICogVXRpbGl0eSBjb21wYXJlIGZ1bmN0aW9uc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAxIGlmIGEgPiBiLCAwIGlmIGEgPSBiLCAtMSBpZiBhIDwgYlxuICAgICAqL1xuICAgIG51bWNtcDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBiXG4gICAgICogQHJldHVybnMge051bWJlcn0gMSBpZiBhID4gYiwgMCBpZiBhID0gYiwgLTEgaWYgYSA8IGJcbiAgICAgKi9cbiAgICBzdHJjbXA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICB9XG5cbn07XG4iLCIvKipcbiAqIEluZGV4ZWQgQXJyYXkgQmluYXJ5IFNlYXJjaCBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgY21wID0gcmVxdWlyZShcIi4vY29tcGFyZVwiKSxcbiAgICBiaW4gPSByZXF1aXJlKFwiLi9zZWFyY2gvYmluYXJ5XCIpO1xuXG4vKipcbiAqIE1vZHVsZSBpbnRlcmZhY2UgZGVmaW5pdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWRBcnJheTtcblxuLyoqXG4gKiBJbmRleGVkIEFycmF5IGNvbnN0cnVjdG9yXG4gKlxuICogSXQgbG9hZHMgdGhlIGFycmF5IGRhdGEsIGRlZmluZXMgdGhlIGluZGV4IGZpZWxkIGFuZCB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICogdG8gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIGlzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbmRleCBpcyB0aGUgb2JqZWN0J3MgcHJvcGVydHkgdXNlZCB0byBzZWFyY2ggdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRBcnJheShkYXRhLCBpbmRleCkge1xuXG4gICAgLy8gaXMgZGF0YSBzb3J0YWJsZSBhcnJheSBvciBhcnJheS1saWtlIG9iamVjdD9cbiAgICBpZiAoIXV0aWwuaXNTb3J0YWJsZUFycmF5TGlrZShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhXCIpO1xuXG4gICAgLy8gaXMgaW5kZXggYSB2YWxpZCBwcm9wZXJ0eT9cbiAgICBpZiAoIWluZGV4IHx8IGRhdGEubGVuZ3RoID4gMCAmJiAhKGluZGV4IGluIGRhdGFbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGV4XCIpO1xuXG4gICAgLy8gZGF0YSBhcnJheVxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBuYW1lIG9mIHRoZSBpbmRleCBwcm9wZXJ0eVxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcblxuICAgIC8vIHNldCBpbmRleCBib3VuZGFyeSB2YWx1ZXNcbiAgICB0aGlzLnNldEJvdW5kYXJpZXMoKTtcblxuICAgIC8vIGRlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgIHRoaXMuY29tcGFyZSA9IHR5cGVvZiB0aGlzLm1pbnYgPT09IFwibnVtYmVyXCIgPyBjbXAubnVtY21wIDogY21wLnN0cmNtcDtcblxuICAgIC8vIGRlZmF1bHQgc2VhcmNoIGZ1bmN0aW9uXG4gICAgdGhpcy5zZWFyY2ggPSBiaW4uc2VhcmNoO1xuXG4gICAgLy8gY2FjaGUgb2YgaW5kZXggdmFsdWVzIHRvIGFycmF5IHBvc2l0aW9uc1xuICAgIC8vIGVhY2ggdmFsdWUgc3RvcmVzIGFuIG9iamVjdCBhcyB7IGZvdW5kOiB0cnVlfGZhbHNlLCBpbmRleDogYXJyYXktaW5kZXggfVxuICAgIHRoaXMudmFscG9zID0ge307XG5cbiAgICAvLyBjdXJzb3IgYW5kIGFkamFjZW50IHBvc2l0aW9uc1xuICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgIHRoaXMubmV4dGhpZ2ggPSBudWxsO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRvIGNvbXBhcmUgaW5kZXggdmFsdWVzIHRoYXQgcmV0dXJuZXMgMSwgMCwgLTFcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zZXRDb21wYXJlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuXG4gICAgdGhpcy5jb21wYXJlID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc2VhcmNoIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gc2VhcmNoIGluZGV4IHZhbHVlcyBpbiB0aGUgYXJyYXkgb2Ygb2JqZWN0c1xuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLnNldFNlYXJjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcblxuICAgIHRoaXMuc2VhcmNoID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvcnQgdGhlIGRhdGEgYXJyYXkgYnkgaXRzIGluZGV4IHByb3BlcnR5XG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgIC8vIHNvcnQgdGhlIGFycmF5XG4gICAgdGhpcy5kYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY29tcGFyZShhW2luZGV4XSwgYltpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgYm91bmRhcnkgdmFsdWVzXG4gICAgdGhpcy5zZXRCb3VuZGFyaWVzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5zcGVjdCBhbmQgc2V0IHRoZSBib3VuZGFyaWVzIG9mIHRoZSBpbnRlcm5hbCBkYXRhIGFycmF5XG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuc2V0Qm91bmRhcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgdGhpcy5taW52ID0gZGF0YS5sZW5ndGggJiYgZGF0YVswXVtpbmRleF07XG4gICAgdGhpcy5tYXh2ID0gZGF0YS5sZW5ndGggJiYgZGF0YVtkYXRhLmxlbmd0aCAtIDFdW2luZGV4XTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhcbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGluZGV4IGlzIHRoZSBpZCBvZiB0aGUgcmVxdWVzdGVkIG9iamVjdFxuICogQHJldHVybnMge051bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5XG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBjaGVjayBkYXRhIGhhcyBvYmplY3RzXG4gICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRoaWdoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGhlIHJlcXVlc3QgaXMgd2l0aGluIHJhbmdlXG4gICAgaWYgKHRoaXMuY29tcGFyZSh2YWx1ZSwgdGhpcy5taW52KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRoaWdoID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbXBhcmUodmFsdWUsIHRoaXMubWF4dikgPT09IDEpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRsb3cgPSB0aGlzLmRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB2YWxwb3MgPSB0aGlzLnZhbHBvcyxcbiAgICAgICAgcG9zID0gdmFscG9zW3ZhbHVlXTtcblxuICAgIC8vIGlmIHRoZSByZXF1ZXN0IGlzIG1lbW9yaXplZCwganVzdCBnaXZlIGl0IGJhY2tcbiAgICBpZiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MuZm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gcG9zLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5uZXh0bG93ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmV4dGhpZ2ggPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZXh0bG93ID0gcG9zLnByZXY7XG4gICAgICAgICAgICB0aGlzLm5leHRoaWdoID0gcG9zLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gaWYgbm90LCBkbyB0aGUgc2VhcmNoXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuc2VhcmNoLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIHRoaXMuY3Vyc29yID0gcmVzdWx0LmluZGV4O1xuICAgIHRoaXMubmV4dGxvdyA9IHJlc3VsdC5wcmV2O1xuICAgIHRoaXMubmV4dGhpZ2ggPSByZXN1bHQubmV4dDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhcbiAqXG4gKiBXaGVuIG5vIHZhbHVlIGlzIGdpdmVuLCB0aGUgZnVuY3Rpb24gd2lsbCBkZWZhdWx0IHRvIHRoZSBsYXN0IGZldGNoZWQgaXRlbS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcHRpb25hbF0gaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgZm91bmQgb2JqZWN0IG9yIG51bGxcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpXG4gICAgICAgIHRoaXMuZmV0Y2godmFsdWUpO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMuY3Vyc29yO1xuICAgIHJldHVybiBwb3MgIT09IG51bGwgPyB0aGlzLmRhdGFbcG9zXSA6IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBhbiBzbGljZSBvZiB0aGUgZGF0YSBhcnJheVxuICpcbiAqIEJvdW5kYXJpZXMgaGF2ZSB0byBiZSBpbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJlZ2luIGluZGV4IGlzIHRoZSBpZCBvZiB0aGUgcmVxdWVzdGVkIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBlbmQgaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgc2xpY2Ugb2YgZGF0YSBhcnJheSBvciBbXVxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLmdldFJhbmdlID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQpIHtcbiAgICAvLyBjaGVjayBpZiBib3VuZGFyaWVzIGFyZSBpbiBvcmRlclxuICAgIGlmICh0aGlzLmNvbXBhcmUoYmVnaW4sIGVuZCkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIGZldGNoIHN0YXJ0IGFuZCBkZWZhdWx0IHRvIHRoZSBuZXh0IGluZGV4IGFib3ZlXG4gICAgdGhpcy5mZXRjaChiZWdpbik7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5jdXJzb3IgfHwgdGhpcy5uZXh0aGlnaDtcblxuICAgIC8vIGZldGNoIGZpbmlzaCBhbmQgZGVmYXVsdCB0byB0aGUgbmV4dCBpbmRleCBiZWxvd1xuICAgIHRoaXMuZmV0Y2goZW5kKTtcbiAgICB2YXIgZmluaXNoID0gdGhpcy5jdXJzb3IgfHwgdGhpcy5uZXh0bG93O1xuXG4gICAgLy8gaWYgYW55IGJvdW5kYXJ5IGlzIG5vdCBzZXQsIHJldHVybiBubyByYW5nZVxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBmaW5pc2ggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIHJldHVybiByYW5nZVxuICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2Uoc3RhcnQsIGZpbmlzaCArIDEpO1xufTtcbiIsIi8qKlxuICogQmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvblxuICovXG5cbi8qKlxuICogTWFpbiBzZWFyY2ggcmVjdXJzaXZlIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGxvb3AoZGF0YSwgbWluLCBtYXgsIGluZGV4LCB2YWxwb3MpIHtcblxuICAgIC8vIHNldCBjdXJyZW50IHBvc2l0aW9uIGFzIHRoZSBtaWRkbGUgcG9pbnQgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgIHZhciBjdXJyID0gKG1heCArIG1pbikgPj4+IDE7XG5cbiAgICAvLyBjb21wYXJlIGN1cnJlbnQgaW5kZXggdmFsdWUgd2l0aCB0aGUgb25lIHdlIGFyZSBsb29raW5nIGZvclxuICAgIHZhciBkaWZmID0gdGhpcy5jb21wYXJlKGRhdGFbY3Vycl1bdGhpcy5pbmRleF0sIGluZGV4KTtcblxuICAgIC8vIGZvdW5kP1xuICAgIGlmICghZGlmZikge1xuICAgICAgICByZXR1cm4gdmFscG9zW2luZGV4XSA9IHtcbiAgICAgICAgICAgIFwiZm91bmRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiaW5kZXhcIjogY3VycixcbiAgICAgICAgICAgIFwicHJldlwiOiBudWxsLFxuICAgICAgICAgICAgXCJuZXh0XCI6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHBvc2l0aW9ucyBhdmFpbGFibGU/XG4gICAgaWYgKG1pbiA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHBvc1tpbmRleF0gPSB7XG4gICAgICAgICAgICBcImZvdW5kXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJpbmRleFwiOiBudWxsLFxuICAgICAgICAgICAgXCJwcmV2XCI6IChkaWZmIDwgMCkgPyBtYXggOiBtYXggLSAxLFxuICAgICAgICAgICAgXCJuZXh0XCI6IChkaWZmIDwgMCkgPyBtYXggKyAxIDogbWF4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gY29udGludWUgbG9va2luZyBmb3IgaW5kZXggaW4gb25lIG9mIHRoZSByZW1haW5pbmcgYXJyYXkgaGFsdmVzXG4gICAgLy8gY3VycmVudCBwb3NpdGlvbiBjYW4gYmUgc2tlcHQgYXMgaW5kZXggaXMgbm90IHRoZXJlLi4uXG4gICAgaWYgKGRpZmYgPiAwKVxuICAgICAgICByZXR1cm4gbG9vcC5jYWxsKHRoaXMsIGRhdGEsIG1pbiwgY3VyciAtIDEsIGluZGV4LCB2YWxwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxvb3AuY2FsbCh0aGlzLCBkYXRhLCBjdXJyICsgMSwgbWF4LCBpbmRleCwgdmFscG9zKTtcbn1cblxuLyoqXG4gKiBTZWFyY2ggYm9vdHN0cmFwXG4gKiBUaGUgZnVuY3Rpb24gaGFzIHRvIGJlIGV4ZWN1dGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBJbmRleGVkQXJyYXkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHNlYXJjaChpbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHJldHVybiBsb29wLmNhbGwodGhpcywgZGF0YSwgMCwgZGF0YS5sZW5ndGggLSAxLCBpbmRleCwgdGhpcy52YWxwb3MpO1xufVxuXG4vKipcbiAqIEV4cG9ydCBzZWFyY2ggZnVuY3Rpb25cbiAqL1xubW9kdWxlLmV4cG9ydHMuc2VhcmNoID0gc2VhcmNoO1xuIiwiLyoqXG4gKiBVdGlscyBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBhcnJheS1saWtlIG9iamVjdFxuICpcbiAqIEBjcmVkaXQgSmF2YXNjcmlwdDogVGhlIERlZmluaXRpdmUgR3VpZGUsIE8nUmVpbGx5LCAyMDExXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKG8pIHtcbiAgICBpZiAobyAmJiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG8gaXMgbm90IG51bGwsIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiAgICAgICAgICAgICAvLyBvIGlzIGFuIG9iamVjdFxuICAgICAgICBpc0Zpbml0ZShvLmxlbmd0aCkgJiYgICAgICAgICAgICAgICAgLy8gby5sZW5ndGggaXMgYSBmaW5pdGUgbnVtYmVyXG4gICAgICAgIG8ubGVuZ3RoID49IDAgJiYgICAgICAgICAgICAgICAgICAgICAvLyBvLmxlbmd0aCBpcyBub24tbmVnYXRpdmVcbiAgICAgICAgby5sZW5ndGggPT09IE1hdGguZmxvb3Ioby5sZW5ndGgpICYmIC8vIG8ubGVuZ3RoIGlzIGFuIGludGVnZXJcbiAgICAgICAgby5sZW5ndGggPCA0Mjk0OTY3Mjk2KSAgICAgICAgICAgICAgIC8vIG8ubGVuZ3RoIDwgMl4zMlxuICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiBvIGlzIGFycmF5LWxpa2VcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQgaXMgbm90XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgdGhlIHNvcnQgZnVuY3Rpb24gaW4gdGhlIG9iamVjdFxuICovXG5mdW5jdGlvbiBpc1NvcnRhYmxlKG8pIHtcbiAgICBpZiAobyAmJiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG8gaXMgbm90IG51bGwsIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiAgICAgICAgICAgICAvLyBvIGlzIGFuIG9iamVjdFxuICAgICAgICB0eXBlb2Ygby5zb3J0ID09PSBcImZ1bmN0aW9uXCIpICAgICAgICAvLyBvLnNvcnQgaXMgYSBmdW5jdGlvblxuICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiBvIGlzIGFycmF5LWxpa2VcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQgaXMgbm90XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHNvcnRhYmxlLWFycmF5LWxpa2Ugb2JqZWN0c1xuICovXG5tb2R1bGUuZXhwb3J0cy5pc1NvcnRhYmxlQXJyYXlMaWtlID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gaXNBcnJheUxpa2UobykgJiYgaXNTb3J0YWJsZShvKTtcbn07XG4iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBNYWluIGZyb20gJy4uLy4uL3NyYy9leHRlbnNpb25zL2NoYXJ0LWxpbmsvbWFpbi5qcydcbk1haW4uX19uYW1lX18gPSAnY2hhcnQtbGluaydcblxuY29uc3Qgd2lkZ2V0cyA9IHsgIH1cbmNvbnN0IGNvbXBvbmVudHMgPSB7ICB9XG5jb25zdCBvdmVybGF5cyA9IHsgIH1cbmNvbnN0IGNvbG9ycGFja3MgPSB7ICB9XG5jb25zdCBza2lucyA9IHsgIH1cblxuY29uc3QgUGFjayA9IHtcbiAgICB3aWRnZXRzLFxuICAgIGNvbXBvbmVudHMsXG4gICAgb3ZlcmxheXMsXG4gICAgY29sb3JwYWNrcyxcbiAgICBza2lucyxcbiAgICBNYWluXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhY2tcblxuZXhwb3J0IHtcbiAgICB3aWRnZXRzLFxuICAgIGNvbXBvbmVudHMsXG4gICAgb3ZlcmxheXMsXG4gICAgY29sb3JwYWNrcyxcbiAgICBza2lucyxcbiAgICBNYWluXG59IiwiXG5cbi8vIC0tLS0tLS0tIERldmVsb3BtZW50IGV4dGVuc2lvbiBpbmRleCAtLS0tLS0tLS1cbi8vICAgICAgISBUSElTIEZJTEUgV0FTIEFVVE8tR0VORVJBVEVEICFcbi8vXG4vLyBZb3UgY2FuIG92ZXJ3cml0ZSBpdCBhbmQgaGF2ZSBmdW4sIHRvIHJlc3RvcmVcbi8vIHRoZSBkZWZhdWx0IHN0YXRlOiAnbnBtIHJ1biBjb21waWxlJ1xuXG5pbXBvcnQgTWFpbiBmcm9tICcuLi8uLi9zcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS9tYWluLmpzJ1xuTWFpbi5fX25hbWVfXyA9ICdncmlkLXJlc2l6ZSdcblxuY29uc3Qgd2lkZ2V0cyA9IHsgIH1cbmNvbnN0IGNvbXBvbmVudHMgPSB7ICB9XG5jb25zdCBvdmVybGF5cyA9IHsgIH1cbmNvbnN0IGNvbG9ycGFja3MgPSB7ICB9XG5jb25zdCBza2lucyA9IHsgIH1cblxuY29uc3QgUGFjayA9IHtcbiAgICB3aWRnZXRzLFxuICAgIGNvbXBvbmVudHMsXG4gICAgb3ZlcmxheXMsXG4gICAgY29sb3JwYWNrcyxcbiAgICBza2lucyxcbiAgICBNYWluXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhY2tcblxuZXhwb3J0IHtcbiAgICB3aWRnZXRzLFxuICAgIGNvbXBvbmVudHMsXG4gICAgb3ZlcmxheXMsXG4gICAgY29sb3JwYWNrcyxcbiAgICBza2lucyxcbiAgICBNYWluXG59IiwiXG5cbi8vIC0tLS0tLS0tIERldmVsb3BtZW50IGV4dGVuc2lvbiBpbmRleCAtLS0tLS0tLS1cbi8vICAgICAgISBUSElTIEZJTEUgV0FTIEFVVE8tR0VORVJBVEVEICFcbi8vXG4vLyBZb3UgY2FuIG92ZXJ3cml0ZSBpdCBhbmQgaGF2ZSBmdW4sIHRvIHJlc3RvcmVcbi8vIHRoZSBkZWZhdWx0IHN0YXRlOiAnbnBtIHJ1biBjb21waWxlJ1xuXG5pbXBvcnQgTWFpbiBmcm9tICcuLi8uLi9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9tYWluLmpzJ1xuTWFpbi5fX25hbWVfXyA9ICdsZWdlbmQtYnV0dG9ucydcblxuY29uc3Qgd2lkZ2V0cyA9IHsgIH1cbmNvbnN0IGNvbXBvbmVudHMgPSB7ICB9XG5jb25zdCBvdmVybGF5cyA9IHsgIH1cbmNvbnN0IGNvbG9ycGFja3MgPSB7ICB9XG5jb25zdCBza2lucyA9IHsgIH1cblxuY29uc3QgUGFjayA9IHtcbiAgICB3aWRnZXRzLFxuICAgIGNvbXBvbmVudHMsXG4gICAgb3ZlcmxheXMsXG4gICAgY29sb3JwYWNrcyxcbiAgICBza2lucyxcbiAgICBNYWluXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhY2tcblxuZXhwb3J0IHtcbiAgICB3aWRnZXRzLFxuICAgIGNvbXBvbmVudHMsXG4gICAgb3ZlcmxheXMsXG4gICAgY29sb3JwYWNrcyxcbiAgICBza2lucyxcbiAgICBNYWluXG59IiwiXG5cbi8vIC0tLS0tLS0tIERldmVsb3BtZW50IGV4dGVuc2lvbiBpbmRleCAtLS0tLS0tLS1cbi8vICAgICAgISBUSElTIEZJTEUgV0FTIEFVVE8tR0VORVJBVEVEICFcbi8vXG4vLyBZb3UgY2FuIG92ZXJ3cml0ZSBpdCBhbmQgaGF2ZSBmdW4sIHRvIHJlc3RvcmVcbi8vIHRoZSBkZWZhdWx0IHN0YXRlOiAnbnBtIHJ1biBjb21waWxlJ1xuXG5pbXBvcnQgU2V0dGluZ3NXaW4gZnJvbSAnLi4vLi4vc3JjL2V4dGVuc2lvbnMvc2V0dGluZ3Mtd2luL1NldHRpbmdzV2luLnZ1ZSdcbmltcG9ydCBNYWluIGZyb20gJy4uLy4uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9tYWluLmpzJ1xuTWFpbi5fX25hbWVfXyA9ICdzZXR0aW5ncy13aW4nXG5cbmNvbnN0IHdpZGdldHMgPSB7IFNldHRpbmdzV2luIH1cbmNvbnN0IGNvbXBvbmVudHMgPSB7ICB9XG5jb25zdCBvdmVybGF5cyA9IHsgIH1cbmNvbnN0IGNvbG9ycGFja3MgPSB7ICB9XG5jb25zdCBza2lucyA9IHsgIH1cblxuY29uc3QgUGFjayA9IHtcbiAgICB3aWRnZXRzLFxuICAgIFNldHRpbmdzV2luLFxuICAgIGNvbXBvbmVudHMsXG4gICAgb3ZlcmxheXMsXG4gICAgY29sb3JwYWNrcyxcbiAgICBza2lucyxcbiAgICBNYWluXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhY2tcblxuZXhwb3J0IHtcbiAgICB3aWRnZXRzLFxuICAgIFNldHRpbmdzV2luLFxuICAgIGNvbXBvbmVudHMsXG4gICAgb3ZlcmxheXMsXG4gICAgY29sb3JwYWNrcyxcbiAgICBza2lucyxcbiAgICBNYWluXG59IiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJmbGV4LXN0YXJ0IGNvbC0xMCBjb2wteGxsLTEwIGNvbC14bC0xMCBjb2wtbGctMTAgY29sLW1kLTkgY29sLXNtLTEyXCI+XG4gICAgICAgIDxkaXYgaWQ9XCJ0dmpzLWhlYWRlclwiPlxuICAgICAgICAgICAgPGE+PHNwYW4gaWQ9XCJ0b2dnbGVDb250cmFjdHNcIiBjbGFzcz1cIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1wiIGRhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cIiNjb2xsYXBzZUNvbnRyYWN0c1wiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiIGFyaWEtY29udHJvbHM9XCJjb2xsYXBzZUNvbnRyYWN0c1wiPjxpXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJpIGJpLWJyaWVmY2FzZVwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiBDb250cmFjdHM8L2Rpdj48L3NwYW4+PC9hPlxuICAgICAgICAgICAgPGE+PHNwYW4gdi1vbjpjbGljaz1cImNhbmRsZXNcIiBjbGFzcz1cIm1lLTEgYmFkZ2UgYmctbGlnaHQtc2Vjb25kYXJ5XCI+PGkgY2xhc3M9XCJiaSBiaS1iYXItY2hhcnRcIiAvPjxkaXYgY2xhc3M9XCJkLW1kLWlubGluZSBkLW5vbmVcIj4gIENhbmRsZXM8L2Rpdj48L3NwYW4+PC9hPlxuICAgICAgICAgICAgPGE+PHNwYW4gdi1vbjpjbGljaz1cInNwbGluZVwiIGNsYXNzPVwibWUtMSBiYWRnZSBiZy1saWdodC1zZWNvbmRhcnlcIj48aSBjbGFzcz1cImJpIGJpLWdyYXBoLXVwXCIgLz48ZGl2IGNsYXNzPVwiZC1tZC1pbmxpbmUgZC1ub25lXCI+ICBTcGxpbmU8L2Rpdj48L3NwYW4+PC9hPlxuICAgICAgICAgICAgPGE+PHNwYW4gaWQ9XCJ0b2dnbGVJbmZvXCIgY2xhc3M9XCJtZS0xIGJhZGdlIGJnLWxpZ2h0LWluZm9cIiBkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1icy10YXJnZXQ9XCIjY29sbGFwc2VJbmZvc1wiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiIGFyaWEtY29udHJvbHM9XCJjb2xsYXBzZUluZm9zXCI+PGlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmkgYmktaW5mby1jaXJjbGVcIiAvPjxkaXYgY2xhc3M9XCJkLW1kLWlubGluZSBkLW5vbmVcIj4gIEluZm88L2Rpdj48L3NwYW4+PC9hPlxuICAgICAgICAgICAgPGE+PHNwYW4gaWQ9XCJ0b2dnbGVEZXB0aFwiIGNsYXNzPVwibWUtMSBiYWRnZSBiZy1saWdodC1wcmltYXJ5IFwiIGRhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cIiNjb2xsYXBzZURlcHRoXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCIgYXJpYS1jb250cm9scz1cImNvbGxhcHNlRGVwdGhcIj48aVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJiaSBiaS1rYW5iYW5cIiAvPjxkaXYgY2xhc3M9XCJkLW1kLWlubGluZSBkLW5vbmVcIj4gIERlcHRoIFZpZXc8L2Rpdj48L3NwYW4+PC9hPlxuICAgICAgICAgICAgPGE+PHNwYW4gaWQ9XCJ0b2dnbGVPcmRlcnNcIiBjbGFzcz1cIm1lLTEgYmFkZ2UgYmctbGlnaHQtd2FybmluZyBcIiBkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCJcbiAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVwiI2NvbGxhcHNlT3JkZXJzXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCIgYXJpYS1jb250cm9scz1cImNvbGxhcHNlT3JkZXJzXCI+PGlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmkgYmktZmlsZS1iYXItZ3JhcGhcIiAvPjxkaXYgY2xhc3M9XCJkLW1kLWlubGluZSBkLW5vbmVcIj4gIE9yZGVyIEJvb2s8L2Rpdj48L3NwYW4+PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cImNvbGxhcHNlSW5mb3NcIlxuICAgICAgICAgICAgY2xhc3M9XCJjb2xsYXBzZSBjb2wtbGctNCBjb2wtbWQtNSBjb2wtc20tNiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwIFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIiBzdHlsZT1cImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC04XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJjYXJkLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgc3ltYm9sIH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2g0PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLThcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInNob3dfYlwiIGNsYXNzPVwidGV4dC1zdGFydCBmcy0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJzaG93X3BcIiBjbGFzcz1cInRleHQtZW5kXCIgc3R5bGU9XCJmb250LXNpemU6MTRweDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInNob3dfUFwiIGNsYXNzPVwidGV4dC1lbmRcIiBzdHlsZT1cImZvbnQtc2l6ZToxNHB4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG10LTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwibXlSYW5nZUNvbG9yXCIgY2xhc3M9XCJwcm9ncmVzc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwibXlSYW5nZVwiIGNsYXNzPVwicHJvZ3Jlc3MtYmFyIHByb2dyZXNzLWJhci1zdHJpcGVkIHByb2dyZXNzLWJhci1hbmltYXRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIiBhcmlhLXZhbHVlbm93PVwiNTBcIiBhcmlhLXZhbHVlbWluPVwiMFwiIGFyaWEtdmFsdWVtYXg9XCIxMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJ3aWR0aDogODAlXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInNob3dfbFwiIGNsYXNzPVwiY29sIHRleHQtc3RhcnQgdGV4dC1kYW5nZXJcIiBzdHlsZT1cImZvbnQtc2l6ZToxMHB4O1wiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbCB0ZXh0LWRhcmsgdGV4dC1jZW50ZXJcIiBzdHlsZT1cImZvbnQtc2l6ZToxMHB4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXkgUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwic2hvd19oXCIgY2xhc3M9XCJjb2wgdGV4dC1lbmQgdGV4dC1zdWNjZXNzXCIgc3R5bGU9XCJmb250LXNpemU6MTBweDtcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG10LTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhcmsgY2xlYXJmaXhcIj5Wb2x1bWUgMjRIPC9zbWFsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgaWQ9XCJzaG93X3ZcIiBjbGFzcz1cImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiPk1hcmtldCBDYXA8L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBpZD1cInNob3dfbWNcIiBjbGFzcz1cImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiY29sIHRleHQtc3RhcnQgdGV4dC1kYXJrIGNsZWFyZml4XCI+VG90YWwgU3VwcGx5PC9zbWFsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgaWQ9XCJzaG93X3RzXCIgY2xhc3M9XCJjb2wgdGV4dC1lbmQgdGV4dC13YXJuaW5nIGNsZWFyZml4XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJjb2xsYXBzZURlcHRoXCJcbiAgICAgICAgICAgIGNsYXNzPVwiY29sbGFwc2UgY29sLWxnLTYgY29sLW1kLTEwIGNvbC1zbS0xMiBjb2wtMTIgcG9zaXRpb24tYWJzb2x1dGUgc3RpY2t5LXRvcCBjYXJkLTExMCBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkXCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiMxMzE3MjJlNiFpbXBvcnRhbnQ7Ym94LXNoYWRvdzogMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSk7XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiY2hhcnRkaXZcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cImNvbGxhcHNlT3JkZXJzXCJcbiAgICAgICAgICAgIGNsYXNzPVwiY29sbGFwc2UgY29sLWxnLTQgY29sLW1kLTQgY29sLXNtLTYgY29sLTEyIHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTBcIiBzdHlsZT1cIm1heC13aWR0aDoyODBweDtcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkXCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiMxMzE3MjJlNiFpbXBvcnRhbnQ7Ym94LXNoYWRvdzogMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSk7XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtY29udGVudCBteS0xXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJib3hcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cIm1iLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInRleHQtc3RhcnQgcHMtMSB0ZXh0LWRhcmtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInRleHQtY2VudGVyIHBzLTEgdGV4dC1kYXJrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVhbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJ0ZXh0LWVuZCBwZS0xIHRleHQtZGFya1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvdGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwiYXNrc1wiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmV3ZXN0XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cImJpZHNcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFwcC1jb250YWluZXJcIiBzdHlsZT1cIm1hcmdpbi10b3A6NDBweFwiPlxuICAgICAgICAgICAgPHRyYWRpbmctdnVlIDprZXk9XCJyZXNldGtleVwiIHJlZj1cInR2anNcIiA6ZGF0YT1cImRjXCIgOndpZHRoPVwid2lkdGhcIiA6aGVpZ2h0PVwiaGVpZ2h0XCIgOnRpdGxlLXR4dD1cInRpdGxlXCJcbiAgICAgICAgICAgICAgICBjb2xvci10aXRsZT1cIiNmZjlmNDNcIiA6bGVnZW5kLWJ1dHRvbnM9XCJbJ2Rpc3BsYXknLCAnc2V0dGluZ3MnLCAndXAnLCAnZG93bicsICdhZGQnLCAncmVtb3ZlJ11cIlxuICAgICAgICAgICAgICAgIDpjaGFydC1jb25maWc9XCJ7REVGQVVMVF9MRU46MzAsTUlOX1pPT006MX1cIiA6Y29sb3ItYmFjaz1cImNvbG9ycy5jb2xvckJhY2tcIlxuICAgICAgICAgICAgICAgIDpjb2xvci1ncmlkPVwiY29sb3JzLmNvbG9yR3JpZFwiIDpjb2xvci10ZXh0PVwiY29sb3JzLmNvbG9yVGV4dFwiIDpleHRlbnNpb25zPVwiZXh0XCIgOm92ZXJsYXlzPVwib3ZzXCJcbiAgICAgICAgICAgICAgICA6bmlnaHQ9XCJuaWdodFwiIDpyZXNldGtleT1cInJlc2V0a2V5XCIgOngtc2V0dGluZ3M9XCJ4c2V0dFwiIDp0aW1lem9uZT1cInRpbWV6b25lXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgVHJhZGluZ1Z1ZSwgRGF0YUN1YmUgfSBmcm9tICd0cmFkaW5nLXZ1ZS1qcydcbmltcG9ydCBPdmVybGF5cyBmcm9tICd0dmpzLW92ZXJsYXlzJ1xuaW1wb3J0IERhdGEgZnJvbSAnLi4vcmVzb3VyY2VzL2RhdGEvZGF0YS5qc29uJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vc3R1ZmYvdXRpbHMuanMnXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9zdHVmZi9jb25zdGFudHMuanMnXG5pbXBvcnQgU3RyZWFtIGZyb20gJy4vc3RyZWFtLmpzJ1xuaW1wb3J0IEV4dGVuc2lvbnMgZnJvbSAnLi9pbmRleF9kZXYnXG5cbi8vIEdldHRpbicgZGF0YSB0aHJvdWdoIHdlYnBlY2sgcHJveHlcbmNvbnN0IHN5bWJvbHNtID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKVszXSsndXNkdCdcbmNvbnN0IHN5bWJvbGJnID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvVXBwZXJDYXNlKCkuc3BsaXQoJy8nKVszXSsnVVNEVCdcbmNvbnN0IFVSTCA9IGBodHRwczovL2JpbmFuY2Utd2F0Y2gtd3JhcHBlci5oZXJva3VhcHAuY29tL2h0dHBzOi8vYXBpLmJpbmFuY2UuY29tL2FwaS92MS9rbGluZXM/c3ltYm9sPWBcbmNvbnN0IFdTUyA9IGB3c3M6Ly9zdHJlYW0uYmluYW5jZS5jb206OTQ0My93cy8ke3N5bWJvbHNtfUBhZ2dUcmFkZWBcbmNvbnN0IGRhdGFzID0gYGRhdGFzZXRzLmJpbmFuY2UtJHtzeW1ib2xzbX1gXG4vL2NvbnN0IFBPUlQgPSBsb2NhdGlvbi5wb3J0XG4vL2NvbnN0IFVSTCA9IGBodHRwOi8vbG9jYWxob3N0OiR7UE9SVH0vYXBpL3YxL2tsaW5lcz9zeW1ib2w9YFxuLy9jb25zdCBXU1MgPSBgd3M6Ly9sb2NhbGhvc3Q6JHtQT1JUfS93cy8ke3N5bWJvbHNtfUBhZ2dUcmFkZWBcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdBcHAnLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgVHJhZGluZ1Z1ZVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRjOiBuZXcgRGF0YUN1YmUoRGF0YSksXG4gICAgICAgICAgICB0aXRsZTogc3ltYm9sYmcsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGxvZ19zY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIHN5bWJvbDogc3ltYm9sYmcsXG4gICAgICAgICAgICBpbmRleF9iYXNlZDogdHJ1ZSxcbiAgICAgICAgICAgIHRpbWV6b25lOiB0aGlzLnRpbWV6b25lZCgpLFxuICAgICAgICAgICAgeHNldHQ6IHtcbiAgICAgICAgICAgICAgICAnZ3JpZC1yZXNpemUnOiB7IG1pbl9oZWlnaHQ6IDMwIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvdnM6IE9iamVjdC52YWx1ZXMoT3ZlcmxheXMpLFxuICAgICAgICAgICAgZXh0OiBPYmplY3QudmFsdWVzKEV4dGVuc2lvbnMpLFxuICAgICAgICAgICAgbmlnaHQ6IHRydWUsXG4gICAgICAgICAgICB0b3A6IDUwLFxuICAgICAgICAgICAgcmVzZXRrZXk6IDBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29sb3JzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmlnaHQgPyB7fSA6IHtcbiAgICAgICAgICAgICAgICBjb2xvckJhY2s6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBjb2xvckdyaWQ6ICcjZWVlJyxcbiAgICAgICAgICAgICAgICBjb2xvclRleHQ6ICcjMzMzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSlcbiAgICAgICAgbGV0IHEgPSB0aGlzLndpbl9xdWVyeSgpXG4gICAgICAgIGlmIChxLm5tID09PSAnZmFsc2UnKSB0aGlzLm5pZ2h0ID0gZmFsc2VcbiAgICAgICAgaWYgKHEub3YpIHRoaXMuY3VycmVudCA9IHEub3ZcbiAgICAgICAgaWYgKHEuaGVhZGVyID09PSAnZmFsc2UnKSB0aGlzLnRvcCA9IDBcbiAgICAgICAgdGhpcy5vblJlc2l6ZSgpLFxuICAgICAgICB3aW5kb3cuZGMgPSB0aGlzLmRjXG4gICAgICAgIHdpbmRvdy50diA9IHRoaXMuJHJlZnMudHZqc1xuICAgICAgICAvLyBMb2FkIHRoZSBsYXN0IGRhdGEgY2h1bmsgJiBpbml0IERhdGFDdWJlOlxuICAgICAgICBsZXQgbm93ID0gVXRpbHMubm93KClcbiAgICAgICAgdGhpcy5sb2FkX2NodW5rKFtub3cgLSBDb25zdC5IT1VSNCwgbm93XSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGRjLmRhdGEuY2hhcnQuZGF0YSA9IGRhdGFbJ2NoYXJ0LmRhdGEnXVxuICAgICAgICAgICAgLy8gUmVnaXN0ZXIgb25yYW5nZSBjYWxsYmFjayAmIEFuZCBhIHN0cmVhbSBvZiB0cmFkZXNcbiAgICAgICAgICAgIHRoaXMuZGMub25yYW5nZSh0aGlzLmxvYWRfY2h1bmspXG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBTdHJlYW0oV1NTKVxuICAgICAgICAgICAgdGhpcy5zdHJlYW0ub250cmFkZXMgPSB0aGlzLm9uX3RyYWRlc1xuICAgICAgICAgICAgd2luZG93LmRjID0gdGhpcy5jaGFydCAgICAgIC8vIERlYnVnXG4gICAgICAgICAgICB3aW5kb3cudHYgPSB0aGlzLiRyZWZzLnR2anMgLy8gRGVidWdcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplKVxuICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHRoaXMuc3RyZWFtLm9mZigpXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIG9uUmVzaXplKCkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgJzUwMCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuNTNcbiAgICAgICAgICAgIH0vKiBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+ICc3NjgnICAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8PSAnOTkyJykge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAod2luZG93LmlubmVyV2lkdGggLSAod2luZG93LmlubmVyV2lkdGggKiAwLjI2KSlcbiAgICAgICAgICAgIH0qLyBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGggKiAwLjdcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuNjhcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuICAgICAgICBzcGxpbmUgKCkge1xuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnR5cGUgPSBcIlNwbGluZVwiXG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudGYgPSBcIjFtXCJcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudHZqcy5yZXNldENoYXJ0KClcbiAgICAgICAgfSxcbiAgICAgICAgY2FuZGxlcyAoKSB7XG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudHlwZSA9IFwiQ2FuZGxlc1wiXG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudGYgPSBcIjFtXCJcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudHZqcy5yZXNldENoYXJ0KClcbiAgICAgICAgfSxcbiAgICAgICAgeGJhcnMgKCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLm92cyA9ICdYT2hsY0JhcnMnXG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudGYgPSBcIjFtXCJcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudHZqcy5yZXNldENoYXJ0KClcbiAgICAgICAgfSxcbiAgICAgICAgdHJhZGUgKCkge1xuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnR5cGUgPSBcIlNwbGluZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHdpbl9xdWVyeSgpIHtcbiAgICAgICAgICAgIGxldCBxcyA9IChmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEgPT0gXCJcIikgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgIHZhciBiID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwPWFbaV0uc3BsaXQoJz0nLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBiW3BbMF1dID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYltwWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwWzFdLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgIH0pKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpLnNwbGl0KCcmJykpO1xuICAgICAgICAgICAgcmV0dXJuIHFzXG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KHN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgc3ViID0gT2JqZWN0LmtleXMoc3RhdGUpLmZpbHRlcih4ID0+IHN0YXRlW3hdKVxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zID0gc3ViLm1hcCh4ID0+IEV4dGVuc2lvbnNbeF0pXG4gICAgICAgICAgICB0aGlzLnJlc2V0a2V5KytcbiAgICAgICAgfSxcbiAgICAgICAgb25zZWxlY3QoaWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGlkXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWV6b25lZCgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgbWludXRlcyA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gb2Zmc2V0IDwgMCA/IFwiXCIgOiBcIi1cIjtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwcmVmaXgraG91cnMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBOZXcgZGF0YSBoYW5kbGVyLiBTaG91bGQgcmV0dXJuIFByb21pc2UsIG9yXG4gICAgICAgIC8vIHVzZSBjYWxsYmFjazogbG9hZF9jaHVuayhyYW5nZSwgdGYsIGNhbGxiYWNrKVxuICAgICAgICBhc3luYyBsb2FkX2NodW5rKHJhbmdlKSB7XG4gICAgICAgICAgICBsZXQgW3QxLCB0Ml0gPSByYW5nZVxuICAgICAgICAgICAgbGV0IHggPSBzeW1ib2xiZ1xuICAgICAgICAgICAgbGV0IHEgPSBgJHt4fSZpbnRlcnZhbD0xbSZzdGFydFRpbWU9JHt0MX0mZW5kVGltZT0ke3QyfWBcbiAgICAgICAgICAgIGxldCByID0gYXdhaXQgZmV0Y2goVVJMICsgcSkudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHRoaXMucGFyc2VfYmluYW5jZShyKSlcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGFyc2UgYSBzcGVjaWZpYyBleGNoYW5nZSBmb3JtYXRcbiAgICAgICAgcGFyc2VfYmluYW5jZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHJldHVybiBbXVxuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKHggPT4ge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB4W2ldID0gcGFyc2VGbG9hdCh4W2ldKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geC5zbGljZSgwLDYpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnY2hhcnQuZGF0YSc6IGRhdGEsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uX3RyYWRlcyh0cmFkZSkge1xuICAgICAgICAgICAgdGhpcy5kYy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHQ6IHRyYWRlLlQsICAgICAvLyBFeGNoYW5nZSB0aW1lIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICBwcmljZTogcGFyc2VGbG9hdCh0cmFkZS5wKSwgICAvLyBUcmFkZSBwcmljZVxuICAgICAgICAgICAgICAgIHZvbHVtZTogcGFyc2VGbG9hdCh0cmFkZS5xKSwgIC8vIFRyYWRlIGFtb3VudFxuICAgICAgICAgICAgICAgIGRhdGFzIDogWyAvLyBVcGRhdGUgZGF0YXNldFxuICAgICAgICAgICAgICAgICAgICB0cmFkZS5ULFxuICAgICAgICAgICAgICAgICAgICB0cmFkZS5tID8gMCA6IDEsICAgICAgICAgIC8vIFNlbGwgb3IgQnV5XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodHJhZGUucSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodHJhZGUucClcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlciBvbmNoYXJ0L29mZmNoYXJ0IHVwZGF0ZXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuLmFwcC1jb250ZW50IHtcbiAgICBwYWRkaW5nOiBjYWxjKDJyZW0gKyAyLjQ1cmVtKSAwIDAgMHJlbSAhaW1wb3J0YW50O1xuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbn1cbkBtZWRpYSAobWF4LXdpZHRoOiA3NjcuOThweCl7XG4gICAgaHRtbCBib2R5Lm5hdmJhci1zdGlja3kgLmFwcC1jb250ZW50IHtcbiAgICAgICAgcGFkZGluZzogY2FsYygxcmVtIC0gMC44cmVtICsgNC40NXJlbSkgMCAwIDAgIWltcG9ydGFudDtcbiAgICB9XG59XG4uZmxleGVkIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiBub3dyYXA7XG59XG5cbiNhcHAtY29uYWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcbn1cblxuLyogQG1lZGlhIChtYXgtd2lkdGg6IDc2Ny45OHB4KXtcbiAgICAjYXBwLWNvbmFpbmVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAgfVxufSAqL1xuI3RyYWRlYmFyIHtcbiAgICBjb2xvcjogI2RkZDtcbn1cblxuI3R2anMtaGVhZGVyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGhlaWdodDogNDBweDtcbiAgICBjb2xvcjogI2RkZDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTIxODI2O1xufVxuXG4ubmlnaHQtbW9kZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMTVweDtcbiAgICByaWdodDogMjBweDtcbn1cblxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMC1jYW52YXMsXG4jdHJhZGluZy12dWUtanMtc2lkZWJhci0wLWNhbnZhcyxcbiN0cmFkaW5nLXZ1ZS1qcy1ncmlkLTEtY2FudmFzLFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMS1jYW52YXMsXG4jdHJhZGluZy12dWUtanMtYm90YmFyLWNhbnZhcyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAgMCAwIC8gMCUpICFpbXBvcnRhbnQ7XG59XG5cbiN0cmFkaW5nLXZ1ZS10Yml0ZW0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigxOCwgMjQsIDM4KTtcbn1cblxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LWRldmljZS13aWR0aDogNDgwcHgpIHtcbiAgICAudGYtc2VsZWN0b3Ige1xuICAgICAgICB0b3A6IDUwcHg7XG4gICAgICAgIHJpZ2h0OiAxNDBweDtcbiAgICAgICAgbWF4LXdpZHRoOiAxNDBweDtcbiAgICAgICAgZm9udDogMTJweCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsXG4gICAgICAgICAgICBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLFxuICAgICAgICAgICAgRmlyYSBTYW5zLCBEcm9pZCBTYW5zLCBIZWx2ZXRpY2EgTmV1ZSxcbiAgICAgICAgICAgIHNhbnMtc2VyaWY7XG4gICAgfVxufVxuXG4uYm94IHtcbiAgICB3aWR0aDogMjgwcHg7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gICAgYm94LXNoYWRvdzogMCAxLjVweCA1cHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIHBhZGRpbmc6IDAgMTVweCAwIDE1cHg7XG59XG5cbnRhYmxlIHtcbiAgICBmb250LXNpemU6IDEzcHg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBjb2xvcjogcmdiKDE4MywgMTg5LCAxOTgpO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbnRkIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgaGVpZ2h0OiAyMHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xufVxuXG50ZC5wcmljZSB7XG4gICAgd2lkdGg6IDMwJTtcbn1cblxudGQucHJpY2Ugc3BhbiB7XG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7XG59XG5cbnRkLnF1YW50aXR5IHtcbiAgICB3aWR0aDogMzAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xufVxuXG50ZC50aW1lIHtcbiAgICB3aWR0aDogNDAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIGNvbG9yOiAjOTk5O1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbn1cblxudGQuYnRjIHtcbiAgICB3aWR0aDogNDAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbn1cblxudGQgc3BhbiB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHotaW5kZXg6IDI7XG59XG5cbnRhYmxlLmFza3MgLnBlcmNlbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ2LCA3MCwgOTQsIDAuMik7XG59XG5cbnRhYmxlLmJpZHMgLnBlcmNlbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTQsIDIwMywgMTI5LCAwLjIpO1xufVxuXG50ZCAucGVyY2VudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgcmlnaHQ6IDA7XG59XG5cbi5uZXdlc3Qge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xuICAgIG1hcmdpbjogMTVweCAtMTVweDtcbn1cblxuLmNhcmQtMTEwIHtcbiAgICB0b3A6IDExMHB4ICFpbXBvcnRhbnQ7XG4gICAgbGVmdDogNzBweDtcbn1cbi8qIFN0eWxlIHBhZ2UgY29udGVudCAtIHVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIHB1c2ggdGhlIHBhZ2UgY29udGVudCB0byB0aGUgcmlnaHQgd2hlbiB5b3Ugb3BlbiB0aGUgc2lkZSBuYXZpZ2F0aW9uICovXG4jbWFpbiB7XG4gICAgdHJhbnNpdGlvbjogbWFyZ2luLWxlZnQgLjVzO1xuICAgIC8qIElmIHlvdSB3YW50IGEgdHJhbnNpdGlvbiBlZmZlY3QgKi9cbn1cblxuLyogT24gc21hbGxlciBzY3JlZW5zLCB3aGVyZSBoZWlnaHQgaXMgbGVzcyB0aGFuIDQ1MHB4LCBjaGFuZ2UgdGhlIHN0eWxlIG9mIHRoZSBzaWRlbmF2IChsZXNzIHBhZGRpbmcgYW5kIGEgc21hbGxlciBmb250IHNpemUpICovXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogNDUwcHgpIHtcbiAgICAuc2lkZWJhcjEge1xuICAgICAgICBwYWRkaW5nLXRvcDogMTVweDtcbiAgICB9XG5cbiAgICAuc2lkZWJhcjEgYSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICB9XG59XG5cbi5idG4tY2lyY2xlIHtcbiAgICB3aWR0aDogMzBweDtcbiAgICBoZWlnaHQ6IDMwcHg7XG4gICAgcGFkZGluZzogNnB4IDBweDtcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xuICAgIGZvbnQtc2l6ZTogOHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuI2NoYXJ0ZGl2IHtcbiAgICBtaW4taGVpZ2h0OiAzMDBweDtcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcbiAgICBoZWlnaHQ6IDcwdmg7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxyXG4gICAgPHNwYW4+XHJcbiAgICAgICAgPGlucHV0XG52LWlmPVwidHlwZT09PSd0ZXh0JyB8fCAhdHlwZVwiXHJcbiAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbmNsYXNzPVwidHZqcy1zdGQtaW5wdXRcIlxuOnN0eWxlPVwic3R5bGVcIlxyXG4gICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJuYW1lXCJcclxuICAgICAgICAgICAgQGNoYW5nZT1cIiRlbWl0KCdjaGFuZ2UnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXHJcbiAgICAgICAgICAgIEBpbnB1dD1cIiRlbWl0KCdpbnB1dCcsICRldmVudC50YXJnZXQudmFsdWUpXCJcbj5cclxuICAgICAgICA8c2VsZWN0XG52LWVsc2UtaWY9XCJ0eXBlPT09J3NlbGVjdCdcIlxyXG4gICAgICAgICAgICBjbGFzcz1cInR2anMtc3RkLWlucHV0XCJcbjpzdHlsZT1cInN0eWxlXCJcclxuICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxyXG4gICAgICAgICAgICBAaW5wdXQ9XCIkZW1pdCgnaW5wdXQnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4+XHJcbiAgICAgICAgICAgIDxvcHRpb24gdi1mb3I9XCJvcHQgaW4gbGlzdFwiPnt7IG9wdCB9fTwvb3B0aW9uPlxyXG4gICAgICAgIDwvc2VsZWN0PlxyXG4gICAgPC9zcGFuPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbmFtZTogJ1N0ZElucHV0JyxcclxuICAgIHByb3BzOiBbJ3ZhbHVlJywgJ25hbWUnLCAndHlwZScsICdsaXN0JywgJ2NvbG9ycyddLFxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIHN0eWxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kOiB0aGlzLiRwcm9wcy5jb2xvcnMuYmFjayxcclxuICAgICAgICAgICAgICAgIC8vY29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy50ZXh0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge31cclxufVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuLnR2anMtc3RkLWlucHV0IHtcclxuICAgIG1hcmdpbjogNXB4O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzE2MWIyNztcclxuICAgIGJvcmRlcjogMXB4IGRvdHRlZCAjMzUzOTQwO1xyXG4gICAgaGVpZ2h0OiAyMnB4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xyXG4gICAgcGFkZGluZzogMnB4IDBweCAzcHggMTBweDtcclxuICAgIGNvbG9yOiB3aGl0ZXNtb2tlO1xyXG4gICAgZm9udC1zaXplOiAxLjJlbTtcclxuICAgIG91dGxpbmU6IG5vbmU7XHJcbiAgICB3aWR0aDogMTAwcHg7XHJcbn1cclxuXHJcbnNlbGVjdC50dmpzLXN0ZC1pbnB1dCB7XHJcbiAgICBoZWlnaHQ6IDI5cHg7XHJcbiAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XHJcblxyXG59XHJcblxyXG5zZWxlY3QudHZqcy1zdGQtaW5wdXQgIHtcclxuICAgIC8vZGlzcGxheTogbm9uZTsgLypoaWRlIG9yaWdpbmFsIFNFTEVDVCBlbGVtZW50OiAqL1xyXG59XHJcblxyXG5cclxuLnR2anMtc3RkLWlucHV0OjpwbGFjZWhvbGRlciB7XHJcbiAgICBjb2xvcjogIzhlOTA5YTtcclxuICAgIG9wYWNpdHk6IDAuMjU7XHJcbn1cclxuPC9zdHlsZT5cclxuIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdlxucmVmPVwid2luXCJcbmNsYXNzPVwidHZqcy14LXdpbmRvd1wiXG46c3R5bGU9XCJzdHlsZVwiXG4+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInR2anMteC13aW5kb3ctaGVhZFwiPlxyXG4gICAgICAgICAgICA8ZGl2XG5jbGFzcz1cInR2anMteC13aW5kb3ctdGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgQG1vdXNlZG93bj1cIm9uTW91c2VEb3duXCJcbj5cclxuICAgICAgICAgICAgICAgIHt7IHRpdGxlIH19XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2XG5jbGFzcz1cInR2anMteC13aW5kb3ctY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgQGNsaWNrPVwiJGVtaXQoJ2Nsb3NlJylcIlxuPlxyXG4gICAgICAgICAgICAgICAg4pWzXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0dmpzLXgtd2luZG93LWJvZHlcIj5cclxuICAgICAgICAgICAgPHNsb3QgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5cclxuaW1wb3J0IERyYWdnIGZyb20gJy4vZHJhZ2cuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBuYW1lOiAnV2luZG93JyxcclxuICAgIG1peGluczogW0RyYWdnXSxcclxuICAgIHByb3BzOiBbJ3RpdGxlJywgJ3R2J10sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHd3OiAwLFxyXG4gICAgICAgICAgICB3aDogMCxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIHN0eWxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiBgJHt0aGlzLnl9cHhgLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogYCR7dGhpcy54fXB4YFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0dncoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy50di53aWR0aFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHZoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcHJvcHMudHYuaGVpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoKSB7XHJcbiAgICAgICAgdGhpcy53dyA9IHRoaXMuJHJlZnMud2luLmNsaWVudFdpZHRoXHJcbiAgICAgICAgdGhpcy53aCA9IHRoaXMuJHJlZnMud2luLmNsaWVudEhlaWdodFxyXG4gICAgICAgIHRoaXMueCA9IHRoaXMudHZ3ICogMC41IC0gdGhpcy53dyAqIDAuNVxyXG4gICAgICAgIHRoaXMueSA9IHRoaXMudHZoICogMC41IC0gdGhpcy53aCAqIDAuNVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbi50dmpzLXgtd2luZG93IHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGJhY2tncm91bmQ6ICMxYjIwMmRlZjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbiAgICBwYWRkaW5nLWxlZnQ6IDdweDtcclxuICAgIHotaW5kZXg6IDEwMDtcclxuICAgIGNvbG9yOiAjZGVkZGRkO1xyXG59XHJcbi50dmpzLXgtd2luZG93LWhlYWQge1xyXG4gICAgZm9udC1zaXplOiAyZW07XHJcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xyXG4gICAgZmxleC13cmFwOiBub3dyYXA7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XHJcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgaGVpZ2h0OiAzNnB4O1xyXG4gICAgcGFkZGluZzogMTBweDtcclxuICAgIGN1cnNvcjogZ3JhYjtcclxufVxyXG5cclxuLnR2anMteC13aW5kb3ctYm9keSB7XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG4gICAgZm9udC1zaXplOiAxLjFlbTtcclxufVxyXG4udHZqcy14LXdpbmRvdy10aXRsZSB7XHJcbiAgICB3aWR0aDogMzAwcHg7XHJcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxufVxyXG4udHZqcy14LXdpbmRvdy1jbG9zZSB7XHJcbiAgICB3aWR0aDogMjZweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIG1hcmdpbjogLTFlbTtcclxuICAgIHBhZGRpbmc6IDFlbTtcclxuICAgIGZvbnQtc2l6ZTogMC43NWVtO1xyXG59XHJcbjwvc3R5bGU+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICAgIDxzcGFuXG5jbGFzcz1cImgtc3BsaXR0ZXJcIlxyXG4gICAgICAgIDpzdHlsZT1cImhzX3N0eWxlXCJcbkBtb3VzZWRvd249XCJoc19tb3VzZWRvd25cIlxuLz5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbmFtZTogJ1NwbGl0dGVyJyxcclxuICAgIHByb3BzOiBbJ2lkJywgJ21haW4nLCAnZGMnLCAndHYnLCAnZGF0YSddLFxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBoc19zdHlsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRyYWc6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuZGF0YS5ncmlkMi5vZmZzZXQgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY29sb3JzLnNwbGl0dGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoKSB7XHJcbiAgICAgICAgdGhpcy5NSU5fSEVJR0hUID0gdGhpcy5kYXRhLnNldHQubWluX2hlaWdodCB8fCAyMFxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBoc19tb3VzZWRvd24oZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHMnLFxyXG4gICAgICAgICAgICAgICAgeTogZS5jbGllbnRZLFxyXG4gICAgICAgICAgICAgICAgaDE6IHRoaXMuZGF0YS5ncmlkMS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBoMjogdGhpcy5kYXRhLmdyaWQyLmhlaWdodFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFV0aWxzLmFkZF9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcsIGBib2R5ICoge1xyXG4gICAgICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLnRyYWRpbmctdnVlLWNoYXJ0IHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgICAgICB9YClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzX21vdXNldXAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXHJcbiAgICAgICAgICAgIFV0aWxzLnJlbV9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoc19tb3VzZW1vdmUoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2ZmID0gZS5jbGllbnRZIC0gdGhpcy5kcmFnLnlcclxuICAgICAgICAgICAgICAgIGxldCBuZXdfaDEgPSB0aGlzLmRyYWcuaDEgKyBvZmZcclxuICAgICAgICAgICAgICAgIGxldCBuZXdfaDIgPSB0aGlzLmRyYWcuaDIgLSBvZmZcclxuICAgICAgICAgICAgICAgIGlmIChuZXdfaDEgPiB0aGlzLk1JTl9IRUlHSFQgJiZcclxuICAgICAgICAgICAgICAgICAgICBuZXdfaDIgPiB0aGlzLk1JTl9IRUlHSFQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZ3JpZDEuaGVpZ2h0ID0gbmV3X2gxXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmdyaWQyLmhlaWdodCA9IG5ld19oMlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNhbGNfaGVpZ2h0cygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzX21vdXNlbGVhdmUoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXHJcbiAgICAgICAgICAgIFV0aWxzLnJlbV9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGUgc2NvcGVkPlxyXG4uaC1zcGxpdHRlciB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBsZWZ0OiAwO1xyXG4gICAgaGVpZ2h0OiA1cHg7XHJcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICB6LWluZGV4OiAxO1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNlZTRhZmI1O1xyXG4gICAgb3BhY2l0eTogMDtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbn1cclxuLmgtc3BsaXR0ZXI6aG92ZXIge1xyXG4gICAgY3Vyc29yOiByb3ctcmVzaXplO1xyXG4gICAgb3BhY2l0eTogMTtcclxufVxyXG48L3N0eWxlPlxyXG4iLCI8dGVtcGxhdGU+XG4gICAgPHdpbmRvdyB0aXRsZT1cIkFkZCBJbmRpY2F0b3JcIiBjbGFzcz1cImFkZC13aW5cIiA6dHY9XCJ0dlwiIEBjbG9zZT1cIm9uX2Nsb3NlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhZGQtd2luLWxpc3RcIj5cbiAgICAgICAgICAgIDxkaXYgdi1mb3I9XCJvdiBvZiBvdnNcIiBjbGFzcz1cImFkZC13aW4taXRlbVwiIEBjbGljaz1cIm9uX2NsaWNrKG92Lm5hbWUpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4+e3sgb3YubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFkZC13aW4taXRlbS1kZXNjXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IG92Lm1ldGhvZHMubWV0YV9pbmZvKCkuZGVzYyB9fVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L3dpbmRvdz5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuXG5pbXBvcnQgV2luZG93IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvV2luZG93LnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdBZGRXaW4nLFxuICAgIGNvbXBvbmVudHM6IHsgV2luZG93IH0sXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG92czogdGhpcy50di5vdmVybGF5cy5maWx0ZXIoeCA9PiB4Lm1ldGhvZHMuY2FsYylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2V0dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm92LnNldHRpbmdzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIG9uX2Nsb3NlKCkge1xuICAgICAgICAgICAgdGhpcy4kcHJvcHMubWFpbi5yZW1vdmVfd2lkZ2V0KHRoaXMuJHByb3BzLmlkKVxuICAgICAgICB9LFxuICAgICAgICBvbl9jbGljayhuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm9uX2Nsb3NlKClcbiAgICAgICAgICAgIHRoaXMubWFpbi5hZGRfb3ZlcmxheSh7XG4gICAgICAgICAgICAgICAgc2lkZTogdGhpcy5kYXRhLnR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZGF0YS5pbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlOiBuYW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGUgc2NvcGVkPlxuLnR2anMteC13aW5kb3cuYWRkLXdpbiB7XG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xufVxuLmFkZC13aW4tbGlzdCB7XG4gICAgaGVpZ2h0OiAzMDBweDtcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBDaHJvbWUsIFNhZmFyaSBhbmQgT3BlcmEgKi9cbi5hZGQtd2luLWxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLyogSGlkZSBzY3JvbGxiYXIgZm9yIElFLCBFZGdlIGFuZCBGaXJlZm94ICovXG4uYWRkLXdpbi1saXN0IHtcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAgLyogSUUgYW5kIEVkZ2UgKi9cbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lOyAgLyogRmlyZWZveCAqL1xufVxuLmFkZC13aW4taXRlbSB7XG4gICAgY29sb3I6ICNmZmZmZmY4ODtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwYWRkaW5nOiA1cHg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuLmFkZC13aW4taXRlbTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogIzg4ODg4ODIyO1xuICAgIGNvbG9yOiAjZmZmZmZmZmY7XG59XG4uYWRkLXdpbi1pdGVtLWRlc2Mge1xuICAgIGNvbG9yOiAjZmZmZmZmMzM7XG4gICAgbWFyZ2luLWxlZnQ6IDNweDtcbn1cbi5hZGQtd2luLWl0ZW06aG92ZXIgLmFkZC13aW4taXRlbS1kZXNjIHtcbiAgICBjb2xvcjogI2ZmZmZmZjQ0O1xufVxuLmFkZC13aW4tZW1wdHkge1xuICAgIG9wYWNpdHk6IDAuNTtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPHdpbmRvdyA6dGl0bGU9XCJkYXRhLm92Lm5hbWVcIiBjbGFzcz1cInNldHQtd2luXCIgOnR2PVwidHZcIiBAY2xvc2U9XCJvbl9jbG9zZVwiPlxuICAgICAgICA8ZGl2IHYtZm9yPVwiayBpbiBzZXR0bGlzdFwiIGNsYXNzPVwic2V0dC13aW4taXRlbVwiPlxuICAgICAgICAgICAgPGxhYmVsPnt7IHMyZChrKSB9fTwvbGFiZWw+XG4gICAgICAgICAgICA8c3RkLWlucHV0IDp2YWx1ZT1cInNldHRba11cIiBAaW5wdXQ9XCJ1cGRhdGVfc2V0dChrLCAkZXZlbnQpXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxzcGFuIHYtaWY9XCIhc2V0dGxpc3QubGVuZ3RoXCIgY2xhc3M9XCJzZXR0LXdpbi1lbXB0eVwiPlxuICAgICAgICAgICAgPGk+Tm8gc2NyaXB0IHNldHRpbmdzPC9pPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC93aW5kb3c+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cblxuaW1wb3J0IFdpbmRvdyBmcm9tICcuLi8uLi9jb21wb25lbnRzL1dpbmRvdy52dWUnXG5pbXBvcnQgU3RkSW5wdXQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9TdGRJbnB1dC52dWUnXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdTZXR0aW5nc1dpbicsXG4gICAgY29tcG9uZW50czogeyBXaW5kb3csIFN0ZElucHV0IH0sXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2V0dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm92LnNldHRpbmdzXG4gICAgICAgIH0sXG4gICAgICAgIHNldHRsaXN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0dCkuZmlsdGVyKHggPT5cbiAgICAgICAgICAgICAgICB4WzBdICE9PSAnJCcgJiYgdGhpcy5zZXR0LiRwcm9wcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dC4kcHJvcHMuaW5jbHVkZXMoeCkpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHMyZChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5zZXR0MmRlc2Moc3RyKVxuICAgICAgICB9LFxuICAgICAgICBvbl9jbG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJHByb3BzLm1haW4ucmVtb3ZlX3dpZGdldCh0aGlzLiRwcm9wcy5pZClcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlX3NldHQoaywgdmFsKSB7XG4gICAgICAgICAgICBsZXQgZGNpZCA9IHRoaXMuJHByb3BzLmRhdGEub3YuaWRcblxuICAgICAgICAgICAgbGV0IHZhbE4gPSBwYXJzZUZsb2F0KHZhbClcbiAgICAgICAgICAgIGlmICh2YWxOICE9PSB2YWxOKSB2YWxOID0gdmFsXG5cbiAgICAgICAgICAgIHRoaXMuJHByb3BzLmRjLm1lcmdlKGAke2RjaWR9LnNldHRpbmdzYCxcbiAgICAgICAgICAgICAgICB7IFtrXTogdmFsTiB9XG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZSBzY29wZWQ+XG4udHZqcy14LXdpbmRvdy5zZXR0LXdpbiB7XG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xufVxuLnNldHQtd2luLWl0ZW0ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG4uc2V0dC13aW4taXRlbSBsYWJlbCB7XG4gICAgbWluLXdpZHRoOiA4MHB4O1xuICAgIGNvbG9yOiAjMzVhNzc2O1xufVxuLnNldHQtd2luLWVtcHR5IHtcbiAgICBvcGFjaXR5OiAwLjU7XG59XG48L3N0eWxlPlxuIiwiZXhwb3J0IGRlZmF1bHQgIHtcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBvbk1vdXNlRG93bihlKSB7XHJcbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudFxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICAgICAgdGhpcy5kcmFnLm9mZnNldF94ID0gZS5jbGllbnRYIC0gdGhpcy54XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZy5vZmZzZXRfeSA9IGUuY2xpZW50WSAtIHRoaXMueVxyXG4gICAgICAgICAgICBkb2N1bWVudC5vbm1vdXNldXAgPSB0aGlzLnN0b3BkcmFnXHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gdGhpcy5vbmRyYWdcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvbmRyYWcoZSkge1xyXG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnRcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgIHRoaXMueCA9IGUuY2xpZW50WCAtIHRoaXMuZHJhZy5vZmZzZXRfeFxyXG4gICAgICAgICAgICB0aGlzLnkgPSAgZS5jbGllbnRZIC0gdGhpcy5kcmFnLm9mZnNldF95XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3RvcGRyYWcoKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IG51bGxcclxuICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZHJhZzoge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0X3g6IDAsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRfeTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIlxyXG4vKiBFeGFtcGxlOlxyXG5cclxucnVsZXM6IHtcclxuICAgICcqIC0+IConOiB7fSwgICAgIC8vIEZyb20gZWFjaCB0byBlYWNoXHJcbiAgICAnKic6IHsgICAgICAgICAgICAvLyBUaGUgc2FtZSBhcyBeXHJcbiAgICAgICAgY3Vyc29yOiB0cnVlLCAvLyBib29sLCAnWCcsICdZJywgJ1hZJ1xyXG4gICAgICAgIHBvc2l0aW9uOiAnWCcsIC8vIGJvb2wsICdYJywgJ1knLCAnWFknXHJcbiAgICAgICAgdG9vbHM6IHRydWVcclxuICAgIH0sXHJcbiAgICAndHJhZGluZy12dWUtMSAtPiB0cmFkaW5nLXZ1ZS0yJzoge1xyXG4gICAgICAgIGRhdGE6IFtcclxuICAgICAgICAgICAgJ29uY2hhcnQuU01BJyxcclxuICAgICAgICAgICAgJ1JTSTRIJyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogJ2NoYXJ0LmRhdGEnLFxyXG4gICAgICAgICAgICAgICAgdG86ICdkYXRhc2V0cycsXHJcbiAgICAgICAgICAgICAgICBvYmo6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogJ3NtYWxsLXRmLWRhdGEnLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTb3VyY2VEYXRhJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgICdub25lJzoge1xyXG4gICAgICAgIHJhbmdlOiAnWCcsIC8vIGJvb2wsICdYJywgJ1knLCAnWFknXHJcbiAgICB9XHJcbn1cclxuKi9cclxuXHJcbmltcG9ydCBTaGFyZWQgZnJvbSAnLi9zaGFyZWQuanMnXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiB7XHJcblxyXG4gICAgY29uc3RydWN0b3IodHYsIGRjLCBzZXR0KSB7XHJcblxyXG4gICAgICAgIGlmIChzZXR0LnVzZV93aW5kb3cpIHtcclxuICAgICAgICAgICAgaWYgKCF3aW5kb3cueGNoYXJ0bGluayQpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy54Y2hhcnRsaW5rJCA9IHt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaGFyZWQgPSB3aW5kb3cueGNoYXJ0bGluayRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZCA9IFNoYXJlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50diA9IHR2XHJcbiAgICAgICAgdGhpcy5kYyA9IGRjXHJcbiAgICAgICAgdGhpcy5zZXR0ID0gc2V0dFxyXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IHt9XHJcblxyXG4gICAgICAgIHRoaXMub25zZXR0aW5ncyh7J2NoYXJ0LWxpbmsnOiBzZXR0fSlcclxuICAgIH1cclxuXHJcbiAgICBvbnNldHRpbmdzKGFsbCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0X2lkKVxyXG4gICAgICAgIHRoaXMuc2V0dCA9IGFsbFsnY2hhcnQtbGluayddXHJcbiAgICAgICAgaWYgKCF0aGlzLnNoYXJlZC5ydWxlcykge1xyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZC5ydWxlcyA9IHt9XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkLnJlZnMgPSB7fVxyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZC5tZXRhID0ge31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudHYuaWQpXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNldHQucnVsZXMgJiYgZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFyZWQucnVsZXNbdGhpcy50di5pZF0gPSB0aGlzLnNldHQucnVsZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcmVkLnJlZnNbdGhpcy50di5pZF0gPSB0aGlzLnR2XHJcblxyXG4gICAgICAgIHRoaXMuY29tYmluZSgpXHJcbiAgICAgICAgdGhpcy5yZXNldF9pZCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXNldCgpKVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBDb21iaW5lIHJ1bGVzIGZyb20gZGlmZmVyZW50IGluc3RhbmNlc1xyXG4gICAgY29tYmluZSgpIHtcclxuICAgICAgICB0aGlzLnNoYXJlZC5jb21iaW5lZCA9IHt9XHJcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zaGFyZWQucnVsZXMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnNoYXJlZC5ydWxlc1tpZF0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLmNvbWJpbmVkW3JdID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZC5ydWxlc1tpZF1bcl1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21waWxlIHJ1bGVzIGZvciB0aGlzIGluc3RhbmNlXHJcbiAgICBjb21waWxlKCkge1xyXG5cclxuICAgICAgICBsZXQgZ2ViY24gPSAnZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSdcclxuICAgICAgICBsZXQgZWxzID0gWy4uLmRvY3VtZW50W2dlYmNuXSgndHJhZGluZy12dWUnKV1cclxuICAgICAgICB0aGlzLnRhcmdldHMgPSB7fVxyXG5cclxuICAgICAgICBmb3IgKGxldCBlbCBvZiBlbHMpIHtcclxuICAgICAgICAgICAgaWYgKGVsLmlkID09PSB0aGlzLnR2LmlkKSBjb250aW51ZVxyXG4gICAgICAgICAgICB0aGlzLnRhcmdldHNbZWwuaWRdID0ge31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBydWxlcyA9IHRoaXMucmFuayh0aGlzLnNoYXJlZC5jb21iaW5lZClcclxuXHJcbiAgICAgICAgZm9yICh2YXIgciBvZiBydWxlcykge1xyXG4gICAgICAgICAgICBsZXQgZHN0ID0gci5wYWlyWzFdXHJcbiAgICAgICAgICAgIGlmIChkc3QgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgZHN0ID0gT2JqZWN0LmtleXModGhpcy50YXJnZXRzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRzdCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGQgb2YgZHN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZCBpbiB0aGlzLnRhcmdldHMpKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50YXJnZXRzW2RdLCByLnIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShkc3QgaW4gdGhpcy50YXJnZXRzKSkgY29udGludWVcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50YXJnZXRzW2RzdF0sIHIucilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWxlY3QsIHJhbmsgJiBzb3J0IHRoZSBydWxlc1xyXG4gICAgcmFuayhydWxlcykge1xyXG4gICAgICAgIGxldCBvdXQgPSBbXVxyXG4gICAgICAgIGZvciAodmFyIHIgaW4gcnVsZXMpIHtcclxuICAgICAgICAgICAgbGV0IHBhaXIgPSB0aGlzLnNwbGl0cihyKVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hlcyhwYWlyWzBdKSkgY29udGludWVcclxuICAgICAgICAgICAgaWYgKHBhaXJbMF0gPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmsgPSAyMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFpclswXSkgKSB7XHJcbiAgICAgICAgICAgICAgICByYW5rID0gMTBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJhbmsgPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhaXJbMV0gPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgcmFuayArPSAyXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYWlyWzFdKSApIHtcclxuICAgICAgICAgICAgICAgIHJhbmsgKz0gMVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmFuayArPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LnB1c2goe3BhaXIsIHJhbmssIHI6IHJ1bGVzW3JdfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dC5zb3J0KChhLCBiKSA9PiBiLnJhbmsgLSBhLnJhbmspXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHNvdXJjZSBvZiBhIHJ1bGUgbWF0Y2hlcyB0di5pZFxyXG4gICAgbWF0Y2hlcyhzcmMpIHtcclxuICAgICAgICByZXR1cm4gc3JjID09PSAnKicgfHwgc3JjID09PSB0aGlzLnR2LmlkIHx8XHJcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHNyYykgJiYgc3JjLmluY2x1ZGVzKHRoaXMudHYuaWQpKVxyXG4gICAgfVxyXG5cclxuICAgIHNwbGl0cihydWxlKSB7XHJcbiAgICAgICAgaWYgKHJ1bGUudHJpbSgpID09PSAnKicpIHJldHVybiBbJyonLCAnKiddXHJcbiAgICAgICAgcmV0dXJuIHJ1bGUuc3BsaXQoJy0+JykubWFwKHggPT4ge1xyXG4gICAgICAgICAgICBsZXQgdHVwID0geC5zcGxpdCgnLCcpXHJcbiAgICAgICAgICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1cC5tYXAoeSA9PiB5LnRyaW0oKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geC50cmltKClcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSBhbGwgcnVsZXMgZm9yIHRoaXMgaW5zdGFuY2VcclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY29tcGlsZSgpXHJcblxyXG4gICAgICAgIC8vIEVuYWJsZSBzb21lIGNoYXJ0IGhvb2sgZXZlbnRzXHJcbiAgICAgICAgdGhpcy50di4kcmVmcy5jaGFydC5ob29rcygneGNoYW5nZWQnKVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy50di4kd2F0Y2goeCA9PiB0aGlzLmRjLmdldCgnLicpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4LnNldHRpbmdzLiRzdGF0ZSksXHJcbiAgICAgICAgICAgIHRoaXMub250b29scy5iaW5kKHRoaXMpKVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBMaXN0ZW5pbmcgdG8gdGhlIENoYXJ0LnZ1ZSBob29rcyAmXHJcbiAgICAvLyBvdGhlciBldmVudHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoIChlLmV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJz94LWNoYW5nZWQnOlxyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUuYXJnc1swXVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5wcmV2ZW50RGVmYXVsdCkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBsZXQgbWFpbiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuX2xheW91dC5ncmlkc1tjdXJzb3IuZ3JpZF9pZF1cclxuICAgICAgICAgICAgICAgIGxldCBtYyA9IHRoaXMudHYuJHJlZnMuY2hhcnQuY3Vyc29yXHJcbiAgICAgICAgICAgICAgICBjdXJzb3IudCA9IG1jLnRcclxuICAgICAgICAgICAgICAgIGN1cnNvci4kID0gbWMueSRcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMudGFyZ2V0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByID0gdGhpcy50YXJnZXRzW2lkXS5jdXJzb3JcclxuICAgICAgICAgICAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZyA9IHR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHNbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHh4ID0gdGhpcy5pc1gocilcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHl5ID0gZy5pZCA9PT0gbWFpbi5pZCAmJiB0aGlzLmlzWShyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4eCA/IGcudDJzY3JlZW4oY3Vyc29yLnQpIDogLTEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogeXkgPyBnLiQyc2NyZWVuKGN1cnNvci4kKSA6IC0xMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRfaWQ6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0di4kcmVmcy5jaGFydC5jdXJzb3JfY2hhbmdlZCh1cGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LiRyZWZzLmNoYXJ0LmN1cnNvci50ID0geHggPyBjdXJzb3IudCA6IC0xMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0di4kcmVmcy5jaGFydC5jdXJzb3IueSQgPSB5eSA/IGN1cnNvci4kIDogLTEwXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAncmFuZ2UtY2hhbmdlZCc6XHJcbiAgICAgICAgICAgICAgICBsZXQgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKClcclxuICAgICAgICAgICAgICAgIGxldCBtZXRhID0gdGhpcy5zaGFyZWQubWV0YVt0aGlzLnR2LmlkXVxyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhLnBvc2l0aW9uLmxvY2sgPiBub3cpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZS5hcmdzWzBdXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnRhcmdldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IHRoaXMudGFyZ2V0c1tpZF0ucG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4eCA9IHRoaXMuaXNYKHIpXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHl5ID0gdGhpcy5pc1kocilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVkLm1ldGFbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdID0ge31cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgYW4gaW5maW5pdGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdLnBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NrOiBub3cgKyAxMDBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHh4KSB0di5nb3RvKHJhbmdlWzFdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb250b29scyhuLCBwKSB7XHJcbiAgICAgICAgbGV0IHJlbSA9IFV0aWxzLnJlbW92ZWQoXHJcbiAgICAgICAgICAgIG4ubWFwKHggPT4geC5zZXR0aW5ncy4kdXVpZCksXHJcbiAgICAgICAgICAgIHAubWFwKHggPT4geC5zZXR0aW5ncy4kdXVpZClcclxuICAgICAgICApXHJcbiAgICAgICAgbGV0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLnNoYXJlZC5tZXRhW3RoaXMudHYuaWRdXHJcbiAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS50b29scykge1xyXG4gICAgICAgICAgICBpZiAobWV0YS50b29scy5sb2NrID4gbm93KSByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy50YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIGxldCByID0gdGhpcy50YXJnZXRzW2lkXS50b29sc1xyXG4gICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlZC5tZXRhW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdID0ge31cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIGFuIGluZmluaXRlIGxvb3BcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdLnRvb2xzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2s6IG5vdyArIDEwMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5X3Rvb2xzKG4sIHR2KVxyXG4gICAgICAgICAgICAgICAgcmVtLmZvckVhY2gociA9PiB0di5kYXRhLmRlbChgJHtyfWApKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvcHlfdG9vbHMobiwgdHYpIHtcclxuICAgICAgICBmb3IgKHZhciB0b29sIG9mIG4pIHtcclxuICAgICAgICAgICAgaWYgKHRvb2wuaWQuaW5jbHVkZXMoJ29mZmNoYXJ0JykpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGxldCB1dWlkID0gdG9vbC5zZXR0aW5ncy4kdXVpZFxyXG4gICAgICAgICAgICBsZXQgZXhpID0gdHYuZGF0YS5nZXRfb25lKGAke3V1aWR9YClcclxuICAgICAgICAgICAgaWYgKGV4aSkge1xyXG4gICAgICAgICAgICAgICAgdHYuJHNldChleGksICdzZXR0aW5ncycsIFV0aWxzLmNvcHkoXHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbC5zZXR0aW5ncyxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZWxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZTogJ2ZpbmlzaGVkJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBhZGQgYSBwcm9wZXIgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBhY2Nlc3Npbmcgb3ZlcmxheXNcclxuICAgICAgICAgICAgICAgIGxldCBvdnMgPSB0di4kcmVmcy5jaGFydC4kcmVmcy5zZWNbMF1cclxuICAgICAgICAgICAgICAgICAgICAuJHJlZnMuZ3JpZFxyXG4gICAgICAgICAgICAgICAgICAgIC4kY2hpbGRyZW4uZmlsdGVyKHggPT4geC50b29sKVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG92IG9mIG92cykge1xyXG4gICAgICAgICAgICAgICAgICAgIG92LnBpbnMuZm9yRWFjaCh4ID0+IHgucmVfaW5pdCgpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gVXRpbHMuY29weSh0b29sKVxyXG4gICAgICAgICAgICAgICAgY29weS5zZXR0aW5ncy4kc2VsZWN0ZWQgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgY29weS5zZXR0aW5ncy4kc3RhdGUgPSAnZmluaXNoZWQnXHJcbiAgICAgICAgICAgICAgICB0di5kYXRhLmFkZCgnb25jaGFydCcsIGNvcHkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaXNYKHJ1bGUpIHtcclxuICAgICAgICByZXR1cm4gcnVsZSA9PT0gdHJ1ZSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHJ1bGUgPT09ICdzdHJpbmcnICYmIHJ1bGUuaW5jbHVkZXMoJ1gnKSlcclxuICAgIH1cclxuXHJcbiAgICBpc1kocnVsZSkge1xyXG4gICAgICAgIHJldHVybiBydWxlID09PSB0cnVlIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgcnVsZSA9PT0gJ3N0cmluZycgJiYgcnVsZS5pbmNsdWRlcygnWScpKVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuLy8gIE9iamVjdCBzaGFyZWQgYmVldHdlZW4gdHZqcyBpbnN0YW5jZXNcclxuXHJcbmNsYXNzIFNoYXJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9faWRfXyA9IE1hdGgucmFuZG9tKClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IFNoYXJlZCgpXHJcbiIsImV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgICBjb3B5KG9iaiwgbW9kKSB7XHJcbiAgICAgICAgbGV0IGNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29weSwgbW9kKVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVkKGlkcywgcHJldikge1xyXG4gICAgICAgIGxldCBsaXN0ID0gW11cclxuICAgICAgICBmb3IgKHZhciBpZCBvZiBwcmV2KSB7XHJcbiAgICAgICAgICAgIGlmICghaWRzLmluY2x1ZGVzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKGlkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0XHJcbiAgICB9XHJcbn1cclxuIiwiXG4vLyBFeHRlbnNpb24ncyBjb250cm9sbGVyXG5cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAndHJhZGluZy12dWUtanMnXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBTcGxpdHRlciBmcm9tICcuL1NwbGl0dGVyLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0diwgZGMsIHNldHQpIHtcblxuICAgICAgICB0aGlzLndpZGdldHMgPSB7fVxuICAgICAgICB0aGlzLnR2ID0gdHZcbiAgICAgICAgdGhpcy5kYyA9IGRjXG4gICAgICAgIHRoaXMuc2V0dCA9IHNldHRcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgdGhpcy50di4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAnbW91c2Vtb3ZlJywgdGhpcy5vbm1vdXNlbW92ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMudHYuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgJ21vdXNldXAnLCB0aGlzLm9ubW91c2V1cC5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMudHYuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgJ21vdXNlbGVhdmUnLCB0aGlzLm9ubW91c2VsZWF2ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMucGxhY2Vfc3BsaXR0ZXJzKClcbiAgICAgICAgICAgIHRoaXMuY2FsY19oZWlnaHRzKClcblxuICAgICAgICAgICAgLy8gVHJhY2sgY2hhbmdlcyBvZiBncmlkcyBjb3VudFxuICAgICAgICAgICAgdGhpcy50di4kd2F0Y2goeCA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZGMuZ2V0KCcuJykubWFwKHggPT4geC5pZCksXG4gICAgICAgICAgICAgICAgdGhpcy5vbmdyaWRzLmJpbmQodGhpcykpXG5cbiAgICAgICAgfSlcblxuICAgIH1cblxuICAgIC8vIExpc3RlbnMgdG8gYWxsIHR2anMgZXZlbnRzLCBjcmVhdGVzIG5ldyB3aWRnZXRzXG4gICAgdXBkYXRlKGUpIHtcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9uIHNldHRpbmdzIGhhcyBjaGFuZ2VkXG4gICAgb25zZXR0aW5ncyhzZXR0KSB7fVxuXG4gICAgb25ncmlkcygpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZV93aWRnZXRzKClcbiAgICAgICAgICAgIHRoaXMucGxhY2Vfc3BsaXR0ZXJzKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBvbm1vdXNlbW92ZShlKSB7XG4gICAgICAgIC8vIExpc3Qgb2Ygd2lkZ2V0cyBjcmVhdGVkIGJ5IHRoaXMgY29udHJvbGxlclxuICAgICAgICBsZXQgbGlzdCA9IHRoaXMudHYuJHJlZnMud2lkZ2V0cy4kY2hpbGRyZW5cbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4Lm1haW4gPT09IHRoaXMpXG5cbiAgICAgICAgZm9yICh2YXIgcyBvZiBsaXN0KSB7XG4gICAgICAgICAgICBzLmhzX21vdXNlbW92ZShlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25tb3VzZXVwKGUpIHtcbiAgICAgICAgLy8gTGlzdCBvZiB3aWRnZXRzIGNyZWF0ZWQgYnkgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy50di4kcmVmcy53aWRnZXRzLiRjaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgubWFpbiA9PT0gdGhpcylcblxuICAgICAgICBmb3IgKHZhciBzIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIHMuaHNfbW91c2V1cChlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25tb3VzZWxlYXZlKGUpIHtcbiAgICAgICAgLy8gTGlzdCBvZiB3aWRnZXRzIGNyZWF0ZWQgYnkgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy50di4kcmVmcy53aWRnZXRzLiRjaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgubWFpbiA9PT0gdGhpcylcblxuICAgICAgICBmb3IgKHZhciBzIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIHMuaHNfbW91c2VsZWF2ZShlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGxhY2Vfc3BsaXR0ZXJzKCkge1xuICAgICAgICBsZXQgZ3JpZHMgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncmlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGcxID0gZ3JpZHNbaS0xXVxuICAgICAgICAgICAgbGV0IGcyID0gZ3JpZHNbaV1cbiAgICAgICAgICAgIGxldCBpZCA9IGBTcGxpdHRlci0ke2cxLmlkfS0ke2cyLmlkfS0ke1V0aWxzLnV1aWQyKCl9YFxuICAgICAgICAgICAgVnVlLnNldCh0aGlzLndpZGdldHMsIGlkLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGNsczogU3BsaXR0ZXIsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBncmlkMTogZzEsXG4gICAgICAgICAgICAgICAgICAgIGdyaWQyOiBnMixcbiAgICAgICAgICAgICAgICAgICAgc2V0dDogdGhpcy5zZXR0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGNfaGVpZ2h0cygpIHtcbiAgICAgICAgbGV0IGhzID0gW11cbiAgICAgICAgZm9yICh2YXIgZyBvZiB0aGlzLnR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHMpIHtcbiAgICAgICAgICAgIGhzLnB1c2goZy5oZWlnaHQpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1bSA9IGhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApXG4gICAgICAgIGhzID0gaHMubWFwKGggPT4gaCAvIHN1bSlcbiAgICAgICAgdGhpcy5ncmlkX292cygpLmZvckVhY2goKG92LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW92LmdyaWQpIHtcbiAgICAgICAgICAgICAgICBWdWUuc2V0KG92LCAnZ3JpZCcsIHt9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVnVlLnNldChvdi5ncmlkLCAnaGVpZ2h0JywgaHNbaV0gfHwgMSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBHcmlkIGRlZmluaW5nIG92ZXJsYXlzXG4gICAgZ3JpZF9vdnMoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gW3RoaXMuZGMuZGF0YS5jaGFydF1cbiAgICAgICAgZm9yICh2YXIgb3Ygb2YgdGhpcy5kYy5kYXRhLm9mZmNoYXJ0KSB7XG4gICAgICAgICAgICBpZiAoIW92LmdyaWQgfHwgb3YuZ3JpZC5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKG92KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0XG4gICAgfVxuXG4gICAgcmVtb3ZlX3dpZGdldHMoKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMud2lkZ2V0cykge1xuICAgICAgICAgICAgdGhpcy50di4kZGVsZXRlKHRoaXMud2lkZ2V0cywgaWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNlbW92ZScsIHRoaXMub25tb3VzZW1vdmVcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNldXAnLCB0aGlzLm1vdXNldXBcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNlbGVhdmUnLCB0aGlzLm1vdXNlbGVhdmVcbiAgICAgICAgKVxuICAgIH1cblxufVxuIiwiZXhwb3J0IGRlZmF1bHQge1xyXG5cclxuICAgIGFkZF9zdHlsZShpZCwgc3R5bGUpIHtcclxuXHJcbiAgICAgICAgdmFyIHN0YnIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcclxuICAgICAgICBpZiAoc3Ricikge1xyXG4gICAgICAgICAgICB2YXIgc2hlZXRQYXJlbnQgPSBzdGJyLnBhcmVudE5vZGVcclxuICAgICAgICAgICAgc2hlZXRQYXJlbnQucmVtb3ZlQ2hpbGQoc3RicilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcclxuICAgICAgICBzaGVldC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZClcclxuICAgICAgICBzaGVldC5pbm5lckhUTUwgPSBzdHlsZVxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2hlZXQpXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbV9zdHlsZShpZCwgc3R5bGUpIHtcclxuICAgICAgICB2YXIgc3RiciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxyXG4gICAgICAgIGlmIChzdGJyKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGVldFBhcmVudCA9IHN0YnIucGFyZW50Tm9kZVxyXG4gICAgICAgICAgICBzaGVldFBhcmVudC5yZW1vdmVDaGlsZChzdGJyKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiXHJcbi8vIEV4dGVuc2lvbidzIGNvbnRyb2xsZXJcclxuXHJcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAndHJhZGluZy12dWUtanMnXHJcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5pbXBvcnQgQWRkV2luIGZyb20gJy4vQWRkV2luLnZ1ZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR2LCBkYywgc2V0dCkge1xyXG5cclxuICAgICAgICB0aGlzLndpZGdldHMgPSB7fVxyXG4gICAgICAgIHRoaXMudHYgPSB0dlxyXG4gICAgICAgIHRoaXMuZGMgPSBkY1xyXG4gICAgICAgIHRoaXMuc2V0dCA9IHNldHRcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlzdGVucyB0byBhbGwgdHZqcyBldmVudHMsIGNyZWF0ZXMgbmV3IHdpZGdldHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGVnZW5kLWJ1dHRvbi1jbGljayc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uYnV0dG9uKGUuYXJnc1swXSlcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25idXR0b24oZSkge1xyXG4gICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZ2V0KGUudHlwZSlbZS5kYXRhSW5kZXhdXHJcbiAgICAgICAgbGV0IG9uY2hhcnQgPSB0aGlzLmRjLmRhdGEub25jaGFydFxyXG4gICAgICAgIGxldCBvZmZjaGFydCA9IHRoaXMuZGMuZGF0YS5vZmZjaGFydFxyXG4gICAgICAgIGlmICghb3YpIHJldHVyblxyXG4gICAgICAgIHN3aXRjaChlLmJ1dHRvbikge1xyXG4gICAgICAgICAgICBjYXNlICdkaXNwbGF5JzpcclxuICAgICAgICAgICAgICAgIGlmIChvdi5zZXR0aW5ncy5kaXNwbGF5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZyA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSAhb3Yuc2V0dGluZ3MuZGlzcGxheVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50di4kc2V0KG92LnNldHRpbmdzLCAnZGlzcGxheScsIGZsYWcpXHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICBjYXNlICd1cCc6XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnb2ZmY2hhcnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YUluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZmNoYXJ0LnNwbGljZShlLmRhdGFJbmRleCwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25jaGFydC5wdXNoKG92KVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gb2ZmY2hhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkwID0gZS5kYXRhSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkxID0gZS5kYXRhSW5kZXgtMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2kwXSA9IGRhdGEuc3BsaWNlKGkxLCAxLCBkYXRhW2kwXSlbMF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAnZG93bic6XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnb25jaGFydCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaCA9IHRoaXMuYXZnX2dyaWRfaChvZmZjaGFydClcclxuICAgICAgICAgICAgICAgICAgICBvbmNoYXJ0LnNwbGljZShlLmRhdGFJbmRleCwgMSlcclxuICAgICAgICAgICAgICAgICAgICBvZmZjaGFydC51bnNoaWZ0KG92KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldChvdiwgJ2dyaWQnLCB7aGVpZ2h0OiBofSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBvZmZjaGFydC5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG9mZmNoYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YUluZGV4IDwgbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkwID0gZS5kYXRhSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkxID0gZS5kYXRhSW5kZXgrMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2kwXSA9IGRhdGEuc3BsaWNlKGkxLCAxLCBkYXRhW2kwXSlbMF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAnYWRkJzpcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gYEFkZFdpbi0ke1V0aWxzLnV1aWQyKCl9YFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZGF0YVtlLnR5cGVdW2UuZGF0YUluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0gT2JqZWN0LnZhbHVlcyh0aGlzLndpZGdldHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHggPT4geC5kYXRhLm92ID09PSBvdilcclxuICAgICAgICAgICAgICAgICAgICBpZihmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGYuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldCh0aGlzLndpZGdldHMsIGlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLCBjbHM6IEFkZFdpbiwgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Y6IG92LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGUuZGF0YUluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLmRhdGFbZS50eXBlXS5zcGxpY2UoZS5kYXRhSW5kZXgsIDEpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsbGVkIGZyb20gQWRkV2luLnZ1ZVxyXG4gICAgYWRkX292ZXJsYXkoZSkge1xyXG4gICAgICAgIGxldCBwcmVzZXQgPSB0aGlzLmdldF9wcmVzZXQoZS50eXBlKSB8fCB7fVxyXG4gICAgICAgIGlmIChwcmVzZXQuc2lkZSkgZS5zaWRlID0gcHJlc2V0LnNpZGVcclxuICAgICAgICBsZXQgb25jaGFydCA9IHRoaXMuZGMuZGF0YS5vbmNoYXJ0XHJcbiAgICAgICAgbGV0IG9mZmNoYXJ0ID0gdGhpcy5kYy5kYXRhLm9mZmNoYXJ0XHJcbiAgICAgICAgaWYgKGUuc2lkZSA9PT0gJ29uY2hhcnQnKSB7XHJcbiAgICAgICAgICAgIG9uY2hhcnQuc3BsaWNlKGUuaW5kZXgrMSwgMCwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogcHJlc2V0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBwcmVzZXQuc2V0dGluZ3MgfHwge31cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgaCA9IHRoaXMuYXZnX2dyaWRfaChvZmZjaGFydClcclxuICAgICAgICAgICAgb2ZmY2hhcnQuc3BsaWNlKGUuaW5kZXgrMSwgMCwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogcHJlc2V0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBwcmVzZXQuc2V0dGluZ3MgfHwge30sXHJcbiAgICAgICAgICAgICAgICBncmlkOiB7aGVpZ2h0OiBofVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBwcmVzZXQgKGRlZmF1bHQgc2V0dGluZ3MsIGNvbG9ycykgaWYgZGVmaW5lZFxyXG4gICAgZ2V0X3ByZXNldCh0eXBlKSB7XHJcbiAgICAgICAgbGV0IHByb3RvID0gdGhpcy50di5vdmVybGF5cy5maW5kKHggPT4geC5uYW1lID09PSB0eXBlKVxyXG4gICAgICAgIGlmIChwcm90byAmJiBwcm90by5tZXRob2RzLm1ldGFfaW5mbykge1xyXG4gICAgICAgICAgICBsZXQgbWV0YSA9IHByb3RvLm1ldGhvZHMubWV0YV9pbmZvKClcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGEucHJlc2V0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dGVuc2lvbiBzZXR0aW5ncyBoYXMgY2hhbmdlZFxyXG4gICAgb25zZXR0aW5ncyhzZXR0KSB7fVxyXG5cclxuICAgIGF2Z19ncmlkX2gob3ZzKSB7XHJcbiAgICAgICAgaWYgKCFvdnMubGVuZ3RoKSByZXR1cm4gMC4yNVxyXG4gICAgICAgIGxldCBnaCA9IDBcclxuICAgICAgICBmb3IgKHZhciBvdiBvZiBvdnMpIHtcclxuICAgICAgICAgICAgaWYgKG92LmdyaWQgJiYgdHlwZW9mIG92LmdyaWQuaGVpZ2h0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgZ2ggKz0gb3YuZ3JpZC5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2ggLyBvdnMubGVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlX3dpZGdldChpZCkge1xyXG4gICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGlkKVxyXG4gICAgfVxyXG5cclxuICAgIGRlc3Ryb3koKSB7XHJcblxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuLy8gRXh0ZW5zaW9uJ3MgY29udHJvbGxlclxyXG5cclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICd0cmFkaW5nLXZ1ZS1qcydcclxuaW1wb3J0IFNldHRpbmdzV2luIGZyb20gJy4vU2V0dGluZ3NXaW4udnVlJ1xyXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR2LCBkYykge1xyXG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IHt9XHJcbiAgICAgICAgdGhpcy50diA9IHR2XHJcbiAgICAgICAgdGhpcy5kYyA9IGRjXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlzdGVucyB0byBhbGwgdHZqcyBldmVudHMsIGNyZWF0ZXMgbmV3IHdpZGdldHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGVnZW5kLWJ1dHRvbi1jbGljayc6XHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBgU2V0dGluZ3NXaW4tJHtVdGlscy51dWlkMigpfWBcclxuICAgICAgICAgICAgICAgIGxldCBhcmdzID0gZS5hcmdzWzBdXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5idXR0b24gIT09ICdzZXR0aW5ncycpIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZGF0YVthcmdzLnR5cGVdW2FyZ3MuZGF0YUluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0gT2JqZWN0LnZhbHVlcyh0aGlzLndpZGdldHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHggPT4geC5kYXRhLm92ID09PSBvdilcclxuICAgICAgICAgICAgICAgICAgICBpZihmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGYuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldCh0aGlzLndpZGdldHMsIGlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLCBjbHM6IFNldHRpbmdzV2luLCBkYXRhOiB7IG92OiBvdiB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVfd2lkZ2V0KGlkKSB7XHJcbiAgICAgICAgdGhpcy50di4kZGVsZXRlKHRoaXMud2lkZ2V0cywgaWQpXHJcbiAgICB9XHJcblxyXG59XHJcbiIsIlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblxyXG4gICAgc2V0dDJkZXNjKHNldHQpIHtcclxuICAgICAgICBmdW5jdGlvbiBzZXRDaGFyQXQoc3RyLGluZGV4LGNocikge1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IHN0ci5sZW5ndGgtMSkgcmV0dXJuIHN0clxyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLGluZGV4KSArIGNociArIHN0ci5zdWJzdHJpbmcoaW5kZXgrMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLyhbXkEtWl0pKFtBLVpdKS9nLCAnJDEgJDInKVxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLy18Xy9nLCAnICcpXHJcbiAgICAgICAgbGV0IHR1cGxlID0gc2V0dC5zcGxpdCgnICcpXHJcbiAgICAgICAgdHVwbGUgPSB0dXBsZVxyXG4gICAgICAgICAgICAuZmlsdGVyKHggPT4geC5sZW5ndGgpXHJcbiAgICAgICAgICAgIC5tYXAoeCA9PiBzZXRDaGFyQXQoeCwgMCwgeFswXS50b1VwcGVyQ2FzZSgpKSlcclxuICAgICAgICByZXR1cm4gdHVwbGUuam9pbignICcpXHJcbiAgICB9XHJcbiAgICBcclxufVxyXG4iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBDaGFydExpbmsgZnJvbSAnLi4vYnVpbGQvY2hhcnQtbGluay9jaGFydC1saW5rLWRldi5qcydcbmltcG9ydCBHcmlkUmVzaXplIGZyb20gJy4uL2J1aWxkL2dyaWQtcmVzaXplL2dyaWQtcmVzaXplLWRldi5qcydcbmltcG9ydCBMZWdlbmRCdXR0b25zIGZyb20gJy4uL2J1aWxkL2xlZ2VuZC1idXR0b25zL2xlZ2VuZC1idXR0b25zLWRldi5qcydcbmltcG9ydCBTZXR0aW5nc1dpbiBmcm9tICcuLi9idWlsZC9zZXR0aW5ncy13aW4vc2V0dGluZ3Mtd2luLWRldi5qcydcblxuXG5cbmNvbnN0IFBhY2sgPSB7XG4gICAgJ2NoYXJ0LWxpbmsnOiBDaGFydExpbmssXG4gICAgJ2dyaWQtcmVzaXplJzogR3JpZFJlc2l6ZSxcbiAgICAnbGVnZW5kLWJ1dHRvbnMnOiBMZWdlbmRCdXR0b25zLFxuICAgICdzZXR0aW5ncy13aW4nOiBTZXR0aW5nc1dpblxufVxuXG5leHBvcnQgZGVmYXVsdCBQYWNrXG5cbmV4cG9ydCB7XG4gICAgXG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3RyZWFtKHVybCkge1xyXG5cclxuICAgIHZhciB3cyA9IG5ldyBXZWJTb2NrZXQodXJsKVxyXG4gICAgdmFyIGNiID0gKCkgPT4ge31cclxuXHJcblxyXG4gICAgd3Mub25vcGVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1dlYnNvY2tldCBpcyBvcGVuZWQnKVxyXG4gICAgfVxyXG5cclxuICAgIHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhLmRhdGEpXHJcbiAgICAgICAgICAgIGNiKGRhdGEpXHJcbiAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2V0IG9udHJhZGVzKHZhbCkgeyBjYiA9IHZhbCB9LFxyXG4gICAgICAgIG9mZigpIHsgd3MuY2xvc2UoMTAwMCkgfVxyXG4gICAgfVxyXG59XHJcbiIsIlxyXG5jb25zdCBTRUNPTkQgPSAxMDAwXHJcbmNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwXHJcbmNvbnN0IE1JTlVURTMgPSBNSU5VVEUgKiAzXHJcbmNvbnN0IE1JTlVURTUgPSBNSU5VVEUgKiA1XHJcbmNvbnN0IE1JTlVURTE1ID0gTUlOVVRFICogMTVcclxuY29uc3QgTUlOVVRFMzAgPSBNSU5VVEUgKiAzMFxyXG5jb25zdCBIT1VSID0gTUlOVVRFICogNjBcclxuY29uc3QgSE9VUjQgPSBIT1VSICogNFxyXG5jb25zdCBIT1VSMTIgPSBIT1VSICogMTJcclxuY29uc3QgREFZID0gSE9VUiAqIDI0XHJcbmNvbnN0IFdFRUsgPSBEQVkgKiA3XHJcbmNvbnN0IE1PTlRIID0gV0VFSyAqIDRcclxuY29uc3QgWUVBUiA9IERBWSAqIDM2NVxyXG5cclxuY29uc3QgTU9OVEhNQVAgPSBbXHJcbiAgICBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLFxyXG4gICAgXCJNYXlcIiwgXCJKdW5cIixcIkp1bFwiLCBcIkF1Z1wiLFxyXG4gICAgXCJTZXBcIiwgXCJPY3RcIixcIk5vdlwiLCBcIkRlY1wiXHJcbl1cclxuXHJcbi8vIEdyaWQgdGltZSBzdGVwc1xyXG5jb25zdCBUSU1FU0NBTEVTID0gW1xyXG4gICAgWUVBUiAqIDEwLCBZRUFSICogNSwgWUVBUiAqIDMsIFlFQVIgKiAyLCBZRUFSLFxyXG4gICAgTU9OVEggKiA2LCBNT05USCAqIDQsIE1PTlRIICogMywgTU9OVEggKiAyLCBNT05USCxcclxuICAgIERBWSAqIDE1LCBEQVkgKiAxMCwgREFZICogNywgREFZICogNSwgREFZICogMywgREFZICogMiwgREFZLFxyXG4gICAgSE9VUiAqIDEyLCBIT1VSICogNiwgSE9VUiAqIDMsIEhPVVIgKiAxLjUsIEhPVVIsXHJcbiAgICBNSU5VVEUzMCwgTUlOVVRFMTUsIE1JTlVURSAqIDEwLCBNSU5VVEU1LCBNSU5VVEUgKiAyLCBNSU5VVEVcclxuXVxyXG5cclxuLy8gR3JpZCAkIHN0ZXBzXHJcbmNvbnN0ICRTQ0FMRVMgPSBbMC4wNSwgMC4xLCAwLjIsIDAuMjUsIDAuNSwgMC44LCAxLCAyLCA1XVxyXG5cclxuY29uc3QgQ2hhcnRDb25maWcgPSB7XHJcbiAgICBTQk1JTjogNjAsICAgICAgIC8vIE1pbmltYWwgc2lkZWJhciBweFxyXG4gICAgU0JNQVg6IEluZmluaXR5LCAvLyBNYXggc2lkZWJhciwgcHhcclxuICAgIFRPT0xCQVI6IDU3LCAgICAgLy8gVG9vbGJhciB3aWR0aCBweFxyXG4gICAgVEJfSUNPTjogMjUsICAgICAvLyBUb29sYmFyIGljb24gc2l6ZSBweFxyXG4gICAgVEJfSVRFTV9NOiA2LCAgICAvLyBUb29sYmFyIGl0ZW0gbWFyZ2luIHB4XHJcbiAgICBUQl9JQ09OX0JSSTogMSwgIC8vIFRvb2xiYXIgaWNvbiBicmlnaHRuZXNzXHJcbiAgICBUQl9JQ09OX0hPTEQ6IDQyMCwgLy8gbXMsIHdhaXQgdG8gZXhwYW5kXHJcbiAgICBUQl9CT1JERVI6IDEsICAgIC8vIFRvb2xiYXIgYm9yZGVyIHB4XHJcbiAgICBUQl9CX1NUWUxFOiAnZG90dGVkJywgLy8gVG9vbGJhciBib3JkZXIgc3R5bGVcclxuICAgIFRPT0xfQ09MTDogNywgICAgLy8gVG9vbCBjb2xsaXNpb24gdGhyZXNob2xkXHJcbiAgICBFWFBBTkQ6IDAuMTUsICAgIC8vICUvMTAwIG9mIHJhbmdlXHJcbiAgICBDQU5ETEVXOiAwLjYsICAgIC8vICUvMTAwIG9mIHN0ZXBcclxuICAgIEdSSURYOiAxMDAsICAgICAgLy8gcHhcclxuICAgIEdSSURZOiA0NywgICAgICAgLy8gcHhcclxuICAgIEJPVEJBUjogMjgsICAgICAgLy8gcHhcclxuICAgIFBBTkhFSUdIVDogMjIsICAgLy8gcHhcclxuICAgIERFRkFVTFRfTEVOOiA1MCwgLy8gY2FuZGxlc1xyXG4gICAgTUlOSU1VTV9MRU46IDUsICAvLyBjYW5kbGVzLFxyXG4gICAgTUlOX1pPT006IDI1LCAgICAvLyBjYW5kbGVzXHJcbiAgICBNQVhfWk9PTTogMTAwMCwgIC8vIGNhbmRsZXMsXHJcbiAgICBWT0xTQ0FMRTogMC4xNSwgIC8vICUvMTAwIG9mIGhlaWdodFxyXG4gICAgVVhfT1BBQ0lUWTogMC45LCAvLyBVeCBiYWNrZ3JvdW5kIG9wYWNpdHlcclxuICAgIFpPT01fTU9ERTogJ3R2JywgLy8gJ3R2JyBvciAndGwnXHJcbiAgICBMX0JUTl9TSVpFOiAyMSwgIC8vIExlZ2VuZCBCdXR0b24gc2l6ZSwgcHhcclxuICAgIExfQlROX01BUkdJTjogJy02cHggMCAtNnB4IDAnLCAvLyBjc3MgbWFyZ2luXHJcbiAgICBTQ1JPTExfV0hFRUw6ICdwcmV2ZW50JywgLy8gJ3Bhc3MnLCAnY2xpY2snXHJcbn1cclxuXHJcbkNoYXJ0Q29uZmlnLkZPTlQgPVxyXG4gICAgYDExcHggLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsXHJcbiAgICBTZWdvZSBVSSxSb2JvdG8sT3h5Z2VuLFVidW50dSxDYW50YXJlbGwsXHJcbiAgICBGaXJhIFNhbnMsRHJvaWQgU2FucyxIZWx2ZXRpY2EgTmV1ZSxcclxuICAgIHNhbnMtc2VyaWZgXHJcblxyXG5jb25zdCBJQl9URl9XQVJOID1cclxuICAgIGBXaGVuIHVzaW5nIElCIG1vZGUgeW91IHNob3VsZCBzcGVjaWZ5IGAgK1xyXG4gICAgYHRpbWVmcmFtZSAoJ3RmJyBmaWxlZCBpbiAnY2hhcnQnIG9iamVjdCksYCArXHJcbiAgICBgb3RoZXJ3aXNlIHlvdSBjYW4gZ2V0IGFuIHVuZXhwZWN0ZWQgYmVoYXZpb3VyYFxyXG5cclxuY29uc3QgTUFQX1VOSVQgPSB7XHJcbiAgXCIxc1wiOiBTRUNPTkQsXHJcbiAgXCI1c1wiOiBTRUNPTkQgKiA1LFxyXG4gIFwiMTBzXCI6IFNFQ09ORCAqIDEwLFxyXG4gIFwiMjBzXCI6IFNFQ09ORCAqIDIwLFxyXG4gIFwiMzBzXCI6IFNFQ09ORCAqIDMwLFxyXG4gIFwiMW1cIjogTUlOVVRFLFxyXG4gIFwiM21cIjogTUlOVVRFMyxcclxuICBcIjVtXCI6IE1JTlVURTUsXHJcbiAgXCIxNW1cIjogTUlOVVRFMTUsXHJcbiAgXCIzMG1cIjogTUlOVVRFMzAsXHJcbiAgXCIxSFwiOiBIT1VSLFxyXG4gIFwiMkhcIjogSE9VUiAqIDIsXHJcbiAgXCIzSFwiOiBIT1VSICogMyxcclxuICBcIjRIXCI6IEhPVVI0LFxyXG4gIFwiMTJIXCI6IEhPVVIxMixcclxuICBcIjFEXCI6IERBWSxcclxuICBcIjFXXCI6IFdFRUssXHJcbiAgXCIxTVwiOiBNT05USCxcclxuICBcIjFZXCI6IFlFQVJcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgU0VDT05EOiBTRUNPTkQsXHJcbiAgICBNSU5VVEU6IE1JTlVURSxcclxuICAgIE1JTlVURTU6IE1JTlVURTUsXHJcbiAgICBNSU5VVEUxNTogTUlOVVRFMTUsXHJcbiAgICBNSU5VVEUzMDogTUlOVVRFMzAsXHJcbiAgICBIT1VSOiBIT1VSLFxyXG4gICAgSE9VUjQ6IEhPVVI0LFxyXG4gICAgREFZOiBEQVksXHJcbiAgICBXRUVLOiBXRUVLLFxyXG4gICAgTU9OVEg6IE1PTlRILFxyXG4gICAgWUVBUjogWUVBUixcclxuICAgIE1PTlRITUFQOiBNT05USE1BUCxcclxuICAgIFRJTUVTQ0FMRVM6IFRJTUVTQ0FMRVMsXHJcbiAgICAkU0NBTEVTOiAkU0NBTEVTLFxyXG4gICAgQ2hhcnRDb25maWc6IENoYXJ0Q29uZmlnLFxyXG4gICAgbWFwX3VuaXQ6IE1BUF9VTklULFxyXG4gICAgSUJfVEZfV0FSTlxyXG59XHJcbiIsImltcG9ydCBJbmRleGVkQXJyYXkgZnJvbSAnYXJyYXlzbGljZXInXHJcbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0YW50cy5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgICBuYW1lMk5hbWUoc2V0dCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldENoYXJBdChzdHIsaW5kZXgsY2hyKSB7XHJcbiAgICAgICAgICAgIGlmKGluZGV4ID4gc3RyLmxlbmd0aC0xKSByZXR1cm4gc3RyXHJcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsaW5kZXgpICsgY2hyICsgc3RyLnN1YnN0cmluZyhpbmRleCsxKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0dCA9IHNldHQucmVwbGFjZSgvKFteQS1aXSkoW0EtWl0pL2csICckMSAkMicpXHJcbiAgICAgICAgc2V0dCA9IHNldHQucmVwbGFjZSgvLXxfL2csICcgJylcclxuICAgICAgICBsZXQgdHVwbGUgPSBzZXR0LnNwbGl0KCcgJylcclxuICAgICAgICB0dXBsZSA9IHR1cGxlXHJcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4Lmxlbmd0aClcclxuICAgICAgICAgICAgLm1hcCh4ID0+IHNldENoYXJBdCh4LCAwLCB4WzBdLnRvVXBwZXJDYXNlKCkpKVxyXG4gICAgICAgIHJldHVybiB0dXBsZS5qb2luKCcnKVxyXG4gICAgfSxcclxuXHJcbiAgICBjbGFtcChudW0sIG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bSA8PSBtaW4gPyBtaW4gOiBudW0gPj0gbWF4ID8gbWF4IDogbnVtXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZF96ZXJvKGkpIHtcclxuICAgICAgICBpZiAoaSA8IDEwKSB7XHJcbiAgICAgICAgICAgIGkgPSBcIjBcIiArIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFN0YXJ0IG9mIHRoZSBkYXkgKHplcm8gbWlsbGlzZWNvbmQpXHJcbiAgICBkYXlfc3RhcnQodCkge1xyXG4gICAgICAgIGxldCBzdGFydCA9IG5ldyBEYXRlKHQpXHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0LnNldFVUQ0hvdXJzKDAsMCwwLDApXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFN0YXJ0IG9mIHRoZSBtb250aFxyXG4gICAgbW9udGhfc3RhcnQodCkge1xyXG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUodClcclxuICAgICAgICByZXR1cm4gRGF0ZS5VVEMoXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRNb250aCgpLCAxXHJcbiAgICAgICAgKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTdGFydCBvZiB0aGUgeWVhclxyXG4gICAgeWVhcl9zdGFydCh0KSB7XHJcbiAgICAgICAgcmV0dXJuIERhdGUuVVRDKG5ldyBEYXRlKHQpLmdldEZ1bGxZZWFyKCkpXHJcbiAgICB9LFxyXG5cclxuICAgIGdldF95ZWFyKHQpIHtcclxuICAgICAgICBpZiAoIXQpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUodCkuZ2V0VVRDRnVsbFllYXIoKVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRfbW9udGgodCkge1xyXG4gICAgICAgIGlmICghdCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0KS5nZXRVVENNb250aCgpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIE5lYXJlc3QgaW4gYXJyYXlcclxuICAgIG5lYXJlc3RfYSh4LCBhcnJheSkge1xyXG4gICAgICAgIGxldCBkaXN0ID0gSW5maW5pdHlcclxuICAgICAgICBsZXQgdmFsID0gbnVsbFxyXG4gICAgICAgIGxldCBpbmRleCA9IC0xXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgeGkgPSBhcnJheVtpXVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoeGkgLSB4KSA8IGRpc3QpIHtcclxuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLmFicyh4aSAtIHgpXHJcbiAgICAgICAgICAgICAgICB2YWwgPSB4aVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtpbmRleCwgdmFsXVxyXG4gICAgfSxcclxuXHJcbiAgICByb3VuZChudW0sIGRlY2ltYWxzID0gOCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b0ZpeGVkKGRlY2ltYWxzKSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU3RyaXA/IE5vLCBpdCdzIHVnbHkgZmxvYXRzIGluIGpzXHJcbiAgICBzdHJpcChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChcclxuICAgICAgICAgICAgcGFyc2VGbG9hdChudW1iZXIpLnRvUHJlY2lzaW9uKDEyKVxyXG4gICAgICAgIClcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0X2RheSh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQgPyBuZXcgRGF0ZSh0KS5nZXREYXRlKCkgOiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFVwZGF0ZSBhcnJheSBrZWVwaW5nIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG4gICAgb3ZlcndyaXRlKGFyciwgbmV3X2Fycikge1xyXG4gICAgICAgIGFyci5zcGxpY2UoMCwgYXJyLmxlbmd0aCwgLi4ubmV3X2FycilcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ29weSBsYXlvdXQgaW4gcmVhY3RpdmUgd2F5XHJcbiAgICBjb3B5X2xheW91dChvYmosIG5ld19vYmopIHtcclxuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoc29tZSBvZmZjaGFydCBpbmRpY2F0b3JzIGFyZSBhZGRlZC9yZW1vdmVkKVxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgbGF5b3V0IGluIGEgcmVhY3RpdmUgd2F5XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqW2tdLmxlbmd0aCAhPT0gbmV3X29ialtrXS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm92ZXJ3cml0ZShvYmpba10sIG5ld19vYmpba10pXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gb2JqW2tdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvYmpba11bbV0sIG5ld19vYmpba11bbV0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9ialtrXSwgbmV3X29ialtrXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGV0ZWN0cyBjYW5kbGVzIGludGVydmFsXHJcbiAgICBkZXRlY3RfaW50ZXJ2YWwob2hsY3YpIHtcclxuICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4ob2hsY3YubGVuZ3RoIC0gMSwgOTkpXHJcbiAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5XHJcbiAgICAgICAgb2hsY3Yuc2xpY2UoMCwgbGVuKS5mb3JFYWNoKCh4LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkID0gb2hsY3ZbaSsxXVswXSAtIHhbMF1cclxuICAgICAgICAgICAgaWYgKGQgPT09IGQgJiYgZCA8IG1pbikgbWluID0gZFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gVGhpcyBzYXZlcyBtb250aGx5IGNoYXJ0IGZyb20gYmVpbmcgYXdrd2FyZFxyXG4gICAgICAgIGlmIChtaW4gPj0gQ29uc3QuTU9OVEggJiYgbWluIDw9IENvbnN0LkRBWSAqIDMwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb25zdC5EQVkgKiAzMVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWluXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdldHMgbnVtYmVyaWMgcGFydCBvZiBvdmVybGF5IGlkIChlLmcgJ0VNQV8xJyA9ID4gMSlcclxuICAgIGdldF9udW1faWQoaWQpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaWQuc3BsaXQoJ18nKS5wb3AoKSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRmFzdCBmaWx0ZXIuIFJlYWxseSBmYXN0LCBsaWtlIDEwWFxyXG4gICAgZmFzdF9maWx0ZXIoYXJyLCB0MSwgdDIpIHtcclxuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHJldHVybiBbYXJyLCB1bmRlZmluZWRdXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IGlhID0gbmV3IEluZGV4ZWRBcnJheShhcnIsIFwiMFwiKVxyXG4gICAgICAgICAgICBsZXQgcmVzID0gaWEuZ2V0UmFuZ2UodDEsIHQyKVxyXG4gICAgICAgICAgICBsZXQgaTAgPSBpYS52YWxwb3NbdDFdLm5leHRcclxuICAgICAgICAgICAgcmV0dXJuIFtyZXMsIGkwXVxyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgd3Jvbmcgd2l0aCBmYW5jeSBzbGljZSBsaWJcclxuICAgICAgICAgICAgLy8gRmFzdCBmaXg6IGZhbGxiYWNrIHRvIGZpbHRlclxyXG4gICAgICAgICAgICByZXR1cm4gW2Fyci5maWx0ZXIoeCA9PlxyXG4gICAgICAgICAgICAgICAgeFswXSA+PSB0MSAmJiB4WzBdIDw9IHQyXHJcbiAgICAgICAgICAgICksIDBdXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGYXN0IGZpbHRlciAoaW5kZXgtYmFzZWQpXHJcbiAgICBmYXN0X2ZpbHRlcl9pKGFyciwgdDEsIHQyKSB7XHJcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSByZXR1cm4gW2FyciwgdW5kZWZpbmVkXVxyXG4gICAgICAgIGxldCBpMSA9ICBNYXRoLmZsb29yKHQxKVxyXG4gICAgICAgIGlmIChpMSA8IDApIGkxID0gMFxyXG4gICAgICAgIGxldCBpMiA9ICBNYXRoLmZsb29yKHQyICsgMSlcclxuICAgICAgICBsZXQgcmVzID0gYXJyLnNsaWNlKGkxLCBpMilcclxuICAgICAgICByZXR1cm4gW3JlcywgaTFdXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIE5lYXJlc3QgaW5kZXhlcyAobGVmdCBhbmQgcmlnaHQpXHJcbiAgICBmYXN0X25lYXJlc3QoYXJyLCB0MSkge1xyXG4gICAgICAgIGxldCBpYSA9IG5ldyBJbmRleGVkQXJyYXkoYXJyLCBcIjBcIilcclxuICAgICAgICBpYS5mZXRjaCh0MSlcclxuICAgICAgICByZXR1cm4gW2lhLm5leHRsb3csIGlhLm5leHRoaWdoXVxyXG4gICAgfSxcclxuXHJcbiAgICBub3coKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH0sXHJcblxyXG4gICAgcGF1c2UoZGVsYXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJzLCByaikgPT4gc2V0VGltZW91dChycywgZGVsYXkpKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBMaW1pdCBjcmF6eSB3aGVlbCBkZWx0YSB2YWx1ZXNcclxuICAgIHNtYXJ0X3doZWVsKGRlbHRhKSB7XHJcbiAgICAgICAgbGV0IGFicyA9IE1hdGguYWJzKGRlbHRhKVxyXG4gICAgICAgIGlmIChhYnMgPiA1MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICgyMDAgKyBNYXRoLmxvZyhhYnMpKSAqIE1hdGguc2lnbihkZWx0YSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFBhcnNlIHRoZSBvcmlnaW5hbCBtb3VzZSBldmVudCB0byBmaW5kIGRlbHRhWFxyXG4gICAgZ2V0X2RlbHRhWChldmVudCkge1xyXG4gICAgICAgIHJldHVybiBldmVudC5vcmlnaW5hbEV2ZW50LmRlbHRhWCAvIDEyXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFBhcnNlIHRoZSBvcmlnaW5hbCBtb3VzZSBldmVudCB0byBmaW5kIGRlbHRhWVxyXG4gICAgZ2V0X2RlbHRhWShldmVudCkge1xyXG4gICAgICAgIHJldHVybiBldmVudC5vcmlnaW5hbEV2ZW50LmRlbHRhWSAvIDEyXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEFwcGx5IG9wYWNpdHkgdG8gYSBoZXggY29sb3JcclxuICAgIGFwcGx5X29wYWNpdHkoYywgb3ApIHtcclxuICAgICAgICBpZiAoYy5sZW5ndGggPT09IDcpIHtcclxuICAgICAgICAgICAgbGV0IG4gPSBNYXRoLmZsb29yKG9wICogMjU1KVxyXG4gICAgICAgICAgICBuID0gdGhpcy5jbGFtcChuLCAwLCAyNTUpXHJcbiAgICAgICAgICAgIGMgKz0gbi50b1N0cmluZygxNilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUGFyc2UgdGltZWZyYW1lIG9yIHJldHVybiB2YWx1ZSBpbiBtc1xyXG4gICAgcGFyc2VfdGYoc210aCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc210aCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0Lm1hcF91bml0W3NtdGhdXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNtdGhcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERldGVjdCBpbmRleCBzaGlmdCBiZXR3ZWVuIHRoZSBtYWluIGRhdGEgc3ViXHJcbiAgICAvLyBhbmQgdGhlIG92ZXJsYXkncyBzdWIgKGZvciBJQi1tb2RlKVxyXG4gICAgaW5kZXhfc2hpZnQoc3ViLCBkYXRhKSB7XHJcblxyXG4gICAgICAgIC8vIEZpbmQgdGhlIHNlY29uZCB0aW1lc3RhbXAgKGJ5IHZhbHVlKVxyXG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHJldHVybiAwXHJcbiAgICAgICAgbGV0IGZpcnN0ID0gZGF0YVswXVswXVxyXG4gICAgICAgIGxldCBzZWNvbmRcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhW2ldWzBdICE9PSBmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kID0gZGF0YVtpXVswXVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKHN1YltqXVswXSA9PT0gc2Vjb25kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaiAtIGlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIDBcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRmFsbGJhY2sgZml4IGZvciBCcmF2ZSBicm93c2VyXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnJhdmUvYnJhdmUtYnJvd3Nlci9pc3N1ZXMvMTczOFxyXG4gICAgbWVhc3VyZVRleHQoY3R4LCB0ZXh0LCB0dl9pZCkge1xyXG4gICAgICAgIGxldCBtID0gY3R4Lm1lYXN1cmVUZXh0T3JnKHRleHQpXHJcbiAgICAgICAgaWYgKG0ud2lkdGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZG9jID0gZG9jdW1lbnRcclxuICAgICAgICAgICAgY29uc3QgaWQgPSAndHZqcy1tZWFzdXJlLXRleHQnXHJcbiAgICAgICAgICAgIGxldCBlbCA9IGRvYy5nZXRFbGVtZW50QnlJZChpZClcclxuICAgICAgICAgICAgaWYgKCFlbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBkb2MuZ2V0RWxlbWVudEJ5SWQodHZfaWQpXHJcbiAgICAgICAgICAgICAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICAgICAgICAgICAgICBlbC5pZCA9IGlkXHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRvcCA9ICctMTAwMHB4J1xyXG4gICAgICAgICAgICAgICAgYmFzZS5hcHBlbmRDaGlsZChlbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihjdHguZm9udCkgZWwuc3R5bGUuZm9udCA9IGN0eC5mb250XHJcbiAgICAgICAgICAgIGVsLmlubmVyVGV4dCA9IHRleHQucmVwbGFjZSgvIC9nLCAnLicpO1xyXG4gICAgICAgICAgICByZXR1cm4geyB3aWR0aDogZWwub2Zmc2V0V2lkdGggfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1dWlkKHRlbXAgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jykge1xyXG4gICAgICAgIHJldHVybiB0ZW1wXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xyXG4gICAgICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09ICd4JyA/XHJcbiAgICAgICAgICAgICAgICByIDpcclxuICAgICAgICAgICAgICAgIChyICYgMHgzIHwgMHg4KVxyXG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNilcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuXHJcbiAgICB1dWlkMigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51dWlkKCd4eHh4eHh4eHh4eHgnKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBEZWxheWVkIHdhcm5pbmcsIGYgPSBjb25kaXRpb24gbGFtYmRhIGZuXHJcbiAgICB3YXJuKGYsIHRleHQsIGRlbGF5ID0gMCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZigpKSBjb25zb2xlLndhcm4odGV4dClcclxuICAgICAgICB9LCBkZWxheSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hlY2tzIGlmIHNjcmlwdCBwcm9wcyB1cGRhdGVkXHJcbiAgICAvLyAoYW5kIG5vdCBzdHlsZSBzZXR0aW5ncyBvciBzb21ldGhpbmcgZWxzZSlcclxuICAgIGlzX3Njcl9wcm9wc191cGQobiwgcHJldikge1xyXG4gICAgICAgIGxldCBwID0gcHJldi5maW5kKHggPT4geC52LiR1dWlkID09PSBuLnYuJHV1aWQpXHJcbiAgICAgICAgaWYgKCFwKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgbGV0IHByb3BzID0gbi5wLnNldHRpbmdzLiRwcm9wc1xyXG4gICAgICAgIGlmICghcHJvcHMpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvcHMuc29tZSh4ID0+IG4udlt4XSAhPT0gcC52W3hdKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDaGVja3MgaWYgaXQncyB0aW1lIHRvIG1ha2UgYSBzY3JpcHQgdXBkYXRlXHJcbiAgICAvLyAoYmFzZWQgb24gZXhlY0ludGVydmFsIGluIG1zKVxyXG4gICAgZGVsYXllZF9leGVjKHYpIHtcclxuICAgICAgICBpZiAoIXYuc2NyaXB0IHx8ICF2LnNjcmlwdC5leGVjSW50ZXJ2YWwpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgbGV0IHQgPSB0aGlzLm5vdygpXHJcbiAgICAgICAgbGV0IGR0ID0gdi5zY3JpcHQuZXhlY0ludGVydmFsXHJcbiAgICAgICAgaWYgKCF2LnNldHRpbmdzLiRsYXN0X2V4ZWMgfHxcclxuICAgICAgICAgICAgdCA+IHYuc2V0dGluZ3MuJGxhc3RfZXhlYyArIGR0KSB7XHJcbiAgICAgICAgICAgIHYuc2V0dGluZ3MuJGxhc3RfZXhlYyA9IHRcclxuICAgICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZvcm1hdCBuYW1lcyBzdWNoICdSU0ksICRsZW5ndGgnLCB3aGVyZVxyXG4gICAgLy8gbGVuZ3RoIC0gaXMgb25lIG9mIHRoZSBzZXR0aW5nc1xyXG4gICAgZm9ybWF0X25hbWUob3YpIHtcclxuICAgICAgICBpZiAoIW92Lm5hbWUpIHJldHVybiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgbGV0IG5hbWUgPSBvdi5uYW1lXHJcblxyXG4gICAgICAgIGZvciAodmFyIGsgaW4gb3Yuc2V0dGluZ3MgfHwge30pIHtcclxuICAgICAgICAgICAgbGV0IHZhbCA9IG92LnNldHRpbmdzW2tdXHJcbiAgICAgICAgICAgIGxldCByZWcgPSBuZXcgUmVnRXhwKGBcXFxcJCR7a31gLCAnZycpXHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UocmVnLCB2YWwpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmFtZVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBEZWZhdWx0IGN1cnNvciBtb2RlXHJcbiAgICB4bW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc19tb2JpbGUgPyAnZXhwbG9yZScgOiAnZGVmYXVsdCdcclxuICAgIH0sXHJcblxyXG4gICAgZGVmYXVsdF9wcmV2ZW50ZWQoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50Lm9yaWdpbmFsLmRlZmF1bHRQcmV2ZW50ZWRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcclxuICAgIH0sXHJcblxyXG4gICAgLy8gV1RGIHdpdGggbW9kZXJuIHdlYiBkZXZlbG9wbWVudFxyXG4gICAgaXNfbW9iaWxlOiAodyA9PiAnb25vcmllbnRhdGlvbmNoYW5nZScgaW4gdyAmJlxyXG4gICAgICAgKCEhbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8XHJcbiAgICAgICAgISFuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyB8fFxyXG4gICAgICAgICgnb250b3VjaHN0YXJ0JyBpbiB3IHx8XHJcbiAgICAgICAgKHcuRG9jdW1lbnRUb3VjaCAmJlxyXG4gICAgICAgIGRvY3VtZW50IGluc3RhbmNlb2Ygdy5Eb2N1bWVudFRvdWNoKSkpKVxyXG4gICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9KVxyXG5cclxufVxyXG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmFwcC1jb250ZW50IHtcXG4gICAgcGFkZGluZzogY2FsYygycmVtICsgMi40NXJlbSkgMCAwIDByZW0gIWltcG9ydGFudDtcXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbn1cXG5AbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpe1xcbmh0bWwgYm9keS5uYXZiYXItc3RpY2t5IC5hcHAtY29udGVudCB7XFxuICAgICAgICBwYWRkaW5nOiBjYWxjKDFyZW0gLSAwLjhyZW0gKyA0LjQ1cmVtKSAwIDAgMCAhaW1wb3J0YW50O1xcbn1cXG59XFxuLmZsZXhlZCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbn1cXG4jYXBwLWNvbmFpbmVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxufVxcblxcbi8qIEBtZWRpYSAobWF4LXdpZHRoOiA3NjcuOThweCl7XFxuICAgICNhcHAtY29uYWluZXIge1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgICAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICAgICAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG4gICAgfVxcbn0gKi9cXG4jdHJhZGViYXIge1xcbiAgICBjb2xvcjogI2RkZDtcXG59XFxuI3R2anMtaGVhZGVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgaGVpZ2h0OiA0MHB4O1xcbiAgICBjb2xvcjogI2RkZDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxMjE4MjY7XFxufVxcbi5uaWdodC1tb2RlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDE1cHg7XFxuICAgIHJpZ2h0OiAyMHB4O1xcbn1cXG4jdHJhZGluZy12dWUtanMtZ3JpZC0wLWNhbnZhcyxcXG4jdHJhZGluZy12dWUtanMtc2lkZWJhci0wLWNhbnZhcyxcXG4jdHJhZGluZy12dWUtanMtZ3JpZC0xLWNhbnZhcyxcXG4jdHJhZGluZy12dWUtanMtc2lkZWJhci0xLWNhbnZhcyxcXG4jdHJhZGluZy12dWUtanMtYm90YmFyLWNhbnZhcyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigwIDAgMCAvIDAlKSAhaW1wb3J0YW50O1xcbn1cXG4jdHJhZGluZy12dWUtdGJpdGVtIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDE4LCAyNCwgMzgpO1xcbn1cXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtZGV2aWNlLXdpZHRoOiA0ODBweCkge1xcbi50Zi1zZWxlY3RvciB7XFxuICAgICAgICB0b3A6IDUwcHg7XFxuICAgICAgICByaWdodDogMTQwcHg7XFxuICAgICAgICBtYXgtd2lkdGg6IDE0MHB4O1xcbiAgICAgICAgZm9udDogMTJweCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsXFxuICAgICAgICAgICAgU2Vnb2UgVUksIFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIENhbnRhcmVsbCxcXG4gICAgICAgICAgICBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLFxcbiAgICAgICAgICAgIHNhbnMtc2VyaWY7XFxufVxcbn1cXG4uYm94IHtcXG4gICAgd2lkdGg6IDI4MHB4O1xcbiAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgYm94LXNoYWRvdzogMCAxLjVweCA1cHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgcGFkZGluZzogMCAxNXB4IDAgMTVweDtcXG59XFxudGFibGUge1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgIGNvbG9yOiByZ2IoMTgzLCAxODksIDE5OCk7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG50ZCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgaGVpZ2h0OiAyMHB4O1xcbiAgICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxudGQucHJpY2Uge1xcbiAgICB3aWR0aDogMzAlO1xcbn1cXG50ZC5wcmljZSBzcGFuIHtcXG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7XFxufVxcbnRkLnF1YW50aXR5IHtcXG4gICAgd2lkdGg6IDMwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcbnRkLnRpbWUge1xcbiAgICB3aWR0aDogNDAlO1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXG4gICAgY29sb3I6ICM5OTk7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcXG59XFxudGQuYnRjIHtcXG4gICAgd2lkdGg6IDQwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcXG59XFxudGQgc3BhbiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgei1pbmRleDogMjtcXG59XFxudGFibGUuYXNrcyAucGVyY2VudCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ2LCA3MCwgOTQsIDAuMik7XFxufVxcbnRhYmxlLmJpZHMgLnBlcmNlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE0LCAyMDMsIDEyOSwgMC4yKTtcXG59XFxudGQgLnBlcmNlbnQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICByaWdodDogMDtcXG59XFxuLm5ld2VzdCB7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbiAgICBtYXJnaW46IDE1cHggLTE1cHg7XFxufVxcbi5jYXJkLTExMCB7XFxuICAgIHRvcDogMTEwcHggIWltcG9ydGFudDtcXG4gICAgbGVmdDogNzBweDtcXG59XFxuLyogU3R5bGUgcGFnZSBjb250ZW50IC0gdXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gcHVzaCB0aGUgcGFnZSBjb250ZW50IHRvIHRoZSByaWdodCB3aGVuIHlvdSBvcGVuIHRoZSBzaWRlIG5hdmlnYXRpb24gKi9cXG4jbWFpbiB7XFxuICAgIHRyYW5zaXRpb246IG1hcmdpbi1sZWZ0IC41cztcXG4gICAgLyogSWYgeW91IHdhbnQgYSB0cmFuc2l0aW9uIGVmZmVjdCAqL1xcbn1cXG5cXG4vKiBPbiBzbWFsbGVyIHNjcmVlbnMsIHdoZXJlIGhlaWdodCBpcyBsZXNzIHRoYW4gNDUwcHgsIGNoYW5nZSB0aGUgc3R5bGUgb2YgdGhlIHNpZGVuYXYgKGxlc3MgcGFkZGluZyBhbmQgYSBzbWFsbGVyIGZvbnQgc2l6ZSkgKi9cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogNDUwcHgpIHtcXG4uc2lkZWJhcjEge1xcbiAgICAgICAgcGFkZGluZy10b3A6IDE1cHg7XFxufVxcbi5zaWRlYmFyMSBhIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcXG59XFxufVxcbi5idG4tY2lyY2xlIHtcXG4gICAgd2lkdGg6IDMwcHg7XFxuICAgIGhlaWdodDogMzBweDtcXG4gICAgcGFkZGluZzogNnB4IDBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gICAgZm9udC1zaXplOiA4cHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuI2NoYXJ0ZGl2IHtcXG4gICAgbWluLWhlaWdodDogMzAwcHg7XFxuICAgIG1heC1oZWlnaHQ6IDQwMHB4O1xcbiAgICBoZWlnaHQ6IDcwdmg7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9NYWluTS52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQWtUQTtJQUNBLGlEQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUNBO0FBQ0E7UUFDQSx1REFBQTtBQUNBO0FBQ0E7QUFDQTtJQUNBLGFBQUE7SUFDQSxzQkFBQTtJQUNBLG1CQUFBO0lBQ0EsdUJBQUE7SUFDQSxxQkFBQTtJQUNBLGlCQUFBO0FBQ0E7QUFFQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtJQUNBLDhCQUFBO0lBQ0EsNEJBQUE7SUFDQSx1QkFBQTtJQUNBLGlCQUFBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztHQVNBO0FBQ0E7SUFDQSxXQUFBO0FBQ0E7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsYUFBQTtJQUNBLHFCQUFBO0lBQ0EsbUJBQUE7SUFDQSxpQkFBQTtJQUNBLHVCQUFBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsV0FBQTtJQUNBLFdBQUE7SUFDQSx5QkFBQTtBQUNBO0FBRUE7SUFDQSxrQkFBQTtJQUNBLFNBQUE7SUFDQSxXQUFBO0FBQ0E7QUFFQTs7Ozs7SUFLQSw0Q0FBQTtBQUNBO0FBRUE7SUFDQSxpQ0FBQTtBQUNBO0FBRUE7QUFDQTtRQUNBLFNBQUE7UUFDQSxZQUFBO1FBQ0EsZ0JBQUE7UUFDQTs7O3NCQUdBO0FBQ0E7QUFDQTtBQUVBO0lBQ0EsWUFBQTtJQUNBLGNBQUE7SUFDQSwrQ0FBQTtJQUNBLGtCQUFBO0lBQ0Esc0JBQUE7QUFDQTtBQUVBO0lBQ0EsZUFBQTtJQUNBLGdCQUFBO0lBQ0EseUJBQUE7SUFDQSxnQkFBQTtJQUNBLFdBQUE7QUFDQTtBQUVBO0lBQ0Esa0JBQUE7SUFDQSxZQUFBO0lBQ0EsaUJBQUE7QUFDQTtBQUVBO0lBQ0EsVUFBQTtBQUNBO0FBRUE7SUFDQSxpQkFBQTtBQUNBO0FBRUE7SUFDQSxVQUFBO0lBQ0EsaUJBQUE7QUFDQTtBQUVBO0lBQ0EsVUFBQTtJQUNBLGlCQUFBO0lBQ0EsV0FBQTtJQUNBLGtCQUFBO0FBQ0E7QUFFQTtJQUNBLFVBQUE7SUFDQSxpQkFBQTtJQUNBLGtCQUFBO0FBQ0E7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsVUFBQTtBQUNBO0FBRUE7SUFDQSx3Q0FBQTtBQUNBO0FBRUE7SUFDQSx5Q0FBQTtBQUNBO0FBRUE7SUFDQSxrQkFBQTtJQUNBLE1BQUE7SUFDQSxTQUFBO0lBQ0EsUUFBQTtBQUNBO0FBRUE7SUFDQSw2QkFBQTtJQUNBLGtCQUFBO0FBQ0E7QUFFQTtJQUNBLHFCQUFBO0lBQ0EsVUFBQTtBQUNBO0FBQ0Esc0hBQUE7QUFDQTtJQUNBLDJCQUFBO0lBQ0Esb0NBQUE7QUFDQTs7QUFFQSxnSUFBQTtBQUNBO0FBQ0E7UUFDQSxpQkFBQTtBQUNBO0FBRUE7UUFDQSxlQUFBO0FBQ0E7QUFDQTtBQUVBO0lBQ0EsV0FBQTtJQUNBLFlBQUE7SUFDQSxnQkFBQTtJQUNBLG1CQUFBO0lBQ0EsY0FBQTtJQUNBLGtCQUFBO0FBQ0E7QUFFQTtJQUNBLGlCQUFBO0lBQ0EsaUJBQUE7SUFDQSxZQUFBO0FBQ0FcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmbGV4LXN0YXJ0IGNvbC0xMCBjb2wteGxsLTEwIGNvbC14bC0xMCBjb2wtbGctMTAgY29sLW1kLTkgY29sLXNtLTEyXFxcIj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcInR2anMtaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cXFwidG9nZ2xlQ29udHJhY3RzXFxcIiBjbGFzcz1cXFwibWUtMSBiYWRnZSBiZy1saWdodC1pbmZvXFxcIiBkYXRhLWJzLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXFxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cXFwiI2NvbGxhcHNlQ29udHJhY3RzXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgYXJpYS1jb250cm9scz1cXFwiY29sbGFwc2VDb250cmFjdHNcXFwiPjxpXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImJpIGJpLWJyaWVmY2FzZVxcXCIgLz48ZGl2IGNsYXNzPVxcXCJkLW1kLWlubGluZSBkLW5vbmVcXFwiPiBDb250cmFjdHM8L2Rpdj48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgIDxhPjxzcGFuIHYtb246Y2xpY2s9XFxcImNhbmRsZXNcXFwiIGNsYXNzPVxcXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXNlY29uZGFyeVxcXCI+PGkgY2xhc3M9XFxcImJpIGJpLWJhci1jaGFydFxcXCIgLz48ZGl2IGNsYXNzPVxcXCJkLW1kLWlubGluZSBkLW5vbmVcXFwiPiAgQ2FuZGxlczwvZGl2Pjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgPGE+PHNwYW4gdi1vbjpjbGljaz1cXFwic3BsaW5lXFxcIiBjbGFzcz1cXFwibWUtMSBiYWRnZSBiZy1saWdodC1zZWNvbmRhcnlcXFwiPjxpIGNsYXNzPVxcXCJiaSBiaS1ncmFwaC11cFxcXCIgLz48ZGl2IGNsYXNzPVxcXCJkLW1kLWlubGluZSBkLW5vbmVcXFwiPiAgU3BsaW5lPC9kaXY+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cXFwidG9nZ2xlSW5mb1xcXCIgY2xhc3M9XFxcIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1xcXCIgZGF0YS1icy10b2dnbGU9XFxcImNvbGxhcHNlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1icy10YXJnZXQ9XFxcIiNjb2xsYXBzZUluZm9zXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgYXJpYS1jb250cm9scz1cXFwiY29sbGFwc2VJbmZvc1xcXCI+PGlcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiYmkgYmktaW5mby1jaXJjbGVcXFwiIC8+PGRpdiBjbGFzcz1cXFwiZC1tZC1pbmxpbmUgZC1ub25lXFxcIj4gIEluZm88L2Rpdj48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgIDxhPjxzcGFuIGlkPVxcXCJ0b2dnbGVEZXB0aFxcXCIgY2xhc3M9XFxcIm1lLTEgYmFkZ2UgYmctbGlnaHQtcHJpbWFyeSBcXFwiIGRhdGEtYnMtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVxcXCIjY29sbGFwc2VEZXB0aFxcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiIGFyaWEtY29udHJvbHM9XFxcImNvbGxhcHNlRGVwdGhcXFwiPjxpXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImJpIGJpLWthbmJhblxcXCIgLz48ZGl2IGNsYXNzPVxcXCJkLW1kLWlubGluZSBkLW5vbmVcXFwiPiAgRGVwdGggVmlldzwvZGl2Pjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgPGE+PHNwYW4gaWQ9XFxcInRvZ2dsZU9yZGVyc1xcXCIgY2xhc3M9XFxcIm1lLTEgYmFkZ2UgYmctbGlnaHQtd2FybmluZyBcXFwiIGRhdGEtYnMtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCJcXG4gICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cXFwiI2NvbGxhcHNlT3JkZXJzXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgYXJpYS1jb250cm9scz1cXFwiY29sbGFwc2VPcmRlcnNcXFwiPjxpXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImJpIGJpLWZpbGUtYmFyLWdyYXBoXFxcIiAvPjxkaXYgY2xhc3M9XFxcImQtbWQtaW5saW5lIGQtbm9uZVxcXCI+ICBPcmRlciBCb29rPC9kaXY+PC9zcGFuPjwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cXFwiY29sbGFwc2VJbmZvc1xcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiY29sbGFwc2UgY29sLWxnLTQgY29sLW1kLTUgY29sLXNtLTYgcG9zaXRpb24tYWJzb2x1dGUgc3RpY2t5LXRvcCBjYXJkLTExMCBcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmRcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kOiMxMzE3MjJlNiFpbXBvcnRhbnQ7Ym94LXNoYWRvdzogMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSk7XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1oZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLThcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cXFwiY2FyZC10aXRsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHN5bWJvbCB9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaDQ+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC04XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcInNob3dfYlxcXCIgY2xhc3M9XFxcInRleHQtc3RhcnQgZnMtMVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcInNob3dfcFxcXCIgY2xhc3M9XFxcInRleHQtZW5kXFxcIiBzdHlsZT1cXFwiZm9udC1zaXplOjE0cHg7XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwic2hvd19QXFxcIiBjbGFzcz1cXFwidGV4dC1lbmRcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6MTRweDtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBtdC0xXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwibXlSYW5nZUNvbG9yXFxcIiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwibXlSYW5nZVxcXCIgY2xhc3M9XFxcInByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItc3RyaXBlZCBwcm9ncmVzcy1iYXItYW5pbWF0ZWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcIjUwXFxcIiBhcmlhLXZhbHVlbWluPVxcXCIwXFxcIiBhcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XFxcIndpZHRoOiA4MCVcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwic2hvd19sXFxcIiBjbGFzcz1cXFwiY29sIHRleHQtc3RhcnQgdGV4dC1kYW5nZXJcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6MTBweDtcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCB0ZXh0LWRhcmsgdGV4dC1jZW50ZXJcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6MTBweDtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF5IFJhbmdlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJzaG93X2hcXFwiIGNsYXNzPVxcXCJjb2wgdGV4dC1lbmQgdGV4dC1zdWNjZXNzXFxcIiBzdHlsZT1cXFwiZm9udC1zaXplOjEwcHg7XFxcIiAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBtdC0xXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVxcXCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhcmsgY2xlYXJmaXhcXFwiPlZvbHVtZSAyNEg8L3NtYWxsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgaWQ9XFxcInNob3dfdlxcXCIgY2xhc3M9XFxcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFxcXCI+TWFya2V0IENhcDwvc21hbGw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBpZD1cXFwic2hvd19tY1xcXCIgY2xhc3M9XFxcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFxcXCI+VG90YWwgU3VwcGx5PC9zbWFsbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGlkPVxcXCJzaG93X3RzXFxcIiBjbGFzcz1cXFwiY29sIHRleHQtZW5kIHRleHQtd2FybmluZyBjbGVhcmZpeFxcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJjb2xsYXBzZURlcHRoXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJjb2xsYXBzZSBjb2wtbGctNiBjb2wtbWQtMTAgY29sLXNtLTEyIGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwIFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZFxcXCIgc3R5bGU9XFxcImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwiY2hhcnRkaXZcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cXFwiY29sbGFwc2VPcmRlcnNcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImNvbGxhcHNlIGNvbC1sZy00IGNvbC1tZC00IGNvbC1zbS02IGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwXFxcIiBzdHlsZT1cXFwibWF4LXdpZHRoOjI4MHB4O1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZFxcXCIgc3R5bGU9XFxcImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLWNvbnRlbnQgbXktMVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3hcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoZWFkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXCJtYi0xXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcInRleHQtc3RhcnQgcHMtMSB0ZXh0LWRhcmtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmljZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlciBwcy0xIHRleHQtZGFya1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1YW50aXR5XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcInRleHQtZW5kIHBlLTEgdGV4dC1kYXJrXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG90YWxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cXFwiYXNrc1xcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuZXdlc3RcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJiaWRzXFxcIiAvPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhcHAtY29udGFpbmVyXFxcIiBzdHlsZT1cXFwibWFyZ2luLXRvcDo0MHB4XFxcIj5cXG4gICAgICAgICAgICA8dHJhZGluZy12dWUgOmtleT1cXFwicmVzZXRrZXlcXFwiIHJlZj1cXFwidHZqc1xcXCIgOmRhdGE9XFxcImRjXFxcIiA6d2lkdGg9XFxcIndpZHRoXFxcIiA6aGVpZ2h0PVxcXCJoZWlnaHRcXFwiIDp0aXRsZS10eHQ9XFxcInRpdGxlXFxcIlxcbiAgICAgICAgICAgICAgICBjb2xvci10aXRsZT1cXFwiI2ZmOWY0M1xcXCIgOmxlZ2VuZC1idXR0b25zPVxcXCJbJ2Rpc3BsYXknLCAnc2V0dGluZ3MnLCAndXAnLCAnZG93bicsICdhZGQnLCAncmVtb3ZlJ11cXFwiXFxuICAgICAgICAgICAgICAgIDpjaGFydC1jb25maWc9XFxcIntERUZBVUxUX0xFTjozMCxNSU5fWk9PTToxfVxcXCIgOmNvbG9yLWJhY2s9XFxcImNvbG9ycy5jb2xvckJhY2tcXFwiXFxuICAgICAgICAgICAgICAgIDpjb2xvci1ncmlkPVxcXCJjb2xvcnMuY29sb3JHcmlkXFxcIiA6Y29sb3ItdGV4dD1cXFwiY29sb3JzLmNvbG9yVGV4dFxcXCIgOmV4dGVuc2lvbnM9XFxcImV4dFxcXCIgOm92ZXJsYXlzPVxcXCJvdnNcXFwiXFxuICAgICAgICAgICAgICAgIDpuaWdodD1cXFwibmlnaHRcXFwiIDpyZXNldGtleT1cXFwicmVzZXRrZXlcXFwiIDp4LXNldHRpbmdzPVxcXCJ4c2V0dFxcXCIgOnRpbWV6b25lPVxcXCJ0aW1lem9uZVxcXCIgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuaW1wb3J0IHsgVHJhZGluZ1Z1ZSwgRGF0YUN1YmUgfSBmcm9tICd0cmFkaW5nLXZ1ZS1qcydcXG5pbXBvcnQgT3ZlcmxheXMgZnJvbSAndHZqcy1vdmVybGF5cydcXG5pbXBvcnQgRGF0YSBmcm9tICcuLi9yZXNvdXJjZXMvZGF0YS9kYXRhLmpzb24nXFxuaW1wb3J0IFV0aWxzIGZyb20gJy4vc3R1ZmYvdXRpbHMuanMnXFxuaW1wb3J0IENvbnN0IGZyb20gJy4vc3R1ZmYvY29uc3RhbnRzLmpzJ1xcbmltcG9ydCBTdHJlYW0gZnJvbSAnLi9zdHJlYW0uanMnXFxuaW1wb3J0IEV4dGVuc2lvbnMgZnJvbSAnLi9pbmRleF9kZXYnXFxuXFxuLy8gR2V0dGluJyBkYXRhIHRocm91Z2ggd2VicGVjayBwcm94eVxcbmNvbnN0IHN5bWJvbHNtID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKVszXSsndXNkdCdcXG5jb25zdCBzeW1ib2xiZyA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS50b1VwcGVyQ2FzZSgpLnNwbGl0KCcvJylbM10rJ1VTRFQnXFxuY29uc3QgVVJMID0gYGh0dHBzOi8vYmluYW5jZS13YXRjaC13cmFwcGVyLmhlcm9rdWFwcC5jb20vaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vYXBpL3YxL2tsaW5lcz9zeW1ib2w9YFxcbmNvbnN0IFdTUyA9IGB3c3M6Ly9zdHJlYW0uYmluYW5jZS5jb206OTQ0My93cy8ke3N5bWJvbHNtfUBhZ2dUcmFkZWBcXG5jb25zdCBkYXRhcyA9IGBkYXRhc2V0cy5iaW5hbmNlLSR7c3ltYm9sc219YFxcbi8vY29uc3QgUE9SVCA9IGxvY2F0aW9uLnBvcnRcXG4vL2NvbnN0IFVSTCA9IGBodHRwOi8vbG9jYWxob3N0OiR7UE9SVH0vYXBpL3YxL2tsaW5lcz9zeW1ib2w9YFxcbi8vY29uc3QgV1NTID0gYHdzOi8vbG9jYWxob3N0OiR7UE9SVH0vd3MvJHtzeW1ib2xzbX1AYWdnVHJhZGVgXFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBuYW1lOiAnQXBwJyxcXG4gICAgY29tcG9uZW50czoge1xcbiAgICAgICAgVHJhZGluZ1Z1ZVxcbiAgICB9LFxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBkYzogbmV3IERhdGFDdWJlKERhdGEpLFxcbiAgICAgICAgICAgIHRpdGxlOiBzeW1ib2xiZyxcXG4gICAgICAgICAgICB3aWR0aDogMCxcXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXFxuICAgICAgICAgICAgbG9nX3NjYWxlOiB0cnVlLFxcbiAgICAgICAgICAgIHN5bWJvbDogc3ltYm9sYmcsXFxuICAgICAgICAgICAgaW5kZXhfYmFzZWQ6IHRydWUsXFxuICAgICAgICAgICAgdGltZXpvbmU6IHRoaXMudGltZXpvbmVkKCksXFxuICAgICAgICAgICAgeHNldHQ6IHtcXG4gICAgICAgICAgICAgICAgJ2dyaWQtcmVzaXplJzogeyBtaW5faGVpZ2h0OiAzMCB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBvdnM6IE9iamVjdC52YWx1ZXMoT3ZlcmxheXMpLFxcbiAgICAgICAgICAgIGV4dDogT2JqZWN0LnZhbHVlcyhFeHRlbnNpb25zKSxcXG4gICAgICAgICAgICBuaWdodDogdHJ1ZSxcXG4gICAgICAgICAgICB0b3A6IDUwLFxcbiAgICAgICAgICAgIHJlc2V0a2V5OiAwXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICBjb2xvcnMoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmlnaHQgPyB7fSA6IHtcXG4gICAgICAgICAgICAgICAgY29sb3JCYWNrOiAnI2ZmZicsXFxuICAgICAgICAgICAgICAgIGNvbG9yR3JpZDogJyNlZWUnLFxcbiAgICAgICAgICAgICAgICBjb2xvclRleHQ6ICcjMzMzJ1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbW91bnRlZCgpIHtcXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplKVxcbiAgICAgICAgbGV0IHEgPSB0aGlzLndpbl9xdWVyeSgpXFxuICAgICAgICBpZiAocS5ubSA9PT0gJ2ZhbHNlJykgdGhpcy5uaWdodCA9IGZhbHNlXFxuICAgICAgICBpZiAocS5vdikgdGhpcy5jdXJyZW50ID0gcS5vdlxcbiAgICAgICAgaWYgKHEuaGVhZGVyID09PSAnZmFsc2UnKSB0aGlzLnRvcCA9IDBcXG4gICAgICAgIHRoaXMub25SZXNpemUoKSxcXG4gICAgICAgIHdpbmRvdy5kYyA9IHRoaXMuZGNcXG4gICAgICAgIHdpbmRvdy50diA9IHRoaXMuJHJlZnMudHZqc1xcbiAgICAgICAgLy8gTG9hZCB0aGUgbGFzdCBkYXRhIGNodW5rICYgaW5pdCBEYXRhQ3ViZTpcXG4gICAgICAgIGxldCBub3cgPSBVdGlscy5ub3coKVxcbiAgICAgICAgdGhpcy5sb2FkX2NodW5rKFtub3cgLSBDb25zdC5IT1VSNCwgbm93XSkudGhlbihkYXRhID0+IHtcXG4gICAgICAgICAgICBkYy5kYXRhLmNoYXJ0LmRhdGEgPSBkYXRhWydjaGFydC5kYXRhJ11cXG4gICAgICAgICAgICAvLyBSZWdpc3RlciBvbnJhbmdlIGNhbGxiYWNrICYgQW5kIGEgc3RyZWFtIG9mIHRyYWRlc1xcbiAgICAgICAgICAgIHRoaXMuZGMub25yYW5nZSh0aGlzLmxvYWRfY2h1bmspXFxuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgU3RyZWFtKFdTUylcXG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5vbnRyYWRlcyA9IHRoaXMub25fdHJhZGVzXFxuICAgICAgICAgICAgd2luZG93LmRjID0gdGhpcy5jaGFydCAgICAgIC8vIERlYnVnXFxuICAgICAgICAgICAgd2luZG93LnR2ID0gdGhpcy4kcmVmcy50dmpzIC8vIERlYnVnXFxuICAgICAgICB9KVxcbiAgICB9LFxcbiAgICBiZWZvcmVEZXN0cm95KCkge1xcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUpXFxuICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHRoaXMuc3RyZWFtLm9mZigpXFxuICAgIH0sXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICAgIG9uUmVzaXplKCkge1xcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8ICc1MDAnKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuNTNcXG4gICAgICAgICAgICB9LyogZWxzZSBpZiAod2luZG93LmlubmVyV2lkdGggPiAnNzY4JyAgJiYgd2luZG93LmlubmVyV2lkdGggPD0gJzk5MicpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtICh3aW5kb3cuaW5uZXJXaWR0aCAqIDAuMjYpKVxcbiAgICAgICAgICAgIH0qLyBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogMC43XFxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICogMC42OFxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgIH0sXFxuICAgICAgICBzcGxpbmUgKCkge1xcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50eXBlID0gXFxcIlNwbGluZVxcXCJcXG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudGYgPSBcXFwiMW1cXFwiXFxuICAgICAgICAgICAgdGhpcy4kcmVmcy50dmpzLnJlc2V0Q2hhcnQoKVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNhbmRsZXMgKCkge1xcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50eXBlID0gXFxcIkNhbmRsZXNcXFwiXFxuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnRmID0gXFxcIjFtXFxcIlxcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudHZqcy5yZXNldENoYXJ0KClcXG4gICAgICAgIH0sXFxuICAgICAgICB4YmFycyAoKSB7XFxuICAgICAgICAgICAgdGhpcy5kYXRhLm92cyA9ICdYT2hsY0JhcnMnXFxuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnRmID0gXFxcIjFtXFxcIlxcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudHZqcy5yZXNldENoYXJ0KClcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFkZSAoKSB7XFxuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnR5cGUgPSBcXFwiU3BsaW5lXFxcIlxcbiAgICAgICAgfSxcXG4gICAgICAgIHdpbl9xdWVyeSgpIHtcXG4gICAgICAgICAgICBsZXQgcXMgPSAoZnVuY3Rpb24oYSkge1xcbiAgICAgICAgICAgICAgICBpZiAoYSA9PSBcXFwiXFxcIikgcmV0dXJuIHt9O1xcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHt9O1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBwPWFbaV0uc3BsaXQoJz0nLCAyKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA9PSAxKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJbcFswXV0gPSBcXFwiXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICBiW3BbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHBbMV0ucmVwbGFjZSgvXFxcXCsvZywgXFxcIiBcXFwiKSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XFxuICAgICAgICAgICAgfSkod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkuc3BsaXQoJyYnKSk7XFxuICAgICAgICAgICAgcmV0dXJuIHFzXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVzZXQoc3RhdGUpIHtcXG4gICAgICAgICAgICBsZXQgc3ViID0gT2JqZWN0LmtleXMoc3RhdGUpLmZpbHRlcih4ID0+IHN0YXRlW3hdKVxcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHN1Yi5tYXAoeCA9PiBFeHRlbnNpb25zW3hdKVxcbiAgICAgICAgICAgIHRoaXMucmVzZXRrZXkrK1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9uc2VsZWN0KGlkKSB7XFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gaWRcXG4gICAgICAgIH0sXFxuICAgICAgICB0aW1lem9uZWQoKSB7XFxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcXG4gICAgICAgICAgICB2YXIgbWludXRlcyA9IE1hdGguYWJzKG9mZnNldCk7XFxuICAgICAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gNjApO1xcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBvZmZzZXQgPCAwID8gXFxcIlxcXCIgOiBcXFwiLVxcXCI7XFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHByZWZpeCtob3Vycyk7XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gTmV3IGRhdGEgaGFuZGxlci4gU2hvdWxkIHJldHVybiBQcm9taXNlLCBvclxcbiAgICAgICAgLy8gdXNlIGNhbGxiYWNrOiBsb2FkX2NodW5rKHJhbmdlLCB0ZiwgY2FsbGJhY2spXFxuICAgICAgICBhc3luYyBsb2FkX2NodW5rKHJhbmdlKSB7XFxuICAgICAgICAgICAgbGV0IFt0MSwgdDJdID0gcmFuZ2VcXG4gICAgICAgICAgICBsZXQgeCA9IHN5bWJvbGJnXFxuICAgICAgICAgICAgbGV0IHEgPSBgJHt4fSZpbnRlcnZhbD0xbSZzdGFydFRpbWU9JHt0MX0mZW5kVGltZT0ke3QyfWBcXG4gICAgICAgICAgICBsZXQgciA9IGF3YWl0IGZldGNoKFVSTCArIHEpLnRoZW4ociA9PiByLmpzb24oKSlcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQodGhpcy5wYXJzZV9iaW5hbmNlKHIpKVxcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIFBhcnNlIGEgc3BlY2lmaWMgZXhjaGFuZ2UgZm9ybWF0XFxuICAgICAgICBwYXJzZV9iaW5hbmNlKGRhdGEpIHtcXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHJldHVybiBbXVxcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcCh4ID0+IHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICB4W2ldID0gcGFyc2VGbG9hdCh4W2ldKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiB4LnNsaWNlKDAsNilcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSxcXG4gICAgICAgIGZvcm1hdChkYXRhKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgJ2NoYXJ0LmRhdGEnOiBkYXRhLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBvbl90cmFkZXModHJhZGUpIHtcXG4gICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZSh7XFxuICAgICAgICAgICAgICAgIHQ6IHRyYWRlLlQsICAgICAvLyBFeGNoYW5nZSB0aW1lIChvcHRpb25hbClcXG4gICAgICAgICAgICAgICAgcHJpY2U6IHBhcnNlRmxvYXQodHJhZGUucCksICAgLy8gVHJhZGUgcHJpY2VcXG4gICAgICAgICAgICAgICAgdm9sdW1lOiBwYXJzZUZsb2F0KHRyYWRlLnEpLCAgLy8gVHJhZGUgYW1vdW50XFxuICAgICAgICAgICAgICAgIGRhdGFzIDogWyAvLyBVcGRhdGUgZGF0YXNldFxcbiAgICAgICAgICAgICAgICAgICAgdHJhZGUuVCxcXG4gICAgICAgICAgICAgICAgICAgIHRyYWRlLm0gPyAwIDogMSwgICAgICAgICAgLy8gU2VsbCBvciBCdXlcXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodHJhZGUucSksXFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRyYWRlLnApXFxuICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlciBvbmNoYXJ0L29mZmNoYXJ0IHVwZGF0ZXNcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcblxcbjxzdHlsZT5cXG4uYXBwLWNvbnRlbnQge1xcbiAgICBwYWRkaW5nOiBjYWxjKDJyZW0gKyAyLjQ1cmVtKSAwIDAgMHJlbSAhaW1wb3J0YW50O1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxufVxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjcuOThweCl7XFxuICAgIGh0bWwgYm9keS5uYXZiYXItc3RpY2t5IC5hcHAtY29udGVudCB7XFxuICAgICAgICBwYWRkaW5nOiBjYWxjKDFyZW0gLSAwLjhyZW0gKyA0LjQ1cmVtKSAwIDAgMCAhaW1wb3J0YW50O1xcbiAgICB9XFxufVxcbi5mbGV4ZWQge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG59XFxuXFxuI2FwcC1jb25haW5lciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbn1cXG5cXG4vKiBAbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpe1xcbiAgICAjYXBwLWNvbmFpbmVyIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIH1cXG59ICovXFxuI3RyYWRlYmFyIHtcXG4gICAgY29sb3I6ICNkZGQ7XFxufVxcblxcbiN0dmpzLWhlYWRlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgY29sb3I6ICNkZGQ7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTIxODI2O1xcbn1cXG5cXG4ubmlnaHQtbW9kZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAxNXB4O1xcbiAgICByaWdodDogMjBweDtcXG59XFxuXFxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMC1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMC1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMS1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMS1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLWJvdGJhci1jYW52YXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyAwJSkgIWltcG9ydGFudDtcXG59XFxuXFxuI3RyYWRpbmctdnVlLXRiaXRlbSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigxOCwgMjQsIDM4KTtcXG59XFxuXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LWRldmljZS13aWR0aDogNDgwcHgpIHtcXG4gICAgLnRmLXNlbGVjdG9yIHtcXG4gICAgICAgIHRvcDogNTBweDtcXG4gICAgICAgIHJpZ2h0OiAxNDBweDtcXG4gICAgICAgIG1heC13aWR0aDogMTQwcHg7XFxuICAgICAgICBmb250OiAxMnB4IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCxcXG4gICAgICAgICAgICBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLFxcbiAgICAgICAgICAgIEZpcmEgU2FucywgRHJvaWQgU2FucywgSGVsdmV0aWNhIE5ldWUsXFxuICAgICAgICAgICAgc2Fucy1zZXJpZjtcXG4gICAgfVxcbn1cXG5cXG4uYm94IHtcXG4gICAgd2lkdGg6IDI4MHB4O1xcbiAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgYm94LXNoYWRvdzogMCAxLjVweCA1cHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgcGFkZGluZzogMCAxNXB4IDAgMTVweDtcXG59XFxuXFxudGFibGUge1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgIGNvbG9yOiByZ2IoMTgzLCAxODksIDE5OCk7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG50ZCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgaGVpZ2h0OiAyMHB4O1xcbiAgICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxuXFxudGQucHJpY2Uge1xcbiAgICB3aWR0aDogMzAlO1xcbn1cXG5cXG50ZC5wcmljZSBzcGFuIHtcXG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7XFxufVxcblxcbnRkLnF1YW50aXR5IHtcXG4gICAgd2lkdGg6IDMwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcblxcbnRkLnRpbWUge1xcbiAgICB3aWR0aDogNDAlO1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXG4gICAgY29sb3I6ICM5OTk7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcXG59XFxuXFxudGQuYnRjIHtcXG4gICAgd2lkdGg6IDQwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcXG59XFxuXFxudGQgc3BhbiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgei1pbmRleDogMjtcXG59XFxuXFxudGFibGUuYXNrcyAucGVyY2VudCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ2LCA3MCwgOTQsIDAuMik7XFxufVxcblxcbnRhYmxlLmJpZHMgLnBlcmNlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE0LCAyMDMsIDEyOSwgMC4yKTtcXG59XFxuXFxudGQgLnBlcmNlbnQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICByaWdodDogMDtcXG59XFxuXFxuLm5ld2VzdCB7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbiAgICBtYXJnaW46IDE1cHggLTE1cHg7XFxufVxcblxcbi5jYXJkLTExMCB7XFxuICAgIHRvcDogMTEwcHggIWltcG9ydGFudDtcXG4gICAgbGVmdDogNzBweDtcXG59XFxuLyogU3R5bGUgcGFnZSBjb250ZW50IC0gdXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gcHVzaCB0aGUgcGFnZSBjb250ZW50IHRvIHRoZSByaWdodCB3aGVuIHlvdSBvcGVuIHRoZSBzaWRlIG5hdmlnYXRpb24gKi9cXG4jbWFpbiB7XFxuICAgIHRyYW5zaXRpb246IG1hcmdpbi1sZWZ0IC41cztcXG4gICAgLyogSWYgeW91IHdhbnQgYSB0cmFuc2l0aW9uIGVmZmVjdCAqL1xcbn1cXG5cXG4vKiBPbiBzbWFsbGVyIHNjcmVlbnMsIHdoZXJlIGhlaWdodCBpcyBsZXNzIHRoYW4gNDUwcHgsIGNoYW5nZSB0aGUgc3R5bGUgb2YgdGhlIHNpZGVuYXYgKGxlc3MgcGFkZGluZyBhbmQgYSBzbWFsbGVyIGZvbnQgc2l6ZSkgKi9cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogNDUwcHgpIHtcXG4gICAgLnNpZGViYXIxIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAxNXB4O1xcbiAgICB9XFxuXFxuICAgIC5zaWRlYmFyMSBhIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgfVxcbn1cXG5cXG4uYnRuLWNpcmNsZSB7XFxuICAgIHdpZHRoOiAzMHB4O1xcbiAgICBoZWlnaHQ6IDMwcHg7XFxuICAgIHBhZGRpbmc6IDZweCAwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbiNjaGFydGRpdiB7XFxuICAgIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcXG4gICAgaGVpZ2h0OiA3MHZoO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnR2anMtc3RkLWlucHV0IHtcXHJcXG4gICAgbWFyZ2luOiA1cHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxNjFiMjc7XFxyXFxuICAgIGJvcmRlcjogMXB4IGRvdHRlZCAjMzUzOTQwO1xcclxcbiAgICBoZWlnaHQ6IDIycHg7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXHJcXG4gICAgcGFkZGluZzogMnB4IDBweCAzcHggMTBweDtcXHJcXG4gICAgY29sb3I6IHdoaXRlc21va2U7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS4yZW07XFxyXFxuICAgIG91dGxpbmU6IG5vbmU7XFxyXFxuICAgIHdpZHRoOiAxMDBweDtcXG59XFxuc2VsZWN0LnR2anMtc3RkLWlucHV0IHtcXHJcXG4gICAgaGVpZ2h0OiAyOXB4O1xcclxcbiAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbnNlbGVjdC50dmpzLXN0ZC1pbnB1dCAge1xcclxcbiAgICAvL2Rpc3BsYXk6IG5vbmU7IC8qaGlkZSBvcmlnaW5hbCBTRUxFQ1QgZWxlbWVudDogKi9cXG59XFxuLnR2anMtc3RkLWlucHV0OjotbW96LXBsYWNlaG9sZGVyIHtcXHJcXG4gICAgY29sb3I6ICM4ZTkwOWE7XFxyXFxuICAgIG9wYWNpdHk6IDAuMjU7XFxufVxcbi50dmpzLXN0ZC1pbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXIge1xcclxcbiAgICBjb2xvcjogIzhlOTA5YTtcXHJcXG4gICAgb3BhY2l0eTogMC4yNTtcXG59XFxuLnR2anMtc3RkLWlucHV0OjpwbGFjZWhvbGRlciB7XFxyXFxuICAgIGNvbG9yOiAjOGU5MDlhO1xcclxcbiAgICBvcGFjaXR5OiAwLjI1O1xcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQTRDQTtJQUNBLFdBQUE7SUFDQSx5QkFBQTtJQUNBLDBCQUFBO0lBQ0EsWUFBQTtJQUNBLGtCQUFBO0lBQ0EseUJBQUE7SUFDQSxpQkFBQTtJQUNBLGdCQUFBO0lBQ0EsYUFBQTtJQUNBLFlBQUE7QUFDQTtBQUVBO0lBQ0EsWUFBQTtJQUNBLHFCQUFBO0FBRUE7QUFFQTtJQUNBLGVBQUEsRUFBQSxpQ0FBQTtBQUNBO0FBR0E7SUFDQSxjQUFBO0lBQ0EsYUFBQTtBQUNBO0FBSEE7SUFDQSxjQUFBO0lBQ0EsYUFBQTtBQUNBO0FBSEE7SUFDQSxjQUFBO0lBQ0EsYUFBQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG4gICAgPHNwYW4+XFxyXFxuICAgICAgICA8aW5wdXRcXG52LWlmPVxcXCJ0eXBlPT09J3RleHQnIHx8ICF0eXBlXFxcIlxcclxcbiAgICAgICAgICAgIDp2YWx1ZT1cXFwidmFsdWVcXFwiXFxuY2xhc3M9XFxcInR2anMtc3RkLWlucHV0XFxcIlxcbjpzdHlsZT1cXFwic3R5bGVcXFwiXFxyXFxuICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVxcXCJuYW1lXFxcIlxcclxcbiAgICAgICAgICAgIEBjaGFuZ2U9XFxcIiRlbWl0KCdjaGFuZ2UnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxcXCJcXHJcXG4gICAgICAgICAgICBAaW5wdXQ9XFxcIiRlbWl0KCdpbnB1dCcsICRldmVudC50YXJnZXQudmFsdWUpXFxcIlxcbj5cXHJcXG4gICAgICAgIDxzZWxlY3RcXG52LWVsc2UtaWY9XFxcInR5cGU9PT0nc2VsZWN0J1xcXCJcXHJcXG4gICAgICAgICAgICBjbGFzcz1cXFwidHZqcy1zdGQtaW5wdXRcXFwiXFxuOnN0eWxlPVxcXCJzdHlsZVxcXCJcXHJcXG4gICAgICAgICAgICA6dmFsdWU9XFxcInZhbHVlXFxcIlxcclxcbiAgICAgICAgICAgIEBpbnB1dD1cXFwiJGVtaXQoJ2lucHV0JywgJGV2ZW50LnRhcmdldC52YWx1ZSlcXFwiXFxuPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdi1mb3I9XFxcIm9wdCBpbiBsaXN0XFxcIj57eyBvcHQgfX08L29wdGlvbj5cXHJcXG4gICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICA8L3NwYW4+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgbmFtZTogJ1N0ZElucHV0JyxcXHJcXG4gICAgcHJvcHM6IFsndmFsdWUnLCAnbmFtZScsICd0eXBlJywgJ2xpc3QnLCAnY29sb3JzJ10sXFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgc3R5bGUoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kOiB0aGlzLiRwcm9wcy5jb2xvcnMuYmFjayxcXHJcXG4gICAgICAgICAgICAgICAgLy9jb2xvcjogdGhpcy4kcHJvcHMuY29sb3JzLnRleHRcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6IHt9XFxyXFxufVxcclxcbjwvc2NyaXB0PlxcclxcblxcclxcbjxzdHlsZT5cXHJcXG4udHZqcy1zdGQtaW5wdXQge1xcclxcbiAgICBtYXJnaW46IDVweDtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzE2MWIyNztcXHJcXG4gICAgYm9yZGVyOiAxcHggZG90dGVkICMzNTM5NDA7XFxyXFxuICAgIGhlaWdodDogMjJweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgICBwYWRkaW5nOiAycHggMHB4IDNweCAxMHB4O1xcclxcbiAgICBjb2xvcjogd2hpdGVzbW9rZTtcXHJcXG4gICAgZm9udC1zaXplOiAxLjJlbTtcXHJcXG4gICAgb3V0bGluZTogbm9uZTtcXHJcXG4gICAgd2lkdGg6IDEwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5zZWxlY3QudHZqcy1zdGQtaW5wdXQge1xcclxcbiAgICBoZWlnaHQ6IDI5cHg7XFxyXFxuICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuc2VsZWN0LnR2anMtc3RkLWlucHV0ICB7XFxyXFxuICAgIC8vZGlzcGxheTogbm9uZTsgLypoaWRlIG9yaWdpbmFsIFNFTEVDVCBlbGVtZW50OiAqL1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4udHZqcy1zdGQtaW5wdXQ6OnBsYWNlaG9sZGVyIHtcXHJcXG4gICAgY29sb3I6ICM4ZTkwOWE7XFxyXFxuICAgIG9wYWNpdHk6IDAuMjU7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy14LXdpbmRvdyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgYmFja2dyb3VuZDogIzFiMjAyZGVmO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogN3B4O1xcclxcbiAgICB6LWluZGV4OiAxMDA7XFxyXFxuICAgIGNvbG9yOiAjZGVkZGRkO1xcbn1cXG4udHZqcy14LXdpbmRvdy1oZWFkIHtcXHJcXG4gICAgZm9udC1zaXplOiAyZW07XFxyXFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxyXFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gICAgaGVpZ2h0OiAzNnB4O1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgICBjdXJzb3I6IC13ZWJraXQtZ3JhYjtcXHJcXG4gICAgY3Vyc29yOiBncmFiO1xcbn1cXG4udHZqcy14LXdpbmRvdy1ib2R5IHtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgZm9udC1zaXplOiAxLjFlbTtcXG59XFxuLnR2anMteC13aW5kb3ctdGl0bGUge1xcclxcbiAgICB3aWR0aDogMzAwcHg7XFxyXFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi50dmpzLXgtd2luZG93LWNsb3NlIHtcXHJcXG4gICAgd2lkdGg6IDI2cHg7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgbWFyZ2luOiAtMWVtO1xcclxcbiAgICBwYWRkaW5nOiAxZW07XFxyXFxuICAgIGZvbnQtc2l6ZTogMC43NWVtO1xcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFnRUE7SUFDQSxrQkFBQTtJQUNBLHFCQUFBO0lBQ0Esa0JBQUE7SUFDQSxtQkFBQTtJQUNBLGlCQUFBO0lBQ0EsWUFBQTtJQUNBLGNBQUE7QUFDQTtBQUNBO0lBQ0EsY0FBQTtJQUNBLHlCQUFBO09BQUEsc0JBQUE7UUFBQSxxQkFBQTtZQUFBLGlCQUFBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0lBQ0EsaUJBQUE7SUFDQSwyQkFBQTtJQUNBLHFCQUFBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLG9CQUFBO0lBQUEsWUFBQTtBQUNBO0FBRUE7SUFDQSxhQUFBO0lBQ0EsZ0JBQUE7QUFDQTtBQUNBO0lBQ0EsWUFBQTtJQUNBLHlCQUFBO09BQUEsc0JBQUE7UUFBQSxxQkFBQTtZQUFBLGlCQUFBO0FBQ0E7QUFDQTtJQUNBLFdBQUE7SUFDQSxlQUFBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxpQkFBQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG4gICAgPGRpdlxcbnJlZj1cXFwid2luXFxcIlxcbmNsYXNzPVxcXCJ0dmpzLXgtd2luZG93XFxcIlxcbjpzdHlsZT1cXFwic3R5bGVcXFwiXFxuPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHZqcy14LXdpbmRvdy1oZWFkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2XFxuY2xhc3M9XFxcInR2anMteC13aW5kb3ctdGl0bGVcXFwiXFxyXFxuICAgICAgICAgICAgICAgIEBtb3VzZWRvd249XFxcIm9uTW91c2VEb3duXFxcIlxcbj5cXHJcXG4gICAgICAgICAgICAgICAge3sgdGl0bGUgfX1cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2XFxuY2xhc3M9XFxcInR2anMteC13aW5kb3ctY2xvc2VcXFwiXFxyXFxuICAgICAgICAgICAgICAgIEBjbGljaz1cXFwiJGVtaXQoJ2Nsb3NlJylcXFwiXFxuPlxcclxcbiAgICAgICAgICAgICAgICDilbNcXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHZqcy14LXdpbmRvdy1ib2R5XFxcIj5cXHJcXG4gICAgICAgICAgICA8c2xvdCAvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5cXHJcXG5pbXBvcnQgRHJhZ2cgZnJvbSAnLi9kcmFnZy5qcydcXHJcXG5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIG5hbWU6ICdXaW5kb3cnLFxcclxcbiAgICBtaXhpbnM6IFtEcmFnZ10sXFxyXFxuICAgIHByb3BzOiBbJ3RpdGxlJywgJ3R2J10sXFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIHd3OiAwLFxcclxcbiAgICAgICAgICAgIHdoOiAwLFxcclxcbiAgICAgICAgICAgIHg6IDAsXFxyXFxuICAgICAgICAgICAgeTogMFxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgc3R5bGUoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgdG9wOiBgJHt0aGlzLnl9cHhgLFxcclxcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHt0aGlzLnh9cHhgXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHR2dygpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcHJvcHMudHYud2lkdGhcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB0dmgoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnR2LmhlaWdodFxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtb3VudGVkKCkge1xcclxcbiAgICAgICAgdGhpcy53dyA9IHRoaXMuJHJlZnMud2luLmNsaWVudFdpZHRoXFxyXFxuICAgICAgICB0aGlzLndoID0gdGhpcy4kcmVmcy53aW4uY2xpZW50SGVpZ2h0XFxyXFxuICAgICAgICB0aGlzLnggPSB0aGlzLnR2dyAqIDAuNSAtIHRoaXMud3cgKiAwLjVcXHJcXG4gICAgICAgIHRoaXMueSA9IHRoaXMudHZoICogMC41IC0gdGhpcy53aCAqIDAuNVxcclxcbiAgICB9XFxyXFxufVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG4udHZqcy14LXdpbmRvdyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgYmFja2dyb3VuZDogIzFiMjAyZGVmO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogN3B4O1xcclxcbiAgICB6LWluZGV4OiAxMDA7XFxyXFxuICAgIGNvbG9yOiAjZGVkZGRkO1xcclxcbn1cXHJcXG4udHZqcy14LXdpbmRvdy1oZWFkIHtcXHJcXG4gICAgZm9udC1zaXplOiAyZW07XFxyXFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcclxcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIGhlaWdodDogMzZweDtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgY3Vyc29yOiBncmFiO1xcclxcbn1cXHJcXG5cXHJcXG4udHZqcy14LXdpbmRvdy1ib2R5IHtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgZm9udC1zaXplOiAxLjFlbTtcXHJcXG59XFxyXFxuLnR2anMteC13aW5kb3ctdGl0bGUge1xcclxcbiAgICB3aWR0aDogMzAwcHg7XFxyXFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcbn1cXHJcXG4udHZqcy14LXdpbmRvdy1jbG9zZSB7XFxyXFxuICAgIHdpZHRoOiAyNnB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIG1hcmdpbjogLTFlbTtcXHJcXG4gICAgcGFkZGluZzogMWVtO1xcclxcbiAgICBmb250LXNpemU6IDAuNzVlbTtcXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5oLXNwbGl0dGVyW2RhdGEtdi0xODlmY2NhZF0ge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIGhlaWdodDogNXB4O1xcclxcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgei1pbmRleDogMTtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNlZTRhZmI1O1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbn1cXG4uaC1zcGxpdHRlcltkYXRhLXYtMTg5ZmNjYWRdOmhvdmVyIHtcXHJcXG4gICAgY3Vyc29yOiByb3ctcmVzaXplO1xcclxcbiAgICBvcGFjaXR5OiAxO1xcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS9TcGxpdHRlci52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQWtFQTtJQUNBLGtCQUFBO0lBQ0EsT0FBQTtJQUNBLFdBQUE7SUFDQSxnQkFBQTtJQUNBLFdBQUE7SUFDQSxVQUFBO0lBQ0EsMkJBQUE7SUFDQSxVQUFBO0lBQ0EsbUJBQUE7QUFDQTtBQUNBO0lBQ0Esa0JBQUE7SUFDQSxVQUFBO0FBQ0FcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgICA8c3BhblxcbmNsYXNzPVxcXCJoLXNwbGl0dGVyXFxcIlxcclxcbiAgICAgICAgOnN0eWxlPVxcXCJoc19zdHlsZVxcXCJcXG5AbW91c2Vkb3duPVxcXCJoc19tb3VzZWRvd25cXFwiXFxuLz5cXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuXFxyXFxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMuanMnXFxyXFxuXFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICBuYW1lOiAnU3BsaXR0ZXInLFxcclxcbiAgICBwcm9wczogWydpZCcsICdtYWluJywgJ2RjJywgJ3R2JywgJ2RhdGEnXSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgIGhzX3N0eWxlKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIGRyYWc6IG51bGwsXFxyXFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5kYXRhLmdyaWQyLm9mZnNldCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIC8vYmFja2dyb3VuZENvbG9yOiB0aGlzLmNvbG9ycy5zcGxpdHRlclxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgIH0sXFxyXFxuICAgIG1vdW50ZWQoKSB7XFxyXFxuICAgICAgICB0aGlzLk1JTl9IRUlHSFQgPSB0aGlzLmRhdGEuc2V0dC5taW5faGVpZ2h0IHx8IDIwXFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6IHtcXHJcXG4gICAgICAgIGhzX21vdXNlZG93bihlKSB7XFxyXFxuICAgICAgICAgICAgdGhpcy5kcmFnID0ge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHMnLFxcclxcbiAgICAgICAgICAgICAgICB5OiBlLmNsaWVudFksXFxyXFxuICAgICAgICAgICAgICAgIGgxOiB0aGlzLmRhdGEuZ3JpZDEuaGVpZ2h0LFxcclxcbiAgICAgICAgICAgICAgICBoMjogdGhpcy5kYXRhLmdyaWQyLmhlaWdodFxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBVdGlscy5hZGRfc3R5bGUoJ2Rpc2FibGUtdXNlci1zZWxlY3QnLCBgYm9keSAqIHtcXHJcXG4gICAgICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC50cmFkaW5nLXZ1ZS1jaGFydCB7XFxyXFxuICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgICAgICAgICAgIH1gKVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGhzX21vdXNldXAoZSkge1xcclxcbiAgICAgICAgICAgIHRoaXMuZHJhZyA9IG51bGxcXHJcXG4gICAgICAgICAgICBVdGlscy5yZW1fc3R5bGUoJ2Rpc2FibGUtdXNlci1zZWxlY3QnKVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGhzX21vdXNlbW92ZShlKSB7XFxyXFxuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZykge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgb2ZmID0gZS5jbGllbnRZIC0gdGhpcy5kcmFnLnlcXHJcXG4gICAgICAgICAgICAgICAgbGV0IG5ld19oMSA9IHRoaXMuZHJhZy5oMSArIG9mZlxcclxcbiAgICAgICAgICAgICAgICBsZXQgbmV3X2gyID0gdGhpcy5kcmFnLmgyIC0gb2ZmXFxyXFxuICAgICAgICAgICAgICAgIGlmIChuZXdfaDEgPiB0aGlzLk1JTl9IRUlHSFQgJiZcXHJcXG4gICAgICAgICAgICAgICAgICAgIG5ld19oMiA+IHRoaXMuTUlOX0hFSUdIVCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmdyaWQxLmhlaWdodCA9IG5ld19oMVxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmdyaWQyLmhlaWdodCA9IG5ld19oMlxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jYWxjX2hlaWdodHMoKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBoc19tb3VzZWxlYXZlKGUpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXFxyXFxuICAgICAgICAgICAgVXRpbHMucmVtX3N0eWxlKCdkaXNhYmxlLXVzZXItc2VsZWN0JylcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGUgc2NvcGVkPlxcclxcbi5oLXNwbGl0dGVyIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICBoZWlnaHQ6IDVweDtcXHJcXG4gICAgbWFyZ2luLXRvcDogLTJweDtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHotaW5kZXg6IDE7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzZWU0YWZiNTtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXHJcXG59XFxyXFxuLmgtc3BsaXR0ZXI6aG92ZXIge1xcclxcbiAgICBjdXJzb3I6IHJvdy1yZXNpemU7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy14LXdpbmRvdy5hZGQtd2luW2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzBweDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xcbn1cXG4uYWRkLXdpbi1saXN0W2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBoZWlnaHQ6IDMwMHB4O1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBDaHJvbWUsIFNhZmFyaSBhbmQgT3BlcmEgKi9cXG4uYWRkLXdpbi1saXN0W2RhdGEtdi01MzQwOGFjN106Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBJRSwgRWRnZSBhbmQgRmlyZWZveCAqL1xcbi5hZGQtd2luLWxpc3RbZGF0YS12LTUzNDA4YWM3XSB7XFxuICAtbXMtb3ZlcmZsb3ctc3R5bGU6IG5vbmU7ICAvKiBJRSBhbmQgRWRnZSAqL1xcbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lOyAgLyogRmlyZWZveCAqL1xcbn1cXG4uYWRkLXdpbi1pdGVtW2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBjb2xvcjogI2ZmZmZmZjg4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5hZGQtd2luLWl0ZW1bZGF0YS12LTUzNDA4YWM3XTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQ6ICM4ODg4ODgyMjtcXG4gICAgY29sb3I6ICNmZmZmZmZmZjtcXG59XFxuLmFkZC13aW4taXRlbS1kZXNjW2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBjb2xvcjogI2ZmZmZmZjMzO1xcbiAgICBtYXJnaW4tbGVmdDogM3B4O1xcbn1cXG4uYWRkLXdpbi1pdGVtOmhvdmVyIC5hZGQtd2luLWl0ZW0tZGVzY1tkYXRhLXYtNTM0MDhhYzddIHtcXG4gICAgY29sb3I6ICNmZmZmZmY0NDtcXG59XFxuLmFkZC13aW4tZW1wdHlbZGF0YS12LTUzNDA4YWM3XSB7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBZ0RBO0lBQ0Esb0JBQUE7SUFDQSwyQkFBQTtBQUNBO0FBQ0E7SUFDQSxhQUFBO0lBQ0Esa0JBQUE7SUFDQSxnQkFBQTtJQUNBLHlCQUFBO09BQUEsc0JBQUE7UUFBQSxxQkFBQTtZQUFBLGlCQUFBO0FBQ0E7QUFDQSxnREFBQTtBQUNBO0VBQ0EsYUFBQTtBQUNBOztBQUVBLDRDQUFBO0FBQ0E7RUFDQSx3QkFBQSxHQUFBLGdCQUFBO0VBQ0EscUJBQUEsR0FBQSxZQUFBO0FBQ0E7QUFDQTtJQUNBLGdCQUFBO0lBQ0EsV0FBQTtJQUNBLFlBQUE7SUFDQSxlQUFBO0FBQ0E7QUFDQTtJQUNBLHFCQUFBO0lBQ0EsZ0JBQUE7QUFDQTtBQUNBO0lBQ0EsZ0JBQUE7SUFDQSxnQkFBQTtBQUNBO0FBQ0E7SUFDQSxnQkFBQTtBQUNBO0FBQ0E7SUFDQSxZQUFBO0FBQ0FcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgICA8d2luZG93IHRpdGxlPVxcXCJBZGQgSW5kaWNhdG9yXFxcIiBjbGFzcz1cXFwiYWRkLXdpblxcXCIgOnR2PVxcXCJ0dlxcXCIgQGNsb3NlPVxcXCJvbl9jbG9zZVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhZGQtd2luLWxpc3RcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgdi1mb3I9XFxcIm92IG9mIG92c1xcXCIgY2xhc3M9XFxcImFkZC13aW4taXRlbVxcXCIgQGNsaWNrPVxcXCJvbl9jbGljayhvdi5uYW1lKVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuPnt7IG92Lm5hbWUgfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJhZGQtd2luLWl0ZW0tZGVzY1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICB7eyBvdi5tZXRob2RzLm1ldGFfaW5mbygpLmRlc2MgfX1cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvd2luZG93PlxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5cXG5pbXBvcnQgV2luZG93IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvV2luZG93LnZ1ZSdcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIG5hbWU6ICdBZGRXaW4nLFxcbiAgICBjb21wb25lbnRzOiB7IFdpbmRvdyB9LFxcbiAgICBwcm9wczogWydpZCcsICdtYWluJywgJ2RjJywgJ3R2JywgJ2RhdGEnXSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgb3ZzOiB0aGlzLnR2Lm92ZXJsYXlzLmZpbHRlcih4ID0+IHgubWV0aG9kcy5jYWxjKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgICAgc2V0dCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcHJvcHMuZGF0YS5vdi5zZXR0aW5nc1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtb3VudGVkKCkge1xcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBvbl9jbG9zZSgpIHtcXG4gICAgICAgICAgICB0aGlzLiRwcm9wcy5tYWluLnJlbW92ZV93aWRnZXQodGhpcy4kcHJvcHMuaWQpXFxuICAgICAgICB9LFxcbiAgICAgICAgb25fY2xpY2sobmFtZSkge1xcbiAgICAgICAgICAgIHRoaXMub25fY2xvc2UoKVxcbiAgICAgICAgICAgIHRoaXMubWFpbi5hZGRfb3ZlcmxheSh7XFxuICAgICAgICAgICAgICAgIHNpZGU6IHRoaXMuZGF0YS50eXBlLFxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5kYXRhLmluZGV4LFxcbiAgICAgICAgICAgICAgICB0eXBlOiBuYW1lXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGUgc2NvcGVkPlxcbi50dmpzLXgtd2luZG93LmFkZC13aW4ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzBweDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xcbn1cXG4uYWRkLXdpbi1saXN0IHtcXG4gICAgaGVpZ2h0OiAzMDBweDtcXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuLyogSGlkZSBzY3JvbGxiYXIgZm9yIENocm9tZSwgU2FmYXJpIGFuZCBPcGVyYSAqL1xcbi5hZGQtd2luLWxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBJRSwgRWRnZSBhbmQgRmlyZWZveCAqL1xcbi5hZGQtd2luLWxpc3Qge1xcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAgLyogSUUgYW5kIEVkZ2UgKi9cXG4gIHNjcm9sbGJhci13aWR0aDogbm9uZTsgIC8qIEZpcmVmb3ggKi9cXG59XFxuLmFkZC13aW4taXRlbSB7XFxuICAgIGNvbG9yOiAjZmZmZmZmODg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmFkZC13aW4taXRlbTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQ6ICM4ODg4ODgyMjtcXG4gICAgY29sb3I6ICNmZmZmZmZmZjtcXG59XFxuLmFkZC13aW4taXRlbS1kZXNjIHtcXG4gICAgY29sb3I6ICNmZmZmZmYzMztcXG4gICAgbWFyZ2luLWxlZnQ6IDNweDtcXG59XFxuLmFkZC13aW4taXRlbTpob3ZlciAuYWRkLXdpbi1pdGVtLWRlc2Mge1xcbiAgICBjb2xvcjogI2ZmZmZmZjQ0O1xcbn1cXG4uYWRkLXdpbi1lbXB0eSB7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50dmpzLXgtd2luZG93LnNldHQtd2luW2RhdGEtdi01ZDIyM2IwZV0ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzBweDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xcbn1cXG4uc2V0dC13aW4taXRlbVtkYXRhLXYtNWQyMjNiMGVdIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4uc2V0dC13aW4taXRlbSBsYWJlbFtkYXRhLXYtNWQyMjNiMGVdIHtcXG4gICAgbWluLXdpZHRoOiA4MHB4O1xcbiAgICBjb2xvcjogIzM1YTc3NjtcXG59XFxuLnNldHQtd2luLWVtcHR5W2RhdGEtdi01ZDIyM2IwZV0ge1xcbiAgICBvcGFjaXR5OiAwLjU7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXNEQTtJQUNBLG9CQUFBO0lBQ0EsMkJBQUE7QUFDQTtBQUNBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0lBQ0EsaUJBQUE7SUFDQSwyQkFBQTtJQUNBLHFCQUFBO0lBQ0EsbUJBQUE7QUFDQTtBQUNBO0lBQ0EsZUFBQTtJQUNBLGNBQUE7QUFDQTtBQUNBO0lBQ0EsWUFBQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gICAgPHdpbmRvdyA6dGl0bGU9XFxcImRhdGEub3YubmFtZVxcXCIgY2xhc3M9XFxcInNldHQtd2luXFxcIiA6dHY9XFxcInR2XFxcIiBAY2xvc2U9XFxcIm9uX2Nsb3NlXFxcIj5cXG4gICAgICAgIDxkaXYgdi1mb3I9XFxcImsgaW4gc2V0dGxpc3RcXFwiIGNsYXNzPVxcXCJzZXR0LXdpbi1pdGVtXFxcIj5cXG4gICAgICAgICAgICA8bGFiZWw+e3sgczJkKGspIH19PC9sYWJlbD5cXG4gICAgICAgICAgICA8c3RkLWlucHV0IDp2YWx1ZT1cXFwic2V0dFtrXVxcXCIgQGlucHV0PVxcXCJ1cGRhdGVfc2V0dChrLCAkZXZlbnQpXFxcIiAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8c3BhbiB2LWlmPVxcXCIhc2V0dGxpc3QubGVuZ3RoXFxcIiBjbGFzcz1cXFwic2V0dC13aW4tZW1wdHlcXFwiPlxcbiAgICAgICAgICAgIDxpPk5vIHNjcmlwdCBzZXR0aW5nczwvaT5cXG4gICAgICAgIDwvc3Bhbj5cXG4gICAgPC93aW5kb3c+XFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcblxcbmltcG9ydCBXaW5kb3cgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9XaW5kb3cudnVlJ1xcbmltcG9ydCBTdGRJbnB1dCBmcm9tICcuLi8uLi9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZSdcXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy5qcydcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIG5hbWU6ICdTZXR0aW5nc1dpbicsXFxuICAgIGNvbXBvbmVudHM6IHsgV2luZG93LCBTdGRJbnB1dCB9LFxcbiAgICBwcm9wczogWydpZCcsICdtYWluJywgJ2RjJywgJ3R2JywgJ2RhdGEnXSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIHNldHQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmRhdGEub3Yuc2V0dGluZ3NcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXR0bGlzdCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXR0KS5maWx0ZXIoeCA9PlxcbiAgICAgICAgICAgICAgICB4WzBdICE9PSAnJCcgJiYgdGhpcy5zZXR0LiRwcm9wcyAmJlxcbiAgICAgICAgICAgICAgICB0aGlzLnNldHQuJHByb3BzLmluY2x1ZGVzKHgpKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtb3VudGVkKCkge1xcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBzMmQoc3RyKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnNldHQyZGVzYyhzdHIpXFxuICAgICAgICB9LFxcbiAgICAgICAgb25fY2xvc2UoKSB7XFxuICAgICAgICAgICAgdGhpcy4kcHJvcHMubWFpbi5yZW1vdmVfd2lkZ2V0KHRoaXMuJHByb3BzLmlkKVxcbiAgICAgICAgfSxcXG4gICAgICAgIHVwZGF0ZV9zZXR0KGssIHZhbCkge1xcbiAgICAgICAgICAgIGxldCBkY2lkID0gdGhpcy4kcHJvcHMuZGF0YS5vdi5pZFxcblxcbiAgICAgICAgICAgIGxldCB2YWxOID0gcGFyc2VGbG9hdCh2YWwpXFxuICAgICAgICAgICAgaWYgKHZhbE4gIT09IHZhbE4pIHZhbE4gPSB2YWxcXG5cXG4gICAgICAgICAgICB0aGlzLiRwcm9wcy5kYy5tZXJnZShgJHtkY2lkfS5zZXR0aW5nc2AsXFxuICAgICAgICAgICAgICAgIHsgW2tdOiB2YWxOIH1cXG4gICAgICAgICAgICApXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlIHNjb3BlZD5cXG4udHZqcy14LXdpbmRvdy5zZXR0LXdpbiB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAzMHB4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjODA4MDgwMTE7XFxufVxcbi5zZXR0LXdpbi1pdGVtIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4uc2V0dC13aW4taXRlbSBsYWJlbCB7XFxuICAgIG1pbi13aWR0aDogODBweDtcXG4gICAgY29sb3I6ICMzNWE3NzY7XFxufVxcbi5zZXR0LXdpbi1lbXB0eSB7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyICYmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl0pOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSkge1xuICB2YXIgX2l0ZW0gPSBfc2xpY2VkVG9BcnJheShpdGVtLCA0KSxcbiAgICAgIGNvbnRlbnQgPSBfaXRlbVsxXSxcbiAgICAgIGNzc01hcHBpbmcgPSBfaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMl0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NYWluTS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU3RkSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY5WzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY5WzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1dpbmRvdy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTg5ZmNjYWQmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY5WzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY5WzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FkZFdpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01MzQwOGFjNyZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU2V0dGluZ3NXaW4udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NWQyMjNiMGUmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCIvKiFcbiAqIFRyYWRpbmdWdWUuSlMgLSB2MS4wLjIgLSBUaHUgTWFyIDE4IDIwMjFcbiAqICAgICBodHRwczovL2dpdGh1Yi5jb20vdHZqc3gvdHJhZGluZy12dWUtanNcbiAqICAgICBDb3B5cmlnaHQgKGMpIDIwMTkgQzQ1MSBDb2RlJ3MgQWxsIFJpZ2h0O1xuICogICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJUcmFkaW5nVnVlSnNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiVHJhZGluZ1Z1ZUpzXCJdID0gZmFjdG9yeSgpO1xufSkoc2VsZiwgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDc1Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2Nik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU0Njpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8qKlxuICogVXRpbGl0eSBjb21wYXJlIGZ1bmN0aW9uc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAxIGlmIGEgPiBiLCAwIGlmIGEgPSBiLCAtMSBpZiBhIDwgYlxuICAgICAqL1xuICAgIG51bWNtcDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBiXG4gICAgICogQHJldHVybnMge051bWJlcn0gMSBpZiBhID4gYiwgMCBpZiBhID0gYiwgLTEgaWYgYSA8IGJcbiAgICAgKi9cbiAgICBzdHJjbXA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICB9XG5cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY3ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyoqXG4gKiBJbmRleGVkIEFycmF5IEJpbmFyeSBTZWFyY2ggbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwMCksXG4gICAgY21wID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDYpLFxuICAgIGJpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcblxuLyoqXG4gKiBNb2R1bGUgaW50ZXJmYWNlIGRlZmluaXRpb25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBJbmRleGVkQXJyYXk7XG5cbi8qKlxuICogSW5kZXhlZCBBcnJheSBjb25zdHJ1Y3RvclxuICpcbiAqIEl0IGxvYWRzIHRoZSBhcnJheSBkYXRhLCBkZWZpbmVzIHRoZSBpbmRleCBmaWVsZCBhbmQgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqIHRvIGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBpcyBhbiBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5kZXggaXMgdGhlIG9iamVjdCdzIHByb3BlcnR5IHVzZWQgdG8gc2VhcmNoIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBJbmRleGVkQXJyYXkoZGF0YSwgaW5kZXgpIHtcblxuICAgIC8vIGlzIGRhdGEgc29ydGFibGUgYXJyYXkgb3IgYXJyYXktbGlrZSBvYmplY3Q/XG4gICAgaWYgKCF1dGlsLmlzU29ydGFibGVBcnJheUxpa2UoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YVwiKTtcblxuICAgIC8vIGlzIGluZGV4IGEgdmFsaWQgcHJvcGVydHk/XG4gICAgaWYgKCFpbmRleCB8fCBkYXRhLmxlbmd0aCA+IDAgJiYgIShpbmRleCBpbiBkYXRhWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRleFwiKTtcblxuICAgIC8vIGRhdGEgYXJyYXlcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgLy8gbmFtZSBvZiB0aGUgaW5kZXggcHJvcGVydHlcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAvLyBzZXQgaW5kZXggYm91bmRhcnkgdmFsdWVzXG4gICAgdGhpcy5zZXRCb3VuZGFyaWVzKCk7XG5cbiAgICAvLyBkZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgICB0aGlzLmNvbXBhcmUgPSB0eXBlb2YgdGhpcy5taW52ID09PSBcIm51bWJlclwiID8gY21wLm51bWNtcCA6IGNtcC5zdHJjbXA7XG5cbiAgICAvLyBkZWZhdWx0IHNlYXJjaCBmdW5jdGlvblxuICAgIHRoaXMuc2VhcmNoID0gYmluLnNlYXJjaDtcblxuICAgIC8vIGNhY2hlIG9mIGluZGV4IHZhbHVlcyB0byBhcnJheSBwb3NpdGlvbnNcbiAgICAvLyBlYWNoIHZhbHVlIHN0b3JlcyBhbiBvYmplY3QgYXMgeyBmb3VuZDogdHJ1ZXxmYWxzZSwgaW5kZXg6IGFycmF5LWluZGV4IH1cbiAgICB0aGlzLnZhbHBvcyA9IHt9O1xuXG4gICAgLy8gY3Vyc29yIGFuZCBhZGphY2VudCBwb3NpdGlvbnNcbiAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgdGhpcy5uZXh0bG93ID0gbnVsbDtcbiAgICB0aGlzLm5leHRoaWdoID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0byBjb21wYXJlIGluZGV4IHZhbHVlcyB0aGF0IHJldHVybmVzIDEsIDAsIC0xXG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuc2V0Q29tcGFyZSA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcblxuICAgIHRoaXMuY29tcGFyZSA9IGZuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNlYXJjaCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRvIHNlYXJjaCBpbmRleCB2YWx1ZXMgaW4gdGhlIGFycmF5IG9mIG9iamVjdHNcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zZXRTZWFyY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG5cbiAgICB0aGlzLnNlYXJjaCA9IGZuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTb3J0IHRoZSBkYXRhIGFycmF5IGJ5IGl0cyBpbmRleCBwcm9wZXJ0eVxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAvLyBzb3J0IHRoZSBhcnJheVxuICAgIHRoaXMuZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNvbXBhcmUoYVtpbmRleF0sIGJbaW5kZXhdKTtcbiAgICB9KTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIGJvdW5kYXJ5IHZhbHVlc1xuICAgIHRoaXMuc2V0Qm91bmRhcmllcygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluc3BlY3QgYW5kIHNldCB0aGUgYm91bmRhcmllcyBvZiB0aGUgaW50ZXJuYWwgZGF0YSBhcnJheVxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLnNldEJvdW5kYXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgIHRoaXMubWludiA9IGRhdGEubGVuZ3RoICYmIGRhdGFbMF1baW5kZXhdO1xuICAgIHRoaXMubWF4diA9IGRhdGEubGVuZ3RoICYmIGRhdGFbZGF0YS5sZW5ndGggLSAxXVtpbmRleF07XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZGV4XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpbmRleCBpcyB0aGUgaWQgb2YgdGhlIHJlcXVlc3RlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheVxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gY2hlY2sgZGF0YSBoYXMgb2JqZWN0c1xuICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0bG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHRoZSByZXF1ZXN0IGlzIHdpdGhpbiByYW5nZVxuICAgIGlmICh0aGlzLmNvbXBhcmUodmFsdWUsIHRoaXMubWludikgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0bG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0aGlnaCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb21wYXJlKHZhbHVlLCB0aGlzLm1heHYpID09PSAxKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0bG93ID0gdGhpcy5kYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubmV4dGhpZ2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdmFscG9zID0gdGhpcy52YWxwb3MsXG4gICAgICAgIHBvcyA9IHZhbHBvc1t2YWx1ZV07XG5cbiAgICAvLyBpZiB0aGUgcmVxdWVzdCBpcyBtZW1vcml6ZWQsIGp1c3QgZ2l2ZSBpdCBiYWNrXG4gICAgaWYgKHBvcykge1xuICAgICAgICBpZiAocG9zLmZvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IHBvcy5pbmRleDtcbiAgICAgICAgICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5leHRoaWdoID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmV4dGxvdyA9IHBvcy5wcmV2O1xuICAgICAgICAgICAgdGhpcy5uZXh0aGlnaCA9IHBvcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGlmIG5vdCwgZG8gdGhlIHNlYXJjaFxuICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB0aGlzLmN1cnNvciA9IHJlc3VsdC5pbmRleDtcbiAgICB0aGlzLm5leHRsb3cgPSByZXN1bHQucHJldjtcbiAgICB0aGlzLm5leHRoaWdoID0gcmVzdWx0Lm5leHQ7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZGV4XG4gKlxuICogV2hlbiBubyB2YWx1ZSBpcyBnaXZlbiwgdGhlIGZ1bmN0aW9uIHdpbGwgZGVmYXVsdCB0byB0aGUgbGFzdCBmZXRjaGVkIGl0ZW0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3B0aW9uYWxdIGluZGV4IGlzIHRoZSBpZCBvZiB0aGUgcmVxdWVzdGVkIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gdGhlIGZvdW5kIG9iamVjdCBvciBudWxsXG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKVxuICAgICAgICB0aGlzLmZldGNoKHZhbHVlKTtcblxuICAgIHZhciBwb3MgPSB0aGlzLmN1cnNvcjtcbiAgICByZXR1cm4gcG9zICE9PSBudWxsID8gdGhpcy5kYXRhW3Bvc10gOiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gc2xpY2Ugb2YgdGhlIGRhdGEgYXJyYXlcbiAqXG4gKiBCb3VuZGFyaWVzIGhhdmUgdG8gYmUgaW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBiZWdpbiBpbmRleCBpcyB0aGUgaWQgb2YgdGhlIHJlcXVlc3RlZCBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZW5kIGluZGV4IGlzIHRoZSBpZCBvZiB0aGUgcmVxdWVzdGVkIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gdGhlIHNsaWNlIG9mIGRhdGEgYXJyYXkgb3IgW11cbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uIChiZWdpbiwgZW5kKSB7XG4gICAgLy8gY2hlY2sgaWYgYm91bmRhcmllcyBhcmUgaW4gb3JkZXJcbiAgICBpZiAodGhpcy5jb21wYXJlKGJlZ2luLCBlbmQpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBmZXRjaCBzdGFydCBhbmQgZGVmYXVsdCB0byB0aGUgbmV4dCBpbmRleCBhYm92ZVxuICAgIHRoaXMuZmV0Y2goYmVnaW4pO1xuICAgIHZhciBzdGFydCA9IHRoaXMuY3Vyc29yIHx8IHRoaXMubmV4dGhpZ2g7XG5cbiAgICAvLyBmZXRjaCBmaW5pc2ggYW5kIGRlZmF1bHQgdG8gdGhlIG5leHQgaW5kZXggYmVsb3dcbiAgICB0aGlzLmZldGNoKGVuZCk7XG4gICAgdmFyIGZpbmlzaCA9IHRoaXMuY3Vyc29yIHx8IHRoaXMubmV4dGxvdztcblxuICAgIC8vIGlmIGFueSBib3VuZGFyeSBpcyBub3Qgc2V0LCByZXR1cm4gbm8gcmFuZ2VcbiAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZmluaXNoID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gcmFuZ2VcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNsaWNlKHN0YXJ0LCBmaW5pc2ggKyAxKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEwMTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8qKlxuICogQmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvblxuICovXG5cbi8qKlxuICogTWFpbiBzZWFyY2ggcmVjdXJzaXZlIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGxvb3AoZGF0YSwgbWluLCBtYXgsIGluZGV4LCB2YWxwb3MpIHtcblxuICAgIC8vIHNldCBjdXJyZW50IHBvc2l0aW9uIGFzIHRoZSBtaWRkbGUgcG9pbnQgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgIHZhciBjdXJyID0gKG1heCArIG1pbikgPj4+IDE7XG5cbiAgICAvLyBjb21wYXJlIGN1cnJlbnQgaW5kZXggdmFsdWUgd2l0aCB0aGUgb25lIHdlIGFyZSBsb29raW5nIGZvclxuICAgIHZhciBkaWZmID0gdGhpcy5jb21wYXJlKGRhdGFbY3Vycl1bdGhpcy5pbmRleF0sIGluZGV4KTtcblxuICAgIC8vIGZvdW5kP1xuICAgIGlmICghZGlmZikge1xuICAgICAgICByZXR1cm4gdmFscG9zW2luZGV4XSA9IHtcbiAgICAgICAgICAgIFwiZm91bmRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiaW5kZXhcIjogY3VycixcbiAgICAgICAgICAgIFwicHJldlwiOiBudWxsLFxuICAgICAgICAgICAgXCJuZXh0XCI6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHBvc2l0aW9ucyBhdmFpbGFibGU/XG4gICAgaWYgKG1pbiA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHBvc1tpbmRleF0gPSB7XG4gICAgICAgICAgICBcImZvdW5kXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJpbmRleFwiOiBudWxsLFxuICAgICAgICAgICAgXCJwcmV2XCI6IChkaWZmIDwgMCkgPyBtYXggOiBtYXggLSAxLFxuICAgICAgICAgICAgXCJuZXh0XCI6IChkaWZmIDwgMCkgPyBtYXggKyAxIDogbWF4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gY29udGludWUgbG9va2luZyBmb3IgaW5kZXggaW4gb25lIG9mIHRoZSByZW1haW5pbmcgYXJyYXkgaGFsdmVzXG4gICAgLy8gY3VycmVudCBwb3NpdGlvbiBjYW4gYmUgc2tlcHQgYXMgaW5kZXggaXMgbm90IHRoZXJlLi4uXG4gICAgaWYgKGRpZmYgPiAwKVxuICAgICAgICByZXR1cm4gbG9vcC5jYWxsKHRoaXMsIGRhdGEsIG1pbiwgY3VyciAtIDEsIGluZGV4LCB2YWxwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxvb3AuY2FsbCh0aGlzLCBkYXRhLCBjdXJyICsgMSwgbWF4LCBpbmRleCwgdmFscG9zKTtcbn1cblxuLyoqXG4gKiBTZWFyY2ggYm9vdHN0cmFwXG4gKiBUaGUgZnVuY3Rpb24gaGFzIHRvIGJlIGV4ZWN1dGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBJbmRleGVkQXJyYXkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHNlYXJjaChpbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHJldHVybiBsb29wLmNhbGwodGhpcywgZGF0YSwgMCwgZGF0YS5sZW5ndGggLSAxLCBpbmRleCwgdGhpcy52YWxwb3MpO1xufVxuXG4vKipcbiAqIEV4cG9ydCBzZWFyY2ggZnVuY3Rpb25cbiAqL1xubW9kdWxlLmV4cG9ydHMuc2VhcmNoID0gc2VhcmNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDA6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vKipcbiAqIFV0aWxzIG1vZHVsZVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0XG4gKlxuICogQGNyZWRpdCBKYXZhc2NyaXB0OiBUaGUgRGVmaW5pdGl2ZSBHdWlkZSwgTydSZWlsbHksIDIwMTFcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2Uobykge1xuICAgIGlmIChvICYmICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbyBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmICAgICAgICAgICAgIC8vIG8gaXMgYW4gb2JqZWN0XG4gICAgICAgIGlzRmluaXRlKG8ubGVuZ3RoKSAmJiAgICAgICAgICAgICAgICAvLyBvLmxlbmd0aCBpcyBhIGZpbml0ZSBudW1iZXJcbiAgICAgICAgby5sZW5ndGggPj0gMCAmJiAgICAgICAgICAgICAgICAgICAgIC8vIG8ubGVuZ3RoIGlzIG5vbi1uZWdhdGl2ZVxuICAgICAgICBvLmxlbmd0aCA9PT0gTWF0aC5mbG9vcihvLmxlbmd0aCkgJiYgLy8gby5sZW5ndGggaXMgYW4gaW50ZWdlclxuICAgICAgICBvLmxlbmd0aCA8IDQyOTQ5NjcyOTYpICAgICAgICAgICAgICAgLy8gby5sZW5ndGggPCAyXjMyXG4gICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIG8gaXMgYXJyYXktbGlrZVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBpcyBub3Rcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgc29ydCBmdW5jdGlvbiBpbiB0aGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzU29ydGFibGUobykge1xuICAgIGlmIChvICYmICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbyBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmICAgICAgICAgICAgIC8vIG8gaXMgYW4gb2JqZWN0XG4gICAgICAgIHR5cGVvZiBvLnNvcnQgPT09IFwiZnVuY3Rpb25cIikgICAgICAgIC8vIG8uc29ydCBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIG8gaXMgYXJyYXktbGlrZVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBpcyBub3Rcbn1cblxuLyoqXG4gKiBDaGVjayBmb3Igc29ydGFibGUtYXJyYXktbGlrZSBvYmplY3RzXG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzU29ydGFibGVBcnJheUxpa2UgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvKSAmJiBpc1NvcnRhYmxlKG8pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODUxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcIkNhbmRsZVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2FuZGxlRXh0KSxcbiAgXCJDb25zdGFudHNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNvbnN0YW50cyksXG4gIFwiRGF0YUN1YmVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERhdGFDdWJlKSxcbiAgXCJJbnRlcmZhY2VcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIG1peGluc19pbnRlcmZhY2UpLFxuICBcIk92ZXJsYXlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIG92ZXJsYXkpLFxuICBcIlRvb2xcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHRvb2wpLFxuICBcIlRyYWRpbmdWdWVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRyYWRpbmdWdWUpLFxuICBcIlV0aWxzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyB1dGlscyksXG4gIFwiVm9sYmFyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWb2xiYXJFeHQpLFxuICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc3JjKSxcbiAgXCJsYXlvdXRfY252XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBsYXlvdXRfY252KSxcbiAgXCJsYXlvdXRfdm9sXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBsYXlvdXRfdm9sKSxcbiAgXCJwcmltaXRpdmVzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHByaW1pdGl2ZXMpXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL1RyYWRpbmdWdWUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTIzNWMwYWRlJlxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBjb2xvcjogdGhpcy5jaGFydF9wcm9wcy5jb2xvcnMudGV4dCxcbiAgICAgICAgZm9udDogdGhpcy5mb250X2NvbXAsXG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoICsgXCJweFwiLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0ICsgXCJweFwiXG4gICAgICB9LFxuICAgICAgYXR0cnM6IHsgaWQ6IF92bS5pZCB9LFxuICAgICAgb246IHsgbW91c2Vkb3duOiBfdm0ubW91c2Vkb3duLCBtb3VzZWxlYXZlOiBfdm0ubW91c2VsZWF2ZSB9XG4gICAgfSxcbiAgICBbXG4gICAgICBfdm0udG9vbGJhclxuICAgICAgICA/IF9jKFxuICAgICAgICAgICAgXCJ0b29sYmFyXCIsXG4gICAgICAgICAgICBfdm0uX2IoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWY6IFwidG9vbGJhclwiLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGNvbmZpZzogX3ZtLmNoYXJ0X2NvbmZpZyB9LFxuICAgICAgICAgICAgICAgIG9uOiB7IFwiY3VzdG9tLWV2ZW50XCI6IF92bS5jdXN0b21fZXZlbnQgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcInRvb2xiYXJcIixcbiAgICAgICAgICAgICAgX3ZtLmNoYXJ0X3Byb3BzLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uY29udHJvbGxlcnMubGVuZ3RoXG4gICAgICAgID8gX2MoXCJ3aWRnZXRzXCIsIHtcbiAgICAgICAgICAgIHJlZjogXCJ3aWRnZXRzXCIsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBtYXA6IF92bS53cyxcbiAgICAgICAgICAgICAgd2lkdGg6IF92bS53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBfdm0uaGVpZ2h0LFxuICAgICAgICAgICAgICB0djogdGhpcyxcbiAgICAgICAgICAgICAgZGM6IF92bS5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJjaGFydFwiLFxuICAgICAgICBfdm0uX2IoXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBfdm0ucmVzZXQsXG4gICAgICAgICAgICByZWY6IFwiY2hhcnRcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IHR2X2lkOiBfdm0uaWQsIGNvbmZpZzogX3ZtLmNoYXJ0X2NvbmZpZyB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgXCJjdXN0b20tZXZlbnRcIjogX3ZtLmN1c3RvbV9ldmVudCxcbiAgICAgICAgICAgICAgXCJyYW5nZS1jaGFuZ2VkXCI6IF92bS5yYW5nZV9jaGFuZ2VkLFxuICAgICAgICAgICAgICBcImxlZ2VuZC1idXR0b24tY2xpY2tcIjogX3ZtLmxlZ2VuZF9idXR0b25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY2hhcnRcIixcbiAgICAgICAgICBfdm0uY2hhcnRfcHJvcHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgICAgIHsgYXR0cnM6IHsgbmFtZTogXCJ0dmpzLWRyaWZ0XCIgfSB9LFxuICAgICAgICBbXG4gICAgICAgICAgX3ZtLnRpcFxuICAgICAgICAgICAgPyBfYyhcInRoZS10aXBcIiwge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGRhdGE6IF92bS50aXAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgXCJyZW1vdmUtbWVcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS50aXAgPSBudWxsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICBdLFxuICAgICAgICAxXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1RyYWRpbmdWdWUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTIzNWMwYWRlJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qc1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzXG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzXG5cblxuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHVmZi9jb25zdGFudHMuanNcbnZhciBTRUNPTkQgPSAxMDAwO1xudmFyIE1JTlVURSA9IFNFQ09ORCAqIDYwO1xudmFyIE1JTlVURTMgPSBNSU5VVEUgKiAzO1xudmFyIE1JTlVURTUgPSBNSU5VVEUgKiA1O1xudmFyIE1JTlVURTE1ID0gTUlOVVRFICogMTU7XG52YXIgTUlOVVRFMzAgPSBNSU5VVEUgKiAzMDtcbnZhciBIT1VSID0gTUlOVVRFICogNjA7XG52YXIgSE9VUjQgPSBIT1VSICogNDtcbnZhciBIT1VSMTIgPSBIT1VSICogMTI7XG52YXIgREFZID0gSE9VUiAqIDI0O1xudmFyIFdFRUsgPSBEQVkgKiA3O1xudmFyIE1PTlRIID0gV0VFSyAqIDQ7XG52YXIgWUVBUiA9IERBWSAqIDM2NTtcbnZhciBNT05USE1BUCA9IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXTsgLy8gR3JpZCB0aW1lIHN0ZXBzXG5cbnZhciBUSU1FU0NBTEVTID0gW1lFQVIgKiAxMCwgWUVBUiAqIDUsIFlFQVIgKiAzLCBZRUFSICogMiwgWUVBUiwgTU9OVEggKiA2LCBNT05USCAqIDQsIE1PTlRIICogMywgTU9OVEggKiAyLCBNT05USCwgREFZICogMTUsIERBWSAqIDEwLCBEQVkgKiA3LCBEQVkgKiA1LCBEQVkgKiAzLCBEQVkgKiAyLCBEQVksIEhPVVIgKiAxMiwgSE9VUiAqIDYsIEhPVVIgKiAzLCBIT1VSICogMS41LCBIT1VSLCBNSU5VVEUzMCwgTUlOVVRFMTUsIE1JTlVURSAqIDEwLCBNSU5VVEU1LCBNSU5VVEUgKiAyLCBNSU5VVEVdOyAvLyBHcmlkICQgc3RlcHNcblxudmFyICRTQ0FMRVMgPSBbMC4wNSwgMC4xLCAwLjIsIDAuMjUsIDAuNSwgMC44LCAxLCAyLCA1XTtcbnZhciBDaGFydENvbmZpZyA9IHtcbiAgU0JNSU46IDYwLFxuICAvLyBNaW5pbWFsIHNpZGViYXIgcHhcbiAgU0JNQVg6IEluZmluaXR5LFxuICAvLyBNYXggc2lkZWJhciwgcHhcbiAgVE9PTEJBUjogNTcsXG4gIC8vIFRvb2xiYXIgd2lkdGggcHhcbiAgVEJfSUNPTjogMjUsXG4gIC8vIFRvb2xiYXIgaWNvbiBzaXplIHB4XG4gIFRCX0lURU1fTTogNixcbiAgLy8gVG9vbGJhciBpdGVtIG1hcmdpbiBweFxuICBUQl9JQ09OX0JSSTogMSxcbiAgLy8gVG9vbGJhciBpY29uIGJyaWdodG5lc3NcbiAgVEJfSUNPTl9IT0xEOiA0MjAsXG4gIC8vIG1zLCB3YWl0IHRvIGV4cGFuZFxuICBUQl9CT1JERVI6IDEsXG4gIC8vIFRvb2xiYXIgYm9yZGVyIHB4XG4gIFRCX0JfU1RZTEU6ICdkb3R0ZWQnLFxuICAvLyBUb29sYmFyIGJvcmRlciBzdHlsZVxuICBUT09MX0NPTEw6IDcsXG4gIC8vIFRvb2wgY29sbGlzaW9uIHRocmVzaG9sZFxuICBFWFBBTkQ6IDAuMTUsXG4gIC8vICUvMTAwIG9mIHJhbmdlXG4gIENBTkRMRVc6IDAuNixcbiAgLy8gJS8xMDAgb2Ygc3RlcFxuICBHUklEWDogMTAwLFxuICAvLyBweFxuICBHUklEWTogNDcsXG4gIC8vIHB4XG4gIEJPVEJBUjogMjgsXG4gIC8vIHB4XG4gIFBBTkhFSUdIVDogMjIsXG4gIC8vIHB4XG4gIERFRkFVTFRfTEVOOiA1MCxcbiAgLy8gY2FuZGxlc1xuICBNSU5JTVVNX0xFTjogNSxcbiAgLy8gY2FuZGxlcyxcbiAgTUlOX1pPT006IDI1LFxuICAvLyBjYW5kbGVzXG4gIE1BWF9aT09NOiAxMDAwLFxuICAvLyBjYW5kbGVzLFxuICBWT0xTQ0FMRTogMC4xNSxcbiAgLy8gJS8xMDAgb2YgaGVpZ2h0XG4gIFVYX09QQUNJVFk6IDAuOSxcbiAgLy8gVXggYmFja2dyb3VuZCBvcGFjaXR5XG4gIFpPT01fTU9ERTogJ3R2JyxcbiAgLy8gJ3R2JyBvciAndGwnXG4gIExfQlROX1NJWkU6IDIxLFxuICAvLyBMZWdlbmQgQnV0dG9uIHNpemUsIHB4XG4gIExfQlROX01BUkdJTjogJy02cHggMCAtNnB4IDAnLFxuICAvLyBjc3MgbWFyZ2luXG4gIFNDUk9MTF9XSEVFTDogJ3ByZXZlbnQnIC8vICdwYXNzJywgJ2NsaWNrJ1xuXG59O1xuQ2hhcnRDb25maWcuRk9OVCA9IFwiMTFweCAtYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxcXG4gICAgU2Vnb2UgVUksUm9ib3RvLE94eWdlbixVYnVudHUsQ2FudGFyZWxsLFxcbiAgICBGaXJhIFNhbnMsRHJvaWQgU2FucyxIZWx2ZXRpY2EgTmV1ZSxcXG4gICAgc2Fucy1zZXJpZlwiO1xudmFyIElCX1RGX1dBUk4gPSBcIldoZW4gdXNpbmcgSUIgbW9kZSB5b3Ugc2hvdWxkIHNwZWNpZnkgXCIgKyBcInRpbWVmcmFtZSAoJ3RmJyBmaWxlZCBpbiAnY2hhcnQnIG9iamVjdCksXCIgKyBcIm90aGVyd2lzZSB5b3UgY2FuIGdldCBhbiB1bmV4cGVjdGVkIGJlaGF2aW91clwiO1xudmFyIE1BUF9VTklUID0ge1xuICBcIjFzXCI6IFNFQ09ORCxcbiAgXCI1c1wiOiBTRUNPTkQgKiA1LFxuICBcIjEwc1wiOiBTRUNPTkQgKiAxMCxcbiAgXCIyMHNcIjogU0VDT05EICogMjAsXG4gIFwiMzBzXCI6IFNFQ09ORCAqIDMwLFxuICBcIjFtXCI6IE1JTlVURSxcbiAgXCIzbVwiOiBNSU5VVEUzLFxuICBcIjVtXCI6IE1JTlVURTUsXG4gIFwiMTVtXCI6IE1JTlVURTE1LFxuICBcIjMwbVwiOiBNSU5VVEUzMCxcbiAgXCIxSFwiOiBIT1VSLFxuICBcIjJIXCI6IEhPVVIgKiAyLFxuICBcIjNIXCI6IEhPVVIgKiAzLFxuICBcIjRIXCI6IEhPVVI0LFxuICBcIjEySFwiOiBIT1VSMTIsXG4gIFwiMURcIjogREFZLFxuICBcIjFXXCI6IFdFRUssXG4gIFwiMU1cIjogTU9OVEgsXG4gIFwiMVlcIjogWUVBUlxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29uc3RhbnRzID0gKHtcbiAgU0VDT05EOiBTRUNPTkQsXG4gIE1JTlVURTogTUlOVVRFLFxuICBNSU5VVEU1OiBNSU5VVEU1LFxuICBNSU5VVEUxNTogTUlOVVRFMTUsXG4gIE1JTlVURTMwOiBNSU5VVEUzMCxcbiAgSE9VUjogSE9VUixcbiAgSE9VUjQ6IEhPVVI0LFxuICBEQVk6IERBWSxcbiAgV0VFSzogV0VFSyxcbiAgTU9OVEg6IE1PTlRILFxuICBZRUFSOiBZRUFSLFxuICBNT05USE1BUDogTU9OVEhNQVAsXG4gIFRJTUVTQ0FMRVM6IFRJTUVTQ0FMRVMsXG4gICRTQ0FMRVM6ICRTQ0FMRVMsXG4gIENoYXJ0Q29uZmlnOiBDaGFydENvbmZpZyxcbiAgbWFwX3VuaXQ6IE1BUF9VTklULFxuICBJQl9URl9XQVJOOiBJQl9URl9XQVJOXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0NoYXJ0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00ZDA2YTRkZSZcbnZhciBDaGFydHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRkMDZhNGRlX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtY2hhcnRcIiwgc3R5bGU6IF92bS5zdHlsZXMgfSxcbiAgICBbXG4gICAgICBfYyhcImtleWJvYXJkXCIsIHsgcmVmOiBcImtleWJvYXJkXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9sKHRoaXMuX2xheW91dC5ncmlkcywgZnVuY3Rpb24oZ3JpZCwgaSkge1xuICAgICAgICByZXR1cm4gX2MoXCJncmlkLXNlY3Rpb25cIiwge1xuICAgICAgICAgIGtleTogZ3JpZC5pZCxcbiAgICAgICAgICByZWY6IFwic2VjXCIsXG4gICAgICAgICAgcmVmSW5Gb3I6IHRydWUsXG4gICAgICAgICAgYXR0cnM6IHsgY29tbW9uOiBfdm0uc2VjdGlvbl9wcm9wcyhpKSwgZ3JpZF9pZDogaSB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcInJlZ2lzdGVyLWtiLWxpc3RlbmVyXCI6IF92bS5yZWdpc3Rlcl9rYixcbiAgICAgICAgICAgIFwicmVtb3ZlLWtiLWxpc3RlbmVyXCI6IF92bS5yZW1vdmVfa2IsXG4gICAgICAgICAgICBcInJhbmdlLWNoYW5nZWRcIjogX3ZtLnJhbmdlX2NoYW5nZWQsXG4gICAgICAgICAgICBcImN1cnNvci1jaGFuZ2VkXCI6IF92bS5jdXJzb3JfY2hhbmdlZCxcbiAgICAgICAgICAgIFwiY3Vyc29yLWxvY2tlZFwiOiBfdm0uY3Vyc29yX2xvY2tlZCxcbiAgICAgICAgICAgIFwic2lkZWJhci10cmFuc2Zvcm1cIjogX3ZtLnNldF95dHJhbnNmb3JtLFxuICAgICAgICAgICAgXCJsYXllci1tZXRhLXByb3BzXCI6IF92bS5sYXllcl9tZXRhX3Byb3BzLFxuICAgICAgICAgICAgXCJjdXN0b20tZXZlbnRcIjogX3ZtLmVtaXRfY3VzdG9tX2V2ZW50LFxuICAgICAgICAgICAgXCJsZWdlbmQtYnV0dG9uLWNsaWNrXCI6IF92bS5sZWdlbmRfYnV0dG9uX2NsaWNrXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwiYm90YmFyXCIsXG4gICAgICAgIF92bS5fYihcbiAgICAgICAgICB7IGF0dHJzOiB7IHNoYWRlcnM6IF92bS5zaGFkZXJzLCB0aW1lem9uZTogX3ZtLnRpbWV6b25lIH0gfSxcbiAgICAgICAgICBcImJvdGJhclwiLFxuICAgICAgICAgIF92bS5ib3RiYXJfcHJvcHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKVxuICAgIF0sXG4gICAgMlxuICApXG59XG52YXIgQ2hhcnR2dWVfdHlwZV90ZW1wbGF0ZV9pZF80ZDA2YTRkZV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuQ2hhcnR2dWVfdHlwZV90ZW1wbGF0ZV9pZF80ZDA2YTRkZV9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9DaGFydC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NGQwNmE0ZGUmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qc1xuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanNcblxuXG5cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3R1ZmYvY29udGV4dC5qc1xuLy8gQ2FudmFzIGNvbnRleHQgZm9yIHRleHQgbWVhc3VybWVudHNcbmZ1bmN0aW9uIENvbnRleHQoJHApIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIHZhciBjdHggPSBlbC5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGN0eC5mb250ID0gJHAuZm9udDtcbiAgcmV0dXJuIGN0eDtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb250ZXh0ID0gKENvbnRleHQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9hcnJheXNsaWNlci9saWIvaW5kZXguanNcbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3OCk7XG52YXIgbGliX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxpYik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3R1ZmYvdXRpbHMuanNcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgdXRpbHMgPSAoe1xuICBjbGFtcDogZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBudW0gPD0gbWluID8gbWluIDogbnVtID49IG1heCA/IG1heCA6IG51bTtcbiAgfSxcbiAgYWRkX3plcm86IGZ1bmN0aW9uIGFkZF96ZXJvKGkpIHtcbiAgICBpZiAoaSA8IDEwKSB7XG4gICAgICBpID0gXCIwXCIgKyBpO1xuICAgIH1cblxuICAgIHJldHVybiBpO1xuICB9LFxuICAvLyBTdGFydCBvZiB0aGUgZGF5ICh6ZXJvIG1pbGxpc2Vjb25kKVxuICBkYXlfc3RhcnQ6IGZ1bmN0aW9uIGRheV9zdGFydCh0KSB7XG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUodCk7XG4gICAgcmV0dXJuIHN0YXJ0LnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LFxuICAvLyBTdGFydCBvZiB0aGUgbW9udGhcbiAgbW9udGhfc3RhcnQ6IGZ1bmN0aW9uIG1vbnRoX3N0YXJ0KHQpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHQpO1xuICAgIHJldHVybiBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgMSk7XG4gIH0sXG4gIC8vIFN0YXJ0IG9mIHRoZSB5ZWFyXG4gIHllYXJfc3RhcnQ6IGZ1bmN0aW9uIHllYXJfc3RhcnQodCkge1xuICAgIHJldHVybiBEYXRlLlVUQyhuZXcgRGF0ZSh0KS5nZXRGdWxsWWVhcigpKTtcbiAgfSxcbiAgZ2V0X3llYXI6IGZ1bmN0aW9uIGdldF95ZWFyKHQpIHtcbiAgICBpZiAoIXQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHQpLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH0sXG4gIGdldF9tb250aDogZnVuY3Rpb24gZ2V0X21vbnRoKHQpIHtcbiAgICBpZiAoIXQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHQpLmdldFVUQ01vbnRoKCk7XG4gIH0sXG4gIC8vIE5lYXJlc3QgaW4gYXJyYXlcbiAgbmVhcmVzdF9hOiBmdW5jdGlvbiBuZWFyZXN0X2EoeCwgYXJyYXkpIHtcbiAgICB2YXIgZGlzdCA9IEluZmluaXR5O1xuICAgIHZhciB2YWwgPSBudWxsO1xuICAgIHZhciBpbmRleCA9IC0xO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHhpID0gYXJyYXlbaV07XG5cbiAgICAgIGlmIChNYXRoLmFicyh4aSAtIHgpIDwgZGlzdCkge1xuICAgICAgICBkaXN0ID0gTWF0aC5hYnMoeGkgLSB4KTtcbiAgICAgICAgdmFsID0geGk7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2luZGV4LCB2YWxdO1xuICB9LFxuICByb3VuZDogZnVuY3Rpb24gcm91bmQobnVtLCBkZWNpbWFscykge1xuICAgIGlmIChkZWNpbWFscyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWNpbWFscyA9IDg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtLnRvRml4ZWQoZGVjaW1hbHMpKTtcbiAgfSxcbiAgLy8gU3RyaXA/IE5vLCBpdCdzIHVnbHkgZmxvYXRzIGluIGpzXG4gIHN0cmlwOiBmdW5jdGlvbiBzdHJpcChudW1iZXIpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChwYXJzZUZsb2F0KG51bWJlcikudG9QcmVjaXNpb24oMTIpKTtcbiAgfSxcbiAgZ2V0X2RheTogZnVuY3Rpb24gZ2V0X2RheSh0KSB7XG4gICAgcmV0dXJuIHQgPyBuZXcgRGF0ZSh0KS5nZXREYXRlKCkgOiBudWxsO1xuICB9LFxuICAvLyBVcGRhdGUgYXJyYXkga2VlcGluZyB0aGUgc2FtZSByZWZlcmVuY2VcbiAgb3ZlcndyaXRlOiBmdW5jdGlvbiBvdmVyd3JpdGUoYXJyLCBuZXdfYXJyKSB7XG4gICAgYXJyLnNwbGljZS5hcHBseShhcnIsIFswLCBhcnIubGVuZ3RoXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5ld19hcnIpKSk7XG4gIH0sXG4gIC8vIENvcHkgbGF5b3V0IGluIHJlYWN0aXZlIHdheVxuICBjb3B5X2xheW91dDogZnVuY3Rpb24gY29weV9sYXlvdXQob2JqLCBuZXdfb2JqKSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgLy8gKHNvbWUgb2ZmY2hhcnQgaW5kaWNhdG9ycyBhcmUgYWRkZWQvcmVtb3ZlZClcbiAgICAgICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgbGF5b3V0IGluIGEgcmVhY3RpdmUgd2F5XG4gICAgICAgIGlmIChvYmpba10ubGVuZ3RoICE9PSBuZXdfb2JqW2tdLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMub3ZlcndyaXRlKG9ialtrXSwgbmV3X29ialtrXSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBtIGluIG9ialtrXSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2JqW2tdW21dLCBuZXdfb2JqW2tdW21dKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvYmpba10sIG5ld19vYmpba10pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gRGV0ZWN0cyBjYW5kbGVzIGludGVydmFsXG4gIGRldGVjdF9pbnRlcnZhbDogZnVuY3Rpb24gZGV0ZWN0X2ludGVydmFsKG9obGN2KSB7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKG9obGN2Lmxlbmd0aCAtIDEsIDk5KTtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgb2hsY3Yuc2xpY2UoMCwgbGVuKS5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICB2YXIgZCA9IG9obGN2W2kgKyAxXVswXSAtIHhbMF07XG4gICAgICBpZiAoZCA9PT0gZCAmJiBkIDwgbWluKSBtaW4gPSBkO1xuICAgIH0pOyAvLyBUaGlzIHNhdmVzIG1vbnRobHkgY2hhcnQgZnJvbSBiZWluZyBhd2t3YXJkXG5cbiAgICBpZiAobWluID49IGNvbnN0YW50cy5NT05USCAmJiBtaW4gPD0gY29uc3RhbnRzLkRBWSAqIDMwKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnRzLkRBWSAqIDMxO1xuICAgIH1cblxuICAgIHJldHVybiBtaW47XG4gIH0sXG4gIC8vIEdldHMgbnVtYmVyaWMgcGFydCBvZiBvdmVybGF5IGlkIChlLmcgJ0VNQV8xJyA9ID4gMSlcbiAgZ2V0X251bV9pZDogZnVuY3Rpb24gZ2V0X251bV9pZChpZCkge1xuICAgIHJldHVybiBwYXJzZUludChpZC5zcGxpdCgnXycpLnBvcCgpKTtcbiAgfSxcbiAgLy8gRmFzdCBmaWx0ZXIuIFJlYWxseSBmYXN0LCBsaWtlIDEwWFxuICBmYXN0X2ZpbHRlcjogZnVuY3Rpb24gZmFzdF9maWx0ZXIoYXJyLCB0MSwgdDIpIHtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHJldHVybiBbYXJyLCB1bmRlZmluZWRdO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpYSA9IG5ldyAobGliX2RlZmF1bHQoKSkoYXJyLCBcIjBcIik7XG4gICAgICB2YXIgcmVzID0gaWEuZ2V0UmFuZ2UodDEsIHQyKTtcbiAgICAgIHZhciBpMCA9IGlhLnZhbHBvc1t0MV0ubmV4dDtcbiAgICAgIHJldHVybiBbcmVzLCBpMF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gU29tZXRoaW5nIHdyb25nIHdpdGggZmFuY3kgc2xpY2UgbGliXG4gICAgICAvLyBGYXN0IGZpeDogZmFsbGJhY2sgdG8gZmlsdGVyXG4gICAgICByZXR1cm4gW2Fyci5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhbMF0gPj0gdDEgJiYgeFswXSA8PSB0MjtcbiAgICAgIH0pLCAwXTtcbiAgICB9XG4gIH0sXG4gIC8vIEZhc3QgZmlsdGVyIChpbmRleC1iYXNlZClcbiAgZmFzdF9maWx0ZXJfaTogZnVuY3Rpb24gZmFzdF9maWx0ZXJfaShhcnIsIHQxLCB0Mikge1xuICAgIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuIFthcnIsIHVuZGVmaW5lZF07XG4gICAgdmFyIGkxID0gTWF0aC5mbG9vcih0MSk7XG4gICAgaWYgKGkxIDwgMCkgaTEgPSAwO1xuICAgIHZhciBpMiA9IE1hdGguZmxvb3IodDIgKyAxKTtcbiAgICB2YXIgcmVzID0gYXJyLnNsaWNlKGkxLCBpMik7XG4gICAgcmV0dXJuIFtyZXMsIGkxXTtcbiAgfSxcbiAgLy8gTmVhcmVzdCBpbmRleGVzIChsZWZ0IGFuZCByaWdodClcbiAgZmFzdF9uZWFyZXN0OiBmdW5jdGlvbiBmYXN0X25lYXJlc3QoYXJyLCB0MSkge1xuICAgIHZhciBpYSA9IG5ldyAobGliX2RlZmF1bHQoKSkoYXJyLCBcIjBcIik7XG4gICAgaWEuZmV0Y2godDEpO1xuICAgIHJldHVybiBbaWEubmV4dGxvdywgaWEubmV4dGhpZ2hdO1xuICB9LFxuICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiBwYXVzZShkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocnMsIHJqKSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChycywgZGVsYXkpO1xuICAgIH0pO1xuICB9LFxuICAvLyBMaW1pdCBjcmF6eSB3aGVlbCBkZWx0YSB2YWx1ZXNcbiAgc21hcnRfd2hlZWw6IGZ1bmN0aW9uIHNtYXJ0X3doZWVsKGRlbHRhKSB7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzKGRlbHRhKTtcblxuICAgIGlmIChhYnMgPiA1MDApIHtcbiAgICAgIHJldHVybiAoMjAwICsgTWF0aC5sb2coYWJzKSkgKiBNYXRoLnNpZ24oZGVsdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWx0YTtcbiAgfSxcbiAgLy8gUGFyc2UgdGhlIG9yaWdpbmFsIG1vdXNlIGV2ZW50IHRvIGZpbmQgZGVsdGFYXG4gIGdldF9kZWx0YVg6IGZ1bmN0aW9uIGdldF9kZWx0YVgoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVggLyAxMjtcbiAgfSxcbiAgLy8gUGFyc2UgdGhlIG9yaWdpbmFsIG1vdXNlIGV2ZW50IHRvIGZpbmQgZGVsdGFZXG4gIGdldF9kZWx0YVk6IGZ1bmN0aW9uIGdldF9kZWx0YVkoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVkgLyAxMjtcbiAgfSxcbiAgLy8gQXBwbHkgb3BhY2l0eSB0byBhIGhleCBjb2xvclxuICBhcHBseV9vcGFjaXR5OiBmdW5jdGlvbiBhcHBseV9vcGFjaXR5KGMsIG9wKSB7XG4gICAgaWYgKGMubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgbiA9IE1hdGguZmxvb3Iob3AgKiAyNTUpO1xuICAgICAgbiA9IHRoaXMuY2xhbXAobiwgMCwgMjU1KTtcbiAgICAgIGMgKz0gbi50b1N0cmluZygxNik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG4gIH0sXG4gIC8vIFBhcnNlIHRpbWVmcmFtZSBvciByZXR1cm4gdmFsdWUgaW4gbXNcbiAgcGFyc2VfdGY6IGZ1bmN0aW9uIHBhcnNlX3RmKHNtdGgpIHtcbiAgICBpZiAodHlwZW9mIHNtdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnRzLm1hcF91bml0W3NtdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc210aDtcbiAgICB9XG4gIH0sXG4gIC8vIERldGVjdCBpbmRleCBzaGlmdCBiZXR3ZWVuIHRoZSBtYWluIGRhdGEgc3ViXG4gIC8vIGFuZCB0aGUgb3ZlcmxheSdzIHN1YiAoZm9yIElCLW1vZGUpXG4gIGluZGV4X3NoaWZ0OiBmdW5jdGlvbiBpbmRleF9zaGlmdChzdWIsIGRhdGEpIHtcbiAgICAvLyBGaW5kIHRoZSBzZWNvbmQgdGltZXN0YW1wIChieSB2YWx1ZSlcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm4gMDtcbiAgICB2YXIgZmlyc3QgPSBkYXRhWzBdWzBdO1xuICAgIHZhciBzZWNvbmQ7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkYXRhW2ldWzBdICE9PSBmaXJzdCkge1xuICAgICAgICBzZWNvbmQgPSBkYXRhW2ldWzBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHN1YltqXVswXSA9PT0gc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiBqIC0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgLy8gRmFsbGJhY2sgZml4IGZvciBCcmF2ZSBicm93c2VyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9icmF2ZS9icmF2ZS1icm93c2VyL2lzc3Vlcy8xNzM4XG4gIG1lYXN1cmVUZXh0OiBmdW5jdGlvbiBtZWFzdXJlVGV4dChjdHgsIHRleHQsIHR2X2lkKSB7XG4gICAgdmFyIG0gPSBjdHgubWVhc3VyZVRleHRPcmcodGV4dCk7XG5cbiAgICBpZiAobS53aWR0aCA9PT0gMCkge1xuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50O1xuICAgICAgdmFyIGlkID0gJ3R2anMtbWVhc3VyZS10ZXh0JztcbiAgICAgIHZhciBlbCA9IGRvYy5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBkb2MuZ2V0RWxlbWVudEJ5SWQodHZfaWQpO1xuICAgICAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbC5pZCA9IGlkO1xuICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICAgICAgYmFzZS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHguZm9udCkgZWwuc3R5bGUuZm9udCA9IGN0eC5mb250O1xuICAgICAgZWwuaW5uZXJUZXh0ID0gdGV4dC5yZXBsYWNlKC8gL2csICcuJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgfSxcbiAgdXVpZDogZnVuY3Rpb24gdXVpZCh0ZW1wKSB7XG4gICAgaWYgKHRlbXAgPT09IHZvaWQgMCkge1xuICAgICAgdGVtcCA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgICB2ID0gYyA9PSAneCcgPyByIDogciAmIDB4MyB8IDB4ODtcbiAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbiAgfSxcbiAgdXVpZDI6IGZ1bmN0aW9uIHV1aWQyKCkge1xuICAgIHJldHVybiB0aGlzLnV1aWQoJ3h4eHh4eHh4eHh4eCcpO1xuICB9LFxuICAvLyBEZWxheWVkIHdhcm5pbmcsIGYgPSBjb25kaXRpb24gbGFtYmRhIGZuXG4gIHdhcm46IGZ1bmN0aW9uIHdhcm4oZiwgdGV4dCwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGYoKSkgY29uc29sZS53YXJuKHRleHQpO1xuICAgIH0sIGRlbGF5KTtcbiAgfSxcbiAgLy8gQ2hlY2tzIGlmIHNjcmlwdCBwcm9wcyB1cGRhdGVkXG4gIC8vIChhbmQgbm90IHN0eWxlIHNldHRpbmdzIG9yIHNvbWV0aGluZyBlbHNlKVxuICBpc19zY3JfcHJvcHNfdXBkOiBmdW5jdGlvbiBpc19zY3JfcHJvcHNfdXBkKG4sIHByZXYpIHtcbiAgICB2YXIgcCA9IHByZXYuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgudi4kdXVpZCA9PT0gbi52LiR1dWlkO1xuICAgIH0pO1xuICAgIGlmICghcCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IG4ucC5zZXR0aW5ncy4kcHJvcHM7XG4gICAgaWYgKCFwcm9wcykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBwcm9wcy5zb21lKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbi52W3hdICE9PSBwLnZbeF07XG4gICAgfSk7XG4gIH0sXG4gIC8vIENoZWNrcyBpZiBpdCdzIHRpbWUgdG8gbWFrZSBhIHNjcmlwdCB1cGRhdGVcbiAgLy8gKGJhc2VkIG9uIGV4ZWNJbnRlcnZhbCBpbiBtcylcbiAgZGVsYXllZF9leGVjOiBmdW5jdGlvbiBkZWxheWVkX2V4ZWModikge1xuICAgIGlmICghdi5zY3JpcHQgfHwgIXYuc2NyaXB0LmV4ZWNJbnRlcnZhbCkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHQgPSB0aGlzLm5vdygpO1xuICAgIHZhciBkdCA9IHYuc2NyaXB0LmV4ZWNJbnRlcnZhbDtcblxuICAgIGlmICghdi5zZXR0aW5ncy4kbGFzdF9leGVjIHx8IHQgPiB2LnNldHRpbmdzLiRsYXN0X2V4ZWMgKyBkdCkge1xuICAgICAgdi5zZXR0aW5ncy4kbGFzdF9leGVjID0gdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgLy8gRm9ybWF0IG5hbWVzIHN1Y2ggJ1JTSSwgJGxlbmd0aCcsIHdoZXJlXG4gIC8vIGxlbmd0aCAtIGlzIG9uZSBvZiB0aGUgc2V0dGluZ3NcbiAgZm9ybWF0X25hbWU6IGZ1bmN0aW9uIGZvcm1hdF9uYW1lKG92KSB7XG4gICAgaWYgKCFvdi5uYW1lKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBuYW1lID0gb3YubmFtZTtcblxuICAgIGZvciAodmFyIGsgaW4gb3Yuc2V0dGluZ3MgfHwge30pIHtcbiAgICAgIHZhciB2YWwgPSBvdi5zZXR0aW5nc1trXTtcbiAgICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKFwiXFxcXCRcIi5jb25jYXQoayksICdnJyk7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHJlZywgdmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfSxcbiAgLy8gRGVmYXVsdCBjdXJzb3IgbW9kZVxuICB4bW9kZTogZnVuY3Rpb24geG1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNfbW9iaWxlID8gJ2V4cGxvcmUnIDogJ2RlZmF1bHQnO1xuICB9LFxuICBkZWZhdWx0X3ByZXZlbnRlZDogZnVuY3Rpb24gZGVmYXVsdF9wcmV2ZW50ZWQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQub3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBldmVudC5vcmlnaW5hbC5kZWZhdWx0UHJldmVudGVkO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICB9LFxuICAvLyBXVEYgd2l0aCBtb2Rlcm4gd2ViIGRldmVsb3BtZW50XG4gIGlzX21vYmlsZTogZnVuY3Rpb24gKHcpIHtcbiAgICByZXR1cm4gJ29ub3JpZW50YXRpb25jaGFuZ2UnIGluIHcgJiYgKCEhbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8ICEhbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgfHwgJ29udG91Y2hzdGFydCcgaW4gdyB8fCB3LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3LkRvY3VtZW50VG91Y2gpO1xuICB9KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge30pXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHVmZi9tYXRoLmpzXG4vLyBNYXRoL0dlb21ldHJ5XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG1hdGggPSAoe1xuICAvLyBEaXN0YW5jZSBmcm9tIHBvaW50IHRvIGxpbmVcbiAgLy8gcDEgPSBwb2ludCwgKHAyLCBwMykgPSBsaW5lXG4gIHBvaW50MmxpbmU6IGZ1bmN0aW9uIHBvaW50MmxpbmUocDEsIHAyLCBwMykge1xuICAgIHZhciBfdGhpcyR0cmkgPSB0aGlzLnRyaShwMSwgcDIsIHAzKSxcbiAgICAgICAgYXJlYSA9IF90aGlzJHRyaS5hcmVhLFxuICAgICAgICBiYXNlID0gX3RoaXMkdHJpLmJhc2U7XG5cbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy50cmlfaChhcmVhLCBiYXNlKSk7XG4gIH0sXG4gIC8vIERpc3RhbmNlIGZyb20gcG9pbnQgdG8gc2VnbWVudFxuICAvLyBwMSA9IHBvaW50LCAocDIsIHAzKSA9IHNlZ21lbnRcbiAgcG9pbnQyc2VnOiBmdW5jdGlvbiBwb2ludDJzZWcocDEsIHAyLCBwMykge1xuICAgIHZhciBfdGhpcyR0cmkyID0gdGhpcy50cmkocDEsIHAyLCBwMyksXG4gICAgICAgIGFyZWEgPSBfdGhpcyR0cmkyLmFyZWEsXG4gICAgICAgIGJhc2UgPSBfdGhpcyR0cmkyLmJhc2U7IC8vIFZlY3RvciBwcm9qZWN0aW9uXG5cblxuICAgIHZhciBwcm9qID0gdGhpcy5kb3RfcHJvZChwMSwgcDIsIHAzKSAvIGJhc2U7IC8vIERpc3RhbmNlIGZyb20gbGVmdCBwaW5cblxuICAgIHZhciBsMSA9IE1hdGgubWF4KC1wcm9qLCAwKTsgLy8gRGlzdGFuY2UgZnJvbSByaWdodCBwaW5cblxuICAgIHZhciBsMiA9IE1hdGgubWF4KHByb2ogLSBiYXNlLCAwKTsgLy8gTm9ybWFsXG5cbiAgICB2YXIgaCA9IE1hdGguYWJzKHRoaXMudHJpX2goYXJlYSwgYmFzZSkpO1xuICAgIHJldHVybiBNYXRoLm1heChoLCBsMSwgbDIpO1xuICB9LFxuICAvLyBEaXN0YW5jZSBmcm9tIHBvaW50IHRvIHJheVxuICAvLyBwMSA9IHBvaW50LCAocDIsIHAzKSA9IHJheVxuICBwb2ludDJyYXk6IGZ1bmN0aW9uIHBvaW50MnJheShwMSwgcDIsIHAzKSB7XG4gICAgdmFyIF90aGlzJHRyaTMgPSB0aGlzLnRyaShwMSwgcDIsIHAzKSxcbiAgICAgICAgYXJlYSA9IF90aGlzJHRyaTMuYXJlYSxcbiAgICAgICAgYmFzZSA9IF90aGlzJHRyaTMuYmFzZTsgLy8gVmVjdG9yIHByb2plY3Rpb25cblxuXG4gICAgdmFyIHByb2ogPSB0aGlzLmRvdF9wcm9kKHAxLCBwMiwgcDMpIC8gYmFzZTsgLy8gRGlzdGFuY2UgZnJvbSBsZWZ0IHBpblxuXG4gICAgdmFyIGwxID0gTWF0aC5tYXgoLXByb2osIDApOyAvLyBOb3JtYWxcblxuICAgIHZhciBoID0gTWF0aC5hYnModGhpcy50cmlfaChhcmVhLCBiYXNlKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGgsIGwxKTtcbiAgfSxcbiAgdHJpOiBmdW5jdGlvbiB0cmkocDEsIHAyLCBwMykge1xuICAgIHZhciBhcmVhID0gdGhpcy5hcmVhKHAxLCBwMiwgcDMpO1xuICAgIHZhciBkeCA9IHAzWzBdIC0gcDJbMF07XG4gICAgdmFyIGR5ID0gcDNbMV0gLSBwMlsxXTtcbiAgICB2YXIgYmFzZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZWE6IGFyZWEsXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcblxuICAvKiBBcmVhIG9mIHRyaWFuZ2xlOlxuICAgICAgICAgIHAxXG4gICAgICAgIC8gICAgXFxcbiAgICAgIHAyICBfICBwM1xuICAqL1xuICBhcmVhOiBmdW5jdGlvbiBhcmVhKHAxLCBwMiwgcDMpIHtcbiAgICByZXR1cm4gcDFbMF0gKiAocDJbMV0gLSBwM1sxXSkgKyBwMlswXSAqIChwM1sxXSAtIHAxWzFdKSArIHAzWzBdICogKHAxWzFdIC0gcDJbMV0pO1xuICB9LFxuICAvLyBUcmlhbmdsZSBoZWlnaHRcbiAgdHJpX2g6IGZ1bmN0aW9uIHRyaV9oKGFyZWEsIGJhc2UpIHtcbiAgICByZXR1cm4gYXJlYSAvIGJhc2U7XG4gIH0sXG4gIC8vIERvdCBwcm9kdWN0IG9mIChwMiwgcDMpIGFuZCAocDIsIHAxKVxuICBkb3RfcHJvZDogZnVuY3Rpb24gZG90X3Byb2QocDEsIHAyLCBwMykge1xuICAgIHZhciB2MSA9IFtwM1swXSAtIHAyWzBdLCBwM1sxXSAtIHAyWzFdXTtcbiAgICB2YXIgdjIgPSBbcDFbMF0gLSBwMlswXSwgcDFbMV0gLSBwMlsxXV07XG4gICAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xuICB9LFxuICAvLyBTeW1tZXRyaWNhbCBsb2dcbiAgbG9nOiBmdW5jdGlvbiBsb2coeCkge1xuICAgIC8vIFRPRE86IGxvZyBmb3Igc21hbGwgdmFsdWVzXG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGgubG9nKE1hdGguYWJzKHgpICsgMSk7XG4gIH0sXG4gIC8vIFN5bW1ldHJpY2FsIGV4cFxuICBleHA6IGZ1bmN0aW9uIGV4cCh4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIChNYXRoLmV4cChNYXRoLmFicyh4KSkgLSAxKTtcbiAgfSxcbiAgLy8gTWlkZGxlIGxpbmUgb24gbG9nIHNjYWxlIGJhc2VkIG9uIHJhbmdlICYgcHggaGVpZ2h0XG4gIGxvZ19taWQ6IGZ1bmN0aW9uIGxvZ19taWQociwgaCkge1xuICAgIHZhciBsb2dfaGkgPSB0aGlzLmxvZyhyWzBdKTtcbiAgICB2YXIgbG9nX2xvID0gdGhpcy5sb2coclsxXSk7XG4gICAgdmFyIHB4ID0gaCAvIDI7XG4gICAgdmFyIGd4ID0gbG9nX2hpIC0gcHggKiAobG9nX2hpIC0gbG9nX2xvKSAvIGg7XG4gICAgcmV0dXJuIHRoaXMuZXhwKGd4KTtcbiAgfSxcbiAgLy8gUmV0dXJuIG5ldyBhZGp1c3RlZCByYW5nZSwgYmFzZWQgb24gdGhlIHByZXZpb3VzXG4gIC8vIHJhbmdlLCBuZXcgJF9oaSwgdGFyZ2V0IG1pZGRsZSBsaW5lXG4gIHJlX3JhbmdlOiBmdW5jdGlvbiByZV9yYW5nZShyMSwgaGkyLCBtaWQpIHtcbiAgICB2YXIgbG9nX2hpMSA9IHRoaXMubG9nKHIxWzBdKTtcbiAgICB2YXIgbG9nX2xvMSA9IHRoaXMubG9nKHIxWzFdKTtcbiAgICB2YXIgbG9nX2hpMiA9IHRoaXMubG9nKGhpMik7XG4gICAgdmFyIGxvZ18kID0gdGhpcy5sb2cobWlkKTtcbiAgICB2YXIgVyA9IChsb2dfaGkyIC0gbG9nXyQpICogKGxvZ19oaTEgLSBsb2dfbG8xKSAvIChsb2dfaGkxIC0gbG9nXyQpO1xuICAgIHJldHVybiB0aGlzLmV4cChsb2dfaGkyIC0gVyk7XG4gIH0gLy8gUmV0dXJuIG5ldyBhZGp1c3RlZCByYW5nZSwgYmFzZWQgb24gdGhlIHByZXZpb3VzXG4gIC8vIHJhbmdlLCBuZXcgJF9oaSwgdGFyZ2V0IG1pZGRsZSBsaW5lICsgZHkgKHNoaWZ0KVxuICAvLyBXQVNURVxuXG4gIC8qcmFuZ2Vfc2hpZnQocjEsIGhpMiwgbWlkLCBkeSwgaCkge1xuICAgICAgbGV0IGxvZ19oaTEgPSB0aGlzLmxvZyhyMVswXSlcbiAgICAgIGxldCBsb2dfbG8xID0gdGhpcy5sb2cocjFbMV0pXG4gICAgICBsZXQgbG9nX2hpMiA9IHRoaXMubG9nKGhpMilcbiAgICAgIGxldCBsb2dfJCA9IHRoaXMubG9nKG1pZClcbiAgICAgICBsZXQgVyA9IGggKiAobG9nX2hpMiAtIGxvZ18kKSAvXG4gICAgICAgICAgICAgIChoICogKGxvZ19oaTEgLSBsb2dfJCkgLyAobG9nX2hpMSAtIGxvZ19sbzEpICsgZHkpXG4gICAgICAgcmV0dXJuIHRoaXMuZXhwKGxvZ19oaTIgLSBXKVxuICAgfSovXG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvbGF5b3V0X2ZuLmpzXG4vLyBMYXlvdXQgZnVuY3Rpb25hbCBpbnRlcmZhY2VcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGZ1bmN0aW9uIGxheW91dF9mbihzZWxmLCByYW5nZSkge1xuICB2YXIgaWIgPSBzZWxmLnRpX21hcC5pYjtcbiAgdmFyIGR0ID0gcmFuZ2VbMV0gLSByYW5nZVswXTtcbiAgdmFyIHIgPSBzZWxmLnNwYWNleCAvIGR0O1xuICB2YXIgbHMgPSBzZWxmLmdyaWQubG9nU2NhbGUgfHwgZmFsc2U7XG4gIE9iamVjdC5hc3NpZ24oc2VsZiwge1xuICAgIC8vIFRpbWUgdG8gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgdDJzY3JlZW46IGZ1bmN0aW9uIHQyc2NyZWVuKHQpIHtcbiAgICAgIGlmIChpYikgdCA9IHNlbGYudGlfbWFwLnNtdGgyaSh0KTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKCh0IC0gcmFuZ2VbMF0pICogcikgLSAwLjU7XG4gICAgfSxcbiAgICAvLyAkIHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICQyc2NyZWVuOiBmdW5jdGlvbiAkMnNjcmVlbih5KSB7XG4gICAgICBpZiAobHMpIHkgPSBtYXRoLmxvZyh5KTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHkgKiBzZWxmLkEgKyBzZWxmLkIpIC0gMC41O1xuICAgIH0sXG4gICAgLy8gVGltZS1heGlzIG5lYXJlc3Qgc3RlcFxuICAgIHRfbWFnbmV0OiBmdW5jdGlvbiB0X21hZ25ldCh0KSB7XG4gICAgICBpZiAoaWIpIHQgPSBzZWxmLnRpX21hcC5zbXRoMmkodCk7XG4gICAgICB2YXIgY24gPSBzZWxmLmNhbmRsZXMgfHwgc2VsZi5tYXN0ZXJfZ3JpZC5jYW5kbGVzO1xuICAgICAgdmFyIGFyciA9IGNuLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5yYXdbMF07XG4gICAgICB9KTtcbiAgICAgIHZhciBpID0gdXRpbHMubmVhcmVzdF9hKHQsIGFycilbMF07XG4gICAgICBpZiAoIWNuW2ldKSByZXR1cm47XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihjbltpXS54KSAtIDAuNTtcbiAgICB9LFxuICAgIC8vIFNjcmVlbi1ZIHRvIGRvbGxhciB2YWx1ZSAob3Igd2hhdGV2ZXIpXG4gICAgc2NyZWVuMiQ6IGZ1bmN0aW9uIHNjcmVlbjIkKHkpIHtcbiAgICAgIGlmIChscykgcmV0dXJuIG1hdGguZXhwKCh5IC0gc2VsZi5CKSAvIHNlbGYuQSk7XG4gICAgICByZXR1cm4gKHkgLSBzZWxmLkIpIC8gc2VsZi5BO1xuICAgIH0sXG4gICAgLy8gU2NyZWVuLVggdG8gdGltZXN0YW1wXG4gICAgc2NyZWVuMnQ6IGZ1bmN0aW9uIHNjcmVlbjJ0KHgpIHtcbiAgICAgIC8vIFRPRE86IG1vc3QgbGlrZWx5IE1hdGguZmxvb3Igbm90IG5lZWRlZFxuICAgICAgLy8gcmV0dXJuIE1hdGguZmxvb3IocmFuZ2VbMF0gKyB4IC8gcilcbiAgICAgIHJldHVybiByYW5nZVswXSArIHggLyByO1xuICAgIH0sXG4gICAgLy8gJC1heGlzIG5lYXJlc3Qgc3RlcFxuICAgICRfbWFnbmV0OiBmdW5jdGlvbiAkX21hZ25ldChwcmljZSkge30sXG4gICAgLy8gTmVhcmVzdCBjYW5kbGVzdGlja1xuICAgIGNfbWFnbmV0OiBmdW5jdGlvbiBjX21hZ25ldCh0KSB7XG4gICAgICB2YXIgY24gPSBzZWxmLmNhbmRsZXMgfHwgc2VsZi5tYXN0ZXJfZ3JpZC5jYW5kbGVzO1xuICAgICAgdmFyIGFyciA9IGNuLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5yYXdbMF07XG4gICAgICB9KTtcbiAgICAgIHZhciBpID0gdXRpbHMubmVhcmVzdF9hKHQsIGFycilbMF07XG4gICAgICByZXR1cm4gY25baV07XG4gICAgfSxcbiAgICAvLyBOZWFyZXN0IGRhdGEgcG9pbnRzXG4gICAgZGF0YV9tYWduZXQ6IGZ1bmN0aW9uIGRhdGFfbWFnbmV0KHQpIHtcbiAgICAgIC8qIFRPRE86IGltcGxlbWVudCAqL1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZWxmO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvbG9nX3NjYWxlLmpzXG4vLyBMb2ctc2NhbGUgbW9kZSBoZWxwZXJzXG4vLyBUT0RPOiBhbGwtbmVnYXRpdmUgbnVtYmVycyAoc29tZXRpbWVzIHdyb25nIHNjYWxpbmcpXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbG9nX3NjYWxlID0gKHtcbiAgY2FuZGxlOiBmdW5jdGlvbiBjYW5kbGUoc2VsZiwgbWlkLCBwLCAkcCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBtaWQsXG4gICAgICB3OiBzZWxmLnB4X3N0ZXAgKiAkcC5jb25maWcuQ0FORExFVyxcbiAgICAgIG86IE1hdGguZmxvb3IobWF0aC5sb2cocFsxXSkgKiBzZWxmLkEgKyBzZWxmLkIpLFxuICAgICAgaDogTWF0aC5mbG9vcihtYXRoLmxvZyhwWzJdKSAqIHNlbGYuQSArIHNlbGYuQiksXG4gICAgICBsOiBNYXRoLmZsb29yKG1hdGgubG9nKHBbM10pICogc2VsZi5BICsgc2VsZi5CKSxcbiAgICAgIGM6IE1hdGguZmxvb3IobWF0aC5sb2cocFs0XSkgKiBzZWxmLkEgKyBzZWxmLkIpLFxuICAgICAgcmF3OiBwXG4gICAgfTtcbiAgfSxcbiAgZXhwYW5kOiBmdW5jdGlvbiBleHBhbmQoc2VsZiwgaGVpZ2h0KSB7XG4gICAgLy8gZXhwYW5kIGxvZyBzY2FsZVxuICAgIHZhciBBID0gLWhlaWdodCAvIChtYXRoLmxvZyhzZWxmLiRfaGkpIC0gbWF0aC5sb2coc2VsZi4kX2xvKSk7XG4gICAgdmFyIEIgPSAtbWF0aC5sb2coc2VsZi4kX2hpKSAqIEE7XG4gICAgdmFyIHRvcCA9IC1oZWlnaHQgKiAwLjE7XG4gICAgdmFyIGJvdCA9IGhlaWdodCAqIDEuMTtcbiAgICBzZWxmLiRfaGkgPSBtYXRoLmV4cCgodG9wIC0gQikgLyBBKTtcbiAgICBzZWxmLiRfbG8gPSBtYXRoLmV4cCgoYm90IC0gQikgLyBBKTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9ncmlkX21ha2VyLmpzXG5cblxuXG5cblxuXG52YXIgZ3JpZF9tYWtlcl9USU1FU0NBTEVTID0gY29uc3RhbnRzLlRJTUVTQ0FMRVMsXG4gICAgZ3JpZF9tYWtlcl8kU0NBTEVTID0gY29uc3RhbnRzLiRTQ0FMRVMsXG4gICAgZ3JpZF9tYWtlcl9XRUVLID0gY29uc3RhbnRzLldFRUssXG4gICAgZ3JpZF9tYWtlcl9NT05USCA9IGNvbnN0YW50cy5NT05USCxcbiAgICBncmlkX21ha2VyX1lFQVIgPSBjb25zdGFudHMuWUVBUixcbiAgICBncmlkX21ha2VyX0hPVVIgPSBjb25zdGFudHMuSE9VUixcbiAgICBncmlkX21ha2VyX0RBWSA9IGNvbnN0YW50cy5EQVk7XG52YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOyAvLyBtYXN0ZXJfZ3JpZCAtIHJlZiB0byB0aGUgbWFzdGVyIGdyaWRcblxuZnVuY3Rpb24gR3JpZE1ha2VyKGlkLCBwYXJhbXMsIG1hc3Rlcl9ncmlkKSB7XG4gIGlmIChtYXN0ZXJfZ3JpZCA9PT0gdm9pZCAwKSB7XG4gICAgbWFzdGVyX2dyaWQgPSBudWxsO1xuICB9XG5cbiAgdmFyIHN1YiA9IHBhcmFtcy5zdWIsXG4gICAgICBpbnRlcnZhbCA9IHBhcmFtcy5pbnRlcnZhbCxcbiAgICAgIHJhbmdlID0gcGFyYW1zLnJhbmdlLFxuICAgICAgY3R4ID0gcGFyYW1zLmN0eCxcbiAgICAgICRwID0gcGFyYW1zLiRwLFxuICAgICAgbGF5ZXJzX21ldGEgPSBwYXJhbXMubGF5ZXJzX21ldGEsXG4gICAgICBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0LFxuICAgICAgeV90ID0gcGFyYW1zLnlfdCxcbiAgICAgIHRpX21hcCA9IHBhcmFtcy50aV9tYXAsXG4gICAgICBncmlkID0gcGFyYW1zLmdyaWQsXG4gICAgICB0aW1lem9uZSA9IHBhcmFtcy50aW1lem9uZTtcbiAgdmFyIHNlbGYgPSB7XG4gICAgdGlfbWFwOiB0aV9tYXBcbiAgfTtcbiAgdmFyIGxtID0gbGF5ZXJzX21ldGFbaWRdO1xuICB2YXIgeV9yYW5nZV9mbiA9IG51bGw7XG4gIHZhciBscyA9IGdyaWQubG9nU2NhbGU7XG5cbiAgaWYgKGxtICYmIE9iamVjdC5rZXlzKGxtKS5sZW5ndGgpIHtcbiAgICAvLyBHZXRzIGxhc3QgeV9yYW5nZSBmbigpXG4gICAgdmFyIHlycyA9IE9iamVjdC52YWx1ZXMobG0pLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgueV9yYW5nZTtcbiAgICB9KTsgLy8gVGhlIGZpcnN0IHlfcmFuZ2UoKSBkZXRlcm1pbmVzIHRoZSByYW5nZVxuXG4gICAgaWYgKHlycy5sZW5ndGgpIHlfcmFuZ2VfZm4gPSB5cnNbMF0ueV9yYW5nZTtcbiAgfSAvLyBDYWxjIHZlcnRpY2FsICgkL+KCvykgcmFuZ2VcblxuXG4gIGZ1bmN0aW9uIGNhbGNfJHJhbmdlKCkge1xuICAgIGlmICghbWFzdGVyX2dyaWQpIHtcbiAgICAgIC8vICQgY2FuZGxlc3RpY2sgcmFuZ2VcbiAgICAgIGlmICh5X3JhbmdlX2ZuKSB7XG4gICAgICAgIHZhciBfeV9yYW5nZV9mbiA9IHlfcmFuZ2VfZm4oaGksIGxvKSxcbiAgICAgICAgICAgIF95X3JhbmdlX2ZuMiA9IF9zbGljZWRUb0FycmF5KF95X3JhbmdlX2ZuLCAyKSxcbiAgICAgICAgICAgIGhpID0gX3lfcmFuZ2VfZm4yWzBdLFxuICAgICAgICAgICAgbG8gPSBfeV9yYW5nZV9mbjJbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaSA9IC1JbmZpbml0eSwgbG8gPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHN1Yi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICB2YXIgeCA9IHN1YltpXTtcbiAgICAgICAgICBpZiAoeFsyXSA+IGhpKSBoaSA9IHhbMl07XG4gICAgICAgICAgaWYgKHhbM10gPCBsbykgbG8gPSB4WzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9mZmNoYXJ0IGluZGljYXRvciByYW5nZVxuICAgICAgaGkgPSAtSW5maW5pdHksIGxvID0gSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgc3ViW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHYgPSBzdWJbaV1bal07XG4gICAgICAgICAgaWYgKHYgPiBoaSkgaGkgPSB2O1xuICAgICAgICAgIGlmICh2IDwgbG8pIGxvID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeV9yYW5nZV9mbikge1xuICAgICAgICB2YXIgX3lfcmFuZ2VfZm4zID0geV9yYW5nZV9mbihoaSwgbG8pLFxuICAgICAgICAgICAgX3lfcmFuZ2VfZm40ID0gX3NsaWNlZFRvQXJyYXkoX3lfcmFuZ2VfZm4zLCAzKSxcbiAgICAgICAgICAgIGhpID0gX3lfcmFuZ2VfZm40WzBdLFxuICAgICAgICAgICAgbG8gPSBfeV9yYW5nZV9mbjRbMV0sXG4gICAgICAgICAgICBleHAgPSBfeV9yYW5nZV9mbjRbMl07XG4gICAgICB9XG4gICAgfSAvLyBGaXhlZCB5LXJhbmdlIGluIG5vbi1hdXRvIG1vZGVcblxuXG4gICAgaWYgKHlfdCAmJiAheV90LmF1dG8gJiYgeV90LnJhbmdlKSB7XG4gICAgICBzZWxmLiRfaGkgPSB5X3QucmFuZ2VbMF07XG4gICAgICBzZWxmLiRfbG8gPSB5X3QucmFuZ2VbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbHMpIHtcbiAgICAgICAgZXhwID0gZXhwID09PSBmYWxzZSA/IDAgOiAxO1xuICAgICAgICBzZWxmLiRfaGkgPSBoaSArIChoaSAtIGxvKSAqICRwLmNvbmZpZy5FWFBBTkQgKiBleHA7XG4gICAgICAgIHNlbGYuJF9sbyA9IGxvIC0gKGhpIC0gbG8pICogJHAuY29uZmlnLkVYUEFORCAqIGV4cDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuJF9oaSA9IGhpO1xuICAgICAgICBzZWxmLiRfbG8gPSBsbztcbiAgICAgICAgbG9nX3NjYWxlLmV4cGFuZChzZWxmLCBoZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi4kX2hpID09PSBzZWxmLiRfbG8pIHtcbiAgICAgICAgaWYgKCFscykge1xuICAgICAgICAgIHNlbGYuJF9oaSAqPSAxLjA1OyAvLyBFeHBhbmQgaWYgaGVpZ2h0IHJhbmdlID09PSAwXG5cbiAgICAgICAgICBzZWxmLiRfbG8gKj0gMC45NTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dfc2NhbGUuZXhwYW5kKHNlbGYsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjX3NpZGViYXIoKSB7XG4gICAgaWYgKHN1Yi5sZW5ndGggPCAyKSB7XG4gICAgICBzZWxmLnByZWMgPSAwO1xuICAgICAgc2VsZi5zYiA9ICRwLmNvbmZpZy5TQk1JTjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRPRE86IGltcHJvdmUgc2lkZWJhciB3aWR0aCBjYWxjdWxhdGlvblxuICAgIC8vIGF0IHRyYW5zaXRpb24gcG9pbnQsIHdoZW4gb25lIHByZWNpc2lvbiBpc1xuICAgIC8vIHJlcGxhY2VkIHdpdGggYW5vdGhlclxuICAgIC8vIEdldHMgZm9ybWF0ZWQgbGV2ZWxzICh0aGVpciBsZW5ndGhzKSxcbiAgICAvLyBjYWxjdWxhdGVzIG1heCBhbmQgbWVhc3VyZXMgdGhlIHNpZGViYXIgbGVuZ3RoXG4gICAgLy8gZnJvbSBpdDpcbiAgICAvLyBUT0RPOiBhZGQgY3VzdG9tIGZvcm1hdHRlciBmKClcblxuXG4gICAgc2VsZi5wcmVjID0gY2FsY19wcmVjaXNpb24oc3ViKTtcbiAgICB2YXIgbGVucyA9IFtdO1xuICAgIGxlbnMucHVzaChzZWxmLiRfaGkudG9GaXhlZChzZWxmLnByZWMpLmxlbmd0aCk7XG4gICAgbGVucy5wdXNoKHNlbGYuJF9sby50b0ZpeGVkKHNlbGYucHJlYykubGVuZ3RoKTtcbiAgICB2YXIgc3RyID0gJzAnLnJlcGVhdChNYXRoLm1heC5hcHBseShNYXRoLCBsZW5zKSkgKyAnICAgICc7XG4gICAgc2VsZi5zYiA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xuICAgIHNlbGYuc2IgPSBNYXRoLm1heChNYXRoLmZsb29yKHNlbGYuc2IpLCAkcC5jb25maWcuU0JNSU4pO1xuICAgIHNlbGYuc2IgPSBNYXRoLm1pbihzZWxmLnNiLCAkcC5jb25maWcuU0JNQVgpO1xuICB9IC8vIENhbGN1bGF0ZSAkIHByZWNpc2lvbiBmb3IgdGhlIFktYXhpc1xuXG5cbiAgZnVuY3Rpb24gY2FsY19wcmVjaXNpb24oZGF0YSkge1xuICAgIHZhciBtYXhfciA9IDAsXG4gICAgICAgIG1heF9sID0gMDtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTsgLy8gU3BlZWQgVVBcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciB4ID0gZGF0YVtpXTtcbiAgICAgIGlmICh4WzFdID4gbWF4KSBtYXggPSB4WzFdO2Vsc2UgaWYgKHhbMV0gPCBtaW4pIG1pbiA9IHhbMV07XG4gICAgfSAvLyBHZXQgbWF4IGxlbmd0aHMgb2YgaW50ZWdlciBhbmQgZnJhY3Rpb25hbCBwYXJ0c1xuXG5cbiAgICBbbWluLCBtYXhdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIEZpeCB1bmRlZmluZWQgYnVnXG4gICAgICB2YXIgc3RyID0geCAhPSBudWxsID8geC50b1N0cmluZygpIDogJyc7XG5cbiAgICAgIGlmICh4IDwgMC4wMDAwMDEpIHtcbiAgICAgICAgLy8gUGFyc2luZyB0aGUgZXhwb25lbnRpYWwgZm9ybS4gR29zaCB0aGlzXG4gICAgICAgIC8vIHNtZWxscyB0cmlja2lseVxuICAgICAgICB2YXIgX3N0ciRzcGxpdCA9IHN0ci5zcGxpdCgnZS0nKSxcbiAgICAgICAgICAgIF9zdHIkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3N0ciRzcGxpdCwgMiksXG4gICAgICAgICAgICBscyA9IF9zdHIkc3BsaXQyWzBdLFxuICAgICAgICAgICAgcnMgPSBfc3RyJHNwbGl0MlsxXTtcblxuICAgICAgICB2YXIgX2xzJHNwbGl0ID0gbHMuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIF9scyRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfbHMkc3BsaXQsIDIpLFxuICAgICAgICAgICAgbCA9IF9scyRzcGxpdDJbMF0sXG4gICAgICAgICAgICByID0gX2xzJHNwbGl0MlsxXTtcblxuICAgICAgICBpZiAoIXIpIHIgPSAnJztcbiAgICAgICAgciA9IHtcbiAgICAgICAgICBsZW5ndGg6IHIubGVuZ3RoICsgcGFyc2VJbnQocnMpIHx8IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfc3RyJHNwbGl0MyA9IHN0ci5zcGxpdCgnLicpLFxuICAgICAgICAgICAgX3N0ciRzcGxpdDQgPSBfc2xpY2VkVG9BcnJheShfc3RyJHNwbGl0MywgMiksXG4gICAgICAgICAgICBsID0gX3N0ciRzcGxpdDRbMF0sXG4gICAgICAgICAgICByID0gX3N0ciRzcGxpdDRbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChyICYmIHIubGVuZ3RoID4gbWF4X3IpIHtcbiAgICAgICAgbWF4X3IgPSByLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGwgJiYgbC5sZW5ndGggPiBtYXhfbCkge1xuICAgICAgICBtYXhfbCA9IGwubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pOyAvLyBTZWxlY3QgcHJlY2lzaW9uIHNjaGVtZSBkZXBlbmRpbmdcbiAgICAvLyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydCBsZW5ndGhzXG4gICAgLy9cblxuICAgIHZhciBldmVuID0gbWF4X3IgLSBtYXhfciAlIDIgKyAyO1xuXG4gICAgaWYgKG1heF9sID09PSAxKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oOCwgTWF0aC5tYXgoMiwgZXZlbikpO1xuICAgIH1cblxuICAgIGlmIChtYXhfbCA8PSAyKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oNCwgTWF0aC5tYXgoMiwgZXZlbikpO1xuICAgIH1cblxuICAgIHJldHVybiAyO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY19wb3NpdGlvbnMoKSB7XG4gICAgaWYgKHN1Yi5sZW5ndGggPCAyKSByZXR1cm47XG4gICAgdmFyIGR0ID0gcmFuZ2VbMV0gLSByYW5nZVswXTsgLy8gQSBwaXhlbCBzcGFjZSBhdmFpbGFibGUgdG8gZHJhdyBvbiAoeC1heGlzKVxuXG4gICAgc2VsZi5zcGFjZXggPSAkcC53aWR0aCAtIHNlbGYuc2I7IC8vIENhbmRsZSBjYXBhY2l0eVxuXG4gICAgdmFyIGNhcGFjaXR5ID0gZHQgLyBpbnRlcnZhbDtcbiAgICBzZWxmLnB4X3N0ZXAgPSBzZWxmLnNwYWNleCAvIGNhcGFjaXR5OyAvLyBweCAvIHRpbWUgcmF0aW9cblxuICAgIHZhciByID0gc2VsZi5zcGFjZXggLyBkdDtcbiAgICBzZWxmLnN0YXJ0eCA9IChzdWJbMF1bMF0gLSByYW5nZVswXSkgKiByOyAvLyBDYW5kbGUgWS10cmFuc2Zvcm06IChBID0gc2NhbGUsIEIgPSBzaGlmdClcblxuICAgIGlmICghZ3JpZC5sb2dTY2FsZSkge1xuICAgICAgc2VsZi5BID0gLWhlaWdodCAvIChzZWxmLiRfaGkgLSBzZWxmLiRfbG8pO1xuICAgICAgc2VsZi5CID0gLXNlbGYuJF9oaSAqIHNlbGYuQTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5BID0gLWhlaWdodCAvIChtYXRoLmxvZyhzZWxmLiRfaGkpIC0gbWF0aC5sb2coc2VsZi4kX2xvKSk7XG4gICAgICBzZWxmLkIgPSAtbWF0aC5sb2coc2VsZi4kX2hpKSAqIHNlbGYuQTtcbiAgICB9XG4gIH0gLy8gU2VsZWN0IG5lYXJlc3QgZ29vZC1sb2tpbmcgdCBzdGVwIChtIGlzIHRhcmdldCBzY2FsZSlcblxuXG4gIGZ1bmN0aW9uIHRpbWVfc3RlcCgpIHtcbiAgICB2YXIgayA9IHRpX21hcC5pYiA/IDYwMDAwIDogMTtcbiAgICB2YXIgeHJhbmdlID0gKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICogaztcbiAgICB2YXIgbSA9IHhyYW5nZSAqICgkcC5jb25maWcuR1JJRFggLyAkcC53aWR0aCk7XG4gICAgdmFyIHMgPSBncmlkX21ha2VyX1RJTUVTQ0FMRVM7XG4gICAgcmV0dXJuIHV0aWxzLm5lYXJlc3RfYShtLCBzKVsxXSAvIGs7XG4gIH0gLy8gU2VsZWN0IG5lYXJlc3QgZ29vZC1sb2tpbmcgJCBzdGVwIChtIGlzIHRhcmdldCBzY2FsZSlcblxuXG4gIGZ1bmN0aW9uIGRvbGxhcl9zdGVwKCkge1xuICAgIHZhciB5cmFuZ2UgPSBzZWxmLiRfaGkgLSBzZWxmLiRfbG87XG4gICAgdmFyIG0gPSB5cmFuZ2UgKiAoJHAuY29uZmlnLkdSSURZIC8gaGVpZ2h0KTtcbiAgICB2YXIgcCA9IHBhcnNlSW50KHlyYW5nZS50b0V4cG9uZW50aWFsKCkuc3BsaXQoJ2UnKVsxXSk7XG4gICAgdmFyIGQgPSBNYXRoLnBvdygxMCwgcCk7XG4gICAgdmFyIHMgPSBncmlkX21ha2VyXyRTQ0FMRVMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geCAqIGQ7XG4gICAgfSk7IC8vIFRPRE86IGNlbnRlciB0aGUgcmFuZ2UgKGxvb2sgYXQgUlNJIGZvciBleGFtcGxlLFxuICAgIC8vIGl0IGxvb2tzIHVnbHkgd2hlbiBcIjgwXCIgaXMgbmVhciB0aGUgdG9wKVxuXG4gICAgcmV0dXJuIHV0aWxzLnN0cmlwKHV0aWxzLm5lYXJlc3RfYShtLCBzKVsxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb2xsYXJfbXVsdCgpIHtcbiAgICB2YXIgbXVsdF9oaSA9IGRvbGxhcl9tdWx0X2hpKCk7XG4gICAgdmFyIG11bHRfbG8gPSBkb2xsYXJfbXVsdF9sbygpO1xuICAgIHJldHVybiBNYXRoLm1heChtdWx0X2hpLCBtdWx0X2xvKTtcbiAgfSAvLyBQcmljZSBzdGVwIG11bHRpcGxpZXIgKGZvciB0aGUgbG9nLXNjYWxlIG1vZGUpXG5cblxuICBmdW5jdGlvbiBkb2xsYXJfbXVsdF9oaSgpIHtcbiAgICB2YXIgaCA9IE1hdGgubWluKHNlbGYuQiwgaGVpZ2h0KTtcbiAgICBpZiAoaCA8ICRwLmNvbmZpZy5HUklEWSkgcmV0dXJuIDE7XG4gICAgdmFyIG4gPSBoIC8gJHAuY29uZmlnLkdSSURZOyAvLyB0YXJnZXQgZ3JpZCBOXG5cbiAgICB2YXIgeXJhbmdlID0gc2VsZi4kX2hpO1xuXG4gICAgaWYgKHNlbGYuJF9sbyA+IDApIHtcbiAgICAgIHZhciB5cmF0aW8gPSBzZWxmLiRfaGkgLyBzZWxmLiRfbG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHlyYXRpbyA9IHNlbGYuJF9oaSAvIDE7IC8vIFRPRE86IHNtYWxsIHZhbHVlc1xuICAgIH1cblxuICAgIHZhciBtID0geXJhbmdlICogKCRwLmNvbmZpZy5HUklEWSAvIGgpO1xuICAgIHZhciBwID0gcGFyc2VJbnQoeXJhbmdlLnRvRXhwb25lbnRpYWwoKS5zcGxpdCgnZScpWzFdKTtcbiAgICByZXR1cm4gTWF0aC5wb3coeXJhdGlvLCAxIC8gbik7XG4gIH1cblxuICBmdW5jdGlvbiBkb2xsYXJfbXVsdF9sbygpIHtcbiAgICB2YXIgaCA9IE1hdGgubWluKGhlaWdodCAtIHNlbGYuQiwgaGVpZ2h0KTtcbiAgICBpZiAoaCA8ICRwLmNvbmZpZy5HUklEWSkgcmV0dXJuIDE7XG4gICAgdmFyIG4gPSBoIC8gJHAuY29uZmlnLkdSSURZOyAvLyB0YXJnZXQgZ3JpZCBOXG5cbiAgICB2YXIgeXJhbmdlID0gTWF0aC5hYnMoc2VsZi4kX2xvKTtcblxuICAgIGlmIChzZWxmLiRfaGkgPCAwICYmIHNlbGYuJF9sbyA8IDApIHtcbiAgICAgIHZhciB5cmF0aW8gPSBNYXRoLmFicyhzZWxmLiRfbG8gLyBzZWxmLiRfaGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5cmF0aW8gPSBNYXRoLmFicyhzZWxmLiRfbG8pIC8gMTtcbiAgICB9XG5cbiAgICB2YXIgbSA9IHlyYW5nZSAqICgkcC5jb25maWcuR1JJRFkgLyBoKTtcbiAgICB2YXIgcCA9IHBhcnNlSW50KHlyYW5nZS50b0V4cG9uZW50aWFsKCkuc3BsaXQoJ2UnKVsxXSk7XG4gICAgcmV0dXJuIE1hdGgucG93KHlyYXRpbywgMSAvIG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ3JpZF94KCkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBzdWJncmlkLCBubyBuZWVkIHRvIGNhbGMgYSB0aW1lbGluZSxcbiAgICAvLyB3ZSBqdXN0IGJvcnJvdyBpdCBmcm9tIHRoZSBtYXN0ZXJfZ3JpZFxuICAgIGlmICghbWFzdGVyX2dyaWQpIHtcbiAgICAgIHNlbGYudF9zdGVwID0gdGltZV9zdGVwKCk7XG4gICAgICBzZWxmLnhzID0gW107XG4gICAgICB2YXIgZHQgPSByYW5nZVsxXSAtIHJhbmdlWzBdO1xuICAgICAgdmFyIHIgPSBzZWxmLnNwYWNleCAvIGR0O1xuICAgICAgLyogVE9ETzogcmVtb3ZlIHRoZSBsZWZ0LXNpZGUgZ2xpdGNoXG4gICAgICAgbGV0IHllYXJfMCA9IFV0aWxzLmdldF95ZWFyKHN1YlswXVswXSlcbiAgICAgIGZvciAodmFyIHQwID0geWVhcl8wOyB0MCA8IHJhbmdlWzBdOyB0MCArPSBzZWxmLnRfc3RlcCkge31cbiAgICAgICBsZXQgbTAgPSBVdGlscy5nZXRfbW9udGgodDApKi9cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBzdWJbaV07XG4gICAgICAgIHZhciBwcmV2ID0gc3ViW2kgLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHByZXZfeHMgPSBzZWxmLnhzW3NlbGYueHMubGVuZ3RoIC0gMV0gfHwgWzAsIFtdXTtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKChwWzBdIC0gcmFuZ2VbMF0pICogcik7XG4gICAgICAgIGluc2VydF9saW5lKHByZXYsIHAsIHgpOyAvLyBGaWx0ZXJpbmcgbGluZXMgdGhhdCBhcmUgdG9vIG5lYXJcblxuICAgICAgICB2YXIgeHMgPSBzZWxmLnhzW3NlbGYueHMubGVuZ3RoIC0gMV0gfHwgWzAsIFtdXTtcbiAgICAgICAgaWYgKHByZXZfeHMgPT09IHhzKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoeHNbMV1bMF0gLSBwcmV2X3hzWzFdWzBdIDwgc2VsZi50X3N0ZXAgKiAwLjgpIHtcbiAgICAgICAgICAvLyBwcmV2X3hzIGlzIGEgaGlnaGVyIFwicmFua1wiIGxhYmVsXG4gICAgICAgICAgaWYgKHhzWzJdIDw9IHByZXZfeHNbMl0pIHtcbiAgICAgICAgICAgIHNlbGYueHMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgICAgICAgc2VsZi54cy5zcGxpY2Uoc2VsZi54cy5sZW5ndGggLSAyLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVE9ETzogZml4IGdyaWQgZXh0ZW5zaW9uIGZvciBiaWdnZXIgdGltZWZyYW1lc1xuXG5cbiAgICAgIGlmIChpbnRlcnZhbCA8IGdyaWRfbWFrZXJfV0VFSyAmJiByID4gMCkge1xuICAgICAgICBleHRlbmRfbGVmdChkdCwgcik7XG4gICAgICAgIGV4dGVuZF9yaWdodChkdCwgcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYudF9zdGVwID0gbWFzdGVyX2dyaWQudF9zdGVwO1xuICAgICAgc2VsZi5weF9zdGVwID0gbWFzdGVyX2dyaWQucHhfc3RlcDtcbiAgICAgIHNlbGYuc3RhcnR4ID0gbWFzdGVyX2dyaWQuc3RhcnR4O1xuICAgICAgc2VsZi54cyA9IG1hc3Rlcl9ncmlkLnhzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydF9saW5lKHByZXYsIHAsIHgsIG0wKSB7XG4gICAgdmFyIHByZXZfdCA9IHRpX21hcC5pYiA/IHRpX21hcC5pMnQocHJldlswXSkgOiBwcmV2WzBdO1xuICAgIHZhciBwX3QgPSB0aV9tYXAuaWIgPyB0aV9tYXAuaTJ0KHBbMF0pIDogcFswXTtcblxuICAgIGlmICh0aV9tYXAudGYgPCBncmlkX21ha2VyX0RBWSkge1xuICAgICAgcHJldl90ICs9IHRpbWV6b25lICogZ3JpZF9tYWtlcl9IT1VSO1xuICAgICAgcF90ICs9IHRpbWV6b25lICogZ3JpZF9tYWtlcl9IT1VSO1xuICAgIH1cblxuICAgIHZhciBkID0gdGltZXpvbmUgKiBncmlkX21ha2VyX0hPVVI7IC8vIFRPRE86IHRha2UgdGhpcyBibG9jayA9PT09PT09PT0+IChzZWUgYmVsb3cpXG5cbiAgICBpZiAoKHByZXZbMF0gfHwgaW50ZXJ2YWwgPT09IGdyaWRfbWFrZXJfWUVBUikgJiYgdXRpbHMuZ2V0X3llYXIocF90KSAhPT0gdXRpbHMuZ2V0X3llYXIocHJldl90KSkge1xuICAgICAgc2VsZi54cy5wdXNoKFt4LCBwLCBncmlkX21ha2VyX1lFQVJdKTsgLy8gW3B4LCBbLi4uXSwgcmFua11cbiAgICB9IGVsc2UgaWYgKHByZXZbMF0gJiYgdXRpbHMuZ2V0X21vbnRoKHBfdCkgIT09IHV0aWxzLmdldF9tb250aChwcmV2X3QpKSB7XG4gICAgICBzZWxmLnhzLnB1c2goW3gsIHAsIGdyaWRfbWFrZXJfTU9OVEhdKTtcbiAgICB9IC8vIFRPRE86IHNob3VsZCBiZSBhZGRlZCBpZiB0aGlzIGRheSAhPT0gcHJldiBkYXlcbiAgICAvLyBBbmQgdGhlIHNhbWUgZm9yICdib3RiYXIuanMnLCBUT0RPKCopXG4gICAgZWxzZSBpZiAodXRpbHMuZGF5X3N0YXJ0KHBfdCkgPT09IHBfdCkge1xuICAgICAgICBzZWxmLnhzLnB1c2goW3gsIHAsIGdyaWRfbWFrZXJfREFZXSk7XG4gICAgICB9IGVsc2UgaWYgKHBbMF0gJSBzZWxmLnRfc3RlcCA9PT0gMCkge1xuICAgICAgICBzZWxmLnhzLnB1c2goW3gsIHAsIGludGVydmFsXSk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRfbGVmdChkdCwgcikge1xuICAgIGlmICghc2VsZi54cy5sZW5ndGggfHwgIWlzRmluaXRlKHIpKSByZXR1cm47XG4gICAgdmFyIHQgPSBzZWxmLnhzWzBdWzFdWzBdO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHQgLT0gc2VsZi50X3N0ZXA7XG4gICAgICB2YXIgeCA9IE1hdGguZmxvb3IoKHQgLSByYW5nZVswXSkgKiByKTtcbiAgICAgIGlmICh4IDwgMCkgYnJlYWs7IC8vIFRPRE86ID09PT09PT09PT0+IEFuZCBpbnNlcnQgaXQgaGVyZSBzb21laG93XG5cbiAgICAgIGlmICh0ICUgaW50ZXJ2YWwgPT09IDApIHtcbiAgICAgICAgc2VsZi54cy51bnNoaWZ0KFt4LCBbdF0sIGludGVydmFsXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kX3JpZ2h0KGR0LCByKSB7XG4gICAgaWYgKCFzZWxmLnhzLmxlbmd0aCB8fCAhaXNGaW5pdGUocikpIHJldHVybjtcbiAgICB2YXIgdCA9IHNlbGYueHNbc2VsZi54cy5sZW5ndGggLSAxXVsxXVswXTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB0ICs9IHNlbGYudF9zdGVwO1xuICAgICAgdmFyIHggPSBNYXRoLmZsb29yKCh0IC0gcmFuZ2VbMF0pICogcik7XG4gICAgICBpZiAoeCA+IHNlbGYuc3BhY2V4KSBicmVhaztcblxuICAgICAgaWYgKHQgJSBpbnRlcnZhbCA9PT0gMCkge1xuICAgICAgICBzZWxmLnhzLnB1c2goW3gsIFt0XSwgaW50ZXJ2YWxdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBncmlkX3koKSB7XG4gICAgLy8gUHJldmVudCBkdXBsaWNhdGUgbGV2ZWxzXG4gICAgdmFyIG0gPSBNYXRoLnBvdygxMCwgLXNlbGYucHJlYyk7XG4gICAgc2VsZi4kX3N0ZXAgPSBNYXRoLm1heChtLCBkb2xsYXJfc3RlcCgpKTtcbiAgICBzZWxmLnlzID0gW107XG4gICAgdmFyIHkxID0gc2VsZi4kX2xvIC0gc2VsZi4kX2xvICUgc2VsZi4kX3N0ZXA7XG5cbiAgICBmb3IgKHZhciB5JCA9IHkxOyB5JCA8PSBzZWxmLiRfaGk7IHkkICs9IHNlbGYuJF9zdGVwKSB7XG4gICAgICB2YXIgeSA9IE1hdGguZmxvb3IoeSQgKiBzZWxmLkEgKyBzZWxmLkIpO1xuICAgICAgaWYgKHkgPiBoZWlnaHQpIGNvbnRpbnVlO1xuICAgICAgc2VsZi55cy5wdXNoKFt5LCB1dGlscy5zdHJpcCh5JCldKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBncmlkX3lfbG9nKCkge1xuICAgIC8vIFRPRE86IFByZXZlbnQgZHVwbGljYXRlIGxldmVscywgaXMgdGhpcyBldmVuXG4gICAgLy8gYSBwcm9ibGVtIGhlcmUgP1xuICAgIHNlbGYuJF9tdWx0ID0gZG9sbGFyX211bHQoKTtcbiAgICBzZWxmLnlzID0gW107XG4gICAgaWYgKCFzdWIubGVuZ3RoKSByZXR1cm47XG4gICAgdmFyIHYgPSBNYXRoLmFicyhzdWJbc3ViLmxlbmd0aCAtIDFdWzFdIHx8IDEpO1xuICAgIHZhciB5MSA9IHNlYXJjaF9zdGFydF9wb3Modik7XG4gICAgdmFyIHkyID0gc2VhcmNoX3N0YXJ0X25lZygtdik7XG4gICAgdmFyIHlwID0gLUluZmluaXR5OyAvLyBQcmV2aW91cyB5IHZhbHVlXG5cbiAgICB2YXIgbiA9IGhlaWdodCAvICRwLmNvbmZpZy5HUklEWTsgLy8gdGFyZ2V0IGdyaWQgTlxuXG4gICAgdmFyIHEgPSAxICsgKHNlbGYuJF9tdWx0IC0gMSkgLyAyOyAvLyBPdmVyIDBcblxuICAgIGZvciAodmFyIHkkID0geTE7IHkkID4gMDsgeSQgLz0gc2VsZi4kX211bHQpIHtcbiAgICAgIHkkID0gbG9nX3JvdW5kZXIoeSQsIHEpO1xuICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKG1hdGgubG9nKHkkKSAqIHNlbGYuQSArIHNlbGYuQik7XG4gICAgICBzZWxmLnlzLnB1c2goW3ksIHV0aWxzLnN0cmlwKHkkKV0pO1xuICAgICAgaWYgKHkgPiBoZWlnaHQpIGJyZWFrO1xuICAgICAgaWYgKHkgLSB5cCA8ICRwLmNvbmZpZy5HUklEWSAqIDAuNykgYnJlYWs7XG4gICAgICBpZiAoc2VsZi55cy5sZW5ndGggPiBuICsgMSkgYnJlYWs7XG4gICAgICB5cCA9IHk7XG4gICAgfSAvLyBVbmRlciAwXG5cblxuICAgIHlwID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciB5JCA9IHkyOyB5JCA8IDA7IHkkIC89IHNlbGYuJF9tdWx0KSB7XG4gICAgICB5JCA9IGxvZ19yb3VuZGVyKHkkLCBxKTtcblxuICAgICAgdmFyIF95ID0gTWF0aC5mbG9vcihtYXRoLmxvZyh5JCkgKiBzZWxmLkEgKyBzZWxmLkIpO1xuXG4gICAgICBpZiAoeXAgLSBfeSA8ICRwLmNvbmZpZy5HUklEWSAqIDAuNykgYnJlYWs7XG4gICAgICBzZWxmLnlzLnB1c2goW195LCB1dGlscy5zdHJpcCh5JCldKTtcbiAgICAgIGlmIChfeSA8IDApIGJyZWFrO1xuICAgICAgaWYgKHNlbGYueXMubGVuZ3RoID4gbiAqIDMgKyAxKSBicmVhaztcbiAgICAgIHlwID0gX3k7XG4gICAgfSAvLyBUT0RPOiByZW1vdmUgbGluZXMgbmVhciB0byAwXG5cbiAgfSAvLyBTZWFyY2ggYSBzdGFydCBmb3IgdGhlIHRvcCBncmlkIHNvIHRoYXRcbiAgLy8gdGhlIGZpeGVkIHZhbHVlIGFsd2F5cyBpbmNsdWRlZFxuXG5cbiAgZnVuY3Rpb24gc2VhcmNoX3N0YXJ0X3Bvcyh2YWx1ZSkge1xuICAgIHZhciBOID0gaGVpZ2h0IC8gJHAuY29uZmlnLkdSSURZOyAvLyB0YXJnZXQgZ3JpZCBOXG5cbiAgICB2YXIgeSA9IEluZmluaXR5LFxuICAgICAgICB5JCA9IHZhbHVlLFxuICAgICAgICBjb3VudCA9IDA7XG5cbiAgICB3aGlsZSAoeSA+IDApIHtcbiAgICAgIHkgPSBNYXRoLmZsb29yKG1hdGgubG9nKHkkKSAqIHNlbGYuQSArIHNlbGYuQik7XG4gICAgICB5JCAqPSBzZWxmLiRfbXVsdDtcbiAgICAgIGlmIChjb3VudCsrID4gTiAqIDMpIHJldHVybiAwOyAvLyBQcmV2ZW50cyBkZWFkbG9vcHNcbiAgICB9XG5cbiAgICByZXR1cm4geSQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hfc3RhcnRfbmVnKHZhbHVlKSB7XG4gICAgdmFyIE4gPSBoZWlnaHQgLyAkcC5jb25maWcuR1JJRFk7IC8vIHRhcmdldCBncmlkIE5cblxuICAgIHZhciB5ID0gLUluZmluaXR5LFxuICAgICAgICB5JCA9IHZhbHVlLFxuICAgICAgICBjb3VudCA9IDA7XG5cbiAgICB3aGlsZSAoeSA8IGhlaWdodCkge1xuICAgICAgeSA9IE1hdGguZmxvb3IobWF0aC5sb2coeSQpICogc2VsZi5BICsgc2VsZi5CKTtcbiAgICAgIHkkICo9IHNlbGYuJF9tdWx0O1xuICAgICAgaWYgKGNvdW50KysgPiBOICogMykgYnJlYWs7IC8vIFByZXZlbnRzIGRlYWRsb29wc1xuICAgIH1cblxuICAgIHJldHVybiB5JDtcbiAgfSAvLyBNYWtlIGxvZyBzY2FsZSBsZXZlbHMgbG9vayBncmVhdCBhZ2FpblxuXG5cbiAgZnVuY3Rpb24gbG9nX3JvdW5kZXIoeCwgcXVhbGl0eSkge1xuICAgIHZhciBzID0gTWF0aC5zaWduKHgpO1xuICAgIHggPSBNYXRoLmFicyh4KTtcblxuICAgIGlmICh4ID4gMTApIHtcbiAgICAgIGZvciAodmFyIGRpdiA9IDEwOyBkaXYgPCBNQVhfSU5UOyBkaXYgKj0gMTApIHtcbiAgICAgICAgdmFyIG5pY2UgPSBNYXRoLmZsb29yKHggLyBkaXYpICogZGl2O1xuXG4gICAgICAgIGlmICh4IC8gbmljZSA+IHF1YWxpdHkpIHtcbiAgICAgICAgICAvLyBNb3JlIHRoYW4gMTAlIG9mZlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpdiAvPSAxMDtcbiAgICAgIHJldHVybiBzICogTWF0aC5mbG9vcih4IC8gZGl2KSAqIGRpdjtcbiAgICB9IGVsc2UgaWYgKHggPCAxKSB7XG4gICAgICBmb3IgKHZhciBybyA9IDEwOyBybyA+PSAxOyByby0tKSB7XG4gICAgICAgIHZhciBfbmljZSA9IHV0aWxzLnJvdW5kKHgsIHJvKTtcblxuICAgICAgICBpZiAoeCAvIF9uaWNlID4gcXVhbGl0eSkge1xuICAgICAgICAgIC8vIE1vcmUgdGhhbiAxMCUgb2ZmXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMgKiB1dGlscy5yb3VuZCh4LCBybyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcyAqIE1hdGguZmxvb3IoeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlfc2l6ZXMoKSB7XG4gICAgc2VsZi53aWR0aCA9ICRwLndpZHRoIC0gc2VsZi5zYjtcbiAgICBzZWxmLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIGNhbGNfJHJhbmdlKCk7XG4gIGNhbGNfc2lkZWJhcigpO1xuICByZXR1cm4ge1xuICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gY2FsY3VsYXRlIG1heCBzaWRlYmFyIHdpZHRoXG4gICAgLy8gKGFtb25nIGFsbCBncmlkcykuIFRoZW4gd2UgY2FuIGFjdHVhbGx5IG1ha2VcbiAgICAvLyB0aGVtXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICBjYWxjX3Bvc2l0aW9ucygpO1xuICAgICAgZ3JpZF94KCk7XG5cbiAgICAgIGlmIChncmlkLmxvZ1NjYWxlKSB7XG4gICAgICAgIGdyaWRfeV9sb2coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRfeSgpO1xuICAgICAgfVxuXG4gICAgICBhcHBseV9zaXplcygpOyAvLyBMaW5rIHRvIHRoZSBtYXN0ZXIgZ3JpZCAoY2FuZGxlc3RpY2tzKVxuXG4gICAgICBpZiAobWFzdGVyX2dyaWQpIHtcbiAgICAgICAgc2VsZi5tYXN0ZXJfZ3JpZCA9IG1hc3Rlcl9ncmlkO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmdyaWQgPSBncmlkOyAvLyBHcmlkIHBhcmFtc1xuICAgICAgLy8gSGVyZSB3ZSBhZGQgc29tZSBoZWxwZnVsIGZ1bmN0aW9ucyBmb3JcbiAgICAgIC8vIHBsdWdpbiBjcmVhdG9yc1xuXG4gICAgICByZXR1cm4gbGF5b3V0X2ZuKHNlbGYsIHJhbmdlKTtcbiAgICB9LFxuICAgIGdldF9sYXlvdXQ6IGZ1bmN0aW9uIGdldF9sYXlvdXQoKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgIHNldF9zaWRlYmFyOiBmdW5jdGlvbiBzZXRfc2lkZWJhcih2KSB7XG4gICAgICByZXR1cm4gc2VsZi5zYiA9IHY7XG4gICAgfSxcbiAgICBnZXRfc2lkZWJhcjogZnVuY3Rpb24gZ2V0X3NpZGViYXIoKSB7XG4gICAgICByZXR1cm4gc2VsZi5zYjtcbiAgICB9XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgZ3JpZF9tYWtlciA9IChHcmlkTWFrZXIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvbGF5b3V0LmpzXG5cblxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IGxheW91dF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gbGF5b3V0X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gbGF5b3V0X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBsYXlvdXRfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGxheW91dF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBDYWxjdWxhdGVzIGFsbCBuZWNlc3NhcnkgcyppdCB0byBidWlsZCB0aGUgY2hhcnRcbi8vIEhlaWdodHMsIHdpZHRocywgdHJhbnNmb3JtcywgLi4uID0gZXZlcnl0aGluZ1xuLy8gV2h5IHN1Y2ggYSBtZXNzIHlvdSBhc2s/IFdlbGwsIHRoYXQncyBiZWNhdXNlXG4vLyBvbmUgY29tcG9uZW50cyBzaXplIGNhbiBkZXBlbmQgb24gb3RoZXIgY29tcG9uZW50XG4vLyBkYXRhIGZvcm1hdHRpbmcgKGUuZy4gZ3JpZCB3aWR0aCBkZXBlbmRzIG9uIHNpZGViYXIgcHJlY2lzaW9uKVxuLy8gU28gaXQncyBiZXR0ZXIgdG8gY2FsYyBhbGwgaW4gb25lIHBsYWNlLlxuXG5cblxuXG5cbmZ1bmN0aW9uIExheW91dChwYXJhbXMpIHtcbiAgdmFyIGNoYXJ0ID0gcGFyYW1zLmNoYXJ0LFxuICAgICAgc3ViID0gcGFyYW1zLnN1YixcbiAgICAgIG9mZnN1YiA9IHBhcmFtcy5vZmZzdWIsXG4gICAgICBpbnRlcnZhbCA9IHBhcmFtcy5pbnRlcnZhbCxcbiAgICAgIHJhbmdlID0gcGFyYW1zLnJhbmdlLFxuICAgICAgY3R4ID0gcGFyYW1zLmN0eCxcbiAgICAgIGxheWVyc19tZXRhID0gcGFyYW1zLmxheWVyc19tZXRhLFxuICAgICAgdGlfbWFwID0gcGFyYW1zLnRpX21hcCxcbiAgICAgICRwID0gcGFyYW1zLiRwcm9wcyxcbiAgICAgIHlfdHMgPSBwYXJhbXMueV90cmFuc2Zvcm1zO1xuICB2YXIgbWdyaWQgPSBjaGFydC5ncmlkIHx8IHt9O1xuICBvZmZzdWIgPSBvZmZzdWIuZmlsdGVyKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgLy8gU2tpcCBvZmZjaGFydCBvdmVybGF5cyB3aXRoIGN1c3RvbSBncmlkIGlkLFxuICAgIC8vIGJlY2F1c2UgdGhleSB3aWxsIGJlIG1lcmdyZWQgd2l0aCB0aGUgZXhpc3RpbmcgZ3JpZHNcbiAgICByZXR1cm4gISh4LmdyaWQgJiYgeC5ncmlkLmlkKTtcbiAgfSk7IC8vIFNwbGl0cyBzcGFjZSBiZXR3ZWVuIG1haW4gY2hhcnRcbiAgLy8gYW5kIG9mZmNoYXJ0IGluZGljYXRvciBncmlkc1xuXG4gIGZ1bmN0aW9uIGdyaWRfaHMoKSB7XG4gICAgdmFyIGhlaWdodCA9ICRwLmhlaWdodCAtICRwLmNvbmZpZy5CT1RCQVI7IC8vIFdoZW4gYXQgbGVhc3Qgb25lIGhlaWdodCBkZWZpbmVkIChkZWZhdWx0ID0gMSksXG4gICAgLy8gUHhzIGNhbGN1bGF0ZWQgYXM6IChzdW0gb2Ygd2VpZ2h0cykgLyBudW1iZXJcblxuICAgIGlmIChtZ3JpZC5oZWlnaHQgfHwgb2Zmc3ViLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmdyaWQuaGVpZ2h0O1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gd2VpZ2h0ZWRfaHMobWdyaWQsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIG4gPSBvZmZzdWIubGVuZ3RoO1xuICAgIHZhciBvZmZfaCA9IDIgKiBNYXRoLnNxcnQobikgLyA3IC8gKG4gfHwgMSk7IC8vIE9mZmNoYXJ0IGdyaWQgaGVpZ2h0XG5cbiAgICB2YXIgcHggPSBNYXRoLmZsb29yKGhlaWdodCAqIG9mZl9oKTsgLy8gTWFpbiBncmlkIGhlaWdodFxuXG4gICAgdmFyIG0gPSBoZWlnaHQgLSBweCAqIG47XG4gICAgcmV0dXJuIFttXS5jb25jYXQoQXJyYXkobikuZmlsbChweCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2VpZ2h0ZWRfaHMoZ3JpZCwgaGVpZ2h0KSB7XG4gICAgdmFyIGhzID0gW3tcbiAgICAgIGdyaWQ6IGdyaWRcbiAgICB9XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9mZnN1YikpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguZ3JpZC5oZWlnaHQgfHwgMTtcbiAgICB9KTtcbiAgICB2YXIgc3VtID0gaHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSArIGI7XG4gICAgfSwgMCk7XG4gICAgaHMgPSBocy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHggLyBzdW0gKiBoZWlnaHQpO1xuICAgIH0pOyAvLyBSZWZpbmUgdGhlIGhlaWdodCBpZiBNYXRoLmZsb29yIGRlY3JlYXNlZCBweCBzdW1cblxuICAgIHN1bSA9IGhzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgKyBiO1xuICAgIH0sIDApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQgLSBzdW07IGkrKykge1xuICAgICAgaHNbaSAlIGhzLmxlbmd0aF0rKztcbiAgICB9XG5cbiAgICByZXR1cm4gaHM7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5kbGVzX25fdm9sKCkge1xuICAgIHNlbGYuY2FuZGxlcyA9IFtdO1xuICAgIHNlbGYudm9sdW1lID0gW107XG4gICAgdmFyIG1heHYgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ViLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHhbNV07XG4gICAgfSkpKTtcbiAgICB2YXIgdnMgPSAkcC5jb25maWcuVk9MU0NBTEUgKiAkcC5oZWlnaHQgLyBtYXh2O1xuICAgIHZhciB4MSxcbiAgICAgICAgeDIsXG4gICAgICAgIG1pZCxcbiAgICAgICAgcHJldiA9IHVuZGVmaW5lZDtcbiAgICB2YXIgc3BsaXR0ZXIgPSBzZWxmLnB4X3N0ZXAgPiA1ID8gMSA6IDA7XG4gICAgdmFyIGhmX3B4X3N0ZXAgPSBzZWxmLnB4X3N0ZXAgKiAwLjU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBzdWJbaV07XG4gICAgICBtaWQgPSBzZWxmLnQyc2NyZWVuKHBbMF0pICsgMC41O1xuICAgICAgc2VsZi5jYW5kbGVzLnB1c2gobWdyaWQubG9nU2NhbGUgPyBsb2dfc2NhbGUuY2FuZGxlKHNlbGYsIG1pZCwgcCwgJHApIDoge1xuICAgICAgICB4OiBtaWQsXG4gICAgICAgIHc6IHNlbGYucHhfc3RlcCAqICRwLmNvbmZpZy5DQU5ETEVXLFxuICAgICAgICBvOiBNYXRoLmZsb29yKHBbMV0gKiBzZWxmLkEgKyBzZWxmLkIpLFxuICAgICAgICBoOiBNYXRoLmZsb29yKHBbMl0gKiBzZWxmLkEgKyBzZWxmLkIpLFxuICAgICAgICBsOiBNYXRoLmZsb29yKHBbM10gKiBzZWxmLkEgKyBzZWxmLkIpLFxuICAgICAgICBjOiBNYXRoLmZsb29yKHBbNF0gKiBzZWxmLkEgKyBzZWxmLkIpLFxuICAgICAgICByYXc6IHBcbiAgICAgIH0pOyAvLyBDbGVhciB2b2x1bWUgYmFyIGlmIHRoZXJlIGlzIGEgdGltZSBnYXBcblxuICAgICAgaWYgKHN1YltpIC0gMV0gJiYgcFswXSAtIHN1YltpIC0gMV1bMF0gPiBpbnRlcnZhbCkge1xuICAgICAgICBwcmV2ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgeDEgPSBwcmV2IHx8IE1hdGguZmxvb3IobWlkIC0gaGZfcHhfc3RlcCk7XG4gICAgICB4MiA9IE1hdGguZmxvb3IobWlkICsgaGZfcHhfc3RlcCkgLSAwLjU7XG4gICAgICBzZWxmLnZvbHVtZS5wdXNoKHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIGg6IHBbNV0gKiB2cyxcbiAgICAgICAgZ3JlZW46IHBbNF0gPj0gcFsxXSxcbiAgICAgICAgcmF3OiBwXG4gICAgICB9KTtcbiAgICAgIHByZXYgPSB4MiArIHNwbGl0dGVyO1xuICAgIH1cbiAgfSAvLyBNYWluIGdyaWRcblxuXG4gIHZhciBocyA9IGdyaWRfaHMoKTtcbiAgdmFyIHNwZWNzID0ge1xuICAgIHN1Yjogc3ViLFxuICAgIGludGVydmFsOiBpbnRlcnZhbCxcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgY3R4OiBjdHgsXG4gICAgJHA6ICRwLFxuICAgIGxheWVyc19tZXRhOiBsYXllcnNfbWV0YSxcbiAgICB0aV9tYXA6IHRpX21hcCxcbiAgICBoZWlnaHQ6IGhzWzBdLFxuICAgIHlfdDogeV90c1swXSxcbiAgICBncmlkOiBtZ3JpZCxcbiAgICB0aW1lem9uZTogJHAudGltZXpvbmVcbiAgfTtcbiAgdmFyIGdtcyA9IFtuZXcgZ3JpZF9tYWtlcigwLCBzcGVjcyldOyAvLyBTdWIgZ3JpZHNcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob2Zmc3ViLmVudHJpZXMoKSksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgaSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIF9zdGVwJHZhbHVlJCA9IF9zdGVwJHZhbHVlWzFdLFxuICAgICAgICAgIGRhdGEgPSBfc3RlcCR2YWx1ZSQuZGF0YSxcbiAgICAgICAgICBncmlkID0gX3N0ZXAkdmFsdWUkLmdyaWQ7XG5cbiAgICAgIHNwZWNzLnN1YiA9IGRhdGE7XG4gICAgICBzcGVjcy5oZWlnaHQgPSBoc1tpICsgMV07XG4gICAgICBzcGVjcy55X3QgPSB5X3RzW2kgKyAxXTtcbiAgICAgIHNwZWNzLmdyaWQgPSBncmlkIHx8IHt9O1xuICAgICAgZ21zLnB1c2gobmV3IGdyaWRfbWFrZXIoaSArIDEsIHNwZWNzLCBnbXNbMF0uZ2V0X2xheW91dCgpKSk7XG4gICAgfSAvLyBNYXggc2lkZWJhciBhbW9uZyBhbGwgZ3JpbmRzXG5cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgdmFyIHNiID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGdtcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geC5nZXRfc2lkZWJhcigpO1xuICB9KSkpO1xuICB2YXIgZ3JpZHMgPSBbXSxcbiAgICAgIG9mZnNldCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGdtcy5sZW5ndGg7IGkrKykge1xuICAgIGdtc1tpXS5zZXRfc2lkZWJhcihzYik7XG4gICAgZ3JpZHMucHVzaChnbXNbaV0uY3JlYXRlKCkpO1xuICAgIGdyaWRzW2ldLmlkID0gaTtcbiAgICBncmlkc1tpXS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ICs9IGdyaWRzW2ldLmhlaWdodDtcbiAgfVxuXG4gIHZhciBzZWxmID0gZ3JpZHNbMF07XG4gIGNhbmRsZXNfbl92b2woKTtcbiAgcmV0dXJuIHtcbiAgICBncmlkczogZ3JpZHMsXG4gICAgYm90YmFyOiB7XG4gICAgICB3aWR0aDogJHAud2lkdGgsXG4gICAgICBoZWlnaHQ6ICRwLmNvbmZpZy5CT1RCQVIsXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIHhzOiBncmlkc1swXSA/IGdyaWRzWzBdLnhzIDogW11cbiAgICB9XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbGF5b3V0ID0gKExheW91dCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanNcbmZ1bmN0aW9uIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy91cGRhdGVyLmpzXG5cblxuXG5cbmZ1bmN0aW9uIHVwZGF0ZXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IHVwZGF0ZXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIHVwZGF0ZXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiB1cGRhdGVyX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiB1cGRhdGVyX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiB1cGRhdGVyX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIEN1cnNvciB1cGRhdGVyOiBjYWxjdWxhdGVzIGN1cnJlbnQgdmFsdWVzIGZvclxuLy8gT0hMQ1YgYW5kIGFsbCBvdGhlciBpbmRpY2F0b3JzXG5cblxudmFyIEN1cnNvclVwZGF0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDdXJzb3JVcGRhdGVyKGNvbXApIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJzb3JVcGRhdGVyKTtcblxuICAgIHRoaXMuY29tcCA9IGNvbXAsIHRoaXMuZ3JpZHMgPSBjb21wLl9sYXlvdXQuZ3JpZHMsIHRoaXMuY3Vyc29yID0gY29tcC5jdXJzb3I7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhDdXJzb3JVcGRhdGVyLCBbe1xuICAgIGtleTogXCJzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmMoZSkge1xuICAgICAgLy8gVE9ETzogdmFsdWVzIG5vdCBkaXNwbGF5aW5nIGlmIGEgY3VzdG9tIGdyaWQgaWQgaXMgc2V0OlxuICAgICAgLy8gZ3JpZDogeyBpZDogTiB9XG4gICAgICB0aGlzLmN1cnNvci5ncmlkX2lkID0gZS5ncmlkX2lkO1xuICAgICAgdmFyIG9uY2UgPSB0cnVlO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gdXBkYXRlcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZ3JpZHMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBncmlkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLmN1cnNvcl9kYXRhKGdyaWQsIGUpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmN1cnNvci5sb2NrZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgZml4IHRvIGludmlzaWJsZSBjdXJzb3IgcHJvYlxuICAgICAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5jdXJzb3IudCA9IHRoaXMuY3Vyc29yX3RpbWUoZ3JpZCwgZSwgYyk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvci50KSBvbmNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjLnZhbHVlcykge1xuICAgICAgICAgICAgICB0aGlzLmNvbXAuJHNldCh0aGlzLmN1cnNvci52YWx1ZXMsIGdyaWQuaWQsIGMudmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ3JpZC5pZCAhPT0gZS5ncmlkX2lkKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLmN1cnNvci54ID0gZ3JpZC50MnNjcmVlbih0aGlzLmN1cnNvci50KTtcbiAgICAgICAgICB0aGlzLmN1cnNvci55ID0gYy55O1xuICAgICAgICAgIHRoaXMuY3Vyc29yLnkkID0gYy55JDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdmVybGF5X2RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcmxheV9kYXRhKGdyaWQsIGUpIHtcbiAgICAgIHZhciBzID0gZ3JpZC5pZCA9PT0gMCA/ICdtYWluX3NlY3Rpb24nIDogJ3N1Yl9zZWN0aW9uJztcbiAgICAgIHZhciBkYXRhID0gdGhpcy5jb21wW3NdLmRhdGE7IC8vIFNwbGl0IG9mZmNoYXJ0IGRhdGEgYmV0d2VlbiBvZmZjaGFydCBncmlkc1xuXG4gICAgICBpZiAoZ3JpZC5pZCA+IDApIHtcbiAgICAgICAgLy8gU2VxdWVudGlhbCBncmlkc1xuICAgICAgICB2YXIgX2QgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LmdyaWQuaWQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7IC8vIGdyaWRzIHdpdGggY3VzdG9tIGlkcyAoZm9yIG1lcmdpbmcpXG5cblxuICAgICAgICB2YXIgbSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHguZ3JpZC5pZCA9PT0gZ3JpZC5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGEgPSBbX2RbZ3JpZC5pZCAtIDFdXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG0pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHQgPSBncmlkLnNjcmVlbjJ0KGUueCk7XG4gICAgICB2YXIgaWRzID0ge30sXG4gICAgICAgICAgcmVzID0ge307XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gdXBkYXRlcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB2YXIgdHMgPSBkLmRhdGEubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geFswXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaSA9IHV0aWxzLm5lYXJlc3RfYSh0LCB0cylbMF07XG4gICAgICAgICAgZC50eXBlIGluIGlkcyA/IGlkc1tkLnR5cGVdKysgOiBpZHNbZC50eXBlXSA9IDA7XG4gICAgICAgICAgcmVzW1wiXCIuY29uY2F0KGQudHlwZSwgXCJfXCIpLmNvbmNhdChpZHNbZC50eXBlXSldID0gZC5kYXRhW2ldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIE5lYXJlc3QgZGF0YXBvaW50c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3Vyc29yX2RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3Vyc29yX2RhdGEoZ3JpZCwgZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmNvbXAubWFpbl9zZWN0aW9uLnN1YjtcbiAgICAgIHZhciB4cyA9IGRhdGEubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBncmlkLnQyc2NyZWVuKHhbMF0pICsgMC41O1xuICAgICAgfSk7XG4gICAgICB2YXIgaSA9IHV0aWxzLm5lYXJlc3RfYShlLngsIHhzKVswXTtcbiAgICAgIGlmICgheHNbaV0pIHJldHVybiB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IoeHNbaV0pIC0gMC41LFxuICAgICAgICB5OiBNYXRoLmZsb29yKGUueSAtIDIpIC0gMC41IC0gZ3JpZC5vZmZzZXQsXG4gICAgICAgIHkkOiBncmlkLnNjcmVlbjIkKGUueSAtIDIgLSBncmlkLm9mZnNldCksXG4gICAgICAgIHQ6IChkYXRhW2ldIHx8IFtdKVswXSxcbiAgICAgICAgdmFsdWVzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBvaGxjdjogZ3JpZC5pZCA9PT0gMCA/IGRhdGFbaV0gOiB1bmRlZmluZWRcbiAgICAgICAgfSwgdGhpcy5vdmVybGF5X2RhdGEoZ3JpZCwgZSkpXG4gICAgICB9O1xuICAgIH0gLy8gR2V0IGN1cnNvciB0LXBvc2l0aW9uIChleHRlbmRlZClcblxuICB9LCB7XG4gICAga2V5OiBcImN1cnNvcl90aW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnNvcl90aW1lKGdyaWQsIG1vdXNlLCBjYW5kbGUpIHtcbiAgICAgIHZhciB0ID0gZ3JpZC5zY3JlZW4ydChtb3VzZS54KTtcbiAgICAgIHZhciByID0gTWF0aC5hYnMoKHQgLSBjYW5kbGUudCkgLyB0aGlzLmNvbXAuaW50ZXJ2YWwpO1xuICAgICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24odCAtIGNhbmRsZS50KTtcblxuICAgICAgaWYgKHIgPj0gMC41KSB7XG4gICAgICAgIC8vIE91dHNpZGUgdGhlIGRhdGEgcmFuZ2VcbiAgICAgICAgdmFyIG4gPSBNYXRoLnJvdW5kKHIpO1xuICAgICAgICByZXR1cm4gY2FuZGxlLnQgKyBuICogdGhpcy5jb21wLmludGVydmFsICogc2lnbjtcbiAgICAgIH0gLy8gSW5zaWRlIHRoZSBkYXRhIHJhbmdlXG5cblxuICAgICAgcmV0dXJuIGNhbmRsZS50O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXJzb3JVcGRhdGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHVwZGF0ZXIgPSAoQ3Vyc29yVXBkYXRlcik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9TZWN0aW9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD04ZmJlOTMzNiZcbnZhciBTZWN0aW9udnVlX3R5cGVfdGVtcGxhdGVfaWRfOGZiZTkzMzZfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS1zZWN0aW9uXCIgfSxcbiAgICBbXG4gICAgICBfYyhcImNoYXJ0LWxlZ2VuZFwiLCB7XG4gICAgICAgIHJlZjogXCJsZWdlbmRcIixcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB2YWx1ZXM6IF92bS5zZWN0aW9uX3ZhbHVlcyxcbiAgICAgICAgICBncmlkX2lkOiBfdm0uZ3JpZF9pZCxcbiAgICAgICAgICBjb21tb246IF92bS5sZWdlbmRfcHJvcHMsXG4gICAgICAgICAgbWV0YV9wcm9wczogX3ZtLmdldF9tZXRhX3Byb3BzXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7IFwibGVnZW5kLWJ1dHRvbi1jbGlja1wiOiBfdm0uYnV0dG9uX2NsaWNrIH1cbiAgICAgIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImdyaWRcIixcbiAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlZjogXCJncmlkXCIsXG4gICAgICAgICAgICBhdHRyczogeyBncmlkX2lkOiBfdm0uZ3JpZF9pZCB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgXCJyZWdpc3Rlci1rYi1saXN0ZW5lclwiOiBfdm0ucmVnaXN0ZXJfa2IsXG4gICAgICAgICAgICAgIFwicmVtb3ZlLWtiLWxpc3RlbmVyXCI6IF92bS5yZW1vdmVfa2IsXG4gICAgICAgICAgICAgIFwicmFuZ2UtY2hhbmdlZFwiOiBfdm0ucmFuZ2VfY2hhbmdlZCxcbiAgICAgICAgICAgICAgXCJjdXJzb3ItY2hhbmdlZFwiOiBfdm0uY3Vyc29yX2NoYW5nZWQsXG4gICAgICAgICAgICAgIFwiY3Vyc29yLWxvY2tlZFwiOiBfdm0uY3Vyc29yX2xvY2tlZCxcbiAgICAgICAgICAgICAgXCJsYXllci1tZXRhLXByb3BzXCI6IF92bS5lbWl0X21ldGFfcHJvcHMsXG4gICAgICAgICAgICAgIFwiY3VzdG9tLWV2ZW50XCI6IF92bS5lbWl0X2N1c3RvbV9ldmVudCxcbiAgICAgICAgICAgICAgXCJzaWRlYmFyLXRyYW5zZm9ybVwiOiBfdm0uc2lkZWJhcl90cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIFwicmV6b29tLXJhbmdlXCI6IF92bS5yZXpvb21fcmFuZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ3JpZFwiLFxuICAgICAgICAgIF92bS5ncmlkX3Byb3BzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwic2lkZWJhclwiLFxuICAgICAgICBfdm0uX2IoXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVmOiBcInNiLVwiICsgX3ZtLmdyaWRfaWQsXG4gICAgICAgICAgICBhdHRyczogeyBncmlkX2lkOiBfdm0uZ3JpZF9pZCwgcmVyZW5kZXI6IF92bS5yZXJlbmRlciB9LFxuICAgICAgICAgICAgb246IHsgXCJzaWRlYmFyLXRyYW5zZm9ybVwiOiBfdm0uc2lkZWJhcl90cmFuc2Zvcm0gfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaWRlYmFyXCIsXG4gICAgICAgICAgX3ZtLnNpZGViYXJfcHJvcHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgU2VjdGlvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzhmYmU5MzM2X3N0YXRpY1JlbmRlckZucyA9IFtdXG5TZWN0aW9udnVlX3R5cGVfdGVtcGxhdGVfaWRfOGZiZTkzMzZfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU2VjdGlvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OGZiZTkzMzYmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHVmZi9mcmFtZS5qc1xuXG5cbi8vIEFubmltYXRpb24gZnJhbWUgd2l0aCBhIGZhbGxiYWNrIGZvclxuLy8gc2xvd2VyIGRldmljZXNcblxuXG52YXIgRnJhbWVBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcmFtZUFuaW1hdGlvbihjYikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFtZUFuaW1hdGlvbik7XG5cbiAgICB0aGlzLnQwID0gdGhpcy50ID0gdXRpbHMubm93KCk7XG4gICAgdGhpcy5pZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRoZSBwcmV2IGZyYW1lIHRvb2sgdG9vIGxvbmdcbiAgICAgIGlmICh1dGlscy5ub3coKSAtIF90aGlzLnQgPiAxMDApIHJldHVybjtcblxuICAgICAgaWYgKHV0aWxzLm5vdygpIC0gX3RoaXMudDAgPiAxMjAwKSB7XG4gICAgICAgIF90aGlzLnN0b3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmlkKSBjYihfdGhpcyk7XG4gICAgICBfdGhpcy50ID0gdXRpbHMubm93KCk7XG4gICAgfSwgMTYpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoRnJhbWVBbmltYXRpb24sIFt7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pZCk7XG4gICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJhbWVBbmltYXRpb247XG59KCk7XG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9oYW1tZXJqcy9oYW1tZXIuanNcbnZhciBoYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2hhbXN0ZXJqcy9oYW1zdGVyLmpzXG52YXIgaGFtc3RlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTgxKTtcbnZhciBoYW1zdGVyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGhhbXN0ZXIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvZ3JpZC5qc1xuXG5cblxuXG5cbmZ1bmN0aW9uIGdyaWRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IGdyaWRfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIGdyaWRfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBncmlkX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBncmlkX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBncmlkX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIEdyaWQuanMgbGlzdGVucyB0byB2YXJpb3VzIHVzZXItZ2VuZXJhdGVkIGV2ZW50cyxcbi8vIGVtaXRzIFZ1ZS1ldmVudHMgaWYgc29tZXRoaW5nIGhhcyBjaGFuZ2VkIChlLmcuIHJhbmdlKVxuLy8gVGhpbmsgb2YgaXQgYXMgYW4gSS9PIHN5c3RlbSBmb3IgR3JpZC52dWVcblxuXG5cblxuIC8vIEdyaWQgaXMgZ29vZC5cblxudmFyIEdyaWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHcmlkKGNhbnZhcywgY29tcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyaWQpO1xuXG4gICAgdGhpcy5NSU5fWk9PTSA9IGNvbXAuY29uZmlnLk1JTl9aT09NO1xuICAgIHRoaXMuTUFYX1pPT00gPSBjb21wLmNvbmZpZy5NQVhfWk9PTTtcbiAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSB0aGlzLk1JTl9aT09NICo9IDAuNTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgdGhpcy4kcCA9IGNvbXAuJHByb3BzO1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuJHAuc3ViO1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLiRwLnJhbmdlO1xuICAgIHRoaXMuaWQgPSB0aGlzLiRwLmdyaWRfaWQ7XG4gICAgdGhpcy5sYXlvdXQgPSB0aGlzLiRwLmxheW91dC5ncmlkc1t0aGlzLmlkXTtcbiAgICB0aGlzLmludGVydmFsID0gdGhpcy4kcC5pbnRlcnZhbDtcbiAgICB0aGlzLmN1cnNvciA9IGNvbXAuJHByb3BzLmN1cnNvcjtcbiAgICB0aGlzLm9mZnNldF94ID0gMDtcbiAgICB0aGlzLm9mZnNldF95ID0gMDtcbiAgICB0aGlzLmRlbHRhcyA9IDA7IC8vIFdoZWVsIGRlbHRhIGV2ZW50c1xuXG4gICAgdGhpcy53bW9kZSA9IHRoaXMuJHAuY29uZmlnLlNDUk9MTF9XSEVFTDtcbiAgICB0aGlzLmxpc3RlbmVycygpO1xuICAgIHRoaXMub3ZlcmxheXMgPSBbXTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKEdyaWQsIFt7XG4gICAga2V5OiBcImxpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmhtID0gaGFtc3Rlcl9kZWZhdWx0KCkodGhpcy5jYW52YXMpO1xuICAgICAgdGhpcy5obS53aGVlbChmdW5jdGlvbiAoZXZlbnQsIGRlbHRhKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5tb3VzZXpvb20oLWRlbHRhICogNTAsIGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1jID0gdGhpcy5tYyA9IG5ldyBoYW1tZXIuTWFuYWdlcih0aGlzLmNhbnZhcyk7XG4gICAgICB2YXIgVCA9IHV0aWxzLmlzX21vYmlsZSA/IDEwIDogMDtcbiAgICAgIG1jLmFkZChuZXcgaGFtbWVyLlBhbih7XG4gICAgICAgIHRocmVzaG9sZDogVFxuICAgICAgfSkpO1xuICAgICAgbWMuYWRkKG5ldyBoYW1tZXIuVGFwKCkpO1xuICAgICAgbWMuYWRkKG5ldyBoYW1tZXIuUGluY2goe1xuICAgICAgICB0aHJlc2hvbGQ6IDBcbiAgICAgIH0pKTtcbiAgICAgIG1jLmdldCgncGluY2gnKS5zZXQoe1xuICAgICAgICBlbmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKHV0aWxzLmlzX21vYmlsZSkgbWMuYWRkKG5ldyBoYW1tZXIuUHJlc3MoKSk7XG4gICAgICBtYy5vbigncGFuc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzLmN1cnNvci5zY3JvbGxfbG9jaykgcmV0dXJuO1xuXG4gICAgICAgIGlmIChfdGhpcy5jdXJzb3IubW9kZSA9PT0gJ2FpbScpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdF9jdXJzb3JfY29vcmQoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRmcm0gPSBfdGhpcy4kcC55X3RyYW5zZm9ybTtcbiAgICAgICAgX3RoaXMuZHJ1ZyA9IHtcbiAgICAgICAgICB4OiBldmVudC5jZW50ZXIueCArIF90aGlzLm9mZnNldF94LFxuICAgICAgICAgIHk6IGV2ZW50LmNlbnRlci55ICsgX3RoaXMub2Zmc2V0X3ksXG4gICAgICAgICAgcjogX3RoaXMucmFuZ2Uuc2xpY2UoKSxcbiAgICAgICAgICB0OiBfdGhpcy5yYW5nZVsxXSAtIF90aGlzLnJhbmdlWzBdLFxuICAgICAgICAgIG86IHRmcm0gPyB0ZnJtLm9mZnNldCB8fCAwIDogMCxcbiAgICAgICAgICB5X3I6IHRmcm0gJiYgdGZybS5yYW5nZSA/IHRmcm0ucmFuZ2Uuc2xpY2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBCOiBfdGhpcy5sYXlvdXQuQixcbiAgICAgICAgICB0MDogdXRpbHMubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItY2hhbmdlZCcsIHtcbiAgICAgICAgICBncmlkX2lkOiBfdGhpcy5pZCxcbiAgICAgICAgICB4OiBldmVudC5jZW50ZXIueCArIF90aGlzLm9mZnNldF94LFxuICAgICAgICAgIHk6IGV2ZW50LmNlbnRlci55ICsgX3RoaXMub2Zmc2V0X3lcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWxvY2tlZCcsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBtYy5vbigncGFubW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSB7XG4gICAgICAgICAgX3RoaXMuY2FsY19vZmZzZXQoKTtcblxuICAgICAgICAgIF90aGlzLnByb3BhZ2F0ZSgnbW91c2Vtb3ZlJywgX3RoaXMudG91Y2gybW91c2UoZXZlbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcy5kcnVnKSB7XG4gICAgICAgICAgX3RoaXMubW91c2VkcmFnKF90aGlzLmRydWcueCArIGV2ZW50LmRlbHRhWCwgX3RoaXMuZHJ1Zy55ICsgZXZlbnQuZGVsdGFZKTtcblxuICAgICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZ3JpZF9pZDogX3RoaXMuaWQsXG4gICAgICAgICAgICB4OiBldmVudC5jZW50ZXIueCArIF90aGlzLm9mZnNldF94LFxuICAgICAgICAgICAgeTogZXZlbnQuY2VudGVyLnkgKyBfdGhpcy5vZmZzZXRfeVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmN1cnNvci5tb2RlID09PSAnYWltJykge1xuICAgICAgICAgIF90aGlzLmVtaXRfY3Vyc29yX2Nvb3JkKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtYy5vbigncGFuZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh1dGlscy5pc19tb2JpbGUgJiYgX3RoaXMuZHJ1Zykge1xuICAgICAgICAgIF90aGlzLnBhbl9mYWRlKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmRydWcgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1sb2NrZWQnLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF1dGlscy5pc19tb2JpbGUpIHJldHVybjtcblxuICAgICAgICBfdGhpcy5zaW1fbW91c2Vkb3duKGV2ZW50KTtcblxuICAgICAgICBpZiAoX3RoaXMuZmFkZSkgX3RoaXMuZmFkZS5zdG9wKCk7XG5cbiAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWNoYW5nZWQnLCB7fSk7XG5cbiAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWNoYW5nZWQnLCB7XG4gICAgICAgICAgLypncmlkX2lkOiB0aGlzLmlkLFxuICAgICAgICAgIHg6IHVuZGVmaW5lZCwvL2V2ZW50LmNlbnRlci54ICsgdGhpcy5vZmZzZXRfeCxcbiAgICAgICAgICB5OiB1bmRlZmluZWQsLy9ldmVudC5jZW50ZXIueSArIHRoaXMub2Zmc2V0X3ksKi9cbiAgICAgICAgICBtb2RlOiAnZXhwbG9yZSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdwaW5jaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kcnVnID0gbnVsbDtcbiAgICAgICAgX3RoaXMucGluY2ggPSB7XG4gICAgICAgICAgdDogX3RoaXMucmFuZ2VbMV0gLSBfdGhpcy5yYW5nZVswXSxcbiAgICAgICAgICByOiBfdGhpcy5yYW5nZS5zbGljZSgpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdwaW5jaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucGluY2ggPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBtYy5vbigncGluY2gnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzLnBpbmNoKSBfdGhpcy5waW5jaHpvb20oZXZlbnQuc2NhbGUpO1xuICAgICAgfSk7XG4gICAgICBtYy5vbigncHJlc3MnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF1dGlscy5pc19tb2JpbGUpIHJldHVybjtcbiAgICAgICAgaWYgKF90aGlzLmZhZGUpIF90aGlzLmZhZGUuc3RvcCgpO1xuXG4gICAgICAgIF90aGlzLmNhbGNfb2Zmc2V0KCk7XG5cbiAgICAgICAgX3RoaXMuZW1pdF9jdXJzb3JfY29vcmQoZXZlbnQsIHtcbiAgICAgICAgICBtb2RlOiAnYWltJ1xuICAgICAgICB9KTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzLnNpbV9tb3VzZWRvd24oZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWRkID0gYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgIGFkZChcImdlc3R1cmVzdGFydFwiLCB0aGlzLmdlc3R1cmVzdGFydCk7XG4gICAgICBhZGQoXCJnZXN0dXJlY2hhbmdlXCIsIHRoaXMuZ2VzdHVyZWNoYW5nZSk7XG4gICAgICBhZGQoXCJnZXN0dXJlZW5kXCIsIHRoaXMuZ2VzdHVyZWVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlc3R1cmVzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXN0dXJlc3RhcnQoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlc3R1cmVjaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VzdHVyZWNoYW5nZShldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VzdHVyZWVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXN0dXJlZW5kKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSByZXR1cm47XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1jaGFuZ2VkJywge1xuICAgICAgICBncmlkX2lkOiB0aGlzLmlkLFxuICAgICAgICB4OiBldmVudC5sYXllclgsXG4gICAgICAgIHk6IGV2ZW50LmxheWVyWSArIHRoaXMubGF5b3V0Lm9mZnNldFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNhbGNfb2Zmc2V0KCk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZSgnbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZW91dChldmVudCkge1xuICAgICAgaWYgKHV0aWxzLmlzX21vYmlsZSkgcmV0dXJuO1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItY2hhbmdlZCcsIHt9KTtcbiAgICAgIHRoaXMucHJvcGFnYXRlKCdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2V1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZXVwKGV2ZW50KSB7XG4gICAgICB0aGlzLmRydWcgPSBudWxsO1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItbG9ja2VkJywgZmFsc2UpO1xuICAgICAgdGhpcy5wcm9wYWdhdGUoJ21vdXNldXAnLCBldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZWRvd24oZXZlbnQpIHtcbiAgICAgIGlmICh1dGlscy5pc19tb2JpbGUpIHJldHVybjtcbiAgICAgIHRoaXMucHJvcGFnYXRlKCdtb3VzZWRvd24nLCBldmVudCk7XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1sb2NrZWQnLCB0cnVlKTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6ICdncmlkLW1vdXNlZG93bicsXG4gICAgICAgIGFyZ3M6IFt0aGlzLmlkLCBldmVudF1cbiAgICAgIH0pO1xuICAgIH0gLy8gU2ltdWxhdGVkIG1vdXNlZG93biAoZm9yIG1vYmlsZSlcblxuICB9LCB7XG4gICAga2V5OiBcInNpbV9tb3VzZWRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2ltX21vdXNlZG93bihldmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChldmVudC5zcmNFdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6ICdncmlkLW1vdXNlZG93bicsXG4gICAgICAgIGFyZ3M6IFt0aGlzLmlkLCBldmVudF1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wYWdhdGUoJ21vdXNlbW92ZScsIHRoaXMudG91Y2gybW91c2UoZXZlbnQpKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZSgnbW91c2Vkb3duJywgdGhpcy50b3VjaDJtb3VzZShldmVudCkpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5wcm9wYWdhdGUoJ2NsaWNrJywgX3RoaXMyLnRvdWNoMm1vdXNlKGV2ZW50KSk7XG4gICAgICB9KTtcbiAgICB9IC8vIENvbnZlcnQgdG91Y2ggdG8gXCJtb3VzZVwiIGV2ZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJ0b3VjaDJtb3VzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b3VjaDJtb3VzZShlKSB7XG4gICAgICB0aGlzLmNhbGNfb2Zmc2V0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW5hbDogZS5zcmNFdmVudCxcbiAgICAgICAgbGF5ZXJYOiBlLmNlbnRlci54ICsgdGhpcy5vZmZzZXRfeCxcbiAgICAgICAgbGF5ZXJZOiBlLmNlbnRlci55ICsgdGhpcy5vZmZzZXRfeSxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgIHRoaXMub3JpZ2luYWwucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMucHJvcGFnYXRlKCdjbGljaycsIGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdF9jdXJzb3JfY29vcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdF9jdXJzb3JfY29vcmQoZXZlbnQsIGFkZCkge1xuICAgICAgaWYgKGFkZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFkZCA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1jaGFuZ2VkJywgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGdyaWRfaWQ6IHRoaXMuaWQsXG4gICAgICAgIHg6IGV2ZW50LmNlbnRlci54ICsgdGhpcy5vZmZzZXRfeCxcbiAgICAgICAgeTogZXZlbnQuY2VudGVyLnkgKyB0aGlzLm9mZnNldF95ICsgdGhpcy5sYXlvdXQub2Zmc2V0XG4gICAgICB9LCBhZGQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuX2ZhZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuX2ZhZGUoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZHQgPSB1dGlscy5ub3coKSAtIHRoaXMuZHJ1Zy50MDtcbiAgICAgIHZhciBkeCA9IHRoaXMucmFuZ2VbMV0gLSB0aGlzLmRydWcuclsxXTtcbiAgICAgIHZhciB2ID0gNDIgKiBkeCAvIGR0O1xuICAgICAgdmFyIHYwID0gTWF0aC5hYnModiAqIDAuMDEpO1xuICAgICAgaWYgKGR0ID4gNTAwKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5mYWRlKSB0aGlzLmZhZGUuc3RvcCgpO1xuICAgICAgdGhpcy5mYWRlID0gbmV3IEZyYW1lQW5pbWF0aW9uKGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIHYgKj0gMC44NTtcblxuICAgICAgICBpZiAoTWF0aC5hYnModikgPCB2MCkge1xuICAgICAgICAgIHNlbGYuc3RvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLnJhbmdlWzBdICs9IHY7XG4gICAgICAgIF90aGlzMy5yYW5nZVsxXSArPSB2O1xuXG4gICAgICAgIF90aGlzMy5jaGFuZ2VfcmFuZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjX29mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjX29mZnNldCgpIHtcbiAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLm9mZnNldF94ID0gLXJlY3QueDtcbiAgICAgIHRoaXMub2Zmc2V0X3kgPSAtcmVjdC55O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXdfbGF5ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3X2xheWVyKGxheWVyKSB7XG4gICAgICBpZiAobGF5ZXIubmFtZSA9PT0gJ2Nyb3NzaGFpcicpIHtcbiAgICAgICAgdGhpcy5jcm9zc2hhaXIgPSBsYXllcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3ZlcmxheXMucHVzaChsYXllcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbF9sYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxfbGF5ZXIoaWQpIHtcbiAgICAgIHRoaXMub3ZlcmxheXMgPSB0aGlzLm92ZXJsYXlzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5pZCAhPT0gaWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3dfaGlkZV9sYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93X2hpZGVfbGF5ZXIoZXZlbnQpIHtcbiAgICAgIHZhciBsID0gdGhpcy5vdmVybGF5cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguaWQgPT09IGV2ZW50LmlkO1xuICAgICAgfSk7XG4gICAgICBpZiAobC5sZW5ndGgpIGxbMF0uZGlzcGxheSA9IGV2ZW50LmRpc3BsYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgLy8gVXBkYXRlIHJlZmVyZW5jZSB0byB0aGUgZ3JpZFxuICAgICAgLy8gVE9ETzogY2hlY2sgd2hhdCBoYXBwZW5zIGlmIGRhdGEgY2hhbmdlcyBpbnRlcnZhbFxuICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLiRwLmxheW91dC5ncmlkc1t0aGlzLmlkXTtcbiAgICAgIHRoaXMuaW50ZXJ2YWwgPSB0aGlzLiRwLmludGVydmFsO1xuICAgICAgaWYgKCF0aGlzLmxheW91dCkgcmV0dXJuO1xuICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgaWYgKHRoaXMuJHAuc2hhZGVycy5sZW5ndGgpIHRoaXMuYXBwbHlfc2hhZGVycygpO1xuICAgICAgdGhpcy5ncmlkKCk7XG4gICAgICB2YXIgb3ZlcmxheXMgPSBbXTtcbiAgICAgIG92ZXJsYXlzLnB1c2guYXBwbHkob3ZlcmxheXMsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLm92ZXJsYXlzKSk7IC8vIHotaW5kZXggc29ydGluZ1xuXG4gICAgICBvdmVybGF5cy5zb3J0KGZ1bmN0aW9uIChsMSwgbDIpIHtcbiAgICAgICAgcmV0dXJuIGwxLnogLSBsMi56O1xuICAgICAgfSk7XG4gICAgICBvdmVybGF5cy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIGlmICghbC5kaXNwbGF5KSByZXR1cm47XG5cbiAgICAgICAgX3RoaXM0LmN0eC5zYXZlKCk7XG5cbiAgICAgICAgdmFyIHIgPSBsLnJlbmRlcmVyO1xuICAgICAgICBpZiAoci5wcmVfZHJhdykgci5wcmVfZHJhdyhfdGhpczQuY3R4KTtcbiAgICAgICAgci5kcmF3KF90aGlzNC5jdHgpO1xuICAgICAgICBpZiAoci5wb3N0X2RyYXcpIHIucG9zdF9kcmF3KF90aGlzNC5jdHgpO1xuXG4gICAgICAgIF90aGlzNC5jdHgucmVzdG9yZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmNyb3NzaGFpcikge1xuICAgICAgICB0aGlzLmNyb3NzaGFpci5yZW5kZXJlci5kcmF3KHRoaXMuY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlfc2hhZGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseV9zaGFkZXJzKCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHAubGF5b3V0LmdyaWRzW3RoaXMuaWRdO1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgcmFuZ2U6IHRoaXMucmFuZ2UsXG4gICAgICAgIGludGVydmFsOiB0aGlzLmludGVydmFsLFxuICAgICAgICB0ZjogbGF5b3V0LnRpX21hcC50ZixcbiAgICAgICAgY3Vyc29yOiB0aGlzLmN1cnNvcixcbiAgICAgICAgY29sb3JzOiB0aGlzLiRwLmNvbG9ycyxcbiAgICAgICAgc3ViOiB0aGlzLmRhdGEsXG4gICAgICAgIGZvbnQ6IHRoaXMuJHAuZm9udCxcbiAgICAgICAgY29uZmlnOiB0aGlzLiRwLmNvbmZpZyxcbiAgICAgICAgbWV0YTogdGhpcy4kcC5tZXRhXG4gICAgICB9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gZ3JpZF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHAuc2hhZGVycyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgICAgcy5kcmF3KHRoaXMuY3R4LCBwcm9wcyk7XG4gICAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSAvLyBBY3R1YWxseSBkcmF3cyB0aGUgZ3JpZCAoZm9yIHJlYWwpXG5cbiAgfSwge1xuICAgIGtleTogXCJncmlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyaWQoKSB7XG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuJHAuY29sb3JzLmdyaWQ7XG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHZhciB5bWF4ID0gdGhpcy5sYXlvdXQuaGVpZ2h0O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IGdyaWRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmxheW91dC54cyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICB4ID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgICBwID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKHggLSAwLjUsIDApO1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4IC0gMC41LCB5bWF4KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gZ3JpZF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMubGF5b3V0LnlzKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIHkgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIHkkID0gX3N0ZXAzJHZhbHVlWzFdO1xuXG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKDAsIHkgLSAwLjUpO1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLmxheW91dC53aWR0aCwgeSAtIDAuNSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgIGlmICh0aGlzLiRwLmdyaWRfaWQpIHRoaXMudXBwZXJfYm9yZGVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwcGVyX2JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cHBlcl9ib3JkZXIoKSB7XG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnNjYWxlO1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgMC41KTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLmxheW91dC53aWR0aCwgMC41KTtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZXpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2V6b29tKGRlbHRhLCBldmVudCkge1xuICAgICAgLy8gVE9ETzogZm9yIG1vYmlsZVxuICAgICAgaWYgKHRoaXMud21vZGUgIT09ICdwYXNzJykge1xuICAgICAgICBpZiAodGhpcy53bW9kZSA9PT0gJ2NsaWNrJyAmJiAhdGhpcy4kcC5tZXRhLmFjdGl2YXRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQuZGVsdGFYID0gZXZlbnQuZGVsdGFYIHx8IHV0aWxzLmdldF9kZWx0YVgoZXZlbnQpO1xuICAgICAgZXZlbnQuZGVsdGFZID0gZXZlbnQuZGVsdGFZIHx8IHV0aWxzLmdldF9kZWx0YVkoZXZlbnQpO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoZXZlbnQuZGVsdGFYKSA+IDApIHtcbiAgICAgICAgdGhpcy50cmFja3BhZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGV2ZW50LmRlbHRhWCkgPj0gTWF0aC5hYnMoZXZlbnQuZGVsdGFZKSkge1xuICAgICAgICAgIGRlbHRhICo9IDAuMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhY2twYWRfc2Nyb2xsKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHJhY2twYWQpIGRlbHRhICo9IDAuMDMyO1xuICAgICAgZGVsdGEgPSB1dGlscy5zbWFydF93aGVlbChkZWx0YSk7IC8vIFRPRE86IG1vdXNlIHpvb21pbmcgaXMgYSBsaXR0bGUgamVya3ksXG4gICAgICAvLyBuZWVkcyB0byBmb2xsb3cgZihtb3VzZV93aGVlbF9zcGVlZCkgYW5kXG4gICAgICAvLyBpZiBzcGVlZCBpcyBsb3csIHNjcm9sbCBzaG91ZCBiZSBzbG93ZXJcblxuICAgICAgaWYgKGRlbHRhIDwgMCAmJiB0aGlzLmRhdGEubGVuZ3RoIDw9IHRoaXMuTUlOX1pPT00pIHJldHVybjtcbiAgICAgIGlmIChkZWx0YSA+IDAgJiYgdGhpcy5kYXRhLmxlbmd0aCA+IHRoaXMuTUFYX1pPT00pIHJldHVybjtcbiAgICAgIHZhciBrID0gdGhpcy5pbnRlcnZhbCAvIDEwMDA7XG4gICAgICB2YXIgZGlmZiA9IGRlbHRhICogayAqIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICB2YXIgdGwgPSB0aGlzLmNvbXAuY29uZmlnLlpPT01fTU9ERSA9PT0gJ3RsJztcblxuICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuY3RybEtleSB8fCB0bCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZXZlbnQub3JpZ2luYWxFdmVudC5vZmZzZXRYO1xuICAgICAgICB2YXIgZGlmZjEgPSBvZmZzZXQgLyAodGhpcy5jYW52YXMud2lkdGggLSAxKSAqIGRpZmY7XG4gICAgICAgIHZhciBkaWZmMiA9IGRpZmYgLSBkaWZmMTtcbiAgICAgICAgdGhpcy5yYW5nZVswXSAtPSBkaWZmMTtcbiAgICAgICAgdGhpcy5yYW5nZVsxXSArPSBkaWZmMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFuZ2VbMF0gLT0gZGlmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRsKSB7XG4gICAgICAgIHZhciBfb2Zmc2V0ID0gZXZlbnQub3JpZ2luYWxFdmVudC5vZmZzZXRZO1xuXG4gICAgICAgIHZhciBfZGlmZiA9IF9vZmZzZXQgLyAodGhpcy5jYW52YXMuaGVpZ2h0IC0gMSkgKiAyO1xuXG4gICAgICAgIHZhciBfZGlmZjIgPSAyIC0gX2RpZmY7XG5cbiAgICAgICAgdmFyIHogPSBkaWZmIC8gKHRoaXMucmFuZ2VbMV0gLSB0aGlzLnJhbmdlWzBdKTsgLy9yZXpvb21fcmFuZ2UoeiwgZGlmZl94LCBkaWZmX3kpXG5cbiAgICAgICAgdGhpcy5jb21wLiRlbWl0KCdyZXpvb20tcmFuZ2UnLCB7XG4gICAgICAgICAgZ3JpZF9pZDogdGhpcy5pZCxcbiAgICAgICAgICB6OiB6LFxuICAgICAgICAgIGRpZmYxOiBfZGlmZixcbiAgICAgICAgICBkaWZmMjogX2RpZmYyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoYW5nZV9yYW5nZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZWRyYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2VkcmFnKHgsIHkpIHtcbiAgICAgIHZhciBkdCA9IHRoaXMuZHJ1Zy50ICogKHRoaXMuZHJ1Zy54IC0geCkgLyB0aGlzLmxheW91dC53aWR0aDtcbiAgICAgIHZhciBkJCA9IHRoaXMubGF5b3V0LiRfaGkgLSB0aGlzLmxheW91dC4kX2xvO1xuICAgICAgZCQgKj0gKHRoaXMuZHJ1Zy55IC0geSkgLyB0aGlzLmxheW91dC5oZWlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5kcnVnLm8gKyBkJDtcbiAgICAgIHZhciBscyA9IHRoaXMubGF5b3V0LmdyaWQubG9nU2NhbGU7XG5cbiAgICAgIGlmIChscyAmJiB0aGlzLmRydWcueV9yKSB7XG4gICAgICAgIHZhciBkeSA9IHRoaXMuZHJ1Zy55IC0geTtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5kcnVnLnlfci5zbGljZSgpO1xuICAgICAgICByYW5nZVswXSA9IG1hdGguZXhwKCgwIC0gdGhpcy5kcnVnLkIgKyBkeSkgLyB0aGlzLmxheW91dC5BKTtcbiAgICAgICAgcmFuZ2VbMV0gPSBtYXRoLmV4cCgodGhpcy5sYXlvdXQuaGVpZ2h0IC0gdGhpcy5kcnVnLkIgKyBkeSkgLyB0aGlzLmxheW91dC5BKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZHJ1Zy55X3IgJiYgdGhpcy4kcC55X3RyYW5zZm9ybSAmJiAhdGhpcy4kcC55X3RyYW5zZm9ybS5hdXRvKSB7XG4gICAgICAgIHRoaXMuY29tcC4kZW1pdCgnc2lkZWJhci10cmFuc2Zvcm0nLCB7XG4gICAgICAgICAgZ3JpZF9pZDogdGhpcy5pZCxcbiAgICAgICAgICByYW5nZTogbHMgPyByYW5nZSB8fCB0aGlzLmRydWcueV9yIDogW3RoaXMuZHJ1Zy55X3JbMF0gLSBvZmZzZXQsIHRoaXMuZHJ1Zy55X3JbMV0gLSBvZmZzZXRdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJhbmdlWzBdID0gdGhpcy5kcnVnLnJbMF0gKyBkdDtcbiAgICAgIHRoaXMucmFuZ2VbMV0gPSB0aGlzLmRydWcuclsxXSArIGR0O1xuICAgICAgdGhpcy5jaGFuZ2VfcmFuZ2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGluY2h6b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpbmNoem9vbShzY2FsZSkge1xuICAgICAgaWYgKHNjYWxlID4gMSAmJiB0aGlzLmRhdGEubGVuZ3RoIDw9IHRoaXMuTUlOX1pPT00pIHJldHVybjtcbiAgICAgIGlmIChzY2FsZSA8IDEgJiYgdGhpcy5kYXRhLmxlbmd0aCA+IHRoaXMuTUFYX1pPT00pIHJldHVybjtcbiAgICAgIHZhciB0ID0gdGhpcy5waW5jaC50O1xuICAgICAgdmFyIG50ID0gdCAqIDEgLyBzY2FsZTtcbiAgICAgIHRoaXMucmFuZ2VbMF0gPSB0aGlzLnBpbmNoLnJbMF0gLSAobnQgLSB0KSAqIDAuNTtcbiAgICAgIHRoaXMucmFuZ2VbMV0gPSB0aGlzLnBpbmNoLnJbMV0gKyAobnQgLSB0KSAqIDAuNTtcbiAgICAgIHRoaXMuY2hhbmdlX3JhbmdlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYWNrcGFkX3Njcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFja3BhZF9zY3JvbGwoZXZlbnQpIHtcbiAgICAgIHZhciBkdCA9IHRoaXMucmFuZ2VbMV0gLSB0aGlzLnJhbmdlWzBdO1xuICAgICAgdGhpcy5yYW5nZVswXSArPSBldmVudC5kZWx0YVggKiBkdCAqIDAuMDExO1xuICAgICAgdGhpcy5yYW5nZVsxXSArPSBldmVudC5kZWx0YVggKiBkdCAqIDAuMDExO1xuICAgICAgdGhpcy5jaGFuZ2VfcmFuZ2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhbmdlX3JhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZV9yYW5nZSgpIHtcbiAgICAgIC8vIFRPRE86IGJldHRlciB3YXkgdG8gbGltaXQgdGhlIHZpZXcuIFByb2JsZW06XG4gICAgICAvLyB3aGVuIHlvdSBhcmUgYXQgdGhlIGRlYWQgZW5kIG9mIHRoZSBkYXRhLFxuICAgICAgLy8gYW5kIGtlZXAgc2Nyb2xsaW5nLFxuICAgICAgLy8gdGhlIGNoYXJ0IGNvbnRpbnVlcyB0byBzY2FsZSBkb3duIGEgbGl0dGxlLlxuICAgICAgLy8gU29sdXRpb246IEkgZG9uJ3Qga25vdyB5ZXRcbiAgICAgIGlmICghdGhpcy5yYW5nZS5sZW5ndGggfHwgdGhpcy5kYXRhLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgIHZhciBsID0gdGhpcy5kYXRhLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICByYW5nZVswXSA9IHV0aWxzLmNsYW1wKHJhbmdlWzBdLCAtSW5maW5pdHksIGRhdGFbbF1bMF0gLSB0aGlzLmludGVydmFsICogNS41KTtcbiAgICAgIHJhbmdlWzFdID0gdXRpbHMuY2xhbXAocmFuZ2VbMV0sIGRhdGFbMF1bMF0gKyB0aGlzLmludGVydmFsICogNS41LCBJbmZpbml0eSk7IC8vIFRPRE86IElNUE9SVEFOVCBzY3JvbGxpbmcgaXMgamVya3kgVGhlIFByb2JsZW0gY2F1c2VkXG4gICAgICAvLyBieSB0aGUgbG9uZyByb3VuZCB0cmlwIG9mICdyYW5nZS1jaGFuZ2VkJyBldmVudC5cbiAgICAgIC8vIEZpcnN0IGl0IHByb3BhZ2F0ZXMgdXAgdG8gdXBkYXRlIGxheW91dCBpbiBDaGFydC52dWUsXG4gICAgICAvLyB0aGVuIGl0IG1vdmVzIGJhY2sgYXMgd2F0Y2goKSB1cGRhdGUuIEl0IHRha2VzIDEtNSBtcy5cbiAgICAgIC8vIEFuZCBiZWNhdXNlIHRoZSBkZWxheSBpcyBkaWZmZXJlbnQgZWFjaCB0aW1lIHdlIHNlZVxuICAgICAgLy8gdGhlIGxhZy4gTm8gc21vb3RoIG1vdmVtZW50IGFuZCBpdCdzIGFubm95aW5nLlxuICAgICAgLy8gU29sdXRpb246IHdlIGNvdWxkIHRyeSB0byBjYWxjIHRoZSBsYXlvdXQgaW1tZWRpYXRseVxuICAgICAgLy8gc29tZXdoZXJlIGhlcmUuIFN0aWxsIHdpbGwgaHVydCB0aGUgc2lkZWJhciAmIGJvdHRvbWJhclxuXG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ3JhbmdlLWNoYW5nZWQnLCByYW5nZSk7XG4gICAgfSAvLyBQcm9wYWdhdGUgbW91c2UgZXZlbnQgdG8gb3ZlcmxheXNcblxuICB9LCB7XG4gICAga2V5OiBcInByb3BhZ2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wYWdhdGUobmFtZSwgZXZlbnQpIHtcbiAgICAgIHZhciBfaXRlcmF0b3I0ID0gZ3JpZF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMub3ZlcmxheXMpLFxuICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgbGF5ZXIgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICBpZiAobGF5ZXIucmVuZGVyZXJbbmFtZV0pIHtcbiAgICAgICAgICAgIGxheWVyLnJlbmRlcmVyW25hbWVdKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbW91c2UgPSBsYXllci5yZW5kZXJlci5tb3VzZTtcbiAgICAgICAgICB2YXIga2V5cyA9IGxheWVyLnJlbmRlcmVyLmtleXM7XG5cbiAgICAgICAgICBpZiAobW91c2UubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBtb3VzZS5lbWl0KG5hbWUsIGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAga2V5cy5lbWl0KG5hbWUsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgcm0gPSByZW1vdmVFdmVudExpc3RlbmVyO1xuICAgICAgcm0oXCJnZXN0dXJlc3RhcnRcIiwgdGhpcy5nZXN0dXJlc3RhcnQpO1xuICAgICAgcm0oXCJnZXN0dXJlY2hhbmdlXCIsIHRoaXMuZ2VzdHVyZWNoYW5nZSk7XG4gICAgICBybShcImdlc3R1cmVlbmRcIiwgdGhpcy5nZXN0dXJlZW5kKTtcbiAgICAgIGlmICh0aGlzLm1jKSB0aGlzLm1jLmRlc3Ryb3koKTtcbiAgICAgIGlmICh0aGlzLmhtKSB0aGlzLmhtLnVud2hlZWwoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR3JpZDtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL2NhbnZhcy5qc1xuLy8gSW50ZXJhY3RpdmUgY2FudmFzLWJhc2VkIGNvbXBvbmVudFxuLy8gU2hvdWxkIGltcGxlbWVudDogbW91c2Vtb3ZlLCBtb3VzZW91dCwgbW91c2V1cCwgbW91c2Vkb3duLCBjbGlja1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNhbnZhcyA9ICh7XG4gIG1ldGhvZHM6IHtcbiAgICBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgaWQgPSBcIlwiLmNvbmNhdCh0aGlzLiRwcm9wcy50dl9pZCwgXCItXCIpLmNvbmNhdCh0aGlzLl9pZCwgXCItY2FudmFzXCIpO1xuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgIHZhciBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQodGhpcy5fYXR0cnMud2lkdGgsIFwicHhcIik7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQodGhpcy5fYXR0cnMuaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgaWYgKGRwciA8IDEpIGRwciA9IDE7IC8vIFJlYWx5ID8gVGhhdCdzIGl0PyBJc3N1ZSAjNjNcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCAqIGRwcjtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0ICogZHByO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJywgey8vIFRPRE86IHRlc3QgdGhlIGJvb3N0OlxuICAgICAgICAgIC8vYWxwaGE6IGZhbHNlLFxuICAgICAgICAgIC8vZGVzeW5jaHJvbml6ZWQ6IHRydWUsXG4gICAgICAgICAgLy9wcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuXG4gICAgICAgIF90aGlzLnJlZHJhdygpOyAvLyBGYWxsYmFjayBmaXggZm9yIEJyYXZlIGJyb3dzZXJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JyYXZlL2JyYXZlLWJyb3dzZXIvaXNzdWVzLzE3MzhcblxuXG4gICAgICAgIGlmICghY3R4Lm1lYXN1cmVUZXh0T3JnKSB7XG4gICAgICAgICAgY3R4Lm1lYXN1cmVUZXh0T3JnID0gY3R4Lm1lYXN1cmVUZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4Lm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMubWVhc3VyZVRleHQoY3R4LCB0ZXh0LCBfdGhpcy4kcHJvcHMudHZfaWQpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjcmVhdGVfY2FudmFzOiBmdW5jdGlvbiBjcmVhdGVfY2FudmFzKGgsIGlkLCBwcm9wcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICB0aGlzLl9hdHRycyA9IHByb3BzLmF0dHJzO1xuICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgXCJjbGFzc1wiOiBcInRyYWRpbmctdnVlLVwiLmNvbmNhdChpZCksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgbGVmdDogcHJvcHMucG9zaXRpb24ueCArICdweCcsXG4gICAgICAgICAgdG9wOiBwcm9wcy5wb3NpdGlvbi55ICsgJ3B4JyxcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgICB9XG4gICAgICB9LCBbaCgnY2FudmFzJywge1xuICAgICAgICBvbjoge1xuICAgICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIucmVuZGVyZXIubW91c2Vtb3ZlKGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIG1vdXNlb3V0KGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIucmVuZGVyZXIubW91c2VvdXQoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb3VzZXVwOiBmdW5jdGlvbiBtb3VzZXVwKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIucmVuZGVyZXIubW91c2V1cChlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIucmVuZGVyZXIubW91c2Vkb3duKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGlkOiBcIlwiLmNvbmNhdCh0aGlzLiRwcm9wcy50dl9pZCwgXCItXCIpLmNvbmNhdChpZCwgXCItY2FudmFzXCIpXG4gICAgICAgIH0sIHByb3BzLmF0dHJzKSxcbiAgICAgICAgcmVmOiAnY2FudmFzJyxcbiAgICAgICAgc3R5bGU6IHByb3BzLnN0eWxlXG4gICAgICB9KV0uY29uY2F0KHByb3BzLmhzIHx8IFtdKSk7XG4gICAgfSxcbiAgICByZWRyYXc6IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgIGlmICghdGhpcy5yZW5kZXJlcikgcmV0dXJuO1xuICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGUoKTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKHZhbCkge1xuICAgICAgdGhpcy5fYXR0cnMud2lkdGggPSB2YWw7XG4gICAgICB0aGlzLnNldHVwKCk7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodCh2YWwpIHtcbiAgICAgIHRoaXMuX2F0dHJzLmhlaWdodCA9IHZhbDtcbiAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy91eGxpc3QuanNcbi8vIE1hbmFnZXIgZm9yIEludGVlcmZhY2Ugb2JqZWN0c1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB1eGxpc3QgPSAoe1xuICBtZXRob2RzOiB7XG4gICAgb25fdXhfZXZlbnQ6IGZ1bmN0aW9uIG9uX3V4X2V2ZW50KGQsIHRhcmdldCkge1xuICAgICAgaWYgKGQuZXZlbnQgPT09ICduZXctaW50ZXJmYWNlJykge1xuICAgICAgICBpZiAoZC5hcmdzWzBdLnRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgZC5hcmdzWzBdLnZhcnMgPSBkLmFyZ3NbMF0udmFycyB8fCB7fTtcbiAgICAgICAgICBkLmFyZ3NbMF0uZ3JpZF9pZCA9IGQuYXJnc1sxXTtcbiAgICAgICAgICBkLmFyZ3NbMF0ub3ZlcmxheV9pZCA9IGQuYXJnc1syXTtcbiAgICAgICAgICB0aGlzLnV4cy5wdXNoKGQuYXJnc1swXSk7IC8vIHRoaXMucmVyZW5kZXIrK1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGQuZXZlbnQgPT09ICdjbG9zZS1pbnRlcmZhY2UnKSB7XG4gICAgICAgIHRoaXMudXhzID0gdGhpcy51eHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHgudXVpZCAhPT0gZC5hcmdzWzBdO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZC5ldmVudCA9PT0gJ21vZGlmeS1pbnRlcmZhY2UnKSB7XG4gICAgICAgIHZhciB1eCA9IHRoaXMudXhzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LnV1aWQgPT09IGQuYXJnc1swXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHV4Lmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMubW9kaWZ5KHV4WzBdLCBkLmFyZ3NbMV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGQuZXZlbnQgPT09ICdoaWRlLWludGVyZmFjZScpIHtcbiAgICAgICAgdmFyIF91eCA9IHRoaXMudXhzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LnV1aWQgPT09IGQuYXJnc1swXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKF91eC5sZW5ndGgpIHtcbiAgICAgICAgICBfdXhbMF0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm1vZGlmeShfdXhbMF0sIHtcbiAgICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGQuZXZlbnQgPT09ICdzaG93LWludGVyZmFjZScpIHtcbiAgICAgICAgdmFyIF91eDIgPSB0aGlzLnV4cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC51dWlkID09PSBkLmFyZ3NbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdXgyLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMubW9kaWZ5KF91eDJbMF0sIHtcbiAgICAgICAgICAgIGhpZGRlbjogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBtb2RpZnk6IGZ1bmN0aW9uIG1vZGlmeSh1eCwgb2JqKSB7XG4gICAgICBpZiAob2JqID09PSB2b2lkIDApIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChrIGluIHV4KSB7XG4gICAgICAgICAgdGhpcy4kc2V0KHV4LCBrLCBvYmpba10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBSZW1vdmUgYWxsIFVYcyBmb3IgYSBnaXZlbiBvdmVybGF5IGlkXG4gICAgcmVtb3ZlX2FsbF91eDogZnVuY3Rpb24gcmVtb3ZlX2FsbF91eChpZCkge1xuICAgICAgdGhpcy51eHMgPSB0aGlzLnV4cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgub3ZlcmxheS5pZCAhPT0gaWQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHV4czogW11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL2Nyb3NzaGFpci5qc1xuXG5cblxudmFyIENyb3NzaGFpciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENyb3NzaGFpcihjb21wKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Jvc3NoYWlyKTtcblxuICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgdGhpcy4kcCA9IGNvbXAuJHByb3BzO1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuJHAuc3ViO1xuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMubGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQ7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhDcm9zc2hhaXIsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2UgdG8gdGhlIGdyaWRcbiAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQ7XG4gICAgICB2YXIgY3Vyc29yID0gdGhpcy5jb21wLiRwcm9wcy5jdXJzb3I7XG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSAmJiBjdXJzb3IubW9kZSA9PT0gJ2V4cGxvcmUnKSByZXR1cm47XG4gICAgICB0aGlzLnggPSB0aGlzLiRwLmN1cnNvci54O1xuICAgICAgdGhpcy55ID0gdGhpcy4kcC5jdXJzb3IueTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5jcm9zcztcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbNV0pOyAvLyBIXG5cbiAgICAgIGlmICh0aGlzLiRwLmN1cnNvci5ncmlkX2lkID09PSB0aGlzLmxheW91dC5pZCkge1xuICAgICAgICBjdHgubW92ZVRvKDAsIHRoaXMueSk7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy5sYXlvdXQud2lkdGggLSAwLjUsIHRoaXMueSk7XG4gICAgICB9IC8vIFZcblxuXG4gICAgICBjdHgubW92ZVRvKHRoaXMueCwgMCk7XG4gICAgICBjdHgubGluZVRvKHRoaXMueCwgdGhpcy5sYXlvdXQuaGVpZ2h0KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2aXNpYmxlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Jvc3NoYWlyO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Dcm9zc2hhaXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ3Jvc3NoYWlydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0Nyb3NzaGFpcicsXG4gIHByb3BzOiBbJ2N1cnNvcicsICdjb2xvcnMnLCAnbGF5b3V0JywgJ3N1YiddLFxuICBtZXRob2RzOiB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB0aGlzLmNoID0gbmV3IENyb3NzaGFpcih0aGlzKTsgLy8gTmV3IGdyaWQgb3ZlcmxheS1yZW5kZXJlciBkZXNjcmlwdG9yLlxuICAgICAgLy8gU2hvdWxkIGltcGxlbWVudCBkcmF3KCkgKHNlZSBTcGxpbmUudnVlKVxuXG4gICAgICB0aGlzLiRlbWl0KCduZXctZ3JpZC1sYXllcicsIHtcbiAgICAgICAgbmFtZTogJ2Nyb3NzaGFpcicsXG4gICAgICAgIHJlbmRlcmVyOiB0aGlzLmNoXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgY3Vyc29yOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2gpIHRoaXMuY3JlYXRlKCk7IC8vIEV4cGxvcmUgPSBkZWZhdWx0IG1vZGUgb24gbW9iaWxlXG5cbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuJHByb3BzLmN1cnNvcjtcbiAgICAgICAgdmFyIGV4cGxvcmUgPSBjdXJzb3IubW9kZSA9PT0gJ2V4cGxvcmUnO1xuXG4gICAgICAgIGlmICghY3Vyc29yLnggfHwgIWN1cnNvci55KSB7XG4gICAgICAgICAgdGhpcy5jaC5oaWRlKCk7XG4gICAgICAgICAgdGhpcy4kZW1pdCgncmVkcmF3LWdyaWQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoLnZpc2libGUgPSAhZXhwbG9yZTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoKTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Dcm9zc2hhaXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19Dcm9zc2hhaXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ3Jvc3NoYWlydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgKG9wdGlvbnMuZnVuY3Rpb25hbCA/IHRoaXMucGFyZW50IDogdGhpcykuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdFxuICAgICAgICApXG4gICAgICB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Dcm9zc2hhaXIudnVlXG52YXIgQ3Jvc3NoYWlyX3JlbmRlciwgQ3Jvc3NoYWlyX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19Dcm9zc2hhaXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIENyb3NzaGFpcl9yZW5kZXIsXG4gIENyb3NzaGFpcl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9Dcm9zc2hhaXIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19Dcm9zc2hhaXIgPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0tleWJvYXJkTGlzdGVuZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS2V5Ym9hcmRMaXN0ZW5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdLZXlib2FyZExpc3RlbmVyJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHJldHVybiBoKCk7XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy4kZW1pdCgncmVnaXN0ZXIta2ItbGlzdGVuZXInLCB7XG4gICAgICBpZDogdGhpcy5fdWlkLFxuICAgICAga2V5ZG93bjogdGhpcy5rZXlkb3duLFxuICAgICAga2V5dXA6IHRoaXMua2V5dXAsXG4gICAgICBrZXlwcmVzczogdGhpcy5rZXlwcmVzc1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJGVtaXQoJ3JlbW92ZS1rYi1saXN0ZW5lcicsIHtcbiAgICAgIGlkOiB0aGlzLl91aWRcbiAgICB9KTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGtleWRvd246IGZ1bmN0aW9uIGtleWRvd24oZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2tleWRvd24nLCBldmVudCk7XG4gICAgfSxcbiAgICBrZXl1cDogZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2tleXVwJywgZXZlbnQpO1xuICAgIH0sXG4gICAga2V5cHJlc3M6IGZ1bmN0aW9uIGtleXByZXNzKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdrZXlwcmVzcycsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvS2V5Ym9hcmRMaXN0ZW5lci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0tleWJvYXJkTGlzdGVuZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoS2V5Ym9hcmRMaXN0ZW5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvS2V5Ym9hcmRMaXN0ZW5lci52dWVcbnZhciBLZXlib2FyZExpc3RlbmVyX3JlbmRlciwgS2V5Ym9hcmRMaXN0ZW5lcl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBLZXlib2FyZExpc3RlbmVyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19LZXlib2FyZExpc3RlbmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBLZXlib2FyZExpc3RlbmVyX3JlbmRlcixcbiAgS2V5Ym9hcmRMaXN0ZW5lcl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEtleWJvYXJkTGlzdGVuZXJfYXBpOyB9XG5LZXlib2FyZExpc3RlbmVyX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvS2V5Ym9hcmRMaXN0ZW5lci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLZXlib2FyZExpc3RlbmVyID0gKEtleWJvYXJkTGlzdGVuZXJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVXhMYXllci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzkwY2NmNmUmXG52YXIgVXhMYXllcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5MGNjZjZlX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcInNwYW5cIixcbiAgICB7IGNsYXNzOiBcInRyYWRpbmctdnVlLWdyaWQtdXgtXCIgKyBfdm0uaWQsIHN0eWxlOiBfdm0uc3R5bGUgfSxcbiAgICBfdm0uX2woX3ZtLnV4cywgZnVuY3Rpb24odXgpIHtcbiAgICAgIHJldHVybiBfYyhcInV4LXdyYXBwZXJcIiwge1xuICAgICAgICBrZXk6IHV4LnV1aWQsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdXg6IHV4LFxuICAgICAgICAgIHVwZGF0ZXI6IF92bS51cGRhdGVyLFxuICAgICAgICAgIGNvbG9yczogX3ZtLmNvbG9ycyxcbiAgICAgICAgICBjb25maWc6IF92bS5jb25maWdcbiAgICAgICAgfSxcbiAgICAgICAgb246IHsgXCJjdXN0b20tZXZlbnRcIjogX3ZtLm9uX2N1c3RvbV9ldmVudCB9XG4gICAgICB9KVxuICAgIH0pLFxuICAgIDFcbiAgKVxufVxudmFyIFV4TGF5ZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTBjY2Y2ZV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuVXhMYXllcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5MGNjZjZlX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1V4TGF5ZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM5MGNjZjZlJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9VeFdyYXBwZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTRiYzMyMDcwJlxudmFyIFV4V3JhcHBlcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRiYzMyMDcwX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0udmlzaWJsZVxuICAgID8gX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS11eC13cmFwcGVyXCIsXG4gICAgICAgICAgc3R5bGU6IF92bS5zdHlsZSxcbiAgICAgICAgICBhdHRyczogeyBpZDogXCJ0dmpzLXV4LXdyYXBwZXItXCIgKyBfdm0udXgudXVpZCB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhfdm0udXguY29tcG9uZW50LCB7XG4gICAgICAgICAgICB0YWc6IFwiY29tcG9uZW50XCIsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICB1eDogX3ZtLnV4LFxuICAgICAgICAgICAgICB1cGRhdGVyOiBfdm0udXBkYXRlcixcbiAgICAgICAgICAgICAgd3JhcHBlcjogX3ZtLndyYXBwZXIsXG4gICAgICAgICAgICAgIGNvbG9yczogX3ZtLmNvbG9yc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB7IFwiY3VzdG9tLWV2ZW50XCI6IF92bS5vbl9jdXN0b21fZXZlbnQgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX3ZtLnV4LnNob3dfcGluXG4gICAgICAgICAgICA/IF9jKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXV4LXdyYXBwZXItcGluXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IF92bS5waW5fc3R5bGVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfdm0udXgud2luX2hlYWRlciAhPT0gZmFsc2VcbiAgICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0dmpzLXV4LXdyYXBwZXItaGVhZFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMtdXgtd3JhcHBlci1jbG9zZVwiLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogX3ZtLmJ0bl9zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5jbG9zZSB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW192bS5fdihcIsOXXCIpXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKVxuICAgIDogX3ZtLl9lKClcbn1cbnZhciBVeFdyYXBwZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF80YmMzMjA3MF9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuVXhXcmFwcGVydnVlX3R5cGVfdGVtcGxhdGVfaWRfNGJjMzIwNzBfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVXhXcmFwcGVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00YmMzMjA3MCZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1V4V3JhcHBlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBVeFdyYXBwZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVXhXcmFwcGVyJyxcbiAgcHJvcHM6IFsndXgnLCAndXBkYXRlcicsICdjb2xvcnMnLCAnY29uZmlnJ10sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5zZWxmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy51dWlkKTtcbiAgICB0aGlzLncgPSB0aGlzLnNlbGYub2Zmc2V0V2lkdGg7IC8vIFRPRE86ID0+IHdpZHRoOiBcImNvbnRlbnRcIlxuXG4gICAgdGhpcy5oID0gdGhpcy5zZWxmLm9mZnNldEhlaWdodDsgLy8gVE9ETzogPT4gaGVpZ2h0OiBcImNvbnRlbnRcIlxuXG4gICAgdGhpcy51cGRhdGVfcG9zaXRpb24oKTtcbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgdGhpcy5tb3VzZS5vbignbW91c2VvdXQnLCB0aGlzLm1vdXNlb3V0KTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLm1vdXNlLm9mZignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZW1vdmUpO1xuICAgIHRoaXMubW91c2Uub2ZmKCdtb3VzZW91dCcsIHRoaXMubW91c2VvdXQpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdXBkYXRlX3Bvc2l0aW9uOiBmdW5jdGlvbiB1cGRhdGVfcG9zaXRpb24oKSB7XG4gICAgICBpZiAodGhpcy51eHIuaGlkZGVuKSByZXR1cm47XG4gICAgICB2YXIgbHcgPSB0aGlzLmxheW91dC53aWR0aDtcbiAgICAgIHZhciBsaCA9IHRoaXMubGF5b3V0LmhlaWdodDtcbiAgICAgIHZhciBwaW4gPSB0aGlzLnV4ci5waW47XG5cbiAgICAgIHN3aXRjaCAocGluWzBdKSB7XG4gICAgICAgIGNhc2UgJ2N1cnNvcic6XG4gICAgICAgICAgdmFyIHggPSB0aGlzLnV4ci5vdmVybGF5LmN1cnNvci54O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21vdXNlJzpcbiAgICAgICAgICB4ID0gdGhpcy5tb3VzZS54O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHR5cGVvZiBwaW5bMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5wYXJzZV9jb29yZChwaW5bMF0sIGx3KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRoaXMubGF5b3V0LnQyc2NyZWVuKHBpblswXSk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocGluWzFdKSB7XG4gICAgICAgIGNhc2UgJ2N1cnNvcic6XG4gICAgICAgICAgdmFyIHkgPSB0aGlzLnV4ci5vdmVybGF5LmN1cnNvci55O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21vdXNlJzpcbiAgICAgICAgICB5ID0gdGhpcy5tb3VzZS55O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHR5cGVvZiBwaW5bMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5wYXJzZV9jb29yZChwaW5bMV0sIGxoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHRoaXMubGF5b3V0LiQyc2NyZWVuKHBpblsxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMueCA9IHggKyB0aGlzLm94O1xuICAgICAgdGhpcy55ID0geSArIHRoaXMub3k7XG4gICAgfSxcbiAgICBwYXJzZV9jb29yZDogZnVuY3Rpb24gcGFyc2VfY29vcmQoc3RyLCBzY2FsZSkge1xuICAgICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICAgIGlmIChzdHIgPT09ICcwJyB8fCBzdHIgPT09ICcnKSByZXR1cm4gMDtcbiAgICAgIHZhciBwbHVzID0gc3RyLnNwbGl0KCcrJyk7XG5cbiAgICAgIGlmIChwbHVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9jb29yZChwbHVzWzBdLCBzY2FsZSkgKyB0aGlzLnBhcnNlX2Nvb3JkKHBsdXNbMV0sIHNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pbnVzID0gc3RyLnNwbGl0KCctJyk7XG5cbiAgICAgIGlmIChtaW51cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfY29vcmQobWludXNbMF0sIHNjYWxlKSAtIHRoaXMucGFyc2VfY29vcmQobWludXNbMV0sIHNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBlciA9IHN0ci5zcGxpdCgnJScpO1xuXG4gICAgICBpZiAocGVyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gc2NhbGUgKiBwYXJzZUludChwZXJbMF0pIC8gMTAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHggPSBzdHIuc3BsaXQoJ3B4Jyk7XG5cbiAgICAgIGlmIChweC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHB4WzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKCkge1xuICAgICAgdGhpcy51cGRhdGVfcG9zaXRpb24oKTtcbiAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfSxcbiAgICBtb3VzZW91dDogZnVuY3Rpb24gbW91c2VvdXQoKSB7XG4gICAgICBpZiAodGhpcy51eHIucGluLmluY2x1ZGVzKCdjdXJzb3InKSB8fCB0aGlzLnV4ci5waW4uaW5jbHVkZXMoJ21vdXNlJykpIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgb25fY3VzdG9tX2V2ZW50OiBmdW5jdGlvbiBvbl9jdXN0b21fZXZlbnQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIGV2ZW50KTtcblxuICAgICAgaWYgKGV2ZW50LmV2ZW50ID09PSAnbW9kaWZ5LWludGVyZmFjZScpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZikge1xuICAgICAgICAgIHRoaXMudyA9IHRoaXMuc2VsZi5vZmZzZXRXaWR0aDtcbiAgICAgICAgICB0aGlzLmggPSB0aGlzLnNlbGYub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVfcG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6ICdjbG9zZS1pbnRlcmZhY2UnLFxuICAgICAgICBhcmdzOiBbdGhpcy4kcHJvcHMudXgudXVpZF1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICB1eHI6IGZ1bmN0aW9uIHV4cigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy51eDsgLy8ganVzdCBhIHJlZlxuICAgIH0sXG4gICAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMudXgub3ZlcmxheS5sYXlvdXQ7XG4gICAgfSxcbiAgICBzZXR0aW5nczogZnVuY3Rpb24gc2V0dGluZ3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMudXgub3ZlcmxheS5zZXR0aW5ncztcbiAgICB9LFxuICAgIHV1aWQ6IGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgICByZXR1cm4gXCJ0dmpzLXV4LXdyYXBwZXItXCIuY29uY2F0KHRoaXMudXhyLnV1aWQpO1xuICAgIH0sXG4gICAgbW91c2U6IGZ1bmN0aW9uIG1vdXNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXhyLm92ZXJsYXkubW91c2U7XG4gICAgfSxcbiAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUoKSB7XG4gICAgICB2YXIgc3QgPSB7XG4gICAgICAgICdkaXNwbGF5JzogdGhpcy51eHIuaGlkZGVuID8gJ25vbmUnIDogdW5kZWZpbmVkLFxuICAgICAgICAnbGVmdCc6IFwiXCIuY29uY2F0KHRoaXMueCwgXCJweFwiKSxcbiAgICAgICAgJ3RvcCc6IFwiXCIuY29uY2F0KHRoaXMueSwgXCJweFwiKSxcbiAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogdGhpcy51eHIucG9pbnRlcl9ldmVudHMgfHwgJ2FsbCcsXG4gICAgICAgICd6LWluZGV4JzogdGhpcy56X2luZGV4XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMudXhyLndpbl9zdHlsaW5nICE9PSBmYWxzZSkgc3QgPSBPYmplY3QuYXNzaWduKHN0LCB7XG4gICAgICAgICdib3JkZXInOiBcIjFweCBzb2xpZCBcIi5jb25jYXQodGhpcy4kcHJvcHMuY29sb3JzLmdyaWQpLFxuICAgICAgICAnYm9yZGVyLXJhZGl1cyc6ICczcHgnLFxuICAgICAgICAnYmFja2dyb3VuZCc6IFwiXCIuY29uY2F0KHRoaXMuYmFja2dyb3VuZClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0O1xuICAgIH0sXG4gICAgcGluX3N0eWxlOiBmdW5jdGlvbiBwaW5fc3R5bGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbGVmdCc6IFwiXCIuY29uY2F0KC10aGlzLm94LCBcInB4XCIpLFxuICAgICAgICAndG9wJzogXCJcIi5jb25jYXQoLXRoaXMub3ksIFwicHhcIiksXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogdGhpcy51eHIucGluX2NvbG9yXG4gICAgICB9O1xuICAgIH0sXG4gICAgYnRuX3N0eWxlOiBmdW5jdGlvbiBidG5fc3R5bGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnYmFja2dyb3VuZCc6IFwiXCIuY29uY2F0KHRoaXMuaW5hY3RpdmVfYnRuX2NvbG9yKSxcbiAgICAgICAgJ2NvbG9yJzogXCJcIi5jb25jYXQodGhpcy5pbmFjdGl2ZV9idG5fY29sb3IpXG4gICAgICB9O1xuICAgIH0sXG4gICAgcGluX3BvczogZnVuY3Rpb24gcGluX3BvcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnV4ci5waW5fcG9zaXRpb24gPyB0aGlzLnV4ci5waW5fcG9zaXRpb24uc3BsaXQoJywnKSA6IFsnMCcsICcwJ107XG4gICAgfSxcbiAgICAvLyBPZmZzZXQgeFxuICAgIG94OiBmdW5jdGlvbiBveCgpIHtcbiAgICAgIGlmICh0aGlzLnBpbl9wb3MubGVuZ3RoICE9PSAyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIHggPSB0aGlzLnBhcnNlX2Nvb3JkKHRoaXMucGluX3Bvc1swXSwgdGhpcy53KTtcbiAgICAgIHJldHVybiAteDtcbiAgICB9LFxuICAgIC8vIE9mZnNldCB5XG4gICAgb3k6IGZ1bmN0aW9uIG95KCkge1xuICAgICAgaWYgKHRoaXMucGluX3Bvcy5sZW5ndGggIT09IDIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgeSA9IHRoaXMucGFyc2VfY29vcmQodGhpcy5waW5fcG9zWzFdLCB0aGlzLmgpO1xuICAgICAgcmV0dXJuIC15O1xuICAgIH0sXG4gICAgel9pbmRleDogZnVuY3Rpb24gel9pbmRleCgpIHtcbiAgICAgIHZhciBiYXNlX2luZGV4ID0gdGhpcy5zZXR0aW5nc1snei1pbmRleCddIHx8IHRoaXMuc2V0dGluZ3NbJ3pJbmRleCddIHx8IDA7XG4gICAgICB2YXIgdXhfaW5kZXggPSB0aGlzLnV4clsnel9pbmRleCddIHx8IDA7XG4gICAgICByZXR1cm4gYmFzZV9pbmRleCArIHV4X2luZGV4O1xuICAgIH0sXG4gICAgYmFja2dyb3VuZDogZnVuY3Rpb24gYmFja2dyb3VuZCgpIHtcbiAgICAgIHZhciBjID0gdGhpcy51eHIuYmFja2dyb3VuZCB8fCB0aGlzLiRwcm9wcy5jb2xvcnMuYmFjaztcbiAgICAgIHJldHVybiB1dGlscy5hcHBseV9vcGFjaXR5KGMsIHRoaXMudXhyLmJhY2tncm91bmRfb3BhY2l0eSB8fCB0aGlzLiRwcm9wcy5jb25maWcuVVhfT1BBQ0lUWSk7XG4gICAgfSxcbiAgICBpbmFjdGl2ZV9idG5fY29sb3I6IGZ1bmN0aW9uIGluYWN0aXZlX2J0bl9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnV4ci5pbmFjdGl2ZV9idG5fY29sb3IgfHwgdGhpcy4kcHJvcHMuY29sb3JzLmdyaWQ7XG4gICAgfSxcbiAgICB3cmFwcGVyOiBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy54LFxuICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgIHBpbl94OiB0aGlzLnggLSB0aGlzLm94LFxuICAgICAgICBwaW5feTogdGhpcy55IC0gdGhpcy5veVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdXBkYXRlcjogZnVuY3Rpb24gdXBkYXRlcigpIHtcbiAgICAgIHRoaXMudXBkYXRlX3Bvc2l0aW9uKCk7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHc6IDAsXG4gICAgICBoOiAwLFxuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVXhXcmFwcGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfVXhXcmFwcGVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFV4V3JhcHBlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1V4V3JhcHBlci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBVeFdyYXBwZXJ2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTY1KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1V4V3JhcHBlci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVXhXcmFwcGVyLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFV4V3JhcHBlcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfVXhXcmFwcGVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBVeFdyYXBwZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF80YmMzMjA3MF9yZW5kZXIsXG4gIFV4V3JhcHBlcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRiYzMyMDcwX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVXhXcmFwcGVyX2FwaTsgfVxuVXhXcmFwcGVyX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvVXhXcmFwcGVyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFV4V3JhcHBlciA9IChVeFdyYXBwZXJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1V4TGF5ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBVeExheWVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1V4TGF5ZXInLFxuICBwcm9wczogWyd0dl9pZCcsICdpZCcsICd1eHMnLCAndXBkYXRlcicsICdjb2xvcnMnLCAnY29uZmlnJ10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBVeFdyYXBwZXI6IFV4V3JhcHBlclxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge30sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7fSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHt9LFxuICBtZXRob2RzOiB7XG4gICAgb25fY3VzdG9tX2V2ZW50OiBmdW5jdGlvbiBvbl9jdXN0b21fZXZlbnQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3RvcCc6IHRoaXMuJHByb3BzLmlkICE9PSAwID8gJzFweCcgOiAwLFxuICAgICAgICAnbGVmdCc6IDAsXG4gICAgICAgICd3aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgJ2hlaWdodCc6ICdjYWxjKDEwMCUgLSAycHgpJyxcbiAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAgICAgICAgJ3otaW5kZXgnOiAnMScsXG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJyxcbiAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbidcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1V4TGF5ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19VeExheWVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFV4TGF5ZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1V4TGF5ZXIudnVlXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFV4TGF5ZXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1V4TGF5ZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFV4TGF5ZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTBjY2Y2ZV9yZW5kZXIsXG4gIFV4TGF5ZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTBjY2Y2ZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFV4TGF5ZXJfYXBpOyB9XG5VeExheWVyX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvVXhMYXllci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBVeExheWVyID0gKFV4TGF5ZXJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0dWZmL21vdXNlLmpzXG5cblxuXG5mdW5jdGlvbiBtb3VzZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gbW91c2VfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIG1vdXNlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gbW91c2VfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIG1vdXNlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBtb3VzZV9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBNb3VzZSBldmVudCBoYW5kbGVyIGZvciBvdmVybGF5XG52YXIgTW91c2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb3VzZShjb21wKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW91c2UpO1xuXG4gICAgdGhpcy5jb21wID0gY29tcDtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMubGlzdGVuZXJzID0gMDtcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnggPSBjb21wLiRwcm9wcy5jdXJzb3IueDtcbiAgICB0aGlzLnkgPSBjb21wLiRwcm9wcy5jdXJzb3IueTtcbiAgICB0aGlzLnQgPSBjb21wLiRwcm9wcy5jdXJzb3IudDtcbiAgICB0aGlzLnkkID0gY29tcC4kcHJvcHMuY3Vyc29yLnkkO1xuICB9IC8vIFlvdSBjYW4gY2hvb3NlIHdoZXJlIHRvIHBsYWNlIHRoZSBoYW5kbGVyXG4gIC8vIChiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBxdWV1ZSlcblxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKE1vdXNlLCBbe1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihuYW1lLCBoYW5kbGVyLCBkaXIpIHtcbiAgICAgIGlmIChkaXIgPT09IHZvaWQgMCkge1xuICAgICAgICBkaXIgPSBcInVuc2hpZnRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5kbGVyKSByZXR1cm47XG4gICAgICB0aGlzLm1hcFtuYW1lXSA9IHRoaXMubWFwW25hbWVdIHx8IFtdO1xuICAgICAgdGhpcy5tYXBbbmFtZV1bZGlyXShoYW5kbGVyKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzKys7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9mZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYobmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCF0aGlzLm1hcFtuYW1lXSkgcmV0dXJuO1xuICAgICAgdmFyIGkgPSB0aGlzLm1hcFtuYW1lXS5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgaWYgKGkgPCAwKSByZXR1cm47XG4gICAgICB0aGlzLm1hcFtuYW1lXS5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLmxpc3RlbmVycy0tO1xuICAgIH0gLy8gQ2FsbGVkIGJ5IGdyaWQuanNcblxuICB9LCB7XG4gICAga2V5OiBcImVtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChuYW1lLCBldmVudCkge1xuICAgICAgdmFyIGwgPSB0aGlzLmNvbXAubGF5b3V0O1xuXG4gICAgICBpZiAobmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gbW91c2VfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLm1hcFtuYW1lXSksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgZihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgIHRoaXMueCA9IGV2ZW50LmxheWVyWDtcbiAgICAgICAgdGhpcy55ID0gZXZlbnQubGF5ZXJZO1xuICAgICAgICB0aGlzLnQgPSBsLnNjcmVlbjJ0KHRoaXMueCk7XG4gICAgICAgIHRoaXMueSQgPSBsLnNjcmVlbjIkKHRoaXMueSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNb3VzZTtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL292ZXJsYXkuanNcbi8vIFVzdWZ1bCBzdHVmZiBmb3IgY3JlYXRpbmcgb3ZlcmxheXMuIEluY2x1ZGUgYXMgbWl4aW5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5ID0gKHtcbiAgcHJvcHM6IFsnaWQnLCAnbnVtJywgJ2ludGVydmFsJywgJ2N1cnNvcicsICdjb2xvcnMnLCAnbGF5b3V0JywgJ3N1YicsICdkYXRhJywgJ3NldHRpbmdzJywgJ2dyaWRfaWQnLCAnZm9udCcsICdjb25maWcnLCAnbWV0YScsICd0ZicsICdpMCcsICdsYXN0J10sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgLy8gVE9ETygxKTogd2hlbiBob3QgcmVsb2FkaW5nLCBkeW5hbWljYWx5IGNoYW5nZWQgbWl4aW5zXG4gICAgLy8gZGlzc2FwZWFyIChjdXogaXQncyBhIGhhY2spLCB0aGUgb25seSB3YXkgZm9yIG5vd1xuICAgIC8vIGlzIHRvIHJlbG9hZCB0aGUgYnJvd3NlclxuICAgIGlmICghdGhpcy5kcmF3KSB7XG4gICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciB0ZXh0ID0gJ0VBUkxZIEFET1BURVIgQlVHOiByZWxvYWQgdGhlIGJyb3dzZXIgJiBlbmpveSc7XG4gICAgICAgIGNvbnNvbGUud2Fybih0ZXh0KTtcbiAgICAgIH07XG4gICAgfSAvLyBNYWluIGNoYXJ0P1xuXG5cbiAgICB2YXIgbWFpbiA9IHRoaXMuJHByb3BzLnN1YiA9PT0gdGhpcy4kcHJvcHMuZGF0YTtcbiAgICB0aGlzLm1ldGFfaW5mbygpOyAvLyBUT0RPKDEpOiBxdWljayBmaXggZm9yIHZ1ZTIsIGluIHZ1ZTMgd2UgdXNlIDNyZCBwYXJ0eSBlbWl0XG5cbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIHRoaXMuJGVtaXQpKCk7XG4gICAgICB0aGlzLl8kZW1pdCA9IHRoaXMuJGVtaXQ7XG4gICAgICB0aGlzLiRlbWl0ID0gdGhpcy5jdXN0b21fZXZlbnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuXyRlbWl0KCduZXctZ3JpZC1sYXllcicsIHtcbiAgICAgIG5hbWU6IHRoaXMuJG9wdGlvbnMubmFtZSxcbiAgICAgIGlkOiB0aGlzLiRwcm9wcy5pZCxcbiAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgZGlzcGxheTogJ2Rpc3BsYXknIGluIHRoaXMuJHByb3BzLnNldHRpbmdzID8gdGhpcy4kcHJvcHMuc2V0dGluZ3NbJ2Rpc3BsYXknXSA6IHRydWUsXG4gICAgICB6OiB0aGlzLiRwcm9wcy5zZXR0aW5nc1snei1pbmRleCddIHx8IHRoaXMuJHByb3BzLnNldHRpbmdzWyd6SW5kZXgnXSB8fCAobWFpbiA/IDAgOiAtMSlcbiAgICB9KTsgLy8gT3ZlcmxheSBtZXRhLXByb3BzIChhZGp1c3RpbmcgYmVoYXZpb3VyKVxuXG5cbiAgICB0aGlzLl8kZW1pdCgnbGF5ZXItbWV0YS1wcm9wcycsIHtcbiAgICAgIGdyaWRfaWQ6IHRoaXMuJHByb3BzLmdyaWRfaWQsXG4gICAgICBsYXllcl9pZDogdGhpcy4kcHJvcHMuaWQsXG4gICAgICBsZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgZGF0YV9jb2xvcnM6IHRoaXMuZGF0YV9jb2xvcnMsXG4gICAgICB5X3JhbmdlOiB0aGlzLnlfcmFuZ2VcbiAgICB9KTtcblxuICAgIHRoaXMuZXhlY19zY3JpcHQoKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlKHRoaXMpO1xuICAgIGlmICh0aGlzLmluaXRfdG9vbCkgdGhpcy5pbml0X3Rvb2woKTtcbiAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQoKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95KSB0aGlzLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuXyRlbWl0KCdkZWxldGUtZ3JpZC1sYXllcicsIHRoaXMuJHByb3BzLmlkKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICAvKiBvdmVycmlkZSBpdCAobWFuZGF0b3J5KSAqL1xuICAgICAgY29uc29sZS53YXJuKCd1c2VfZm9yKCkgc2hvdWxkIGJlIGltcGxlbWVudGVkJyk7XG4gICAgICBjb25zb2xlLndhcm4oXCJGb3JtYXQ6IHVzZV9mb3IoKSB7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndHlwZTEnLCAndHlwZTInLCAuLi5dXFxuICAgICAgICAgICAgfVwiKTtcbiAgICB9LFxuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgLyogb3ZlcnJpZGUgaXQgKG9wdGlvbmFsKSAqL1xuICAgICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuaWQ7XG4gICAgICBjb25zb2xlLndhcm4oXCJcIi5jb25jYXQoaWQsIFwiIG1ldGFfaW5mbygpIGlzIHJlcS4gZm9yIHB1Ymxpc2hpbmdcIikpO1xuICAgICAgY29uc29sZS53YXJuKFwiRm9ybWF0OiBtZXRhX2luZm8oKSB7XFxuICAgICAgICAgICAgICAgIGF1dGhvcjogJ1NhdG9zaGkgU21pdGgnLFxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxcbiAgICAgICAgICAgICAgICBjb250YWN0IChvcHQpICc8ZW1haWw+J1xcbiAgICAgICAgICAgICAgICBnaXRodWI6IChvcHQpICc8R2l0SHViIFBhZ2U+JyxcXG4gICAgICAgICAgICB9XCIpO1xuICAgIH0sXG4gICAgY3VzdG9tX2V2ZW50OiBmdW5jdGlvbiBjdXN0b21fZXZlbnQoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zcGxpdCgnOicpWzBdID09PSAnaG9vaycpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50ID09PSAnY2hhbmdlLXNldHRpbmdzJyB8fCBldmVudCA9PT0gJ29iamVjdC1zZWxlY3RlZCcgfHwgZXZlbnQgPT09ICduZXctc2hhZGVyJyB8fCBldmVudCA9PT0gJ25ldy1pbnRlcmZhY2UnIHx8IGV2ZW50ID09PSAncmVtb3ZlLXRvb2wnKSB7XG4gICAgICAgIGFyZ3MucHVzaCh0aGlzLmdyaWRfaWQsIHRoaXMuaWQpO1xuXG4gICAgICAgIGlmICh0aGlzLiRwcm9wcy5zZXR0aW5ncy4kdXVpZCkge1xuICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLiRwcm9wcy5zZXR0aW5ncy4kdXVpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50ID09PSAnbmV3LWludGVyZmFjZScpIHtcbiAgICAgICAgYXJnc1swXS5vdmVybGF5ID0gdGhpcztcbiAgICAgICAgYXJnc1swXS51dWlkID0gdGhpcy5sYXN0X3V4X2lkID0gXCJcIi5jb25jYXQodGhpcy5ncmlkX2lkLCBcIi1cIikuY29uY2F0KHRoaXMuaWQsIFwiLVwiKS5jb25jYXQodGhpcy51eHNfY291bnQrKyk7XG4gICAgICB9IC8vIFRPRE86IGFkZCBhIG5hbWVzcGFjZSB0byB0aGUgZXZlbnQgbmFtZVxuICAgICAgLy8gVE9ETygyKTogdGhpcyBwcmV2ZW50cyBjYWxsIG92ZXJmbG93LCBidXRcbiAgICAgIC8vIHRoZSByb290IG9mIGV2aWwgaXMgaW4gKDEpXG5cblxuICAgICAgaWYgKGV2ZW50ID09PSAnY3VzdG9tLWV2ZW50JykgcmV0dXJuO1xuXG4gICAgICB0aGlzLl8kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gVE9ETzogdGhlIGV2ZW50IGlzIG5vdCBmaXJpbmcgd2hlbiB0aGUgc2FtZVxuICAgIC8vIG92ZXJsYXkgdHlwZSBpcyBhZGRlZCB0byB0aGUgb2ZmY2hhcnRbXVxuICAgIGV4ZWNfc2NyaXB0OiBmdW5jdGlvbiBleGVjX3NjcmlwdCgpIHtcbiAgICAgIGlmICh0aGlzLmNhbGMpIHRoaXMuJGVtaXQoJ2V4ZWMtc2NyaXB0Jywge1xuICAgICAgICBncmlkX2lkOiB0aGlzLiRwcm9wcy5ncmlkX2lkLFxuICAgICAgICBsYXllcl9pZDogdGhpcy4kcHJvcHMuaWQsXG4gICAgICAgIHNyYzogdGhpcy5jYWxjKCksXG4gICAgICAgIHVzZV9mb3I6IHRoaXMudXNlX2ZvcigpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobiwgcCkge1xuICAgICAgICBpZiAodGhpcy53YXRjaF91dWlkKSB0aGlzLndhdGNoX3V1aWQobiwgcCk7XG5cbiAgICAgICAgdGhpcy5fJGVtaXQoJ3Nob3ctZ3JpZC1sYXllcicsIHtcbiAgICAgICAgICBpZDogdGhpcy4kcHJvcHMuaWQsXG4gICAgICAgICAgZGlzcGxheTogJ2Rpc3BsYXknIGluIHRoaXMuJHByb3BzLnNldHRpbmdzID8gdGhpcy4kcHJvcHMuc2V0dGluZ3NbJ2Rpc3BsYXknXSA6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXhzX2NvdW50OiAwLFxuICAgICAgbGFzdF91eF9pZDogbnVsbFxuICAgIH07XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICByZXR1cm4gaCgpO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpbmUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gU3BsaW5lIHJlbmRlcmVyLiAoU01BcywgRU1BcywgVEVNQXMuLi5cbi8vIHlvdSBrbm93IHdoYXQgSSBtZWFuKVxuLy8gVE9ETzogbWFrZSBhIHJlYWwgc3BsaW5lLCBub3QgYSBidW5jaCBvZiBsaW5lcy4uLlxuLy8gQWRkcyBhbGwgbmVjZXNzYXJ5IHN0dWZmIGZvciB5b3UuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3BsaW5ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NwbGluZScsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMS4yJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIEhlcmUgZ29lcyB5b3VyIGNvZGUuIFlvdSBhcmUgcHJvdmlkZWQgd2l0aDpcbiAgICAvLyB7IEFsbCBzdHVmZiBpcyByZWFjdGl2ZSB9XG4gICAgLy8gJHByb3BzLmxheW91dCAtPiBwb3NpdGlvbnMgb2YgYWxsIGNoYXJ0IGVsZW1lbnRzICtcbiAgICAvLyAgc29tZSBoZWxwZXIgZnVuY3Rpb25zIChzZWUgbGF5b3V0X2ZuLmpzKVxuICAgIC8vICRwcm9wcy5pbnRlcnZhbCAtPiBjYW5kbGVzdGljayB0aW1lIGludGVydmFsXG4gICAgLy8gJHByb3BzLnN1YiAtPiBjdXJyZW50IHN1YnNldCBvZiBjYW5kbGVzdGljayBkYXRhXG4gICAgLy8gJHByb3BzLmRhdGEgLT4geW91ciBpbmRpY2F0b3IncyBkYXRhIHN1YnNldC5cbiAgICAvLyAgQ29tZXMgXCJhcyBpc1wiLCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAgICAvLyAgW1s8dGltZXN0YW1wPiwgLi4uIF0sIC4uLiBdXG4gICAgLy8gJHByb3BzLmNvbG9ycyAtPiBjb2xvcnMgKHNlZSBUcmFkaW5nVnVlLnZ1ZSlcbiAgICAvLyAkcHJvcHMuY3Vyc29yIC0+IGN1cnJlbnQgcG9zaXRpb24gb2YgY3Jvc3NoYWlyXG4gICAgLy8gJHByb3BzLnNldHRpbmdzIC0+IGluZGljYXRvcidzIGN1c3RvbSBzZXR0aW5nc1xuICAgIC8vICBFLmcuIGNvbG9ycywgbGluZSB0aGlja25lc3MsIGV0Yy4gWW91IGRlZmluZSBpdC5cbiAgICAvLyAkcHJvcHMubnVtIC0+IGluZGljYXRvcidzIGxheWVyIG51bWJlciAob2YgQWxsXG4gICAgLy8gbGF5ZXJzIGluIHRoZSBjdXJyZW50IGdyaWQpXG4gICAgLy8gJHByb3BzLmlkIC0+IGluZGljYXRvcidzIGlkIChlLmcuIEVNQV8wKVxuICAgIC8vIH5cbiAgICAvLyBGaW5hbGx5LCBsZXQncyBtYWtlIHRoZSBjYW52YXMgZGlydHkhXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBpID0gdGhpcy5kYXRhX2luZGV4O1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLiRwcm9wcy5kYXRhO1xuXG4gICAgICBpZiAoIXRoaXMuc2tpcF9uYW4pIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgayA8IG47IGsrKykge1xuICAgICAgICAgIHZhciBwID0gZGF0YVtrXTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcbiAgICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwW2ldKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2tpcCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICB2YXIgX3AgPSBkYXRhW2tdO1xuXG4gICAgICAgICAgdmFyIF94ID0gbGF5b3V0LnQyc2NyZWVuKF9wWzBdKTtcblxuICAgICAgICAgIHZhciBfeSA9IGxheW91dC4kMnNjcmVlbihfcFtpXSk7XG5cbiAgICAgICAgICBpZiAoX3BbaV0gPT0gbnVsbCB8fCBfeSAhPT0gX3kpIHtcbiAgICAgICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2tpcCkgY3R4Lm1vdmVUbyhfeCwgX3kpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhfeCwgX3kpO1xuICAgICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICAvLyBGb3IgYWxsIGRhdGEgd2l0aCB0aGVzZSB0eXBlcyBvdmVybGF5IHdpbGwgYmVcbiAgICAvLyBhZGRlZCB0byB0aGUgcmVuZGVyZXIgbGlzdC4gQW5kICckcHJvcHMuZGF0YSdcbiAgICAvLyB3aWxsIGhhdmUgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLiBJZiB5b3Ugd2FudCB0b1xuICAgIC8vIHJlZGVmaW5lIHRoZSBkZWZhdWx0IGJlaHZpb3VyIGZvciBhIHBydGljdWxhclxuICAgIC8vIGluZGljYXRvciAobGV0J3Mgc2F5IEVNQSksXG4gICAgLy8ganVzdCBjcmVhdGUgYSBuZXcgb3ZlcmxheSB3aXRoIHRoZSBzYW1lIHR5cGU6XG4gICAgLy8gZS5nLiB1c2VfZm9yKCkgeyByZXR1cm4gWydFTUEnXSB9LlxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydTcGxpbmUnLCAnRU1BJywgJ1NNQSddO1xuICAgIH0sXG4gICAgLy8gQ29sb3JzIGZvciB0aGUgbGVnZW5kLCBzaG91bGQgaGF2ZSB0aGVcbiAgICAvLyBzYW1lIGRpbWVudGlvbiBhcyBhIGRhdGEgcG9pbnQgKGV4Y2wuIHRpbWVzdGFtcClcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3JdO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC43NTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHZhciBuID0gdGhpcy4kcHJvcHMubnVtICUgNTtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgdGhpcy5DT0xPUlNbbl07XG4gICAgfSxcbiAgICBkYXRhX2luZGV4OiBmdW5jdGlvbiBkYXRhX2luZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5kYXRhSW5kZXggfHwgMTtcbiAgICB9LFxuICAgIC8vIERvbid0IGNvbm5lY3Qgc2VwYXJhdGUgcGFydHMgaWYgdHJ1ZVxuICAgIHNraXBfbmFuOiBmdW5jdGlvbiBza2lwX25hbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2tpcE5hTjtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIENPTE9SUzogWycjNDJiMjhhJywgJyM1NjkxY2UnLCAnIzYxMmZmOScsICcjZDUwYjkwJywgJyNmZjIzMTYnXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaW5lLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX1NwbGluZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTcGxpbmV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGluZS52dWVcbnZhciBTcGxpbmVfcmVuZGVyLCBTcGxpbmVfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU3BsaW5lX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfU3BsaW5ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTcGxpbmVfcmVuZGVyLFxuICBTcGxpbmVfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTcGxpbmVfYXBpOyB9XG5TcGxpbmVfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpbmUudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3BsaW5lID0gKFNwbGluZV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaW5lcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBDaGFubmVsIHJlbmRlcmVyLiAoS2VsdG5lciwgQm9sbGluZ2VyKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNwbGluZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU3BsaW5lcycsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMS4wJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXNfbnVtOyBpKyspIHtcbiAgICAgICAgdmFyIF9pID0gaSAlIHRoaXMuY2xyeC5sZW5ndGg7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jbHJ4W19pXTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMud2lkdGhzW2ldIHx8IHRoaXMubGluZV93aWR0aDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmRyYXdfc3BsaW5lKGN0eCwgaSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYXdfc3BsaW5lOiBmdW5jdGlvbiBkcmF3X3NwbGluZShjdHgsIGkpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuJHByb3BzLmRhdGE7XG5cbiAgICAgIGlmICghdGhpcy5za2lwX25hbikge1xuICAgICAgICBmb3IgKHZhciBrID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBrIDwgbjsgaysrKSB7XG4gICAgICAgICAgdmFyIHAgPSBkYXRhW2tdO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuICAgICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbaSArIDFdKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2tpcCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICB2YXIgX3AgPSBkYXRhW2tdO1xuXG4gICAgICAgICAgdmFyIF94ID0gbGF5b3V0LnQyc2NyZWVuKF9wWzBdKTtcblxuICAgICAgICAgIHZhciBfeSA9IGxheW91dC4kMnNjcmVlbihfcFtpICsgMV0pO1xuXG4gICAgICAgICAgaWYgKF9wW2kgKyAxXSA9PSBudWxsIHx8IF95ICE9PSBfeSkge1xuICAgICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChza2lwKSBjdHgubW92ZVRvKF94LCBfeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKF94LCBfeSk7XG4gICAgICAgICAgICBza2lwID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnU3BsaW5lcycsICdETUknXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNscng7XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjc1O1xuICAgIH0sXG4gICAgd2lkdGhzOiBmdW5jdGlvbiB3aWR0aHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aHMgfHwgW107XG4gICAgfSxcbiAgICBjbHJ4OiBmdW5jdGlvbiBjbHJ4KCkge1xuICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuc2V0dC5jb2xvcnMgfHwgW107XG4gICAgICB2YXIgbiA9IHRoaXMuJHByb3BzLm51bTtcblxuICAgICAgaWYgKCFjb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lc19udW07IGkrKykge1xuICAgICAgICAgIGNvbG9ycy5wdXNoKHRoaXMuQ09MT1JTWyhuICsgaSkgJSA1XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICB9LFxuICAgIGxpbmVzX251bTogZnVuY3Rpb24gbGluZXNfbnVtKCkge1xuICAgICAgaWYgKCF0aGlzLiRwcm9wcy5kYXRhWzBdKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhWzBdLmxlbmd0aCAtIDE7XG4gICAgfSxcbiAgICAvLyBEb24ndCBjb25uZWN0IHNlcGFyYXRlIHBhcnRzIGlmIHRydWVcbiAgICBza2lwX25hbjogZnVuY3Rpb24gc2tpcF9uYW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNraXBOYU47XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBDT0xPUlM6IFsnIzQyYjI4YScsICcjNTY5MWNlJywgJyM2MTJmZjknLCAnI2Q1MGI5MCcsICcjZmYyMzE2J11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGluZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfU3BsaW5lc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTcGxpbmVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpbmVzLnZ1ZVxudmFyIFNwbGluZXNfcmVuZGVyLCBTcGxpbmVzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFNwbGluZXNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19TcGxpbmVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTcGxpbmVzX3JlbmRlcixcbiAgU3BsaW5lc19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNwbGluZXNfYXBpOyB9XG5TcGxpbmVzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaW5lcy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTcGxpbmVzID0gKFNwbGluZXNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1JhbmdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIFIgUyBJIC4gQmVjYXVzZSB3ZSBsb3ZlIGl0XG4vLyBBZGRzIGFsbCBuZWNlc3Nhcnkgc3R1ZmYgZm9yIHlvdS5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdSYW5nZScsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4xJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIEhlcmUgZ29lcyB5b3VyIGNvZGUuIFlvdSBhcmUgcHJvdmlkZWQgd2l0aDpcbiAgICAvLyB7IEFsbCBzdHVmZiBpcyByZWFjdGl2ZSB9XG4gICAgLy8gJHByb3BzLmxheW91dCAtPiBwb3NpdGlvbnMgb2YgYWxsIGNoYXJ0IGVsZW1lbnRzICtcbiAgICAvLyAgc29tZSBoZWxwZXIgZnVuY3Rpb25zIChzZWUgbGF5b3V0X2ZuLmpzKVxuICAgIC8vICRwcm9wcy5pbnRlcnZhbCAtPiBjYW5kbGVzdGljayB0aW1lIGludGVydmFsXG4gICAgLy8gJHByb3BzLnN1YiAtPiBjdXJyZW50IHN1YnNldCBvZiBjYW5kbGVzdGljayBkYXRhXG4gICAgLy8gJHByb3BzLmRhdGEgLT4geW91ciBpbmRpY2F0b3IncyBkYXRhIHN1YnNldC5cbiAgICAvLyAgQ29tZXMgXCJhcyBpc1wiLCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAgICAvLyAgW1s8dGltZXN0YW1wPiwgLi4uIF0sIC4uLiBdXG4gICAgLy8gJHByb3BzLmNvbG9ycyAtPiBjb2xvcnMgKHNlZSBUcmFkaW5nVnVlLnZ1ZSlcbiAgICAvLyAkcHJvcHMuY3Vyc29yIC0+IGN1cnJlbnQgcG9zaXRpb24gb2YgY3Jvc3NoYWlyXG4gICAgLy8gJHByb3BzLnNldHRpbmdzIC0+IGluZGljYXRvcidzIGN1c3RvbSBzZXR0aW5nc1xuICAgIC8vICBFLmcuIGNvbG9ycywgbGluZSB0aGlja25lc3MsIGV0Yy4gWW91IGRlZmluZSBpdC5cbiAgICAvLyAkcHJvcHMubnVtIC0+IGluZGljYXRvcidzIGxheWVyIG51bWJlciAob2YgQWxsXG4gICAgLy8gbGF5ZXJzIGluIHRoZSBjdXJyZW50IGdyaWQpXG4gICAgLy8gJHByb3BzLmlkIC0+IGluZGljYXRvcidzIGlkIChlLmcuIEVNQV8wKVxuICAgIC8vIH5cbiAgICAvLyBGaW5hbGx5LCBsZXQncyBtYWtlIHRoZSBjYW52YXMgZGlydHkhXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgdXBwZXIgPSBsYXlvdXQuJDJzY3JlZW4odGhpcy5zZXR0LnVwcGVyIHx8IDcwKTtcbiAgICAgIHZhciBsb3dlciA9IGxheW91dC4kMnNjcmVlbih0aGlzLnNldHQubG93ZXIgfHwgMzApO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLiRwcm9wcy5kYXRhOyAvLyBSU0kgdmFsdWVzXG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBrID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBrIDwgbjsgaysrKSB7XG4gICAgICAgIHZhciBwID0gZGF0YVtrXTtcbiAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG4gICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0pO1xuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJhbmRfY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goWzVdKTsgLy8gV2lsbCBiZSByZW1vdmVkIGFmdGVyIGRyYXcoKVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7IC8vIEZpbGwgdGhlIGFyZWEgYmV0d2VlbiB0aGUgYmFuZHNcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja19jb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCB1cHBlciwgbGF5b3V0LndpZHRoLCBsb3dlciAtIHVwcGVyKTsgLy8gVXBwZXIgYmFuZFxuXG4gICAgICBjdHgubW92ZVRvKDAsIHVwcGVyKTtcbiAgICAgIGN0eC5saW5lVG8obGF5b3V0LndpZHRoLCB1cHBlcik7IC8vIExvd2VyIGJhbmRcblxuICAgICAgY3R4Lm1vdmVUbygwLCBsb3dlcik7XG4gICAgICBjdHgubGluZVRvKGxheW91dC53aWR0aCwgbG93ZXIpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgLy8gRm9yIGFsbCBkYXRhIHdpdGggdGhlc2UgdHlwZXMgb3ZlcmxheSB3aWxsIGJlXG4gICAgLy8gYWRkZWQgdG8gdGhlIHJlbmRlcmVyIGxpc3QuIEFuZCAnJHByb3BzLmRhdGEnXG4gICAgLy8gd2lsbCBoYXZlIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy4gSWYgeW91IHdhbnQgdG9cbiAgICAvLyByZWRlZmluZSB0aGUgZGVmYXVsdCBiZWh2aW91ciBmb3IgYSBwcnRpY3VsYXJcbiAgICAvLyBpbmRpY2F0b3IgKGxldCdzIHNheSBFTUEpLFxuICAgIC8vIGp1c3QgY3JlYXRlIGEgbmV3IG92ZXJsYXkgd2l0aCB0aGUgc2FtZSB0eXBlOlxuICAgIC8vIGUuZy4gdXNlX2ZvcigpIHsgcmV0dXJuIFsnRU1BJ10gfS5cbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnUmFuZ2UnLCAnUlNJJ107XG4gICAgfSxcbiAgICAvLyBDb2xvcnMgZm9yIHRoZSBsZWdlbmQsIHNob3VsZCBoYXZlIHRoZVxuICAgIC8vIHNhbWUgZGltZW50aW9uIGFzIGEgZGF0YSBwb2ludCAoZXhjbC4gdGltZXN0YW1wKVxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvcl07XG4gICAgfSxcbiAgICAvLyBZLVJhbmdlIHRhbnNmb3JtLiBGb3IgZXhhbXBsZSB5b3UgbmVlZCBhIGZpeGVkXG4gICAgLy8gWS1yYW5nZSBmb3IgYW4gaW5kaWNhdG9yLCB5b3UgY2FuIGRvIGl0IGhlcmUhXG4gICAgLy8gR2V0cyBlc3RpbWF0ZWQgcmFuZ2UsIEByZXR1cm4geW91IGZhdm9yaXRlIHJhbmdlXG4gICAgeV9yYW5nZTogZnVuY3Rpb24geV9yYW5nZShoaSwgbG8pIHtcbiAgICAgIHJldHVybiBbTWF0aC5tYXgoaGksIHRoaXMuc2V0dC51cHBlciB8fCA3MCksIE1hdGgubWluKGxvLCB0aGlzLnNldHQubG93ZXIgfHwgMzApXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuNzU7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8ICcjZWMyMDZlJztcbiAgICB9LFxuICAgIGJhbmRfY29sb3I6IGZ1bmN0aW9uIGJhbmRfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhbmRDb2xvciB8fCAnI2RkZCc7XG4gICAgfSxcbiAgICBiYWNrX2NvbG9yOiBmdW5jdGlvbiBiYWNrX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYWNrQ29sb3IgfHwgJyMzODFlOWMxNic7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1JhbmdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX1JhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFJhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9SYW5nZS52dWVcbnZhciBSYW5nZV9yZW5kZXIsIFJhbmdlX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFJhbmdlX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfUmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFJhbmdlX3JlbmRlcixcbiAgUmFuZ2Vfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBSYW5nZV9hcGk7IH1cblJhbmdlX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvUmFuZ2UudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUmFuZ2UgPSAoUmFuZ2VfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1RyYWRlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1RyYWRlcycsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4yJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLiRwcm9wcy5kYXRhO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEuNTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgdmFyIHAgPSBkYXRhW2tdO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gcFsxXSA/IHRoaXMuYnV5X2NvbG9yIDogdGhpcy5zZWxsX2NvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pOyAvLyB4IC0gTWFwcGluZ1xuXG4gICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMl0pOyAvLyB5IC0gTWFwcGluZ1xuXG4gICAgICAgIGN0eC5hcmMoeCwgeSwgdGhpcy5tYXJrZXJfc2l6ZSArIDAuNSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd19sYWJlbCAmJiBwWzNdKSB7XG4gICAgICAgICAgdGhpcy5kcmF3X2xhYmVsKGN0eCwgeCwgeSwgcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYXdfbGFiZWw6IGZ1bmN0aW9uIGRyYXdfbGFiZWwoY3R4LCB4LCB5LCBwKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbF9jb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGhpcy5uZXdfZm9udDtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGN0eC5maWxsVGV4dChwWzNdLCB4LCB5IC0gMjUpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1RyYWRlcyddO1xuICAgIH0sXG4gICAgLy8gRGVmaW5lcyBsZWdlbmQgZm9ybWF0ICh2YWx1ZXMgJiBjb2xvcnMpXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQodmFsdWVzKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlc1sxXSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdmFyIHBvcyA9ICdTZWxsJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcG9zID0gJ0J1eSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwb3MgPSAnVW5rbm93bic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2YWx1ZTogcG9zXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZXNbMl0udG9GaXhlZCg0KSxcbiAgICAgICAgY29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy50ZXh0XG4gICAgICB9XS5jb25jYXQodmFsdWVzWzNdID8gW3tcbiAgICAgICAgdmFsdWU6IHZhbHVlc1szXVxuICAgICAgfV0gOiBbXSk7XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGRlZmF1bHRfZm9udDogZnVuY3Rpb24gZGVmYXVsdF9mb250KCkge1xuICAgICAgcmV0dXJuICcxMnB4ICcgKyB0aGlzLiRwcm9wcy5mb250LnNwbGl0KCdweCcpLnBvcCgpO1xuICAgIH0sXG4gICAgYnV5X2NvbG9yOiBmdW5jdGlvbiBidXlfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJ1eUNvbG9yIHx8ICcjNjNkZjg5JztcbiAgICB9LFxuICAgIHNlbGxfY29sb3I6IGZ1bmN0aW9uIHNlbGxfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNlbGxDb2xvciB8fCAnI2VjNDY2Mic7XG4gICAgfSxcbiAgICBsYWJlbF9jb2xvcjogZnVuY3Rpb24gbGFiZWxfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxhYmVsQ29sb3IgfHwgJyM5OTknO1xuICAgIH0sXG4gICAgbWFya2VyX3NpemU6IGZ1bmN0aW9uIG1hcmtlcl9zaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5tYXJrZXJTaXplIHx8IDU7XG4gICAgfSxcbiAgICBzaG93X2xhYmVsOiBmdW5jdGlvbiBzaG93X2xhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zaG93TGFiZWwgIT09IGZhbHNlO1xuICAgIH0sXG4gICAgbmV3X2ZvbnQ6IGZ1bmN0aW9uIG5ld19mb250KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5mb250IHx8IHRoaXMuZGVmYXVsdF9mb250O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9UcmFkZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfVHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvVHJhZGVzLnZ1ZVxudmFyIFRyYWRlc19yZW5kZXIsIFRyYWRlc19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBUcmFkZXNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19UcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFRyYWRlc19yZW5kZXIsXG4gIFRyYWRlc19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFRyYWRlc19hcGk7IH1cblRyYWRlc19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL1RyYWRlcy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUcmFkZXMgPSAoVHJhZGVzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9DaGFubmVsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIENoYW5uZWwgcmVuZGVyZXIuIChLZWx0bmVyLCBCb2xsaW5nZXIpXG4vLyBUT0RPOiBhbGxvdyBjb2xvciB0cmFuc3BhcmVuY3lcbi8vIFRPRE86IGltcHJvdmUgcGVyZm9ybWFuY2U6IGRyYXcgaW4gb25lIHNvbGlkIGNodW5rXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ2hhbm5lbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDaGFubmVsJyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjEnXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKmRyYXcoY3R4KSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGhcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrX2NvbG9yXG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHByb3BzLmRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBwMSA9IHRoaXMubWFwcCh0aGlzLiRwcm9wcy5kYXRhW2ldKVxuICAgICAgICAgICAgbGV0IHAyID0gdGhpcy5tYXBwKHRoaXMuJHByb3BzLmRhdGFbaSsxXSlcbiAgICAgICAgICAgICBpZiAoIXAyKSBjb250aW51ZVxuICAgICAgICAgICAgaWYgKHAxLnkxICE9PSBwMS55MSkgY29udGludWUgLy8gRml4IE5hTlxuICAgICAgICAgICAgIC8vIEJhY2tncm91bmRcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55MSlcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocDIueCArIDAuMSwgcDIueTEpXG4gICAgICAgICAgICBjdHgubGluZVRvKHAyLnggKyAwLjEsIHAyLnkzKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55MylcbiAgICAgICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgICAgICAvLyBMaW5lc1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkxKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55MSlcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dfbWlkKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55MilcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55MylcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueTMpXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgIH1cbiAgICB9LCovXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIC8vIEJhY2tncm91bmRcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja19jb2xvcjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gZGF0YVtpXTtcbiAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG4gICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0gfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIF9wID0gZGF0YVtpXTtcblxuICAgICAgICB2YXIgX3ggPSBsYXlvdXQudDJzY3JlZW4oX3BbMF0pO1xuXG4gICAgICAgIHZhciBfeSA9IGxheW91dC4kMnNjcmVlbihfcFszXSB8fCB1bmRlZmluZWQpO1xuXG4gICAgICAgIGN0eC5saW5lVG8oX3gsIF95KTtcbiAgICAgIH1cblxuICAgICAgY3R4LmZpbGwoKTsgLy8gTGluZXNcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7IC8vIFRvcCBsaW5lXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfcDIgPSBkYXRhW2ldO1xuXG4gICAgICAgIHZhciBfeDIgPSBsYXlvdXQudDJzY3JlZW4oX3AyWzBdKTtcblxuICAgICAgICB2YXIgX3kyID0gbGF5b3V0LiQyc2NyZWVuKF9wMlsxXSB8fCB1bmRlZmluZWQpO1xuXG4gICAgICAgIGN0eC5saW5lVG8oX3gyLCBfeTIpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7IC8vIEJvdHRvbSBsaW5lXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfcDMgPSBkYXRhW2ldO1xuXG4gICAgICAgIHZhciBfeDMgPSBsYXlvdXQudDJzY3JlZW4oX3AzWzBdKTtcblxuICAgICAgICB2YXIgX3kzID0gbGF5b3V0LiQyc2NyZWVuKF9wM1szXSB8fCB1bmRlZmluZWQpO1xuXG4gICAgICAgIGN0eC5saW5lVG8oX3gzLCBfeTMpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7IC8vIE1pZGRsZSBsaW5lXG5cbiAgICAgIGlmICghdGhpcy5zaG93X21pZCkgcmV0dXJuO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9wNCA9IGRhdGFbaV07XG5cbiAgICAgICAgdmFyIF94NCA9IGxheW91dC50MnNjcmVlbihfcDRbMF0pO1xuXG4gICAgICAgIHZhciBfeTQgPSBsYXlvdXQuJDJzY3JlZW4oX3A0WzJdIHx8IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgY3R4LmxpbmVUbyhfeDQsIF95NCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIG1hcHA6IGZ1bmN0aW9uIG1hcHAocCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHJldHVybiBwICYmIHtcbiAgICAgICAgeDogbGF5b3V0LnQyc2NyZWVuKHBbMF0pLFxuICAgICAgICB5MTogbGF5b3V0LiQyc2NyZWVuKHBbMV0pLFxuICAgICAgICB5MjogbGF5b3V0LiQyc2NyZWVuKHBbMl0pLFxuICAgICAgICB5MzogbGF5b3V0LiQyc2NyZWVuKHBbM10pXG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0NoYW5uZWwnLCAnS0MnLCAnQkInXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvciwgdGhpcy5jb2xvciwgdGhpcy5jb2xvcl07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjc1O1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgdmFyIG4gPSB0aGlzLiRwcm9wcy5udW0gJSA1O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCB0aGlzLkNPTE9SU1tuXTtcbiAgICB9LFxuICAgIHNob3dfbWlkOiBmdW5jdGlvbiBzaG93X21pZCgpIHtcbiAgICAgIHJldHVybiAnc2hvd01pZCcgaW4gdGhpcy5zZXR0ID8gdGhpcy5zZXR0LnNob3dNaWQgOiB0cnVlO1xuICAgIH0sXG4gICAgYmFja19jb2xvcjogZnVuY3Rpb24gYmFja19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFja0NvbG9yIHx8IHRoaXMuY29sb3IgKyAnMTEnO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQ09MT1JTOiBbJyM0MmIyOGEnLCAnIzU2OTFjZScsICcjNjEyZmY5JywgJyNkNTBiOTAnLCAnI2ZmMjMxNiddXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9DaGFubmVsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX0NoYW5uZWx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ2hhbm5lbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvQ2hhbm5lbC52dWVcbnZhciBDaGFubmVsX3JlbmRlciwgQ2hhbm5lbF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBDaGFubmVsX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfQ2hhbm5lbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQ2hhbm5lbF9yZW5kZXIsXG4gIENoYW5uZWxfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBDaGFubmVsX2FwaTsgfVxuQ2hhbm5lbF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL0NoYW5uZWwudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ2hhbm5lbCA9IChDaGFubmVsX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TZWdtZW50LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIFNlZ21lbnQgcmVuZGVyZXIuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU2VnbWVudHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTZWdtZW50JyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGlmICghdGhpcy5wMSB8fCAhdGhpcy5wMikgcmV0dXJuO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHgxID0gbGF5b3V0LnQyc2NyZWVuKHRoaXMucDFbMF0pO1xuICAgICAgdmFyIHkxID0gbGF5b3V0LiQyc2NyZWVuKHRoaXMucDFbMV0pO1xuICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgdmFyIHgyID0gbGF5b3V0LnQyc2NyZWVuKHRoaXMucDJbMF0pO1xuICAgICAgdmFyIHkyID0gbGF5b3V0LiQyc2NyZWVuKHRoaXMucDJbMV0pO1xuICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1NlZ21lbnQnXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvcl07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIHAxOiBmdW5jdGlvbiBwMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncy5wMTtcbiAgICB9LFxuICAgIHAyOiBmdW5jdGlvbiBwMigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncy5wMjtcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjk7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuJHByb3BzLm51bSAlIDU7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8IHRoaXMuQ09MT1JTW25dO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQ09MT1JTOiBbJyM0MmIyOGEnLCAnIzU2OTFjZScsICcjNjEyZmY5JywgJyNkNTBiOTAnLCAnI2ZmMjMxNiddXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TZWdtZW50LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX1NlZ21lbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU2VnbWVudHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU2VnbWVudC52dWVcbnZhciBTZWdtZW50X3JlbmRlciwgU2VnbWVudF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTZWdtZW50X2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfU2VnbWVudHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU2VnbWVudF9yZW5kZXIsXG4gIFNlZ21lbnRfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTZWdtZW50X2FwaTsgfVxuU2VnbWVudF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL1NlZ21lbnQudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU2VnbWVudCA9IChTZWdtZW50X2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL2xheW91dF9jbnYuanNcblxuXG4vLyBDbGFjdWxhdGVzIHBvc3Rpb25zIGFuZCBzaXplcyBmb3IgY2FuZGxlc3RpY2tcbi8vIGFuZCB2b2x1bWUgYmFycyBmb3IgdGhlIGdpdmVuIHN1YnNldCBvZiBkYXRhXG5cbmZ1bmN0aW9uIGxheW91dF9jbnYoc2VsZikge1xuICB2YXIgJHAgPSBzZWxmLiRwcm9wcztcbiAgdmFyIHN1YiA9ICRwLmRhdGE7XG4gIHZhciB0MnNjcmVlbiA9ICRwLmxheW91dC50MnNjcmVlbjtcbiAgdmFyIGxheW91dCA9ICRwLmxheW91dDtcbiAgdmFyIGNhbmRsZXMgPSBbXTtcbiAgdmFyIHZvbHVtZSA9IFtdOyAvLyBUaGUgdm9sdW1lIGJhciBoZWlnaHQgaXMgZGV0ZXJtaW5lZCBhcyBhIHBlcmNlbnRhZ2Ugb2ZcbiAgLy8gdGhlIGNoYXJ0J3MgaGVpZ2h0IChWT0xTQ0FMRSlcblxuICB2YXIgbWF4diA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShzdWIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHhbNV07XG4gIH0pKSk7XG4gIHZhciB2cyA9ICRwLmNvbmZpZy5WT0xTQ0FMRSAqIGxheW91dC5oZWlnaHQgLyBtYXh2O1xuICB2YXIgeDEsXG4gICAgICB4MixcbiAgICAgIHcsXG4gICAgICBhdmdfdyxcbiAgICAgIG1pZCxcbiAgICAgIHByZXYgPSB1bmRlZmluZWQ7IC8vIFN1YnNldCBpbnRlcnZhbCBhZ2FpbnN0IG1haW4gaW50ZXJ2YWxcblxuICB2YXIgX25ld19pbnRlcnZhbCA9IG5ld19pbnRlcnZhbChsYXlvdXQsICRwLCBzdWIpLFxuICAgICAgX25ld19pbnRlcnZhbDIgPSBfc2xpY2VkVG9BcnJheShfbmV3X2ludGVydmFsLCAyKSxcbiAgICAgIGludGVydmFsMiA9IF9uZXdfaW50ZXJ2YWwyWzBdLFxuICAgICAgcmF0aW8gPSBfbmV3X2ludGVydmFsMlsxXTtcblxuICB2YXIgcHhfc3RlcDIgPSBsYXlvdXQucHhfc3RlcCAqIHJhdGlvO1xuICB2YXIgc3BsaXR0ZXIgPSBweF9zdGVwMiA+IDUgPyAxIDogMDsgLy8gQSAmIEIgYXJlIGN1cnJlbnQgY2hhcnQgdHJhbmZvcm1hdGlvbnM6XG4gIC8vIEEgPT09IHNjYWxlLCAgQiA9PT0gWS1heGlzIHNoaWZ0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHN1YltpXTtcbiAgICBtaWQgPSB0MnNjcmVlbihwWzBdKSArIDE7IC8vIENsZWFyIHZvbHVtZSBiYXIgaWYgdGhlcmUgaXMgYSB0aW1lIGdhcFxuXG4gICAgaWYgKHN1YltpIC0gMV0gJiYgcFswXSAtIHN1YltpIC0gMV1bMF0gPiBpbnRlcnZhbDIpIHtcbiAgICAgIHByZXYgPSBudWxsO1xuICAgIH1cblxuICAgIHgxID0gcHJldiB8fCBNYXRoLmZsb29yKG1pZCAtIHB4X3N0ZXAyICogMC41KTtcbiAgICB4MiA9IE1hdGguZmxvb3IobWlkICsgcHhfc3RlcDIgKiAwLjUpIC0gMC41OyAvLyBUT0RPOiBhZGQgbG9nIHNjYWxlIHN1cHBvcnRcblxuICAgIGNhbmRsZXMucHVzaCh7XG4gICAgICB4OiBtaWQsXG4gICAgICB3OiBsYXlvdXQucHhfc3RlcCAqICRwLmNvbmZpZy5DQU5ETEVXICogcmF0aW8sXG4gICAgICBvOiBNYXRoLmZsb29yKHBbMV0gKiBsYXlvdXQuQSArIGxheW91dC5CKSxcbiAgICAgIGg6IE1hdGguZmxvb3IocFsyXSAqIGxheW91dC5BICsgbGF5b3V0LkIpLFxuICAgICAgbDogTWF0aC5mbG9vcihwWzNdICogbGF5b3V0LkEgKyBsYXlvdXQuQiksXG4gICAgICBjOiBNYXRoLmZsb29yKHBbNF0gKiBsYXlvdXQuQSArIGxheW91dC5CKSxcbiAgICAgIHJhdzogcFxuICAgIH0pO1xuICAgIHZvbHVtZS5wdXNoKHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIGg6IHBbNV0gKiB2cyxcbiAgICAgIGdyZWVuOiBwWzRdID49IHBbMV0sXG4gICAgICByYXc6IHBcbiAgICB9KTtcbiAgICBwcmV2ID0geDIgKyBzcGxpdHRlcjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2FuZGxlczogY2FuZGxlcyxcbiAgICB2b2x1bWU6IHZvbHVtZVxuICB9O1xufVxuZnVuY3Rpb24gbGF5b3V0X3ZvbChzZWxmKSB7XG4gIHZhciAkcCA9IHNlbGYuJHByb3BzO1xuICB2YXIgc3ViID0gJHAuZGF0YTtcbiAgdmFyIHQyc2NyZWVuID0gJHAubGF5b3V0LnQyc2NyZWVuO1xuICB2YXIgbGF5b3V0ID0gJHAubGF5b3V0O1xuICB2YXIgdm9sdW1lID0gW107IC8vIERldGVjdCBkYXRhIHNlY29uZCBkaW1lbnRpb24gc2l6ZTpcblxuICB2YXIgZGltID0gc3ViWzBdID8gc3ViWzBdLmxlbmd0aCA6IDA7IC8vIFN1cHBvcnQgc3BlY2lhbCB2b2x1bWUgZGF0YSAoc2VlIEFQSSBib29rKSwgb3IgT0hMQ1ZcbiAgLy8gRGF0YSBpbmRpY2VzOlxuXG4gIHNlbGYuX2kxID0gZGltIDwgNiA/IDEgOiA1O1xuICBzZWxmLl9pMiA9IGRpbSA8IDYgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwWzJdO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcFs0XSA+PSBwWzFdO1xuICB9O1xuICB2YXIgbWF4diA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShzdWIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHhbc2VsZi5faTFdO1xuICB9KSkpO1xuICB2YXIgdm9sc2NhbGUgPSBzZWxmLnZvbHNjYWxlIHx8ICRwLmNvbmZpZy5WT0xTQ0FMRTtcbiAgdmFyIHZzID0gdm9sc2NhbGUgKiBsYXlvdXQuaGVpZ2h0IC8gbWF4djtcbiAgdmFyIHgxLFxuICAgICAgeDIsXG4gICAgICBtaWQsXG4gICAgICBwcmV2ID0gdW5kZWZpbmVkOyAvLyBTdWJzZXQgaW50ZXJ2YWwgYWdhaW5zdCBtYWluIGludGVydmFsXG5cbiAgdmFyIF9uZXdfaW50ZXJ2YWwzID0gbmV3X2ludGVydmFsKGxheW91dCwgJHAsIHN1YiksXG4gICAgICBfbmV3X2ludGVydmFsNCA9IF9zbGljZWRUb0FycmF5KF9uZXdfaW50ZXJ2YWwzLCAyKSxcbiAgICAgIGludGVydmFsMiA9IF9uZXdfaW50ZXJ2YWw0WzBdLFxuICAgICAgcmF0aW8gPSBfbmV3X2ludGVydmFsNFsxXTtcblxuICB2YXIgcHhfc3RlcDIgPSBsYXlvdXQucHhfc3RlcCAqIHJhdGlvO1xuICB2YXIgc3BsaXR0ZXIgPSBweF9zdGVwMiA+IDUgPyAxIDogMDsgLy8gQSAmIEIgYXJlIGN1cnJlbnQgY2hhcnQgdHJhbmZvcm1hdGlvbnM6XG4gIC8vIEEgPT09IHNjYWxlLCAgQiA9PT0gWS1heGlzIHNoaWZ0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHN1YltpXTtcbiAgICBtaWQgPSB0MnNjcmVlbihwWzBdKSArIDE7IC8vIENsZWFyIHZvbHVtZSBiYXIgaWYgdGhlcmUgaXMgYSB0aW1lIGdhcFxuXG4gICAgaWYgKHN1YltpIC0gMV0gJiYgcFswXSAtIHN1YltpIC0gMV1bMF0gPiBpbnRlcnZhbDIpIHtcbiAgICAgIHByZXYgPSBudWxsO1xuICAgIH1cblxuICAgIHgxID0gcHJldiB8fCBNYXRoLmZsb29yKG1pZCAtIHB4X3N0ZXAyICogMC41KTtcbiAgICB4MiA9IE1hdGguZmxvb3IobWlkICsgcHhfc3RlcDIgKiAwLjUpIC0gMC41O1xuICAgIHZvbHVtZS5wdXNoKHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIGg6IHBbc2VsZi5faTFdICogdnMsXG4gICAgICBncmVlbjogc2VsZi5faTIocCksXG4gICAgICByYXc6IHBcbiAgICB9KTtcbiAgICBwcmV2ID0geDIgKyBzcGxpdHRlcjtcbiAgfVxuXG4gIHJldHVybiB2b2x1bWU7XG59XG5cbmZ1bmN0aW9uIG5ld19pbnRlcnZhbChsYXlvdXQsICRwLCBzdWIpIHtcbiAgLy8gU3Vic2V0IGludGVydmFsIGFnYWluc3QgbWFpbiBpbnRlcnZhbFxuICBpZiAoIWxheW91dC50aV9tYXAuaWIpIHtcbiAgICB2YXIgaW50ZXJ2YWwyID0gJHAudGYgfHwgdXRpbHMuZGV0ZWN0X2ludGVydmFsKHN1Yik7XG4gICAgdmFyIHJhdGlvID0gaW50ZXJ2YWwyIC8gJHAuaW50ZXJ2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRwLnRmKSB7XG4gICAgICB2YXIgcmF0aW8gPSAkcC50ZiAvIGxheW91dC50aV9tYXAudGY7XG4gICAgICB2YXIgaW50ZXJ2YWwyID0gcmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbnRlcnZhbDIgPSB1dGlscy5kZXRlY3RfaW50ZXJ2YWwoc3ViKTtcbiAgICAgIHZhciByYXRpbyA9IGludGVydmFsMiAvICRwLmludGVydmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbaW50ZXJ2YWwyLCByYXRpb107XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wcmltaXRpdmVzL2NhbmRsZS5qc1xuXG5cblxuLy8gQ2FuZGxlIG9iamVjdCBmb3IgQ2FuZGxlcyBvdmVybGF5XG52YXIgQ2FuZGxlRXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FuZGxlRXh0KG92ZXJsYXksIGN0eCwgZGF0YSkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbmRsZUV4dCk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLnNlbGYgPSBvdmVybGF5O1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnJhd1s2XSB8fCB0aGlzLnNlbGY7XG4gICAgdGhpcy5kcmF3KGRhdGEpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoQ2FuZGxlRXh0LCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoZGF0YSkge1xuICAgICAgdmFyIGdyZWVuID0gZGF0YS5yYXdbNF0gPj0gZGF0YS5yYXdbMV07XG4gICAgICB2YXIgYm9keV9jb2xvciA9IGdyZWVuID8gdGhpcy5zdHlsZS5jb2xvckNhbmRsZVVwIDogdGhpcy5zdHlsZS5jb2xvckNhbmRsZUR3O1xuICAgICAgdmFyIHdpY2tfY29sb3IgPSBncmVlbiA/IHRoaXMuc3R5bGUuY29sb3JXaWNrVXAgOiB0aGlzLnN0eWxlLmNvbG9yV2lja0R3O1xuICAgICAgdmFyIHcgPSBNYXRoLm1heChkYXRhLncsIDEpO1xuICAgICAgdmFyIGh3ID0gTWF0aC5tYXgoTWF0aC5mbG9vcih3ICogMC41KSwgMSk7XG4gICAgICB2YXIgaCA9IE1hdGguYWJzKGRhdGEubyAtIGRhdGEuYyk7XG4gICAgICB2YXIgbWF4X2ggPSBkYXRhLmMgPT09IGRhdGEubyA/IDEgOiAyO1xuICAgICAgdmFyIHgwNSA9IE1hdGguZmxvb3IoZGF0YS54KSAtIDAuNTtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gd2lja19jb2xvcjtcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5jdHgubW92ZVRvKHgwNSwgTWF0aC5mbG9vcihkYXRhLmgpKTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh4MDUsIE1hdGguZmxvb3IoZGF0YS5sKSk7XG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcblxuICAgICAgaWYgKGRhdGEudyA+IDEuNSkge1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBib2R5X2NvbG9yOyAvLyBUT0RPOiBNb3ZlIGNvbW1vbiBjYWxjdWxhdGlvbnMgdG8gbGF5b3V0LmpzXG5cbiAgICAgICAgdmFyIHMgPSBncmVlbiA/IDEgOiAtMTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoTWF0aC5mbG9vcihkYXRhLnggLSBodyAtIDEpLCBkYXRhLmMsIE1hdGguZmxvb3IoaHcgKiAyICsgMSksIHMgKiBNYXRoLm1heChoLCBtYXhfaCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBib2R5X2NvbG9yO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKHgwNSwgTWF0aC5mbG9vcihNYXRoLm1pbihkYXRhLm8sIGRhdGEuYykpKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHgwNSwgTWF0aC5mbG9vcihNYXRoLm1heChkYXRhLm8sIGRhdGEuYykpICsgKGRhdGEubyA9PT0gZGF0YS5jID8gMSA6IDApKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbmRsZUV4dDtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wcmltaXRpdmVzL3ZvbGJhci5qc1xuXG5cblxudmFyIFZvbGJhckV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZvbGJhckV4dChvdmVybGF5LCBjdHgsIGRhdGEpIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBWb2xiYXJFeHQpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy4kcCA9IG92ZXJsYXkuJHByb3BzO1xuICAgIHRoaXMuc2VsZiA9IG92ZXJsYXk7XG4gICAgdGhpcy5zdHlsZSA9IGRhdGEucmF3WzZdIHx8IHRoaXMuc2VsZjtcbiAgICB0aGlzLmRyYXcoZGF0YSk7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhWb2xiYXJFeHQsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhkYXRhKSB7XG4gICAgICB2YXIgeTAgPSB0aGlzLiRwLmxheW91dC5oZWlnaHQ7XG4gICAgICB2YXIgdyA9IGRhdGEueDIgLSBkYXRhLngxO1xuICAgICAgdmFyIGggPSBNYXRoLmZsb29yKGRhdGEuaCk7XG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBkYXRhLmdyZWVuID8gdGhpcy5zdHlsZS5jb2xvclZvbFVwIDogdGhpcy5zdHlsZS5jb2xvclZvbER3O1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoTWF0aC5mbG9vcihkYXRhLngxKSwgTWF0aC5mbG9vcih5MCAtIGggLSAwLjUpLCBNYXRoLmZsb29yKHcpLCBNYXRoLmZsb29yKGggKyAxKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZvbGJhckV4dDtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wcmltaXRpdmVzL3ByaWNlLmpzXG5cblxuXG4vLyBQcmljZSBiYXIgJiBwcmljZSBsaW5lIChzaGFkZXIpXG52YXIgUHJpY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcmljZShjb21wKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJpY2UpO1xuXG4gICAgdGhpcy5jb21wID0gY29tcDtcbiAgfSAvLyBEZWZpbmVzIGFuIGlubGluZSBzaGFkZXIgKGhhcyBhY2Nlc3MgdG8gYm90aFxuICAvLyB0YXJnZXQgJiBvdmVybGF5J3MgY29udGV4dHMpXG5cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhQcmljZSwgW3tcbiAgICBrZXk6IFwiaW5pdF9zaGFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdF9zaGFkZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5jb21wLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb21wLiRwcm9wcy5jb25maWc7XG4gICAgICB2YXIgY29tcCA9IHRoaXMuY29tcDtcblxuICAgICAgdmFyIGxhc3RfYmFyID0gZnVuY3Rpb24gbGFzdF9iYXIoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5sYXN0X2JhcigpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5jb21wLiRlbWl0KCduZXctc2hhZGVyJywge1xuICAgICAgICB0YXJnZXQ6ICdzaWRlYmFyJyxcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgICAgICB2YXIgYmFyID0gbGFzdF9iYXIoKTtcbiAgICAgICAgICBpZiAoIWJhcikgcmV0dXJuO1xuICAgICAgICAgIHZhciB3ID0gY3R4LmNhbnZhcy53aWR0aDtcbiAgICAgICAgICB2YXIgaCA9IGNvbmZpZy5QQU5IRUlHSFQ7XG4gICAgICAgICAgdmFyIGxibCA9IGJhci5wcmljZS50b0ZpeGVkKGxheW91dC5wcmVjKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFyLmNvbG9yO1xuICAgICAgICAgIHZhciB4ID0gLTAuNTtcbiAgICAgICAgICB2YXIgeSA9IGJhci55IC0gaCAqIDAuNSAtIDAuNTtcbiAgICAgICAgICB2YXIgYSA9IDc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHggLSAwLjUsIHksIHcgKyAxLCBoKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29tcC4kcHJvcHMuY29sb3JzLnRleHRITDtcbiAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIGN0eC5maWxsVGV4dChsYmwsIGEsIHkgKyAxNSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaGFkZXIgPSB0cnVlO1xuICAgIH0gLy8gUmVndWxhciBkcmF3IGNhbGwgZm9yIG92ZXJhbHlcblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGlmICghdGhpcy5jb21wLiRwcm9wcy5tZXRhLmxhc3QpIHJldHVybjtcbiAgICAgIGlmICghdGhpcy5zaGFkZXIpIHRoaXMuaW5pdF9zaGFkZXIoKTtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmNvbXAuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBsYXN0ID0gdGhpcy5jb21wLiRwcm9wcy5sYXN0O1xuICAgICAgdmFyIGRpciA9IGxhc3RbNF0gPj0gbGFzdFsxXTtcbiAgICAgIHZhciBjb2xvciA9IGRpciA/IHRoaXMuZ3JlZW4oKSA6IHRoaXMucmVkKCk7XG4gICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihsYXN0WzRdKSArIChkaXIgPyAxIDogMCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygwLCB5KTtcbiAgICAgIGN0eC5saW5lVG8obGF5b3V0LndpZHRoLCB5KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RfYmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3RfYmFyKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbXAuZGF0YS5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5jb21wLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgbGFzdCA9IHRoaXMuY29tcC5kYXRhW3RoaXMuY29tcC5kYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4obGFzdFs0XSk7IC8vbGV0IGNuZGwgPSBsYXlvdXQuY19tYWduZXQobGFzdFswXSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeTogeSxcbiAgICAgICAgLy9NYXRoLmZsb29yKGNuZGwuYykgLSAwLjUsXG4gICAgICAgIHByaWNlOiBsYXN0WzRdLFxuICAgICAgICBjb2xvcjogbGFzdFs0XSA+PSBsYXN0WzFdID8gdGhpcy5ncmVlbigpIDogdGhpcy5yZWQoKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdF9wcmljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0X3ByaWNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcC4kcHJvcHMubWV0YS5sYXN0ID8gdGhpcy5jb21wLiRwcm9wcy5tZXRhLmxhc3RbNF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyZWVuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcC5jb2xvckNhbmRsZVVwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcC5jb2xvckNhbmRsZUR3O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQcmljZTtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvQ2FuZGxlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBSZW5lZHJlciBmb3IgY2FuZGxlc3RpY2tzICsgdm9sdW1lIChvcHRpb25hbClcbi8vIEl0IGNhbiBiZSB1c2VkIGFzIHRoZSBtYWluIGNoYXJ0IG9yIGFuIGluZGljYXRvclxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ2FuZGxlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDYW5kbGVzJyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4yLjEnXG4gICAgICB9O1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMucHJpY2UgPSBuZXcgUHJpY2UodGhpcyk7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgLy8gSWYgZGF0YSA9PT0gbWFpbiBjYW5kbGVzdGljayBkYXRhXG4gICAgICAvLyByZW5kZXIgYXMgbWFpbiBjaGFydDpcbiAgICAgIGlmICh0aGlzLiRwcm9wcy5zdWIgPT09IHRoaXMuJHByb3BzLmRhdGEpIHtcbiAgICAgICAgdmFyIGNudiA9IHtcbiAgICAgICAgICBjYW5kbGVzOiB0aGlzLiRwcm9wcy5sYXlvdXQuY2FuZGxlcyxcbiAgICAgICAgICB2b2x1bWU6IHRoaXMuJHByb3BzLmxheW91dC52b2x1bWVcbiAgICAgICAgfTsgLy8gRWxzZSwgYXMgb2ZmY2hhcnQgLyBvbmNoYXJ0IGluZGljYXRvcjpcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNudiA9IGxheW91dF9jbnYodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNob3dfdm9sdW1lKSB7XG4gICAgICAgIHZhciBjdiA9IGNudi52b2x1bWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjdi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBuZXcgVm9sYmFyRXh0KHRoaXMsIGN0eCwgY3ZbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjYyA9IGNudi5jYW5kbGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNjLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBuZXcgQ2FuZGxlRXh0KHRoaXMsIGN0eCwgY2NbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmljZV9saW5lKSB0aGlzLnByaWNlLmRyYXcoY3R4KTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydDYW5kbGVzJ107XG4gICAgfSxcbiAgICAvLyBJbiBjYXNlIGl0J3MgYWRkZWQgYXMgb2ZmY2hhcnQgb3ZlcmxheVxuICAgIHlfcmFuZ2U6IGZ1bmN0aW9uIHlfcmFuZ2UoKSB7XG4gICAgICB2YXIgaGkgPSAtSW5maW5pdHksXG4gICAgICAgICAgbG8gPSBJbmZpbml0eTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnN1Yi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLnN1YltpXTtcbiAgICAgICAgaWYgKHhbMl0gPiBoaSkgaGkgPSB4WzJdO1xuICAgICAgICBpZiAoeFszXSA8IGxvKSBsbyA9IHhbM107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaGksIGxvXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgc2hvd192b2x1bWU6IGZ1bmN0aW9uIHNob3dfdm9sdW1lKCkge1xuICAgICAgcmV0dXJuICdzaG93Vm9sdW1lJyBpbiB0aGlzLnNldHQgPyB0aGlzLnNldHQuc2hvd1ZvbHVtZSA6IHRydWU7XG4gICAgfSxcbiAgICBwcmljZV9saW5lOiBmdW5jdGlvbiBwcmljZV9saW5lKCkge1xuICAgICAgcmV0dXJuICdwcmljZUxpbmUnIGluIHRoaXMuc2V0dCA/IHRoaXMuc2V0dC5wcmljZUxpbmUgOiB0cnVlO1xuICAgIH0sXG4gICAgY29sb3JDYW5kbGVVcDogZnVuY3Rpb24gY29sb3JDYW5kbGVVcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JDYW5kbGVVcCB8fCB0aGlzLiRwcm9wcy5jb2xvcnMuY2FuZGxlVXA7XG4gICAgfSxcbiAgICBjb2xvckNhbmRsZUR3OiBmdW5jdGlvbiBjb2xvckNhbmRsZUR3KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvckNhbmRsZUR3IHx8IHRoaXMuJHByb3BzLmNvbG9ycy5jYW5kbGVEdztcbiAgICB9LFxuICAgIGNvbG9yV2lja1VwOiBmdW5jdGlvbiBjb2xvcldpY2tVcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JXaWNrVXAgfHwgdGhpcy4kcHJvcHMuY29sb3JzLndpY2tVcDtcbiAgICB9LFxuICAgIGNvbG9yV2lja0R3OiBmdW5jdGlvbiBjb2xvcldpY2tEdygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JXaWNrRHcgfHwgdGhpcy4kcHJvcHMuY29sb3JzLndpY2tEdztcbiAgICB9LFxuICAgIGNvbG9yV2lja1NtOiBmdW5jdGlvbiBjb2xvcldpY2tTbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JXaWNrU20gfHwgdGhpcy4kcHJvcHMuY29sb3JzLndpY2tTbTtcbiAgICB9LFxuICAgIGNvbG9yVm9sVXA6IGZ1bmN0aW9uIGNvbG9yVm9sVXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yVm9sVXAgfHwgdGhpcy4kcHJvcHMuY29sb3JzLnZvbFVwO1xuICAgIH0sXG4gICAgY29sb3JWb2xEdzogZnVuY3Rpb24gY29sb3JWb2xEdygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JWb2xEdyB8fCB0aGlzLiRwcm9wcy5jb2xvcnMudm9sRHc7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmljZToge31cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0NhbmRsZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfQ2FuZGxlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDYW5kbGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9DYW5kbGVzLnZ1ZVxudmFyIENhbmRsZXNfcmVuZGVyLCBDYW5kbGVzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIENhbmRsZXNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19DYW5kbGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDYW5kbGVzX3JlbmRlcixcbiAgQ2FuZGxlc19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIENhbmRsZXNfYXBpOyB9XG5DYW5kbGVzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvQ2FuZGxlcy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDYW5kbGVzID0gKENhbmRsZXNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1ZvbHVtZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuZnVuY3Rpb24gVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gU3RhbmRhbG9uZSByZW5lZHJlciBmb3IgdGhlIHZvbHVtZVxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVm9sdW1lJyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4xLjAnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIC8vIFRPRE86IHZvbHVtZSBhdmVyYWdlXG4gICAgICAvLyBUT0RPOiBZLWF4aXMgc2NhbGluZ1xuICAgICAgdmFyIF9pdGVyYXRvciA9IFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobGF5b3V0X3ZvbCh0aGlzKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHYgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXcgVm9sYmFyRXh0KHRoaXMsIGN0eCwgdik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydWb2x1bWUnXTtcbiAgICB9LFxuICAgIC8vIERlZmluZXMgbGVnZW5kIGZvcm1hdCAodmFsdWVzICYgY29sb3JzKVxuICAgIC8vIF9pMiAtIGRldGV0ZWN0ZWQgZGF0YSBpbmRleCAoc2VlIGxheW91dF9jbnYpXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQodmFsdWVzKSB7XG4gICAgICB2YXIgZmxhZyA9IHRoaXMuX2kyID8gdGhpcy5faTIodmFsdWVzKSA6IHZhbHVlc1syXTtcbiAgICAgIHZhciBjb2xvciA9IGZsYWcgPyB0aGlzLmNvbG9yVm9sVXBMZWdlbmQgOiB0aGlzLmNvbG9yVm9sRHdMZWdlbmQ7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmFsdWU6IHZhbHVlc1t0aGlzLl9pMSB8fCAxXSxcbiAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICB9XTtcbiAgICB9LFxuICAgIC8vIFdoZW4gYWRkZWQgYXMgb2ZmY2hhcnQgb3ZlcmxheVxuICAgIC8vIElmIGRhdGEgaXMgT0hMQ1YgPT4gcmVjYWxjIHktcmFuZ2VcbiAgICAvLyBfaTEgLSBkZXRldGVjdGVkIGRhdGEgaW5kZXggKHNlZSBsYXlvdXRfY252KVxuICAgIHlfcmFuZ2U6IGZ1bmN0aW9uIHlfcmFuZ2UoaGksIGxvKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5faTEgPT09IDUpIHtcbiAgICAgICAgdmFyIHN1YiA9IHRoaXMuJHByb3BzLnN1YjtcbiAgICAgICAgcmV0dXJuIFtNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ViLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4W190aGlzLl9pMV07XG4gICAgICAgIH0pKSksIE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShzdWIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHhbX3RoaXMuX2kxXTtcbiAgICAgICAgfSkpKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2hpLCBsb107XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGNvbG9yVm9sVXA6IGZ1bmN0aW9uIGNvbG9yVm9sVXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yVm9sVXAgfHwgdGhpcy4kcHJvcHMuY29sb3JzLnZvbFVwO1xuICAgIH0sXG4gICAgY29sb3JWb2xEdzogZnVuY3Rpb24gY29sb3JWb2xEdygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JWb2xEdyB8fCB0aGlzLiRwcm9wcy5jb2xvcnMudm9sRHc7XG4gICAgfSxcbiAgICBjb2xvclZvbFVwTGVnZW5kOiBmdW5jdGlvbiBjb2xvclZvbFVwTGVnZW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvclZvbFVwTGVnZW5kIHx8IHRoaXMuJHByb3BzLmNvbG9ycy5jYW5kbGVVcDtcbiAgICB9LFxuICAgIGNvbG9yVm9sRHdMZWdlbmQ6IGZ1bmN0aW9uIGNvbG9yVm9sRHdMZWdlbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yVm9sRHdMZWdlbmQgfHwgdGhpcy4kcHJvcHMuY29sb3JzLmNhbmRsZUR3O1xuICAgIH0sXG4gICAgdm9sc2NhbGU6IGZ1bmN0aW9uIHZvbHNjYWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC52b2xzY2FsZSB8fCB0aGlzLiRwcm9wcy5ncmlkX2lkID4gMCA/IDAuODUgOiB0aGlzLiRwcm9wcy5jb25maWcuVk9MU0NBTEU7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9Wb2x1bWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvVm9sdW1lLnZ1ZVxudmFyIFZvbHVtZV9yZW5kZXIsIFZvbHVtZV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBWb2x1bWVfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19Wb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFZvbHVtZV9yZW5kZXIsXG4gIFZvbHVtZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFZvbHVtZV9hcGk7IH1cblZvbHVtZV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL1ZvbHVtZS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBWb2x1bWUgPSAoVm9sdW1lX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpdHRlcnMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gRGF0YSBzZWN0aW9uIHNwbGl0dGVycyAod2l0aCBsYWJlbHMpXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3BsaXR0ZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NwbGl0dGVycycsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4xJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMubGluZV9jb2xvcjtcbiAgICAgIHRoaXMuJHByb3BzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pOyAvLyB4IC0gTWFwcGluZ1xuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMTAsIDEwXSk7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgX3RoaXMubGF5b3V0LmhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKHBbMV0pIF90aGlzLmRyYXdfbGFiZWwoY3R4LCB4LCBwKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZHJhd19sYWJlbDogZnVuY3Rpb24gZHJhd19sYWJlbChjdHgsIHgsIHApIHtcbiAgICAgIHZhciBzaWRlID0gcFsyXSA/IDEgOiAtMTtcbiAgICAgIHggKz0gMi41ICogc2lkZTtcbiAgICAgIGN0eC5mb250ID0gdGhpcy5uZXdfZm9udDtcbiAgICAgIHZhciBwb3MgPSBwWzRdIHx8IHRoaXMueV9wb3NpdGlvbjtcbiAgICAgIHZhciB3ID0gY3R4Lm1lYXN1cmVUZXh0KHBbMV0pLndpZHRoICsgMTA7XG4gICAgICB2YXIgeSA9IHRoaXMubGF5b3V0LmhlaWdodCAqICgxLjAgLSBwb3MpO1xuICAgICAgeSA9IE1hdGguZmxvb3IoeSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gcFszXSB8fCB0aGlzLmZsYWdfY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgMTAgKiBzaWRlLCB5IC0gMTAgKiBzaWRlKTtcbiAgICAgIGN0eC5saW5lVG8oeCArICh3ICsgMTApICogc2lkZSwgeSAtIDEwICogc2lkZSk7XG4gICAgICBjdHgubGluZVRvKHggKyAodyArIDEwKSAqIHNpZGUsIHkgKyAxMCAqIHNpZGUpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgMTAgKiBzaWRlLCB5ICsgMTAgKiBzaWRlKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbF9jb2xvcjtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBzaWRlIDwgMCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICBjdHguZmlsbFRleHQocFsxXSwgeCArIDE1ICogc2lkZSwgeSArIDQpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1NwbGl0dGVycyddO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBuZXdfZm9udDogZnVuY3Rpb24gbmV3X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmZvbnQgfHwgJzEycHggJyArIHRoaXMuJHByb3BzLmZvbnQuc3BsaXQoJ3B4JykucG9wKCk7XG4gICAgfSxcbiAgICBmbGFnX2NvbG9yOiBmdW5jdGlvbiBmbGFnX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5mbGFnQ29sb3IgfHwgJyM0Mjg1ZjQnO1xuICAgIH0sXG4gICAgbGFiZWxfY29sb3I6IGZ1bmN0aW9uIGxhYmVsX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5sYWJlbENvbG9yIHx8ICcjZmZmJztcbiAgICB9LFxuICAgIGxpbmVfY29sb3I6IGZ1bmN0aW9uIGxpbmVfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVDb2xvciB8fCAnIzQyODVmNCc7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMS4wO1xuICAgIH0sXG4gICAgeV9wb3NpdGlvbjogZnVuY3Rpb24geV9wb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQueVBvc2l0aW9uIHx8IDAuOTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGl0dGVycy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19TcGxpdHRlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU3BsaXR0ZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpdHRlcnMudnVlXG52YXIgU3BsaXR0ZXJzX3JlbmRlciwgU3BsaXR0ZXJzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFNwbGl0dGVyc19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX1NwbGl0dGVyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU3BsaXR0ZXJzX3JlbmRlcixcbiAgU3BsaXR0ZXJzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU3BsaXR0ZXJzX2FwaTsgfVxuU3BsaXR0ZXJzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaXR0ZXJzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNwbGl0dGVycyA9IChTcGxpdHRlcnNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0dWZmL2tleXMuanNcblxuXG5cbmZ1bmN0aW9uIGtleXNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IGtleXNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIGtleXNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBrZXlzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBrZXlzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBrZXlzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIEtleWJvYXJkIGV2ZW50IGhhbmRsZXIgZm9yIG92ZXJsYXlcbnZhciBLZXlzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gS2V5cyhjb21wKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5cyk7XG5cbiAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAwO1xuICAgIHRoaXMua2V5bWFwID0ge307XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhLZXlzLCBbe1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICAgIHRoaXMubWFwW25hbWVdID0gdGhpcy5tYXBbbmFtZV0gfHwgW107XG4gICAgICB0aGlzLm1hcFtuYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMrKztcbiAgICB9IC8vIENhbGxlZCBieSBncmlkLmpzXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQobmFtZSwgZXZlbnQpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBrZXlzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5tYXBbbmFtZV0pLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGYgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGYoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleW1hcFtldmVudC5rZXldKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LmtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmtleW1hcFtldmVudC5rZXldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdrZXl1cCcpIHtcbiAgICAgICAgdGhpcy5rZXltYXBbZXZlbnQua2V5XSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVzc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXNzZWQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXltYXBba2V5XTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gS2V5cztcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL3Rvb2wuanNcbmZ1bmN0aW9uIHRvb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IHRvb2xfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIHRvb2xfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiB0b29sX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiB0b29sX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiB0b29sX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIFVzdWZ1bCBzdHVmZiBmb3IgY3JlYXRpbmcgdG9vbHMuIEluY2x1ZGUgYXMgbWl4aW5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHRvb2wgPSAoe1xuICBtZXRob2RzOiB7XG4gICAgaW5pdF90b29sOiBmdW5jdGlvbiBpbml0X3Rvb2woKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBDb2xsaXNpb24gZnVuY3Rpb25zIChmbG9hdCwgZmxvYXQpID0+IGJvb2wsXG4gICAgICB0aGlzLmNvbGxpc2lvbnMgPSBbXTtcbiAgICAgIHRoaXMucGlucyA9IFtdO1xuICAgICAgdGhpcy5tb3VzZS5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKF90aGlzLmNvbGxpc2lvbnMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmKF90aGlzLm1vdXNlLngsIF90aGlzLm1vdXNlLnkpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIF90aGlzLnNob3dfcGlucyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2hvd19waW5zID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMuZHJhZykgX3RoaXMuZHJhZ191cGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb3VzZS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHV0aWxzLmRlZmF1bHRfcHJldmVudGVkKGUpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKF90aGlzLmNvbGxpc2lvbnMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmKF90aGlzLm1vdXNlLngsIF90aGlzLm1vdXNlLnkpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGlmICghX3RoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIF90aGlzLiRlbWl0KCdvYmplY3Qtc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5zdGFydF9kcmFnKCk7XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5waW5zLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4Lm1vdXNlZG93bihlLCB0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMuZHJhZyA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuJGVtaXQoJ3Njcm9sbC1sb2NrJywgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmtleXMgPSBuZXcgS2V5cyh0aGlzKTtcbiAgICAgIHRoaXMua2V5cy5vbignRGVsZXRlJywgdGhpcy5yZW1vdmVfdG9vbCk7XG4gICAgICB0aGlzLmtleXMub24oJ0JhY2tzcGFjZScsIHRoaXMucmVtb3ZlX3Rvb2wpO1xuICAgICAgdGhpcy5zaG93X3BpbnMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZHJhZyA9IG51bGw7XG4gICAgfSxcbiAgICByZW5kZXJfcGluczogZnVuY3Rpb24gcmVuZGVyX3BpbnMoY3R4KSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCB8fCB0aGlzLnNob3dfcGlucykge1xuICAgICAgICB0aGlzLnBpbnMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LmRyYXcoY3R4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRfc3RhdGU6IGZ1bmN0aW9uIHNldF9zdGF0ZShuYW1lKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2Utc2V0dGluZ3MnLCB7XG4gICAgICAgICRzdGF0ZTogbmFtZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB3YXRjaF91dWlkOiBmdW5jdGlvbiB3YXRjaF91dWlkKG4sIHApIHtcbiAgICAgIC8vIElmIGxheWVyICR1dWlkIGlzIGNoYW5nZWQsIHRoZW4gcmUtaW5pdFxuICAgICAgLy8gcGlucyAmIGNvbGxpc2lvbnNcbiAgICAgIGlmIChuLiR1dWlkICE9PSBwLiR1dWlkKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSB0b29sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5waW5zKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBwLnJlX2luaXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29sbGlzaW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnNob3dfcGlucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWcgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlX2RyYXc6IGZ1bmN0aW9uIHByZV9kcmF3KCkge1xuICAgICAgLy8gRGVsZXRlIGFsbCBjb2xsaXNpb24gZnVuY3Rpb25zIGJlZm9yZVxuICAgICAgLy8gdGhlIGRyYXcoKSBjYWxsIGFuZCBsZXQgcHJpbWl0aXZlcyBzZXRcbiAgICAgIC8vIHRoZW0gYWdhaW5cbiAgICAgIHRoaXMuY29sbGlzaW9ucyA9IFtdO1xuICAgIH0sXG4gICAgcmVtb3ZlX3Rvb2w6IGZ1bmN0aW9uIHJlbW92ZV90b29sKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHRoaXMuJGVtaXQoJ3JlbW92ZS10b29sJyk7XG4gICAgfSxcbiAgICBzdGFydF9kcmFnOiBmdW5jdGlvbiBzdGFydF9kcmFnKCkge1xuICAgICAgdGhpcy4kZW1pdCgnc2Nyb2xsLWxvY2snLCB0cnVlKTtcbiAgICAgIHZhciBjdXJzb3IgPSB0aGlzLiRwcm9wcy5jdXJzb3I7XG4gICAgICB0aGlzLmRyYWcgPSB7XG4gICAgICAgIHQ6IGN1cnNvci50LFxuICAgICAgICB5JDogY3Vyc29yLnkkXG4gICAgICB9O1xuICAgICAgdGhpcy5waW5zLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgucmVjX3Bvc2l0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYWdfdXBkYXRlOiBmdW5jdGlvbiBkcmFnX3VwZGF0ZSgpIHtcbiAgICAgIHZhciBkdCA9IHRoaXMuJHByb3BzLmN1cnNvci50IC0gdGhpcy5kcmFnLnQ7XG4gICAgICB2YXIgZHkgPSB0aGlzLiRwcm9wcy5jdXJzb3IueSQgLSB0aGlzLmRyYWcueSQ7XG4gICAgICB0aGlzLnBpbnMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC51cGRhdGVfZnJvbShbeC50MSArIGR0LCB4LnkkMSArIGR5XSwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgLy8gU2V0dGluZ3Mgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZFxuICAgIHNlbGVjdGVkOiBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncy4kc2VsZWN0ZWQ7XG4gICAgfSxcbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3MuJHN0YXRlO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3R1ZmYvaWNvbnMuanNvblxuY29uc3QgaWNvbnNfbmFtZXNwYWNlT2JqZWN0ID0gSlNPTi5wYXJzZSgne1wiZXh0ZW5kZWQucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpBUU1BQUFEK0p4Y2dBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQVpRVEZSRkFBQUFUVTFOa0orck9RQUFBQUowVWs1VEFQOWJrU0sxQUFBQU5FbEVRVlI0bkdOZ2dBQkdFTUVFSWxoQUJBZUkrQUFTRjBBbEhtQXFBNGt6S0FBeDh3R1F1QU1Ld2Q2QW9ZekJBV29uQXdBY0x3VGdOZkozUlFBQUFBQkpSVTVFcmtKZ2dnPT1cIixcInJheS5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkFRTUFBQUQrSnhjZ0FBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBWlFURlJGQUFBQVRVMU5rSityT1FBQUFBSjBVazVUQVA5YmtTSzFBQUFBTWtsRVFWUjRuR05nUUFKTUlJSUZSSENBQ0FFUW9RQWlISUNZdlFFa2prcndZeXBqQUlrendrMnpBUkV1cUlRRnpENEFFM2tFNEJFbUdnZ0FBQUFBU1VWT1JLNUNZSUk9XCIsXCJzZWdtZW50LnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQWdNQUFBQzVoMjN3QUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFsUVRGUkZBQUFBVFUxTkpDUWtDeGNISVFBQUFBTjBVazVUQVA4U211dEk1QUFBQUN4SlJFRlVlSnhqWU1BQ0dBTWdOQXNMZHBvVktpOEFWZThBMVFibFFsV1JLdDBBb1VMdzJ3MXpHeG9BQUJkaUF2aVFoRi9tQUFBQUFFbEZUa1N1UW1DQ1wiLFwiYWRkLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDb0FBQUFxQ0FNQUFBRHlIVGxwQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUg1UVRGUkZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ2dvS0JnWUdHeHNiS2lvcVB6OC9QajQrQlFVRkNRa0pBUUVCWkdSa2g0ZUhBZ0lDRUJBUU5qWTJnNE9EZ1lHQkFBQUFBd01EZVhsNWQzZDNHQmdZRVJFUmdJQ0FnSUNBTkRRMFBEdzhZMk5qQ0FnSWhZV0ZHaG9hSnljbk9qbzZZV0ZoZ0lDQWRYVjE0WTE2c1FBQUFDcDBVazVUQUFJTER4SUtFU0VuSmlZb0tDZ1RLU2twS0NBbktTa0ZLQ2twSmlEbC95Y3BLU0EySnlZcEtTa3BPa1EreGdBQUFSZEpSRUZVZUp6bGxOdDJneUFRUlRXaVJzSExvRFUwR3BQWW1Ndi8vMkJNUytzZ2w2WjliTThiaTczZ25Ka0J6L3NuOGxjQklVSG9md3RHOFRwSktVdVRMSTZjWUY3UUVxUkt5blA3MVZYOUFraE5YVmxzYk1RckxMUVZHeVBaTHNHSFdnUHJDeE1Kd0hVUGxYYTc5TkJwMmV0NWQ5ZjN1M20xWHhhdFFObjdTYWdPWENVakNqWVVEdXF4Y1dsSGo0TVNmdzEyRkRKY2hGVmlSTjgrMXFjUW9VSDZsUjFMMW1FTUVFcm9mQjZXekVVd3lsem9tZnpPUUdpT0pkWGlXSDdtUW9VeU1hNFdYSlFXT0J2TEZ2UENHeHQ2RlNyNWt5SDBxaTBZZGRORzIvcGdDc09qZmY0WlRpelhQTndLSXpsNTZPb0dnOWQ5Wi8rNWNzNk9uK0NGQ2ZldkZRM1phVHljeDFZTWJ2RGRSdmprcC9sSGRBY1BYem9reGN3ZkR3QUFBQUJKUlU1RXJrSmdnZz09XCIsXCJjdXJzb3IucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpBZ01BQUFDNWgyM3dBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQXhRVEZSRkFBQUFUVTFOVFUxTlRVMU53bE1ISHdBQUFBUjBVazVUQU92aHhicFByVWtBQUFBa1NVUkJWSGljWTJCZ1lIQmdnQUJ5YWJ4ZzFXb0dCcTJwUkNrOUFLVWJjTkQ0M0FFQXVmWUhsU3V1c0U0QUFBQUFTVVZPUks1Q1lJST1cIixcImRpc3BsYXlfb2ZmLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDb0FBQUFxQ0FNQUFBRHlIVGxwQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQVUxUVRGUkZBQUFBaDRlSGg0ZUhBQUFBQUFBQUFBQUFBd01EQUFBQUFBQUFob2FHR0JnWWdZR0JBQUFBUHo4L0FnSUNnNE9EQ1FrSmhJU0VoNGVIaDRlSFBqNCtOalkyZ1lHQmc0T0RnWUdCZ1lHQmdvS0NBUUVCSnljbmdvS0NoWVdGRUJBUWc0T0RDQWdJS2lvcVpHUmtDZ29LQlFVRkVSRVJkM2QzZ1lHQkd4c2JORFEwaElTRWdZR0JQRHc4Z1lHQmdZR0JoNGVIaDRlSGhZV0ZoNGVIZ29LQ2hZV0ZnWUdCZ1lHQmc0T0Rob2FHZzRPRFlXRmhnb0tDQmdZR2RYVjFnb0tDZzRPRGdZR0JnSUNBZ1lHQkFBQUFnNE9EaFlXRmhJU0VoNGVIZ29LQ2hZV0ZPam82Z29LQ0dob2FoNGVIaDRlSGg0ZUhnb0tDaDRlSGVYbDVob2FHZ29LQ2hJU0VnWUdCZ1lHQmdvS0NZMk5qZ1lHQmdvS0NoNGVIZ29LQ2dZR0Job2FHZzRPRGhvYUdoWVdGaDRlSGdZR0Job2FHaG9hR2hvYUdnNE9EZ29LQ2hJU0Vnb0tDaFlXRmg0ZUhmS2t0VXdBQUFHOTBVazVUQUNuL0FoRUZLQThTTENieENpZ29WQk5LVVRZb0ovbGgzUHlBS1NhVE5pQnRJQ1lwSVNnZ0tTa21KMExFS2VmM2xHeEE4cm4vLytwY01Ta3BuQ2NwdEhQSktlMExVam54NUx6S0thTW5YNzNobDY0cExuaGt6TlNnS2VMdjE3TFErbGlJemFMZTdQZlR3NXRGcHozSzFmWFIvZ0FBQWdCSlJFRlVlSnpsbE5kWHdqQVV4a25CMGxJb0NLVnNHVElGUVJBWjdyMzMzbnV2Ly8vUjNMWjRtbERRWi8wZWtwN2IzN241Ym5JVGsrbWZ5RHh2NVRpcjNmd2phRWxPNUJJT0taRkxKUzFkUVZmSTBZODA5VHRFVitlbG85NVJwRlBXRysxZ280ZmRRNVF5Ykk4aGFhTkJrTTJBTmJNMDlibnJ3YVBZN2lGS3J6N0VNQmR1N0NIZFZydVhJdDBNMWhiK0dLQTNMVFJLa3A1bFRBNkRnNnhJa2hhSGh2UTFJbFcvVUNvdVFkSk5KVFJJcGsxcU83K3dVcGNmcGw1MzdvQmM3Vk5pcDNHaS9BbVZQQkFDMVVyTDZIWHRTR1ZUK2syWXowRm9jYWQwN09NUmYzUDVCRWJkNjNQRlF4N0hOK3c2MUpvQW0rdUJsVjQ4Ty8wamtMU01tdFBDbVE4SHdsWWR5a0ZWNC9MSlBwN2UzaFZ5RmRhcEhOZWhMazZQU2poU2tCdnd1L2NGeUpHSVl2T3lob2MxampZUUZHYnlnRDRDV2pvQU1sYS9vZzNZb1N3K0tQaGpQTm9GY2ltNGlGRCtwRllBOHpaOVdlWVU1T0JqWjNPUld5Q2ZHMDNFKzQ3a0twQ0lKVHBHTzRLUDhYTWd0dzk5MHhHL1BCTlRnbVBFRVh3ZjdQNDJvT2RGSVJBb0JDdHFUS0w2UmN3cTRYc2doNXhZQy9tbVNzNnlKS2sxWWJuVmVUcTFOYUVwbWxIYm1WbjJFT1JrVzJ0ckYyWnptSEdUU1VNR2wxYTlocDR5U1JwZFE4eUtHVVJwTW1SSVlnOXBiMVlQemc2a083OWNMbEU2YllGakV0djkxYkxFVXh2aHdiV3dqWTEzQnhVYjlsOCttbjlFWDh4M05raThmZjV3QUFBQUFFbEZUa1N1UW1DQ1wiLFwiZGlzcGxheV9vbi5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ29BQUFBcUNBTUFBQUR5SFRscEFBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFSMVFURlJGQUFBQWg0ZUhnWUdCQUFBQUFBQUFnWUdCQUFBQUF3TURBQUFBQUFBQWdZR0JnNE9ER0JnWWdZR0JoSVNFQUFBQVB6OC9BZ0lDaG9hR0NRa0poWVdGUGo0K05qWTJnb0tDZ1lHQkFRRUJKeWNuZ1lHQmdvS0NFQkFRQ0FnSWhJU0VLaW9xWkdSa0Nnb0tCUVVGRVJFUmQzZDNnWUdCZzRPRGdZR0JHeHNiTkRRMGhJU0Vnb0tDZ29LQ2hZV0ZQRHc4Z1lHQmdZR0Job2FHZ29LQ2c0T0Rnb0tDZ1lHQmdvS0Nnb0tDZ29LQ2c0T0Rnb0tDaG9hR2dvS0NnWUdCaG9hR2c0T0RZV0ZoQmdZR2RYVjFnWUdCZzRPRGdvS0NnSUNBZzRPRGc0T0RoSVNFQUFBQWc0T0RPam82Z1lHQkdob2FlWGw1Z29LQ2dZR0Jnb0tDaFlXRmdvS0NoSVNFZ29LQ1kyTmpnWUdCZzRPRGdZR0JnWUdCZzRPRGdZR0JvOG41NEFBQUFGOTBVazVUQUNuL0FoSDNCU2dQRXVoVUp2RkFDaWdvTEJNMktDZUE2eWttK3BNZ0lFa21LU0VvSUNuOVhDa21KMHU2bkRvcDRzVXlwR3VFekxaNnZtQ1lMWi9kTHlrcEp5blVZYThwY2xsQ0MxSXAyeWNwaXNsMVBhZEZzaW50YnNQUVpkaS9iVFc3QUFBQjRVbEVRVlI0bk9XVVoxZkNNQlNHU1NHV0ZpcTBVRGJJa3IyWGJCd014UzBiMVAvL00weEs5WFNpZnRYN29lbDU4NXprdmZjbU1SaitTUmh2elJSbHRobS9CVTNSeTNUWXpvZlRzYWpwSU9qdzJpTkFqSWlkZGVodkhYU2RBMG1rWEVFZEcwZmtFMURFS1hta1NWcVZJQTZyQm1za3RVZ0FXTFdIb0dwMzBVTmNsYnRMbXdRZ295eWE5MXdQVGJGeTBtUVhKNXpKUU82QmdYUmpmSDBpU2tYNXN0SElYcjVyMGJCL2x1OHN5alI4cnpzRmJSMlNwWCs1SjJlTVAzY3NMdFlzRVkySzhCZVRGdUUyamFWQ0J3N2JIT0J1eHExNkFYbXBidWkzTHRJZmJSTFVITVkycTRsY0ZvMldCNEtBMVNVQWxXdW1ORUtDenl4QktaeFZIdllHYUZndUNCeDF2TS94MElQem9xUW9qNVNkUDRtbnMyY0NHaEJzcmdqMHVhZVVCdHpNeXhRTjh3NG1ZUk9UVzgrcjBvQU5wOFc1bWY2V1F3NWFDWUoybzd5bVBhS01pMnVWcG1XTTRUVzZ0ZEltZ0dvMWJUNG5LNkRiYnNDYzBBWlNkbUxFRnN6ekhyaDZyaVZ2UnJOQTMvOVNFOFFMV1F1K0dqdG85K2dFOU5CTXdyOXppODNnRmVlRlRlMTF6cG0xQ0hFM0hleVZDU2tuZjNNSURjRlRiZkpLZGJSMUw0eFg0OUwrL0JvaWxsVjV1UEpxa3NoRDNKV1NncE5NWFAvbGNyRDgraE84NE1uRHI1WXBGSHYwRmU5OVZqSjBHQlJzMkg3NGFQNlIrQUNyK1RGdlpOQVExd0FBQUFCSlJVNUVya0pnZ2c9PVwiLFwiZG93bi5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ29BQUFBcUNBTUFBQUR5SFRscEFBQUFBWE5TUjBJQjJja3Nmd0FBQUtWUVRGUkZBQUFBZzRPRGdJQ0FBQUFBQUFBQUFBQUFDQWdJQUFBQUFBQUFBQUFBQUFBQU9UazVoWVdGRUJBUWZIeDhPRGc0ZG5aMk5EUTBYVjFkR3hzYktDZ29nSUNBRkJRVUlpSWlaR1JrZ0lDQWdJQ0FGUlVWQUFBQWdJQ0FnSUNBZ0lDQWYzOS9MaTR1Z0lDQWNIQndnb0tDZ0lDQWdvS0NnSUNBZzRPRGdZR0JQajQrZ29LQ2dJQ0FoSVNFZ1lHQmdJQ0Fnb0tDZ0lDQWdZR0JnWUdCZjM5L2dJQ0FnSUNBSWRQUUhBQUFBRGQwVWs1VEFDbi9LQUlSSUJNRkR3b29LeUFwS1NrbktTWW16Q2NtS2ZMN0pSQ1VpMkwzSjdJcGNMVXJyMFZiS1hudE5FbmtNYnhyVWNHNTZDTXBpNTBBQUFGWlNVUkJWSGljNVpScGY0TWdESWVGS0ZhdFdtL3RmVzA5MXU3ZXZ2OUhtMUFjb3VqbTJ5MHZGUEg1SmYrRUVFMzdKNmJibG1sYXR2NGphQkNJNHJNZlIwQ01YdEFFSjBmY2NnZk03dEFrUUhYekFyZER4Z2dtcUdFVEdDbkpXUk9rTmxPd09xaEloS0N0Z2JTaWN3MXVLL2RBVFNLMGFSYXRJenl0QThpazRYU2l5Sm5MU20rVlB4VUxnZXlMSTN1SFJKSCtxY0I0V1pHcktiNGMyMFd3STdiM2lVdDc0T1M2WEQreFpXclhVQ3RtZTB1S1R2ZmNKNjVDWkZhOVZPZWJxd1htZnQrb1Q4eUYrL1Z5bVQ0WGVHQitYeDhMK2o0Z0Jjb0ZJRFQrb016NlFwOTNZNzRwQ2VCcFVYYUx1VzByVWs2cjFpdjNuUDMyMmV3WWtndjJuWkl2Z3BTUFFEclk1d1RqUkpETmc5WEFFLyt1U1hJVlg4MTJHZEtFbXR2UjJydFdhdys1TUFPdW9mSnk3OVNYdTlUZ0JsNGQ5RFpkSTBOamd5aXN3TkNCL3FrMUo1Qm12cCtsUU9hOUlKTmhXNGJ4bTZINVIrd0xRWU1TUVhaTnpiY0FBQUFBU1VWT1JLNUNZSUk9XCIsXCJwcmljZV9yYW5nZS5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkFRTUFBQUQrSnhjZ0FBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBWlFURlJGQUFBQVRVMU5rSityT1FBQUFBSjBVazVUQVA5YmtTSzFBQUFBSVVsRVFWUjRuR05nZ0FQbS93OWdUQTRRSVFNaXRFQ0VKMXlNRWdMTkRpQUFBRGZnQk1SdTc4R2dBQUFBQUVsRlRrU3VRbUNDXCIsXCJwcmljZV90aW1lLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQVFNQUFBRCtKeGNnQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFaUVRGUkZBQUFBVFUxTmtKK3JPUUFBQUFKMFVrNVRBUDlia1NLMUFBQUFPa2xFUVZSNG5HTmdnQVBtL3c5Z1RBNFFJUVBFQ2xwTVFNSVRSSENBQ1NjUW9RUWloQmdZOVAvL2dyS2dZazV3ZFRBQ1loUUhGanVBQUFCWkZBbGM0ZTFmY1FBQUFBQkpSVTVFcmtKZ2dnPT1cIixcInJlbW92ZS5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ29BQUFBcUNBTUFBQUR5SFRscEFBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFLNVFURlJGQUFBQWg0ZUhnSUNBQUFBQUFBQUFoNGVIQUFBQUF3TURBQUFBQUFBQWdJQ0FHQmdZQUFBQVB6OC9BZ0lDZ0lDQUNRa0pob2FHaG9hR2dJQ0FQajQrTmpZMmdZR0JnNE9EZ1lHQkFRRUJKeWNuZ29LQ0VCQVFnSUNBZ0lDQUNBZ0lLaW9xWkdSa0Nnb0tCUVVGRVJFUmQzZDNnWUdCR3hzYk5EUTBnSUNBUER3OFlXRmhCZ1lHZFhWMWdJQ0FnNE9EZ0lDQUFBQUFPam82R2hvYWVYbDVnSUNBaFlXRlkyTmpoWVdGZ0lDQTlPMG9DZ0FBQURwMFVrNVRBQ24vQWhFckJTZ1BFdkVtQ2lnb3d4TXVNY2dvSjdoV3JDa21kQ0Q2dlNBbUtTRW9JQ2twSmllNktTa25LU2twMHdzcEp5bkNNaWsxMXJyTHRlOEFBQUZ3U1VSQlZIaWM1WlRYa29Jd0ZJWk5BQVBTcEtrb1JRVjdXY3ZhM3YvRkZpUm1Fd2lzZTd0N2JzN01QOThrL3lsSnEvVlBRampLaWlKcndvK2dPTjB1eHJvN1hpUlRzUkhzK3ZvRTRKam9ScmYrNnNEN0FGVE12YURHUmh0OWdsTE1VSnRMcW1Vd0Q1WERDb2hIQW1CVVBRU1YyN0dIdEZLN3h5Y0JXSmFiNXVQYVIrSGxtdWU3R2ZaeEh3eVdGSFZNUWdoWEZnRDJBOElPWnRmc3NkTkpJWGN5RkVhU2ZjaHpwOUJ1TVZQK0ZodnI1UWgwbkdmcVlUR2htM0JjWUZVYVFCS09oTVd6UnFIeUdGUlkwM3BwUTVsQ0ZaMzBSbG9WWkdRVGFhM1FxRXQwT3lyUW5rU2trOEkxWUprdkF3UENNZ1kwVXBielhSWmhWYm9zSVdHYlpUTE5Rc3pHTUNNNDJGSkVqV0REaklBTXRwK3hqNngySysvRHFORGMwcjRZYzh5R2wzdWVyMmFJeVQxaXlkOHNZU3VZOGNsZFpiVnJINHpQZWJUdlA4T01OU29lZGo2WHpEeWszcHdHOTh1MC91ZnFHdTd0Qlc1YzFQeHJpWEZ5SHE1UFF4WEZ6ZURUaHZibXAvbEg0Z3Q2V3hmWjAzSDhEd0FBQUFCSlJVNUVya0pnZ2c9PVwiLFwic2V0dGluZ3MucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNvQUFBQXFDQU1BQUFEeUhUbHBBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBVzVRVEZSRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDZ29LQmdZR0d4c2JLaW9xUUVCQVBqNCtCUVVGQ0FnSUFRRUJQejgvWldWbGg0ZUhaR1JrQWdJQ0NRa0pEdzhQTmpZMmc0T0Rnb0tDTlRVMUVCQVFBQUFBQXdNRGVYbDVkM2QzQUFBQUdCZ1lBQUFBRVJFUmlvcUtnb0tDZ29LQ2dvS0NnWUdCZ29LQ2hJU0Vob2FHTkRRMGc0T0RnSUNBZ0lDQWdJQ0FnWUdCZ1lHQmhZV0ZnSUNBZ0lDQVBUMDlBQUFBZ1lHQmdJQ0FnSUNBZ0lDQWdJQ0FZMk5qQ0FnSWdJQ0FnSUNBaFlXRmhZV0ZnWUdCSEJ3Y2dJQ0FoWVdGR2hvYWdZR0JnWUdCZzRPRGhvYUdKeWNuQUFBQWhJU0VnSUNBZzRPRFBEdzhBQUFBZ29LQ2dJQ0FoSVNFT2pvNmg0ZUhnb0tDZ1lHQmdJQ0FmMzkvZ1lHQmdvS0NnSUNBR0JnWWdZR0JnNE9EZzRPRGdJQ0FDd3NMZ1lHQmdJQ0FnWUdCZ1lHQmdZR0JnSUNBZ1lHQllXRmhmMzkvZzRPRFBqNCtnWUdCZzRPRGdJQ0FoWVdGZ29LQ2dZR0JnSUNBZ1lHQmdvS0NkWFYxVDBrQzlRQUFBSHAwVWs1VEFBSUxEeE1LRVNFbkppWXBLU2dUS1NncEtTa29FeUFuS1NrbklBWW9LU2tGSlFFZ0tsOTRqWVZ2VkM0blU5Zi8rSzhwT3U3MUtCQ2kzTlBxL2lrZzBlMDFOb2ttMVVVbnNaVnFRU1lPVDlscktSSno1bElwSzEyanl1K3Nlc2duaEdWTHhDRzU1YTZVbStHYUtmSkNLS1JnS1V0OG9jZXJneW1EUTlrbkFBQUJzRWxFUVZSNG5PV1VWMXZDTUJTR2cxQVFwQlpyY1ZkRTNLSnhvNExnbnVDb2U0RjdvcmpIdjdkb1RrM2JnRjdyZDVPblg5NG5aK1NrQ1AwVFdRcXNOcHVWcy93STJoMkZUbGVSMitYa0hmYThZTEhnS1JHSlNqMlNOM2Zvc3ZJS2tWSmxWWFdPTkdya1d0RWduMXpISlAxR01Dcy9nN1hJTEZJVXBYb1RXbWFLVG5JSW1Hb3ZoNzJHeHFibWx0YTJkdmdPR3BzbVFPMGRuZmhUWGQzRTZKSDBwTjFETm5yN01GRS9IRHNRMHFFTzZQeGc5c0NoNFhEa0d4Mko2c292QkQrRzhlaVl1bzVQeExUS2VMb0pCWk5nVDJFY25qWTBZWWFqVUtzTDdGazFnY2pVM1B3Q2hjWVRGR29yQW5zUnFscGExdEFWaFViZG1yKzZSdGpJT2xnYkNqTUJVZHpjMnQ3WnpiSjd6QVE0cDZHU2ZSVk53a2VLTHN2Q2czMXcySkJkamxUMEdEeFpOekVucGNRK3hXZm5GeGVYVnlwNlRheTA3Z3ErTC9ZVU9vQnZib21WMFY4c2tpcS8vRHV0V2ZlRWZKRDFKUExDRUQ0K1BiOGtYOTg2dEFwTlE0aXFmU0pUNzZiUnp2bGdCUE9EUVhXL2ZvWXFLNWx5ZUJlWUpFTDFnYW9lR253SUJoalJvUTlTWmdUQWRFYk8vOWNLUmZtWitNcEdQQ1ZIUTNuQnp6UzRoS0lrdU55aC81ZytBTGlBWFNTYXM5aHdBQUFBQUVsRlRrU3VRbUNDXCIsXCJ0aW1lX3JhbmdlLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQVFNQUFBRCtKeGNnQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFaUVRGUkZBQUFBVFUxTmtKK3JPUUFBQUFKMFVrNVRBUDlia1NLMUFBQUFKRWxFUVZSNG5HTmd3QXNVR0poUUNTY1FvUVFpaEJnWTlQLy9ncktnWWs0WU92QUNBQ09wQktHNlN2aitBQUFBQUVsRlRrU3VRbUNDXCIsXCJ0cmFzaC5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkFRTUFBQUQrSnhjZ0FBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBWlFURlJGQUFBQVRVMU5rSityT1FBQUFBSjBVazVUQVA5YmtTSzFBQUFBTFVsRVFWUjRuR05nQUlONkVOSFFBQ1g0Ly85Z1lCQmdZSUVTWUM0TGtBMGxQRWttR0ZBSTV2OFBJTFlDQUh5Z0RKeGxLMFJVQUFBQUFFbEZUa1N1UW1DQ1wiLFwidXAucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNvQUFBQXFDQU1BQUFEeUhUbHBBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBTVpRVEZSRkFBQUFoNGVIZ0lDQUFBQUFBQUFBQUFBQUF3TURBQUFBQUFBQUdCZ1lBQUFBUHo4L0FnSUNDUWtKZ0lDQWg0ZUhQajQrTmpZMkFRRUJKeWNuRUJBUWdJQ0FnSUNBQ0FnSUtpb3FaR1JrQ2dvS0JRVUZnWUdCRVJFUmQzZDNnWUdCR3hzYk5EUTBnSUNBZ1lHQlBEdzhnWUdCaDRlSGdJQ0FZV0ZoQmdZR2dZR0JkWFYxZ29LQ2c0T0RoWVdGZ0lDQWdvS0NBQUFBaElTRU9qbzZnSUNBR2hvYWdZR0JlWGw1aG9hR2dJQ0FZMk5qZzRPRGdvS0Nnb0tDZ1lHQmdvS0NnNE9EZ29LQzY0dXcxZ0FBQUVKMFVrNVRBQ24vQWhFRktBOFNKZ29vS0JQN0tpZ25LU1lnOWMwZ0ppa2hLTFFnS1NrbUo3eXdLWThzNVNrbmxDbHhLVE1wWHd0RktlMG5laWt1OENsS1dtU2JiRkZqTTVHSFNnQUFBVzVKUkVGVWVKemxsR2QvZ2pBUXhrM0FNRldXT0hEdlZhMnJWYnUvLzVjcWhKV1FRTzNiOW5rVmp2L3Y3cm5MS0pYK2lZUzlKTXVTS3Z3SWl1M2xvS2taellIWEZndkJpcVcxUUtTV3BsZnlTenZtQXlEVU41MGNHMlgwRERMcW9US1hWTEpnSUlYRENvaEhBcUN6SGh5bWV1U2h5L1J1OGtrQWh0bWhXVVR2VzlmZEVuUFFhVkxVMG44WEYwTDNrbjVQNkxUdFpQS2dOb0srUnJVa2NHdFE3UzlUc2dPeHhpbnJrVVBZRCtMd0xDSWg3Q1RzV1NWUXFSbVR1UHFwaXRsWkZMUWxBcFhqcnNZQmMzMzV3T3c0N2tzbVVTTU1yZ0tpL2duQUUvYXdDcU5IbVRVd0RmNVgzNExsQnVlZHNnYlVzSzE1a1BNeFRJWHp6dkZTSWRzU1BCdzduR0QxSys3YkwzRjl4U3RFblpob0N3NzFUYnBMNzFHQkJiVUYxTVptWldUT2k5N1BJM2VJSm45ekNFdE9qMCt1bWFPZGUyRXN6cVc5L3hyNnJNNTRXRnRjMHZmUU5hazU3SWJkL0plcm9odTNHRndZcVBqVkVodmUyWjRjYlFVMWlrRnNRNzN6MGZ3aitnYTNWQmV6R3VnZ0ZRQUFBQUJKUlU1RXJrSmdnZz09XCJ9Jyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJpbWl0aXZlcy9waW4uanNcblxuXG5cbi8vIFNlbWktYXV0b21hdGljIHBpbiBvYmplY3QuIEZvciBzdHJldGNoaW5nIHRoaW5ncy5cblxuXG52YXIgUGluID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gKENvbXAgcmVmZXJlbmNlLCBhIG5hbWUgaW4gb3ZlcmxheSBzZXR0aW5ncyxcbiAgLy8gcGluIHBhcmFtZXRlcnMpXG4gIGZ1bmN0aW9uIFBpbihjb21wLCBuYW1lLCBwYXJhbXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG5cbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBQaW4pO1xuXG4gICAgdGhpcy5SQURJVVMgPSBjb21wLiRwcm9wcy5jb25maWcuUElOX1JBRElVUyB8fCA1LjU7XG4gICAgdGhpcy5SQURJVVNfU1EgPSBNYXRoLnBvdyh0aGlzLlJBRElVUyArIDcsIDIpO1xuXG4gICAgaWYgKHV0aWxzLmlzX21vYmlsZSkge1xuICAgICAgdGhpcy5SQURJVVMgKz0gMjtcbiAgICAgIHRoaXMuUkFESVVTX1NRICo9IDIuNTtcbiAgICB9XG5cbiAgICB0aGlzLkNPTE9SX0JBQ0sgPSBjb21wLiRwcm9wcy5jb2xvcnMuYmFjaztcbiAgICB0aGlzLkNPTE9SX0JSID0gY29tcC4kcHJvcHMuY29sb3JzLnRleHQ7XG4gICAgdGhpcy5jb21wID0gY29tcDtcbiAgICB0aGlzLmxheW91dCA9IGNvbXAubGF5b3V0O1xuICAgIHRoaXMubW91c2UgPSBjb21wLm1vdXNlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zdGF0ZSA9IHBhcmFtcy5zdGF0ZSB8fCAnc2V0dGxlZCc7XG4gICAgdGhpcy5oaWRkZW4gPSBwYXJhbXMuaGlkZGVuIHx8IGZhbHNlO1xuICAgIHRoaXMubW91c2Uub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gX3RoaXMubW91c2Vtb3ZlKGUpO1xuICAgIH0pO1xuICAgIHRoaXMubW91c2Uub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gX3RoaXMubW91c2Vkb3duKGUpO1xuICAgIH0pO1xuICAgIHRoaXMubW91c2Uub24oJ21vdXNldXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF90aGlzLm1vdXNldXAoZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoY29tcC5zdGF0ZSA9PT0gJ2ZpbmlzaGVkJykge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdzZXR0bGVkJztcbiAgICAgIHRoaXMudXBkYXRlX2Zyb20oY29tcC4kcHJvcHMuc2V0dGluZ3NbbmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnc2V0dGxlZCcpIHtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnc2Nyb2xsLWxvY2snLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhQaW4sIFt7XG4gICAga2V5OiBcInJlX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVfaW5pdCgpIHtcbiAgICAgIHRoaXMudXBkYXRlX2Zyb20odGhpcy5jb21wLiRwcm9wcy5zZXR0aW5nc1t0aGlzLm5hbWVdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgaWYgKHRoaXMuaGlkZGVuKSByZXR1cm47XG5cbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlICd0cmFja2luZyc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZHJhZ2dpbmcnOlxuICAgICAgICAgIGlmICghdGhpcy5tb3ZlZCkgdGhpcy5kcmF3X2NpcmNsZShjdHgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NldHRsZWQnOlxuICAgICAgICAgIHRoaXMuZHJhd19jaXJjbGUoY3R4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd19jaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd19jaXJjbGUoY3R4KSB7XG4gICAgICB0aGlzLmxheW91dCA9IHRoaXMuY29tcC5sYXlvdXQ7XG5cbiAgICAgIGlmICh0aGlzLmNvbXAuc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLlJBRElVUyxcbiAgICAgICAgICAgIGx3ID0gMS41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLlJBRElVUyAqIDAuOTUsXG4gICAgICAgICAgICBsdyA9IDE7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSBsdztcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuQ09MT1JfQlI7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5DT0xPUl9CQUNLO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyh0aGlzLnggPSB0aGlzLmxheW91dC50MnNjcmVlbih0aGlzLnQpLCB0aGlzLnkgPSB0aGlzLmxheW91dC4kMnNjcmVlbih0aGlzLnkkKSwgciArIDAuNSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMueSQgPSB0aGlzLmNvbXAuJHByb3BzLmN1cnNvci55JDtcbiAgICAgIHRoaXMueSA9IHRoaXMuY29tcC4kcHJvcHMuY3Vyc29yLnk7XG4gICAgICB0aGlzLnQgPSB0aGlzLmNvbXAuJHByb3BzLmN1cnNvci50O1xuICAgICAgdGhpcy54ID0gdGhpcy5jb21wLiRwcm9wcy5jdXJzb3IueDsgLy8gU2F2ZSBwaW4gYXMgdGltZSBpbiBJQiBtb2RlXG4gICAgICAvL2lmICh0aGlzLmxheW91dC50aV9tYXAuaWIpIHtcbiAgICAgIC8vICAgIHRoaXMudCA9IHRoaXMubGF5b3V0LnRpX21hcC5pMnQodGhpcy50IClcbiAgICAgIC8vfVxuICAgICAgLy8gUmVzZXQgdGhlIHNldHRpbmdzIGF0dGFoZWQgdG8gdGhlIHBpbiAocG9zaXRpb24pXG5cbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnY2hhbmdlLXNldHRpbmdzJywgX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLm5hbWUsIFt0aGlzLnQsIHRoaXMueSRdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZV9mcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZV9mcm9tKGRhdGEsIGVtaXQpIHtcbiAgICAgIGlmIChlbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgZW1pdCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHJldHVybjtcbiAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy5jb21wLmxheW91dDtcbiAgICAgIHRoaXMueSQgPSBkYXRhWzFdO1xuICAgICAgdGhpcy55ID0gdGhpcy5sYXlvdXQuJDJzY3JlZW4odGhpcy55JCk7XG4gICAgICB0aGlzLnQgPSBkYXRhWzBdO1xuICAgICAgdGhpcy54ID0gdGhpcy5sYXlvdXQudDJzY3JlZW4odGhpcy50KTsgLy8gVE9ETzogU2F2ZSBwaW4gYXMgdGltZSBpbiBJQiBtb2RlXG4gICAgICAvL2lmICh0aGlzLmxheW91dC50aV9tYXAuaWIpIHtcbiAgICAgIC8vICAgIHRoaXMudCA9IHRoaXMubGF5b3V0LnRpX21hcC5pMnQodGhpcy50IClcbiAgICAgIC8vfVxuXG4gICAgICBpZiAoZW1pdCkgdGhpcy5jb21wLiRlbWl0KCdjaGFuZ2Utc2V0dGluZ3MnLCBfZGVmaW5lUHJvcGVydHkoe30sIHRoaXMubmFtZSwgW3RoaXMudCwgdGhpcy55JF0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjX3Bvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY19wb3NpdGlvbigpIHtcbiAgICAgIHRoaXMudDEgPSB0aGlzLnQ7XG4gICAgICB0aGlzLnkkMSA9IHRoaXMueSQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZW1vdmUoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlICd0cmFja2luZyc6XG4gICAgICAgIGNhc2UgJ2RyYWdnaW5nJzpcbiAgICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZWRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50LCBmb3JjZSkge1xuICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmRlZmF1bHRfcHJldmVudGVkKGV2ZW50KSAmJiAhZm9yY2UpIHJldHVybjtcblxuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ3RyYWNraW5nJzpcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3NldHRsZWQnO1xuICAgICAgICAgIGlmICh0aGlzLm9uX3NldHRsZWQpIHRoaXMub25fc2V0dGxlZCgpO1xuICAgICAgICAgIHRoaXMuY29tcC4kZW1pdCgnc2Nyb2xsLWxvY2snLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2V0dGxlZCc6XG4gICAgICAgICAgaWYgKHRoaXMuaGlkZGVuKSByZXR1cm47XG5cbiAgICAgICAgICBpZiAodGhpcy5ob3ZlcigpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ2RyYWdnaW5nJztcbiAgICAgICAgICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29tcC4kZW1pdCgnc2Nyb2xsLWxvY2snLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuY29tcC4kZW1pdCgnb2JqZWN0LXNlbGVjdGVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhvdmVyKCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2V1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZXVwKGV2ZW50KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAnZHJhZ2dpbmcnOlxuICAgICAgICAgIHRoaXMuc3RhdGUgPSAnc2V0dGxlZCc7XG4gICAgICAgICAgaWYgKHRoaXMub25fc2V0dGxlZCkgdGhpcy5vbl9zZXR0bGVkKCk7XG4gICAgICAgICAgdGhpcy5jb21wLiRlbWl0KCdzY3JvbGwtbG9jaycsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ3NldHRsZWQnOlxuICAgICAgICAgIHRoaXMub25fc2V0dGxlZCA9IGhhbmRsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhvdmVyKCkge1xuICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgIHJldHVybiAoeCAtIHRoaXMubW91c2UueCkgKiAoeCAtIHRoaXMubW91c2UueCkgKyAoeSAtIHRoaXMubW91c2UueSkgKiAoeSAtIHRoaXMubW91c2UueSkgPCB0aGlzLlJBRElVU19TUTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGluO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3ByaW1pdGl2ZXMvc2VnLmpzXG5cblxuLy8gRHJhd3MgYSBzZWdtZW50LCBhZGRzIGNvcnJlc3BvbmRpbmcgY29sbGlzaW9uIGYtblxuXG5cblxudmFyIFNlZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIE92ZXJsYXkgcmVmLCBjYW52YXMgY3R4XG4gIGZ1bmN0aW9uIFNlZyhvdmVybGF5LCBjdHgpIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWcpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jb21wID0gb3ZlcmxheTtcbiAgICB0aGlzLlQgPSBvdmVybGF5LiRwcm9wcy5jb25maWcuVE9PTF9DT0xMO1xuICAgIGlmICh1dGlscy5pc19tb2JpbGUpIHRoaXMuVCAqPSAyO1xuICB9IC8vIHAxW3QsICRdLCBwMlt0LCAkXSAodGltZS1wcmljZSBjb29yZGluYXRlcylcblxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKFNlZywgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHAxLCBwMikge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuY29tcC4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHgxID0gbGF5b3V0LnQyc2NyZWVuKHAxWzBdKTtcbiAgICAgIHZhciB5MSA9IGxheW91dC4kMnNjcmVlbihwMVsxXSk7XG4gICAgICB2YXIgeDIgPSBsYXlvdXQudDJzY3JlZW4ocDJbMF0pO1xuICAgICAgdmFyIHkyID0gbGF5b3V0LiQyc2NyZWVuKHAyWzFdKTtcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgdGhpcy5jdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICB0aGlzLmNvbXAuY29sbGlzaW9ucy5wdXNoKHRoaXMubWFrZShbeDEsIHkxXSwgW3gyLCB5Ml0pKTtcbiAgICB9IC8vIENvbGxpc2lvbiBmdW5jdGlvbi4geCwgeSAtIG1vdXNlIGNvb3JkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFrZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlKHAxLCBwMikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnBvaW50MnNlZyhbeCwgeV0sIHAxLCBwMikgPCBfdGhpcy5UO1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VnO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3ByaW1pdGl2ZXMvbGluZS5qc1xuXG5cbi8vIERyYXdzIGEgbGluZSwgYWRkcyBjb3JyZXNwb25kaW5nIGNvbGxpc2lvbiBmLW5cblxuXG5cbnZhciBMaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gT3ZlcmxheSByZWYsIGNhbnZhcyBjdHhcbiAgZnVuY3Rpb24gTGluZShvdmVybGF5LCBjdHgpIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY29tcCA9IG92ZXJsYXk7XG4gICAgdGhpcy5UID0gb3ZlcmxheS4kcHJvcHMuY29uZmlnLlRPT0xfQ09MTDtcbiAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSB0aGlzLlQgKj0gMjtcbiAgfSAvLyBwMVt0LCAkXSwgcDJbdCwgJF0gKHRpbWUtcHJpY2UgY29vcmRpbmF0ZXMpXG5cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhMaW5lLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcocDEsIHAyKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5jb21wLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgeDEgPSBsYXlvdXQudDJzY3JlZW4ocDFbMF0pO1xuICAgICAgdmFyIHkxID0gbGF5b3V0LiQyc2NyZWVuKHAxWzFdKTtcbiAgICAgIHZhciB4MiA9IGxheW91dC50MnNjcmVlbihwMlswXSk7XG4gICAgICB2YXIgeTIgPSBsYXlvdXQuJDJzY3JlZW4ocDJbMV0pO1xuICAgICAgdGhpcy5jdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICB0aGlzLmN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgIHZhciB3ID0gbGF5b3V0LndpZHRoO1xuICAgICAgdmFyIGggPSBsYXlvdXQuaGVpZ2h0OyAvLyBUT0RPOiB0cmFuc2Zvcm0gayAoYW5nbGUpIHRvIHNjcmVlbiByYXRpb1xuICAgICAgLy8gKHRoaXMgcmVxdWlyZXMgYSBuZXcgYTJzY3JlZW4gZnVuY3Rpb24pXG5cbiAgICAgIHZhciBrID0gKHkyIC0geTEpIC8gKHgyIC0geDEpO1xuICAgICAgdmFyIHMgPSBNYXRoLnNpZ24oeDIgLSB4MSB8fCB5MiAtIHkxKTtcbiAgICAgIHZhciBkeCA9IHcgKiBzICogMjtcbiAgICAgIHZhciBkeSA9IHcgKiBrICogcyAqIDI7XG5cbiAgICAgIGlmIChkeSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgZHggPSAwLCBkeSA9IGggKiBzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5tb3ZlVG8oeDIsIHkyKTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh4MiArIGR4LCB5MiArIGR5KTtcblxuICAgICAgaWYgKCF0aGlzLnJheSkge1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHgxIC0gZHgsIHkxIC0gZHkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXAuY29sbGlzaW9ucy5wdXNoKHRoaXMubWFrZShbeDEsIHkxXSwgW3gyLCB5Ml0pKTtcbiAgICB9IC8vIENvbGxpc2lvbiBmdW5jdGlvbi4geCwgeSAtIG1vdXNlIGNvb3JkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFrZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlKHAxLCBwMikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGYgPSB0aGlzLnJheSA/IG1hdGgucG9pbnQycmF5LmJpbmQobWF0aCkgOiBtYXRoLnBvaW50MmxpbmUuYmluZChtYXRoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gZihbeCwgeV0sIHAxLCBwMikgPCBfdGhpcy5UO1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZTtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanNcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzXG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzXG5mdW5jdGlvbiB0eXBlb2ZfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgdHlwZW9mX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHR5cGVvZl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2ZfdHlwZW9mKG9iaik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcblxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2ZfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZi5qc1xuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJpbWl0aXZlcy9yYXkuanNcblxuXG5cblxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLy8gRHJhd3MgYSByYXksIGFkZHMgY29ycmVzcG9uZGluZyBjb2xsaXNpb24gZi1uXG5cblxudmFyIFJheSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpbmUpIHtcbiAgX2luaGVyaXRzKFJheSwgX0xpbmUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmF5KTtcblxuICBmdW5jdGlvbiBSYXkob3ZlcmxheSwgY3R4KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF5KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3ZlcmxheSwgY3R4KTtcbiAgICBfdGhpcy5yYXkgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBSYXk7XG59KExpbmUpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9MaW5lVG9vbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBMaW5lIGRyYXdpbmcgdG9vbFxuLy8gVE9ETzogbWFrZSBhbiBhbmdsZS1zbmFwIHdoZW4gXCJTaGlmdFwiIGlzIHByZXNzZWRcblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMaW5lVG9vbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdMaW5lVG9vbCcsXG4gIG1peGluczogW292ZXJsYXksIHRvb2xdLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMS4wJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIHRvb2w6IGZ1bmN0aW9uIHRvb2woKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBEZXNjcmlwdG9yIGZvciB0aGUgdG9vbFxuICAgICAgICBncm91cDogJ0xpbmVzJyxcbiAgICAgICAgaWNvbjogaWNvbnNfbmFtZXNwYWNlT2JqZWN0W1wic2VnbWVudC5wbmdcIl0sXG4gICAgICAgIHR5cGU6ICdTZWdtZW50JyxcbiAgICAgICAgaGludDogJ1RoaXMgaGludCB3aWxsIGJlIHNob3duIG9uIGhvdmVyJyxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIC8vIERlZmF1bHQgZGF0YVxuICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgIC8vIERlZmF1bHQgc2V0dGluZ3NcbiAgICAgICAgLy8gTW9kaWZpY2F0aW9uc1xuICAgICAgICBtb2RzOiB7XG4gICAgICAgICAgJ0V4dGVuZGVkJzoge1xuICAgICAgICAgICAgLy8gUmV3cml0ZXMgdGhlIGRlZmF1bHQgc2V0dGluZyBmaWVsZHNcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIGV4dGVuZGVkOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWNvbjogaWNvbnNfbmFtZXNwYWNlT2JqZWN0W1wiZXh0ZW5kZWQucG5nXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnUmF5Jzoge1xuICAgICAgICAgICAgLy8gUmV3cml0ZXMgdGhlIGRlZmF1bHQgc2V0dGluZyBmaWVsZHNcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIHJheTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGljb246IGljb25zX25hbWVzcGFjZU9iamVjdFtcInJheS5wbmdcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBDYWxsZWQgYWZ0ZXIgb3ZlcmxheSBtb3VudGVkXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIEZpcnN0IHBpbiBpcyBzZXR0bGVkIGF0IHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAgdGhpcy5waW5zLnB1c2gobmV3IFBpbih0aGlzLCAncDEnKSk7IC8vIFNlY29uZCBvbmUgaXMgZm9sbG93aW5nIG1vdXNlIHVudGlsIGl0IGNsaWNrc1xuXG4gICAgICB0aGlzLnBpbnMucHVzaChuZXcgUGluKHRoaXMsICdwMicsIHtcbiAgICAgICAgc3RhdGU6ICd0cmFja2luZydcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMucGluc1sxXS5vbignc2V0dGxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2FsbCB3aGVuIGN1cnJlbnQgdG9vbCBkcmF3aW5nIGlzIGZpbmlzaGVkXG4gICAgICAgIC8vIChPcHRpb25hbGx5KSByZXNldCB0aGUgbW9kZSBiYWNrIHRvICdDdXJzb3InXG4gICAgICAgIF90aGlzLnNldF9zdGF0ZSgnZmluaXNoZWQnKTtcblxuICAgICAgICBfdGhpcy4kZW1pdCgnZHJhd2luZy1tb2RlLW9mZicpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnAxIHx8ICF0aGlzLnAyKSByZXR1cm47XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dC5yYXkpIHtcbiAgICAgICAgbmV3IFJheSh0aGlzLCBjdHgpLmRyYXcodGhpcy5wMSwgdGhpcy5wMik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dC5leHRlbmRlZCkge1xuICAgICAgICBuZXcgTGluZSh0aGlzLCBjdHgpLmRyYXcodGhpcy5wMSwgdGhpcy5wMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXcgU2VnKHRoaXMsIGN0eCkuZHJhdyh0aGlzLnAxLCB0aGlzLnAyKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5yZW5kZXJfcGlucyhjdHgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0xpbmVUb29sJ107XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3JdO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBwMTogZnVuY3Rpb24gcDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3MucDE7XG4gICAgfSxcbiAgICBwMjogZnVuY3Rpb24gcDIoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3MucDI7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC45O1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCAnIzQyYjI4YSc7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9MaW5lVG9vbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19MaW5lVG9vbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChMaW5lVG9vbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvTGluZVRvb2wudnVlXG52YXIgTGluZVRvb2xfcmVuZGVyLCBMaW5lVG9vbF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBMaW5lVG9vbF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX0xpbmVUb29sdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBMaW5lVG9vbF9yZW5kZXIsXG4gIExpbmVUb29sX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgTGluZVRvb2xfYXBpOyB9XG5MaW5lVG9vbF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL0xpbmVUb29sLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExpbmVUb29sID0gKExpbmVUb29sX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9SYW5nZVRvb2wudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vLyBQcmljZS9UaW1lIG1lYXN1cm1lbnQgdG9vbFxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUmFuZ2VUb29sdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1JhbmdlVG9vbCcsXG4gIG1peGluczogW292ZXJsYXksIHRvb2xdLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzIuMC4xJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIHRvb2w6IGZ1bmN0aW9uIHRvb2woKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBEZXNjcmlwdG9yIGZvciB0aGUgdG9vbFxuICAgICAgICBncm91cDogJ01lYXN1cmVtZW50cycsXG4gICAgICAgIGljb246IGljb25zX25hbWVzcGFjZU9iamVjdFtcInByaWNlX3JhbmdlLnBuZ1wiXSxcbiAgICAgICAgdHlwZTogJ1ByaWNlJyxcbiAgICAgICAgaGludDogJ1ByaWNlIFJhbmdlJyxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIC8vIERlZmF1bHQgZGF0YVxuICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgIC8vIERlZmF1bHQgc2V0dGluZ3NcbiAgICAgICAgbW9kczoge1xuICAgICAgICAgICdUaW1lJzoge1xuICAgICAgICAgICAgLy8gUmV3cml0ZXMgdGhlIGRlZmF1bHQgc2V0dGluZyBmaWVsZHNcbiAgICAgICAgICAgIGljb246IGljb25zX25hbWVzcGFjZU9iamVjdFtcInRpbWVfcmFuZ2UucG5nXCJdLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgcHJpY2U6IGZhbHNlLFxuICAgICAgICAgICAgICB0aW1lOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnUHJpY2VUaW1lJzoge1xuICAgICAgICAgICAgLy8gUmV3cml0ZXMgdGhlIGRlZmF1bHQgc2V0dGluZyBmaWVsZHNcbiAgICAgICAgICAgIGljb246IGljb25zX25hbWVzcGFjZU9iamVjdFtcInByaWNlX3RpbWUucG5nXCJdLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgcHJpY2U6IHRydWUsXG4gICAgICAgICAgICAgIHRpbWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICdTaGlmdE1vZGUnOiB7XG4gICAgICAgICAgICAvLyBSZXdyaXRlcyB0aGUgZGVmYXVsdCBzZXR0aW5nIGZpZWxkc1xuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgcHJpY2U6IHRydWUsXG4gICAgICAgICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgICAgICAgIHNoaWZ0TW9kZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIENhbGxlZCBhZnRlciBvdmVybGF5IG1vdW50ZWRcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gRmlyc3QgcGluIGlzIHNldHRsZWQgYXQgdGhlIG1vdXNlIHBvc2l0aW9uXG4gICAgICB0aGlzLnBpbnMucHVzaChuZXcgUGluKHRoaXMsICdwMScsIHtcbiAgICAgICAgaGlkZGVuOiB0aGlzLnNoaWZ0XG4gICAgICB9KSk7IC8vIFNlY29uZCBvbmUgaXMgZm9sbG93aW5nIG1vdXNlIHVudGlsIGl0IGNsaWNrc1xuXG4gICAgICB0aGlzLnBpbnMucHVzaChuZXcgUGluKHRoaXMsICdwMicsIHtcbiAgICAgICAgc3RhdGU6ICd0cmFja2luZycsXG4gICAgICAgIGhpZGRlbjogdGhpcy5zaGlmdFxuICAgICAgfSkpO1xuICAgICAgdGhpcy5waW5zWzFdLm9uKCdzZXR0bGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDYWxsIHdoZW4gY3VycmVudCB0b29sIGRyYXdpbmcgaXMgZmluaXNoZWRcbiAgICAgICAgLy8gKE9wdGlvbmFsbHkpIHJlc2V0IHRoZSBtb2RlIGJhY2sgdG8gJ0N1cnNvcidcbiAgICAgICAgX3RoaXMuc2V0X3N0YXRlKCdmaW5pc2hlZCcpO1xuXG4gICAgICAgIF90aGlzLiRlbWl0KCdkcmF3aW5nLW1vZGUtb2ZmJyk7IC8vIERlc2VsZWN0IHRoZSB0b29sIGluIHNoaWZ0TW9kZVxuXG5cbiAgICAgICAgaWYgKF90aGlzLnNoaWZ0KSBfdGhpcy5fJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgICBldmVudDogJ29iamVjdC1zZWxlY3RlZCcsXG4gICAgICAgICAgYXJnczogW11cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBpZiAoIXRoaXMucDEgfHwgIXRoaXMucDIpIHJldHVybjtcbiAgICAgIHZhciBkaXIgPSBNYXRoLnNpZ24odGhpcy5wMlsxXSAtIHRoaXMucDFbMV0pO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciB4bSA9IGxheW91dC50MnNjcmVlbigodGhpcy5wMVswXSArIHRoaXMucDJbMF0pICogMC41KTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yOyAvLyBCYWNrZ3JvdW5kXG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tfY29sb3I7XG4gICAgICB2YXIgeDEgPSBsYXlvdXQudDJzY3JlZW4odGhpcy5wMVswXSk7XG4gICAgICB2YXIgeTEgPSBsYXlvdXQuJDJzY3JlZW4odGhpcy5wMVsxXSk7XG4gICAgICB2YXIgeDIgPSBsYXlvdXQudDJzY3JlZW4odGhpcy5wMlswXSk7XG4gICAgICB2YXIgeTIgPSBsYXlvdXQuJDJzY3JlZW4odGhpcy5wMlsxXSk7XG4gICAgICBjdHguZmlsbFJlY3QoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICAgIGlmICh0aGlzLnByaWNlKSB0aGlzLnZlcnRpY2FsKGN0eCwgeDEsIHkxLCB4MiwgeTIsIHhtKTtcbiAgICAgIGlmICh0aGlzLnRpbWUpIHRoaXMuaG9yaXpvbnRhbChjdHgsIHgxLCB5MSwgeDIsIHkyLCB4bSk7XG4gICAgICB0aGlzLmRyYXdfdmFsdWUoY3R4LCBkaXIsIHhtLCB5Mik7XG4gICAgICB0aGlzLnJlbmRlcl9waW5zKGN0eCk7XG4gICAgfSxcbiAgICB2ZXJ0aWNhbDogZnVuY3Rpb24gdmVydGljYWwoY3R4LCB4MSwgeTEsIHgyLCB5MiwgeG0pIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgZGlyID0gTWF0aC5zaWduKHRoaXMucDJbMV0gLSB0aGlzLnAxWzFdKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKCF0aGlzLnNoaWZ0KSB7XG4gICAgICAgIC8vIFRvcFxuICAgICAgICBuZXcgU2VnKHRoaXMsIGN0eCkuZHJhdyhbdGhpcy5wMVswXSwgdGhpcy5wMlsxXV0sIFt0aGlzLnAyWzBdLCB0aGlzLnAyWzFdXSk7IC8vIEJvdHRvbVxuXG4gICAgICAgIG5ldyBTZWcodGhpcywgY3R4KS5kcmF3KFt0aGlzLnAxWzBdLCB0aGlzLnAxWzFdXSwgW3RoaXMucDJbMF0sIHRoaXMucDFbMV1dKTtcbiAgICAgIH0gLy8gVmVydGljYWwgQXJyb3dcblxuXG4gICAgICBjdHgubW92ZVRvKHhtIC0gNCwgeTIgKyA1ICogZGlyKTtcbiAgICAgIGN0eC5saW5lVG8oeG0sIHkyKTtcbiAgICAgIGN0eC5saW5lVG8oeG0gKyA0LCB5MiArIDUgKiBkaXIpO1xuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBWZXJ0aWNhbCBMaW5lXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbNSwgNV0pO1xuICAgICAgbmV3IFNlZyh0aGlzLCBjdHgpLmRyYXcoWyh0aGlzLnAxWzBdICsgdGhpcy5wMlswXSkgKiAwLjUsIHRoaXMucDJbMV1dLCBbKHRoaXMucDFbMF0gKyB0aGlzLnAyWzBdKSAqIDAuNSwgdGhpcy5wMVsxXV0pO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9LFxuICAgIGhvcml6b250YWw6IGZ1bmN0aW9uIGhvcml6b250YWwoY3R4LCB4MSwgeTEsIHgyLCB5MiwgeG0pIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgeGRpciA9IE1hdGguc2lnbih0aGlzLnAyWzBdIC0gdGhpcy5wMVswXSk7XG4gICAgICB2YXIgeW0gPSAobGF5b3V0LiQyc2NyZWVuKHRoaXMucDFbMV0pICsgbGF5b3V0LiQyc2NyZWVuKHRoaXMucDJbMV0pKSAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGlmICghdGhpcy5zaGlmdCkge1xuICAgICAgICAvLyBMZWZ0XG4gICAgICAgIG5ldyBTZWcodGhpcywgY3R4KS5kcmF3KFt0aGlzLnAxWzBdLCB0aGlzLnAxWzFdXSwgW3RoaXMucDFbMF0sIHRoaXMucDJbMV1dKTsgLy8gUmlnaHRcblxuICAgICAgICBuZXcgU2VnKHRoaXMsIGN0eCkuZHJhdyhbdGhpcy5wMlswXSwgdGhpcy5wMVsxXV0sIFt0aGlzLnAyWzBdLCB0aGlzLnAyWzFdXSk7XG4gICAgICB9IC8vIEhvcml6b250YWwgQXJyb3dcblxuXG4gICAgICBjdHgubW92ZVRvKHgyIC0gNSAqIHhkaXIsIHltIC0gNCk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5bSk7XG4gICAgICBjdHgubGluZVRvKHgyIC0gNSAqIHhkaXIsIHltICsgNCk7XG4gICAgICBjdHguc3Ryb2tlKCk7IC8vIEhvcml6b250YWwgTGluZVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2V0TGluZURhc2goWzUsIDVdKTtcbiAgICAgIGN0eC5tb3ZlVG8oeDEsIHltKTtcbiAgICAgIGN0eC5saW5lVG8oeDIsIHltKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfSxcbiAgICAvLyBXVEY/IEkga25vdyBkdWRlLCBhIGxvdCBvZiBzaGl0dHkgY29kZSBoZXJlXG4gICAgZHJhd192YWx1ZTogZnVuY3Rpb24gZHJhd192YWx1ZShjdHgsIGRpciwgeG0sIHkpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBjdHguZm9udCA9IHRoaXMubmV3X2ZvbnQ7IC8vIFByaWNlIGRlbHRhIChhbmYgcGVyY2VudClcblxuICAgICAgdmFyIGQkID0gKHRoaXMucDJbMV0gLSB0aGlzLnAxWzFdKS50b0ZpeGVkKHRoaXMucHJlYyk7XG4gICAgICB2YXIgcCA9ICgxMDAgKiAodGhpcy5wMlsxXSAvIHRoaXMucDFbMV0gLSAxKSkudG9GaXhlZCh0aGlzLnByZWMpOyAvLyBNYXAgaW50ZXJ2YWwgdG8gdGhlIGFjdHVhbCB0ZiAoaW4gbXMpXG5cbiAgICAgIHZhciBmID0gZnVuY3Rpb24gZih0KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIubGF5b3V0LnRpX21hcC5zbXRoMnQodCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZHQgPSBmKHRoaXMucDJbMF0pIC0gZih0aGlzLnAxWzBdKTtcbiAgICAgIHZhciB0ZiA9IHRoaXMubGF5b3V0LnRpX21hcC50ZjsgLy8gQmFycyBjb3VudCAodGhyb3VnaCB0aGUgY2FuZGxlIGluZGV4KVxuXG4gICAgICB2YXIgZjIgPSBmdW5jdGlvbiBmMih0KSB7XG4gICAgICAgIHZhciBjID0gX3RoaXMyLmxheW91dC5jX21hZ25ldCh0KTtcblxuICAgICAgICB2YXIgY24gPSBfdGhpczIubGF5b3V0LmNhbmRsZXMgfHwgX3RoaXMyLmxheW91dC5tYXN0ZXJfZ3JpZC5jYW5kbGVzO1xuICAgICAgICByZXR1cm4gY24uaW5kZXhPZihjKTtcbiAgICAgIH07IC8vIEJhcnMgY291bnQgKGFuZCBoYW5kbGluZyB0aGUgbmVnYXRpdmUgdmFsdWVzKVxuXG5cbiAgICAgIHZhciBiID0gZjIodGhpcy5wMlswXSkgLSBmMih0aGlzLnAxWzBdKTsgLy8gRm9ybWF0IHRpbWUgZGVsdGFcbiAgICAgIC8vIEZvcm1hdCB0aW1lIGRlbHRhXG5cbiAgICAgIHZhciBkdHN0ciA9IHRoaXMudDJzdHIoZHQpO1xuICAgICAgdmFyIHRleHQgPSBbXTtcbiAgICAgIGlmICh0aGlzLnByaWNlKSB0ZXh0LnB1c2goXCJcIi5jb25jYXQoZCQsIFwiICAoXCIpLmNvbmNhdChwLCBcIiUpXCIpKTtcbiAgICAgIGlmICh0aGlzLnRpbWUpIHRleHQucHVzaChcIlwiLmNvbmNhdChiLCBcIiBiYXJzLCBcIikuY29uY2F0KGR0c3RyKSk7XG4gICAgICB0ZXh0ID0gdGV4dC5qb2luKCdcXG4nKTsgLy8gXCJNdWx0aXBsZVwiIGZpbGxUZXh0XG5cbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHcgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkobGluZXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQoeCkud2lkdGggKyAyMDtcbiAgICAgIH0pKS5jb25jYXQoWzEwMF0pKTtcbiAgICAgIHZhciBuID0gbGluZXMubGVuZ3RoO1xuICAgICAgdmFyIGggPSAyMCAqIG47XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy52YWx1ZV9iYWNrO1xuICAgICAgY3R4LmZpbGxSZWN0KHhtIC0gdyAqIDAuNSwgeSAtICgxMCArIGgpICogZGlyLCB3LCBoICogZGlyKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnZhbHVlX2NvbG9yO1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobCwgaSkge1xuICAgICAgICBjdHguZmlsbFRleHQobCwgeG0sIHkgKyAoZGlyID4gMCA/IDIwICogaSAtIDIwICogbiArIDUgOiAyMCAqIGkgKyAyNSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBGb3JtYXRzIHRpbWUgZnJvbSBtcyB0byBgMUQgMTJoYCBmb3IgZXhhbXBsZVxuICAgIHQyc3RyOiBmdW5jdGlvbiB0MnN0cih0KSB7XG4gICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbih0KTtcbiAgICAgIHZhciBhYnMgPSBNYXRoLmFicyh0KTtcbiAgICAgIHZhciB0ZnMgPSBbWzEwMDAsICdzJywgNjBdLCBbNjAwMDAsICdtJywgNjBdLCBbMzYwMDAwMCwgJ2gnLCAyNF0sIFs4NjQwMDAwMCwgJ0QnLCA3XSwgWzYwNDgwMDAwMCwgJ1cnLCA0XSwgWzI1OTIwMDAwMDAsICdNJywgMTJdLCBbMzE1MzYwMDAwMDAsICdZJywgSW5maW5pdHldLCBbSW5maW5pdHksICdFdGVybml0eScsIEluZmluaXR5XV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRmc1tpXVswXSA9IE1hdGguZmxvb3IoYWJzIC8gdGZzW2ldWzBdKTtcblxuICAgICAgICBpZiAodGZzW2ldWzBdID09PSAwKSB7XG4gICAgICAgICAgdmFyIHAxID0gdGZzW2kgLSAxXTtcbiAgICAgICAgICB2YXIgcDIgPSB0ZnNbaSAtIDJdO1xuICAgICAgICAgIHZhciB0eHQgPSBzaWduIDwgMCA/ICctJyA6ICcnO1xuXG4gICAgICAgICAgaWYgKHAxKSB7XG4gICAgICAgICAgICB0eHQgKz0gcDEuc2xpY2UoMCwgMikuam9pbignJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG4yID0gcDIgPyBwMlswXSAtIHAxWzBdICogcDJbMl0gOiAwO1xuXG4gICAgICAgICAgaWYgKHAyICYmIG4yKSB7XG4gICAgICAgICAgICB0eHQgKz0gJyAnO1xuICAgICAgICAgICAgdHh0ICs9IFwiXCIuY29uY2F0KG4yKS5jb25jYXQocDJbMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0eHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydSYW5nZVRvb2wnXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvcl07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIHAxOiBmdW5jdGlvbiBwMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncy5wMTtcbiAgICB9LFxuICAgIHAyOiBmdW5jdGlvbiBwMigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncy5wMjtcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjk7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8IHRoaXMuJHByb3BzLmNvbG9ycy5jcm9zcztcbiAgICB9LFxuICAgIGJhY2tfY29sb3I6IGZ1bmN0aW9uIGJhY2tfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhY2tDb2xvciB8fCAnIzliOWJhMzE2JztcbiAgICB9LFxuICAgIHZhbHVlX2JhY2s6IGZ1bmN0aW9uIHZhbHVlX2JhY2soKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnZhbHVlQmFjayB8fCAnIzliOWJhMzE2JztcbiAgICB9LFxuICAgIHZhbHVlX2NvbG9yOiBmdW5jdGlvbiB2YWx1ZV9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQudmFsdWVDb2xvciB8fCB0aGlzLiRwcm9wcy5jb2xvcnMudGV4dDtcbiAgICB9LFxuICAgIHByZWM6IGZ1bmN0aW9uIHByZWMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnByZWNpc2lvbiB8fCAyO1xuICAgIH0sXG4gICAgbmV3X2ZvbnQ6IGZ1bmN0aW9uIG5ld19mb250KCkge1xuICAgICAgcmV0dXJuICcxMnB4ICcgKyB0aGlzLiRwcm9wcy5mb250LnNwbGl0KCdweCcpLnBvcCgpO1xuICAgIH0sXG4gICAgcHJpY2U6IGZ1bmN0aW9uIHByaWNlKCkge1xuICAgICAgcmV0dXJuICdwcmljZScgaW4gdGhpcy5zZXR0ID8gdGhpcy5zZXR0LnByaWNlIDogdHJ1ZTtcbiAgICB9LFxuICAgIHRpbWU6IGZ1bmN0aW9uIHRpbWUoKSB7XG4gICAgICByZXR1cm4gJ3RpbWUnIGluIHRoaXMuc2V0dCA/IHRoaXMuc2V0dC50aW1lIDogZmFsc2U7XG4gICAgfSxcbiAgICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNoaWZ0TW9kZTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1JhbmdlVG9vbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19SYW5nZVRvb2x2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoUmFuZ2VUb29sdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9SYW5nZVRvb2wudnVlXG52YXIgUmFuZ2VUb29sX3JlbmRlciwgUmFuZ2VUb29sX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFJhbmdlVG9vbF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX1JhbmdlVG9vbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgUmFuZ2VUb29sX3JlbmRlcixcbiAgUmFuZ2VUb29sX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgUmFuZ2VUb29sX2FwaTsgfVxuUmFuZ2VUb29sX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvUmFuZ2VUb29sLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJhbmdlVG9vbCA9IChSYW5nZVRvb2xfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0dyaWQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gU2V0cyB1cCBhbGwgbGF5ZXJzL292ZXJsYXlzIGZvciB0aGUgZ3JpZCB3aXRoICdncmlkX2lkJ1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdHcmlkJyxcbiAgcHJvcHM6IFsnc3ViJywgJ2xheW91dCcsICdyYW5nZScsICdpbnRlcnZhbCcsICdjdXJzb3InLCAnY29sb3JzJywgJ292ZXJsYXlzJywgJ3dpZHRoJywgJ2hlaWdodCcsICdkYXRhJywgJ2dyaWRfaWQnLCAneV90cmFuc2Zvcm0nLCAnZm9udCcsICd0dl9pZCcsICdjb25maWcnLCAnbWV0YScsICdzaGFkZXJzJ10sXG4gIG1peGluczogW2NhbnZhcywgdXhsaXN0XSxcbiAgY29tcG9uZW50czoge1xuICAgIENyb3NzaGFpcjogY29tcG9uZW50c19Dcm9zc2hhaXIsXG4gICAgS2V5Ym9hcmRMaXN0ZW5lcjogS2V5Ym9hcmRMaXN0ZW5lclxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBMaXN0IG9mIGFsbCBwb3NzaWJsZSBvdmVybGF5cyAoYnVpbHRpbiArIGN1c3RvbSlcbiAgICB0aGlzLl9saXN0ID0gW1NwbGluZSwgU3BsaW5lcywgUmFuZ2UsIFRyYWRlcywgQ2hhbm5lbCwgU2VnbWVudCwgQ2FuZGxlcywgVm9sdW1lLCBTcGxpdHRlcnMsIExpbmVUb29sLCBSYW5nZVRvb2xdLmNvbmNhdCh0aGlzLiRwcm9wcy5vdmVybGF5cyk7XG4gICAgdGhpcy5fcmVnaXN0cnkgPSB7fTsgLy8gV2UgbmVlZCB0byBrbm93IHdoaWNoIGNvbXBvbmVudHMgd2Ugd2lsbCB1c2UuXG4gICAgLy8gQ3VzdG9tIG92ZXJsYXkgY29tcG9uZW50cyBvdmVyd3JpdGUgYnVpbHQtaW5zOlxuXG4gICAgdmFyIHRvb2xzID0gW107XG5cbiAgICB0aGlzLl9saXN0LmZvckVhY2goZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgIHZhciB1c2VfZm9yID0geC5tZXRob2RzLnVzZV9mb3IoKTtcbiAgICAgIGlmICh4Lm1ldGhvZHMudG9vbCkgdG9vbHMucHVzaCh7XG4gICAgICAgIHVzZV9mb3I6IHVzZV9mb3IsXG4gICAgICAgIGluZm86IHgubWV0aG9kcy50b29sKClcbiAgICAgIH0pO1xuICAgICAgdXNlX2Zvci5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgX3RoaXMuX3JlZ2lzdHJ5W2luZGljYXRvcl0gPSBpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICBldmVudDogJ3JlZ2lzdGVyLXRvb2xzJyxcbiAgICAgIGFyZ3M6IHRvb2xzXG4gICAgfSk7XG4gICAgdGhpcy4kb24oJ2N1c3RvbS1ldmVudCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gX3RoaXMub25fdXhfZXZlbnQoZSwgJ2dyaWQnKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgZWwgPSB0aGlzLiRyZWZzWydjYW52YXMnXTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IEdyaWQoZWwsIHRoaXMpO1xuICAgIHRoaXMuc2V0dXAoKTtcbiAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnJlZHJhdygpO1xuICAgIH0pO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0LmdyaWRzW2lkXTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVfY2FudmFzKGgsIFwiZ3JpZC1cIi5jb25jYXQoaWQpLCB7XG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiBsYXlvdXQub2Zmc2V0IHx8IDBcbiAgICAgIH0sXG4gICAgICBhdHRyczoge1xuICAgICAgICB3aWR0aDogbGF5b3V0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHQsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy4kcHJvcHMuY29sb3JzLmJhY2tcbiAgICAgIH0sXG4gICAgICBoczogW2goY29tcG9uZW50c19Dcm9zc2hhaXIsIHtcbiAgICAgICAgcHJvcHM6IHRoaXMuY29tbW9uX3Byb3BzKCksXG4gICAgICAgIG9uOiB0aGlzLmxheWVyX2V2ZW50c1xuICAgICAgfSksIGgoS2V5Ym9hcmRMaXN0ZW5lciwge1xuICAgICAgICBvbjogdGhpcy5rZXlib2FyZF9ldmVudHNcbiAgICAgIH0pLCBoKFV4TGF5ZXIsIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgdHZfaWQ6IHRoaXMuJHByb3BzLnR2X2lkLFxuICAgICAgICAgIHV4czogdGhpcy51eHMsXG4gICAgICAgICAgY29sb3JzOiB0aGlzLiRwcm9wcy5jb2xvcnMsXG4gICAgICAgICAgY29uZmlnOiB0aGlzLiRwcm9wcy5jb25maWcsXG4gICAgICAgICAgdXBkYXRlcjogTWF0aC5yYW5kb20oKVxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgICdjdXN0b20tZXZlbnQnOiB0aGlzLmVtaXRfdXhfZXZlbnRcbiAgICAgICAgfVxuICAgICAgfSldLmNvbmNhdCh0aGlzLmdldF9vdmVybGF5cyhoKSlcbiAgICB9KTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG5ld19sYXllcjogZnVuY3Rpb24gbmV3X2xheWVyKGxheWVyKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnJlbmRlcmVyLm5ld19sYXllcihsYXllcik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlbF9sYXllcjogZnVuY3Rpb24gZGVsX2xheWVyKGxheWVyKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LnJlbmRlcmVyLmRlbF9sYXllcihsYXllcik7XG4gICAgICB9KTtcbiAgICAgIHZhciBncmlkX2lkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6ICdyZW1vdmUtc2hhZGVycycsXG4gICAgICAgIGFyZ3M6IFtncmlkX2lkLCBsYXllcl1cbiAgICAgIH0pOyAvLyBUT0RPOiBjbG9zZSBhbGwgaW50ZXJmYWNlc1xuXG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiAncmVtb3ZlLWxheWVyLW1ldGEnLFxuICAgICAgICBhcmdzOiBbZ3JpZF9pZCwgbGF5ZXJdXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVtb3ZlX2FsbF91eChsYXllcik7XG4gICAgfSxcbiAgICBnZXRfb3ZlcmxheXM6IGZ1bmN0aW9uIGdldF9vdmVybGF5cyhoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gRGlzdHJpYnV0ZXMgb3ZlcmxheSBkYXRhICYgc2V0dGluZ3MgYWNjb3JkaW5nXG4gICAgICAvLyB0byB0aGlzLl9yZWdpc3RyeTsgcmV0dXJucyBjb21wbyBsaXN0XG4gICAgICB2YXIgY29tcF9saXN0ID0gW10sXG4gICAgICAgICAgY291bnQgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGNvbXAgPSB0aGlzLl9saXN0W3RoaXMuX3JlZ2lzdHJ5W2QudHlwZV1dO1xuXG4gICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgIGlmIChjb21wLm1ldGhvZHMuY2FsYykge1xuICAgICAgICAgICAgICBjb21wID0gdGhpcy5pbmplY3RfcmVuZGVyZXIoY29tcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXBfbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgY2xzOiBjb21wLFxuICAgICAgICAgICAgICB0eXBlOiBkLnR5cGUsXG4gICAgICAgICAgICAgIGRhdGE6IGQuZGF0YSxcbiAgICAgICAgICAgICAgc2V0dGluZ3M6IGQuc2V0dGluZ3MsXG4gICAgICAgICAgICAgIGkwOiBkLmkwLFxuICAgICAgICAgICAgICB0ZjogZC50ZixcbiAgICAgICAgICAgICAgbGFzdDogZC5sYXN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvdW50W2QudHlwZV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcF9saXN0Lm1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICByZXR1cm4gaCh4LmNscywge1xuICAgICAgICAgIG9uOiBfdGhpczUubGF5ZXJfZXZlbnRzLFxuICAgICAgICAgIGF0dHJzOiBPYmplY3QuYXNzaWduKF90aGlzNS5jb21tb25fcHJvcHMoKSwge1xuICAgICAgICAgICAgaWQ6IFwiXCIuY29uY2F0KHgudHlwZSwgXCJfXCIpLmNvbmNhdChjb3VudFt4LnR5cGVdKyspLFxuICAgICAgICAgICAgdHlwZTogeC50eXBlLFxuICAgICAgICAgICAgZGF0YTogeC5kYXRhLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHguc2V0dGluZ3MsXG4gICAgICAgICAgICBpMDogeC5pMCxcbiAgICAgICAgICAgIHRmOiB4LnRmLFxuICAgICAgICAgICAgbnVtOiBpLFxuICAgICAgICAgICAgZ3JpZF9pZDogX3RoaXM1LiRwcm9wcy5ncmlkX2lkLFxuICAgICAgICAgICAgbWV0YTogX3RoaXM1LiRwcm9wcy5tZXRhLFxuICAgICAgICAgICAgbGFzdDogeC5sYXN0XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNvbW1vbl9wcm9wczogZnVuY3Rpb24gY29tbW9uX3Byb3BzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3Vyc29yOiB0aGlzLiRwcm9wcy5jdXJzb3IsXG4gICAgICAgIGNvbG9yczogdGhpcy4kcHJvcHMuY29sb3JzLFxuICAgICAgICBsYXlvdXQ6IHRoaXMuJHByb3BzLmxheW91dC5ncmlkc1t0aGlzLiRwcm9wcy5ncmlkX2lkXSxcbiAgICAgICAgaW50ZXJ2YWw6IHRoaXMuJHByb3BzLmludGVydmFsLFxuICAgICAgICBzdWI6IHRoaXMuJHByb3BzLnN1YixcbiAgICAgICAgZm9udDogdGhpcy4kcHJvcHMuZm9udCxcbiAgICAgICAgY29uZmlnOiB0aGlzLiRwcm9wcy5jb25maWdcbiAgICAgIH07XG4gICAgfSxcbiAgICBlbWl0X3V4X2V2ZW50OiBmdW5jdGlvbiBlbWl0X3V4X2V2ZW50KGUpIHtcbiAgICAgIHZhciBlX3Bhc3MgPSB0aGlzLm9uX3V4X2V2ZW50KGUsICdncmlkJyk7XG4gICAgICBpZiAoZV9wYXNzKSB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCBlKTtcbiAgICB9LFxuICAgIC8vIFJlcGxhY2UgdGhlIGN1cnJlbnQgY29tcCB3aXRoICdyZW5kZXJlcidcbiAgICBpbmplY3RfcmVuZGVyZXI6IGZ1bmN0aW9uIGluamVjdF9yZW5kZXJlcihjb21wKSB7XG4gICAgICB2YXIgc3JjID0gY29tcC5tZXRob2RzLmNhbGMoKTtcblxuICAgICAgaWYgKCFzcmMuY29uZiB8fCAhc3JjLmNvbmYucmVuZGVyZXIgfHwgY29tcC5fX3JlbmRlcmVyX18pIHtcbiAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICB9IC8vIFNlYXJjaCBmb3IgYW4gb3ZlcmxheSB3aXRoIHRoZSB0YXJnZXQgJ25hbWUnXG5cblxuICAgICAgdmFyIGYgPSB0aGlzLl9saXN0LmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgubmFtZSA9PT0gc3JjLmNvbmYucmVuZGVyZXI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFmKSByZXR1cm4gY29tcDtcbiAgICAgIGNvbXAubWl4aW5zLnB1c2goZik7XG4gICAgICBjb21wLl9fcmVuZGVyZXJfXyA9IHNyYy5jb25mLnJlbmRlcmVyO1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzX2FjdGl2ZTogZnVuY3Rpb24gaXNfYWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmN1cnNvci50ICE9PSB1bmRlZmluZWQgJiYgdGhpcy4kcHJvcHMuY3Vyc29yLmdyaWRfaWQgPT09IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHJhbmdlOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICAvLyBUT0RPOiBMZWZ0LXNpZGUgcmVuZGVyIGxhZyBmaXg6XG4gICAgICAgIC8vIE92ZXJsYXkgZGF0YSBpcyB1cGRhdGVkIG9uZSB0aWNrIGxhdGVyIHRoYW5cbiAgICAgICAgLy8gdGhlIG1haW4gc3ViLiBGYXN0IGZpeCBpcyB0byBkZWxheSByZWRyYXcoKVxuICAgICAgICAvLyBjYWxsLiBJdCB3aWxsIGJlIGEgc29sdXRpb24gdW50aWwgYSBiZXR0ZXJcbiAgICAgICAgLy8gb25lIGNvbWVzIGJ5LlxuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNi5yZWRyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH0sXG4gICAgY3Vyc29yOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHByb3BzLmN1cnNvci5sb2NrZWQpIHRoaXMucmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH0sXG4gICAgb3ZlcmxheXM6IHtcbiAgICAgIC8vIFRyYWNrIGNoYW5nZXMgaW4gY2FsYygpIGZ1bmN0aW9uc1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihvdnMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvdnMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBvdiA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRjaGlsZHJlbiksXG4gICAgICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgIHZhciBjb21wID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcC5pZCAhPT0gJ3N0cmluZycpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IGNvbXAuaWQuc3BsaXQoJ18nKTtcbiAgICAgICAgICAgICAgICB0dXBsZS5wb3AoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0dXBsZS5qb2luKCdfJykgPT09IG92Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXAuY2FsYyA9IG92Lm1ldGhvZHMuY2FsYztcbiAgICAgICAgICAgICAgICAgIGlmICghY29tcC5jYWxjKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIHZhciBjYWxjID0gY29tcC5jYWxjLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjYWxjICE9PSBvdi5fX3ByZXZzY3JpcHRfXykge1xuICAgICAgICAgICAgICAgICAgICBjb21wLmV4ZWNfc2NyaXB0KCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG92Ll9fcHJldnNjcmlwdF9fID0gY2FsYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfSxcbiAgICAvLyBSZWRyYXcgb24gdGhlIHNoYWRlciBsaXN0IGNoYW5nZVxuICAgIHNoYWRlcnM6IGZ1bmN0aW9uIHNoYWRlcnMobiwgcCkge1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGF5ZXJfZXZlbnRzOiB7XG4gICAgICAgICduZXctZ3JpZC1sYXllcic6IHRoaXMubmV3X2xheWVyLFxuICAgICAgICAnZGVsZXRlLWdyaWQtbGF5ZXInOiB0aGlzLmRlbF9sYXllcixcbiAgICAgICAgJ3Nob3ctZ3JpZC1sYXllcic6IGZ1bmN0aW9uIHNob3dHcmlkTGF5ZXIoZCkge1xuICAgICAgICAgIF90aGlzNy5yZW5kZXJlci5zaG93X2hpZGVfbGF5ZXIoZCk7XG5cbiAgICAgICAgICBfdGhpczcucmVkcmF3KCk7XG4gICAgICAgIH0sXG4gICAgICAgICdyZWRyYXctZ3JpZCc6IHRoaXMucmVkcmF3LFxuICAgICAgICAnbGF5ZXItbWV0YS1wcm9wcyc6IGZ1bmN0aW9uIGxheWVyTWV0YVByb3BzKGQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM3LiRlbWl0KCdsYXllci1tZXRhLXByb3BzJywgZCk7XG4gICAgICAgIH0sXG4gICAgICAgICdjdXN0b20tZXZlbnQnOiBmdW5jdGlvbiBjdXN0b21FdmVudChkKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNy4kZW1pdCgnY3VzdG9tLWV2ZW50JywgZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBrZXlib2FyZF9ldmVudHM6IHtcbiAgICAgICAgJ3JlZ2lzdGVyLWtiLWxpc3RlbmVyJzogZnVuY3Rpb24gcmVnaXN0ZXJLYkxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXM3LiRlbWl0KCdyZWdpc3Rlci1rYi1saXN0ZW5lcicsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3JlbW92ZS1rYi1saXN0ZW5lcic6IGZ1bmN0aW9uIHJlbW92ZUtiTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczcuJGVtaXQoJ3JlbW92ZS1rYi1saXN0ZW5lcicsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2tleXVwJzogZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNy5pc19hY3RpdmUpIHJldHVybjtcblxuICAgICAgICAgIF90aGlzNy5yZW5kZXJlci5wcm9wYWdhdGUoJ2tleXVwJywgZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICAna2V5ZG93bic6IGZ1bmN0aW9uIGtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNy5pc19hY3RpdmUpIHJldHVybjsgLy8gVE9ETzogaXMgdGhpcyBuZWVlZGVkP1xuXG4gICAgICAgICAgX3RoaXM3LnJlbmRlcmVyLnByb3BhZ2F0ZSgna2V5ZG93bicsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2tleXByZXNzJzogZnVuY3Rpb24ga2V5cHJlc3MoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNy5pc19hY3RpdmUpIHJldHVybjtcblxuICAgICAgICAgIF90aGlzNy5yZW5kZXJlci5wcm9wYWdhdGUoJ2tleXByZXNzJywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9HcmlkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9HcmlkLnZ1ZVxudmFyIEdyaWRfcmVuZGVyLCBHcmlkX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEdyaWRfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0dyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEdyaWRfcmVuZGVyLFxuICBHcmlkX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgR3JpZF9hcGk7IH1cbkdyaWRfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9HcmlkLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfR3JpZCA9IChHcmlkX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL3NpZGViYXIuanNcblxuXG5cbmZ1bmN0aW9uIHNpZGViYXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IHNpZGViYXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIHNpZGViYXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBzaWRlYmFyX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBzaWRlYmFyX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBzaWRlYmFyX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuXG5cbnZhciBQQU5IRUlHSFQ7XG5cbnZhciBTaWRlYmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2lkZWJhcihjYW52YXMsIGNvbXAsIHNpZGUpIHtcbiAgICBpZiAoc2lkZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaWRlID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBTaWRlYmFyKTtcblxuICAgIFBBTkhFSUdIVCA9IGNvbXAuY29uZmlnLlBBTkhFSUdIVDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgdGhpcy4kcCA9IGNvbXAuJHByb3BzO1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuJHAuc3ViO1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLiRwLnJhbmdlO1xuICAgIHRoaXMuaWQgPSB0aGlzLiRwLmdyaWRfaWQ7XG4gICAgdGhpcy5sYXlvdXQgPSB0aGlzLiRwLmxheW91dC5ncmlkc1t0aGlzLmlkXTtcbiAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgIHRoaXMubGlzdGVuZXJzKCk7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhTaWRlYmFyLCBbe1xuICAgIGtleTogXCJsaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG1jID0gdGhpcy5tYyA9IG5ldyBoYW1tZXIuTWFuYWdlcih0aGlzLmNhbnZhcyk7XG4gICAgICBtYy5hZGQobmV3IGhhbW1lci5QYW4oe1xuICAgICAgICBkaXJlY3Rpb246IGhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHRocmVzaG9sZDogMFxuICAgICAgfSkpO1xuICAgICAgbWMuYWRkKG5ldyBoYW1tZXIuVGFwKHtcbiAgICAgICAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICAgICAgICB0YXBzOiAyLFxuICAgICAgICBwb3NUaHJlc2hvbGQ6IDUwXG4gICAgICB9KSk7XG4gICAgICBtYy5vbigncGFuc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzLiRwLnlfdHJhbnNmb3JtKSB7XG4gICAgICAgICAgX3RoaXMuem9vbSA9IF90aGlzLiRwLnlfdHJhbnNmb3JtLnpvb207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuem9vbSA9IDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnlfcmFuZ2UgPSBbX3RoaXMubGF5b3V0LiRfaGksIF90aGlzLmxheW91dC4kX2xvXTtcbiAgICAgICAgX3RoaXMuZHJ1ZyA9IHtcbiAgICAgICAgICB5OiBldmVudC5jZW50ZXIueSxcbiAgICAgICAgICB6OiBfdGhpcy56b29tLFxuICAgICAgICAgIG1pZDogbWF0aC5sb2dfbWlkKF90aGlzLnlfcmFuZ2UsIF90aGlzLmxheW91dC5oZWlnaHQpLFxuICAgICAgICAgIEE6IF90aGlzLmxheW91dC5BLFxuICAgICAgICAgIEI6IF90aGlzLmxheW91dC5CXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdwYW5tb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpcy5kcnVnKSB7XG4gICAgICAgICAgX3RoaXMuem9vbSA9IF90aGlzLmNhbGNfem9vbShldmVudCk7XG5cbiAgICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdzaWRlYmFyLXRyYW5zZm9ybScsIHtcbiAgICAgICAgICAgIGdyaWRfaWQ6IF90aGlzLmlkLFxuICAgICAgICAgICAgem9vbTogX3RoaXMuem9vbSxcbiAgICAgICAgICAgIGF1dG86IGZhbHNlLFxuICAgICAgICAgICAgcmFuZ2U6IF90aGlzLmNhbGNfcmFuZ2UoKSxcbiAgICAgICAgICAgIGRydWdnaW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtYy5vbigncGFuZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kcnVnID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdzaWRlYmFyLXRyYW5zZm9ybScsIHtcbiAgICAgICAgICBncmlkX2lkOiBfdGhpcy5pZCxcbiAgICAgICAgICBkcnVnZ2luZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdkb3VibGV0YXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ3NpZGViYXItdHJhbnNmb3JtJywge1xuICAgICAgICAgIGdyaWRfaWQ6IF90aGlzLmlkLFxuICAgICAgICAgIHpvb206IDEuMCxcbiAgICAgICAgICBhdXRvOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzLnpvb20gPSAxLjA7XG5cbiAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICB9KTsgLy8gVE9ETzogRG8gbGF0ZXIgZm9yIG1vYmlsZSB2ZXJzaW9uXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAvLyBVcGRhdGUgcmVmZXJlbmNlIHRvIHRoZSBncmlkXG4gICAgICB0aGlzLmxheW91dCA9IHRoaXMuJHAubGF5b3V0LmdyaWRzW3RoaXMuaWRdO1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0LnlzO1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgc2lkZSA9IHRoaXMuc2lkZTtcbiAgICAgIHZhciBzYiA9IHRoaXMubGF5b3V0LnNiOyAvL3RoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuJHAuY29sb3JzLmJhY2tcblxuICAgICAgdGhpcy5jdHguZm9udCA9IHRoaXMuJHAuZm9udDtcblxuICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHggPSAwO1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgIHcgPSBNYXRoLmZsb29yKHNiKTtcbiAgICAgICAgICBoID0gdGhpcy5sYXlvdXQuaGVpZ2h0OyAvL3RoaXMuY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpXG5cbiAgICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5zY2FsZTtcbiAgICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeCArIDAuNSwgMCk7XG4gICAgICAgICAgdGhpcy5jdHgubGluZVRvKHggKyAwLjUsIGgpO1xuICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICB3ID0gTWF0aC5mbG9vcihzYik7XG4gICAgICAgICAgaCA9IHRoaXMubGF5b3V0LmhlaWdodDsgLy90aGlzLmN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKVxuXG4gICAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy4kcC5jb2xvcnMuc2NhbGU7XG4gICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKHggKyAwLjUsIDApO1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4ICsgMC41LCBoKTtcbiAgICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy4kcC5jb2xvcnMudGV4dDtcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gc2lkZWJhcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvaW50cyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAocFswXSA+IHRoaXMubGF5b3V0LmhlaWdodCkgY29udGludWU7XG4gICAgICAgICAgdmFyIHgxID0gc2lkZSA9PT0gJ2xlZnQnID8gdyAtIDAuNSA6IHggLSAwLjU7XG4gICAgICAgICAgdmFyIHgyID0gc2lkZSA9PT0gJ2xlZnQnID8geDEgLSA0LjUgOiB4MSArIDQuNTtcbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeDEsIHBbMF0gLSAwLjUpO1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4MiwgcFswXSAtIDAuNSk7XG4gICAgICAgICAgdmFyIG9mZnN0ID0gc2lkZSA9PT0gJ2xlZnQnID8gLTEwIDogMTA7XG4gICAgICAgICAgdGhpcy5jdHgudGV4dEFsaWduID0gc2lkZSA9PT0gJ2xlZnQnID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgICAgIHZhciBkID0gdGhpcy5sYXlvdXQucHJlYztcbiAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChwWzFdLnRvRml4ZWQoZCksIHgxICsgb2Zmc3QsIHBbMF0gKyA0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgIGlmICh0aGlzLiRwLmdyaWRfaWQpIHRoaXMudXBwZXJfYm9yZGVyKCk7XG4gICAgICB0aGlzLmFwcGx5X3NoYWRlcnMoKTtcbiAgICAgIGlmICh0aGlzLiRwLmN1cnNvci55ICYmIHRoaXMuJHAuY3Vyc29yLnkkKSB0aGlzLnBhbmVsKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5X3NoYWRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlfc2hhZGVycygpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwLmxheW91dC5ncmlkc1t0aGlzLmlkXTtcbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIGN1cnNvcjogdGhpcy4kcC5jdXJzb3JcbiAgICAgIH07XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gc2lkZWJhcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHAuc2hhZGVycyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICBzLmRyYXcodGhpcy5jdHgsIHByb3BzKTtcbiAgICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cHBlcl9ib3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBwZXJfYm9yZGVyKCkge1xuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5zY2FsZTtcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5jdHgubW92ZVRvKDAsIDAuNSk7XG4gICAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5sYXlvdXQud2lkdGgsIDAuNSk7XG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9IC8vIEEgZ3JheSBiYXIgYmVoaW5kIHRoZSBjdXJyZW50IHByaWNlXG5cbiAgfSwge1xuICAgIGtleTogXCJwYW5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW5lbCgpIHtcbiAgICAgIGlmICh0aGlzLiRwLmN1cnNvci5ncmlkX2lkICE9PSB0aGlzLmxheW91dC5pZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsYmwgPSB0aGlzLiRwLmN1cnNvci55JC50b0ZpeGVkKHRoaXMubGF5b3V0LnByZWMpO1xuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy4kcC5jb2xvcnMucGFuZWw7XG4gICAgICB2YXIgcGFud2lkdGggPSB0aGlzLmxheW91dC5zYiArIDE7XG4gICAgICB2YXIgeCA9IC0wLjU7XG4gICAgICB2YXIgeSA9IHRoaXMuJHAuY3Vyc29yLnkgLSBQQU5IRUlHSFQgKiAwLjUgLSAwLjU7XG4gICAgICB2YXIgYSA9IDc7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCh4IC0gMC41LCB5LCBwYW53aWR0aCwgUEFOSEVJR0hUKTtcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnRleHRITDtcbiAgICAgIHRoaXMuY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KGxibCwgYSwgeSArIDE1KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY196b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfem9vbShldmVudCkge1xuICAgICAgdmFyIGQgPSB0aGlzLmRydWcueSAtIGV2ZW50LmNlbnRlci55O1xuICAgICAgdmFyIHNwZWVkID0gZCA+IDAgPyAzIDogMTtcbiAgICAgIHZhciBrID0gMSArIHNwZWVkICogZCAvIHRoaXMubGF5b3V0LmhlaWdodDtcbiAgICAgIHJldHVybiB1dGlscy5jbGFtcCh0aGlzLmRydWcueiAqIGssIDAuMDA1LCAxMDApO1xuICAgIH0gLy8gTm90IHRoZSBiZXN0IHBsYWNlIHRvIGNhbGN1bGF0ZSB5LXJhbmdlIGJ1dFxuICAgIC8vIHRoaXMgaXMgdGhlIHNpbXBsZXN0IHNvbHV0aW9uIEkgZm91bmQgdXAgdG9cbiAgICAvLyBkYXRlXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjX3JhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfcmFuZ2UoZGlmZjEsIGRpZmYyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKGRpZmYxID09PSB2b2lkIDApIHtcbiAgICAgICAgZGlmZjEgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZjIgPT09IHZvaWQgMCkge1xuICAgICAgICBkaWZmMiA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciB6ID0gdGhpcy56b29tIC8gdGhpcy5kcnVnLno7XG4gICAgICB2YXIgemsgPSAoMSAvIHogLSAxKSAvIDI7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnlfcmFuZ2Uuc2xpY2UoKTtcbiAgICAgIHZhciBkZWx0YSA9IHJhbmdlWzBdIC0gcmFuZ2VbMV07XG5cbiAgICAgIGlmICghdGhpcy5sYXlvdXQuZ3JpZC5sb2dTY2FsZSkge1xuICAgICAgICByYW5nZVswXSA9IHJhbmdlWzBdICsgZGVsdGEgKiB6ayAqIGRpZmYxO1xuICAgICAgICByYW5nZVsxXSA9IHJhbmdlWzFdIC0gZGVsdGEgKiB6ayAqIGRpZmYyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB4X21pZCA9IHRoaXMubGF5b3V0LmhlaWdodCAvIDI7XG4gICAgICAgIHZhciBuZXdfaGkgPSBweF9taWQgLSBweF9taWQgKiAoMSAvIHopO1xuICAgICAgICB2YXIgbmV3X2xvID0gcHhfbWlkICsgcHhfbWlkICogKDEgLyB6KTsgLy8gVXNlIG9sZCBtYXBwaW5nIHRvIGdldCBhIG5ldyByYW5nZVxuXG4gICAgICAgIHZhciBmID0gZnVuY3Rpb24gZih5KSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGguZXhwKCh5IC0gX3RoaXMyLmRydWcuQikgLyBfdGhpczIuZHJ1Zy5BKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY29weSA9IHJhbmdlLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlWzBdID0gZihuZXdfaGkpO1xuICAgICAgICByYW5nZVsxXSA9IGYobmV3X2xvKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXpvb21fcmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV6b29tX3JhbmdlKGRlbHRhLCBkaWZmMSwgZGlmZjIpIHtcbiAgICAgIGlmICghdGhpcy4kcC55X3RyYW5zZm9ybSB8fCB0aGlzLiRwLnlfdHJhbnNmb3JtLmF1dG8pIHJldHVybjtcbiAgICAgIHRoaXMuem9vbSA9IDEuMDsgLy8gVE9ETzogZnVydGhlciB3b3JrIChpbXByb3ZlIHNjYWxpbmcgcmF0aW8pXG5cbiAgICAgIGlmIChkZWx0YSA8IDApIGRlbHRhIC89IDMuNzU7IC8vIEJ0dywgaWRrIHdoeSAzLjc1LCBidXQgaXQgd29ya3NcblxuICAgICAgZGVsdGEgKj0gMC4yNTtcbiAgICAgIHRoaXMueV9yYW5nZSA9IFt0aGlzLmxheW91dC4kX2hpLCB0aGlzLmxheW91dC4kX2xvXTtcbiAgICAgIHRoaXMuZHJ1ZyA9IHtcbiAgICAgICAgeTogMCxcbiAgICAgICAgejogdGhpcy56b29tLFxuICAgICAgICBtaWQ6IG1hdGgubG9nX21pZCh0aGlzLnlfcmFuZ2UsIHRoaXMubGF5b3V0LmhlaWdodCksXG4gICAgICAgIEE6IHRoaXMubGF5b3V0LkEsXG4gICAgICAgIEI6IHRoaXMubGF5b3V0LkJcbiAgICAgIH07XG4gICAgICB0aGlzLnpvb20gPSB0aGlzLmNhbGNfem9vbSh7XG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgIHk6IGRlbHRhICogdGhpcy5sYXlvdXQuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdzaWRlYmFyLXRyYW5zZm9ybScsIHtcbiAgICAgICAgZ3JpZF9pZDogdGhpcy5pZCxcbiAgICAgICAgem9vbTogdGhpcy56b29tLFxuICAgICAgICBhdXRvOiBmYWxzZSxcbiAgICAgICAgcmFuZ2U6IHRoaXMuY2FsY19yYW5nZShkaWZmMSwgZGlmZjIpLFxuICAgICAgICBkcnVnZ2luZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRydWcgPSBudWxsO1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdzaWRlYmFyLXRyYW5zZm9ybScsIHtcbiAgICAgICAgZ3JpZF9pZDogdGhpcy5pZCxcbiAgICAgICAgZHJ1Z2dpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMubWMpIHRoaXMubWMuZGVzdHJveSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKCkge31cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZW91dCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2V1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZXVwKCkge31cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZWRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2Vkb3duKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBTaWRlYmFyO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9TaWRlYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIFRoZSBzaWRlIGJhciAoeWVwLCB0aGF0IHRoaW5nIHdpdGggYSBidW5jaCBvZiAkJCQpXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTaWRlYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NpZGViYXInLFxuICBwcm9wczogWydzdWInLCAnbGF5b3V0JywgJ3JhbmdlJywgJ2ludGVydmFsJywgJ2N1cnNvcicsICdjb2xvcnMnLCAnZm9udCcsICd3aWR0aCcsICdoZWlnaHQnLCAnZ3JpZF9pZCcsICdyZXJlbmRlcicsICd5X3RyYW5zZm9ybScsICd0dl9pZCcsICdjb25maWcnLCAnc2hhZGVycyddLFxuICBtaXhpbnM6IFtjYW52YXNdLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBlbCA9IHRoaXMuJHJlZnNbJ2NhbnZhcyddO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgU2lkZWJhcihlbCwgdGhpcyk7XG4gICAgdGhpcy5zZXR1cCgpO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQuZ3JpZHNbaWRdO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZV9jYW52YXMoaCwgXCJzaWRlYmFyLVwiLmNvbmNhdChpZCksIHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IGxheW91dC53aWR0aCxcbiAgICAgICAgeTogbGF5b3V0Lm9mZnNldCB8fCAwXG4gICAgICB9LFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgcmVyZW5kZXI6IHRoaXMuJHByb3BzLnJlcmVuZGVyLFxuICAgICAgICB3aWR0aDogdGhpcy4kcHJvcHMud2lkdGgsXG4gICAgICAgIGhlaWdodDogbGF5b3V0LmhlaWdodFxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy4kcHJvcHMuY29sb3JzLmJhY2tcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICByYW5nZToge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfSxcbiAgICBjdXJzb3I6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH0sXG4gICAgcmVyZW5kZXI6IGZ1bmN0aW9uIHJlcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVkcmF3KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGVzdHJveSgpO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NpZGViYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19TaWRlYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNpZGViYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NpZGViYXIudnVlXG52YXIgU2lkZWJhcl9yZW5kZXIsIFNpZGViYXJfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU2lkZWJhcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfU2lkZWJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU2lkZWJhcl9yZW5kZXIsXG4gIFNpZGViYXJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTaWRlYmFyX2FwaTsgfVxuU2lkZWJhcl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1NpZGViYXIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19TaWRlYmFyID0gKFNpZGViYXJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvTGVnZW5kLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zNDcyNDg4NiZcbnZhciBMZWdlbmR2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zNDcyNDg4Nl9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLWxlZ2VuZFwiLCBzdHlsZTogX3ZtLmNhbGNfc3R5bGUgfSxcbiAgICBbXG4gICAgICBfdm0uZ3JpZF9pZCA9PT0gMFxuICAgICAgICA/IF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtb2hsY3ZcIixcbiAgICAgICAgICAgICAgc3R5bGU6IHsgXCJtYXgtd2lkdGhcIjogX3ZtLmNvbW1vbi53aWR0aCArIFwicHhcIiB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0LXZ1ZS10aXRsZVwiLFxuICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgY29sb3I6IF92bS5jb21tb24uY29sb3JzLnRpdGxlIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLmNvbW1vbi50aXRsZV90eHQpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF92bS5zaG93X3ZhbHVlc1xuICAgICAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgT1wiKSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtbHNwYW5cIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0ub2hsY3ZbMF0pKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgSFwiKSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtbHNwYW5cIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0ub2hsY3ZbMV0pKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgTFwiKSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtbHNwYW5cIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0ub2hsY3ZbMl0pKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgQ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtbHNwYW5cIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0ub2hsY3ZbM10pKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgVlwiKSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtbHNwYW5cIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0ub2hsY3ZbNF0pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAhX3ZtLnNob3dfdmFsdWVzXG4gICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sc3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGNvbG9yOiBfdm0uY29tbW9uLmNvbG9ycy50ZXh0IH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoKF92bS5jb21tb24ubWV0YS5sYXN0IHx8IFtdKVs0XSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5fbCh0aGlzLmluZGljYXRvcnMsIGZ1bmN0aW9uKGluZCkge1xuICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWluZFwiIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtaW5hbWVcIiB9LCBbXG4gICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoaW5kLm5hbWUpKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJidXR0b24tZ3JvdXBcIiwge1xuICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IF92bS5jb21tb24uYnV0dG9ucyxcbiAgICAgICAgICAgICAgICBjb25maWc6IF92bS5jb21tb24uY29uZmlnLFxuICAgICAgICAgICAgICAgIG92X2lkOiBpbmQuaWQsXG4gICAgICAgICAgICAgICAgZ3JpZF9pZDogX3ZtLmdyaWRfaWQsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZC5pbmRleCxcbiAgICAgICAgICAgICAgICB0dl9pZDogX3ZtLmNvbW1vbi50dl9pZCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmQudlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbjogeyBcImxlZ2VuZC1idXR0b24tY2xpY2tcIjogX3ZtLmJ1dHRvbl9jbGljayB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBpbmQudlxuICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWl2YWx1ZXNcIiB9LFxuICAgICAgICAgICAgICAgICAgX3ZtLl9sKGluZC52YWx1ZXMsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5zaG93X3ZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidC12dWUtbHNwYW4gdC12dWUtaXZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgY29sb3I6IHYuY29sb3IgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3Modi52YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIGluZC51bmtcbiAgICAgICAgICAgICAgPyBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS11bmtub3duXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgKFVua25vd24gdHlwZSlcXG4gICAgICAgIFwiKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwidHJhbnNpdGlvblwiLFxuICAgICAgICAgICAgICB7IGF0dHJzOiB7IG5hbWU6IFwidHZqcy1hcHBlYXJcIiB9IH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBpbmQubG9hZGluZ1xuICAgICAgICAgICAgICAgICAgPyBfYyhcInNwaW5uZXJcIiwgeyBhdHRyczogeyBjb2xvcnM6IF92bS5jb21tb24uY29sb3JzIH0gfSlcbiAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgMVxuICAgICAgICApXG4gICAgICB9KVxuICAgIF0sXG4gICAgMlxuICApXG59XG52YXIgTGVnZW5kdnVlX3R5cGVfdGVtcGxhdGVfaWRfMzQ3MjQ4ODZfc3RhdGljUmVuZGVyRm5zID0gW11cbkxlZ2VuZHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM0NzI0ODg2X3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0xlZ2VuZC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzQ3MjQ4ODYmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0J1dHRvbkdyb3VwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02ZjgyNjQyNiZcbnZhciBCdXR0b25Hcm91cHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzZmODI2NDI2X3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcInNwYW5cIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWxidG4tZ3JwXCIgfSxcbiAgICBfdm0uX2woX3ZtLmJ1dHRvbnMsIGZ1bmN0aW9uKGIsIGkpIHtcbiAgICAgIHJldHVybiBfYyhcImxlZ2VuZC1idXR0b25cIiwge1xuICAgICAgICBrZXk6IGksXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IGIubmFtZSB8fCBiLFxuICAgICAgICAgIHR2X2lkOiBfdm0udHZfaWQsXG4gICAgICAgICAgb3ZfaWQ6IF92bS5vdl9pZCxcbiAgICAgICAgICBncmlkX2lkOiBfdm0uZ3JpZF9pZCxcbiAgICAgICAgICBpbmRleDogX3ZtLmluZGV4LFxuICAgICAgICAgIGRpc3BsYXk6IF92bS5kaXNwbGF5LFxuICAgICAgICAgIGljb246IGIuaWNvbixcbiAgICAgICAgICBjb25maWc6IF92bS5jb25maWdcbiAgICAgICAgfSxcbiAgICAgICAgb246IHsgXCJsZWdlbmQtYnV0dG9uLWNsaWNrXCI6IF92bS5idXR0b25fY2xpY2sgfVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAxXG4gIClcbn1cbnZhciBCdXR0b25Hcm91cHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzZmODI2NDI2X3N0YXRpY1JlbmRlckZucyA9IFtdXG5CdXR0b25Hcm91cHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzZmODI2NDI2X3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0J1dHRvbkdyb3VwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02ZjgyNjQyNiZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvTGVnZW5kQnV0dG9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xYWQ4NzM2MiZcbnZhciBMZWdlbmRCdXR0b252dWVfdHlwZV90ZW1wbGF0ZV9pZF8xYWQ4NzM2Ml9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJpbWdcIiwge1xuICAgIHN0YXRpY0NsYXNzOiBcInQtdnVlLWxidG5cIixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IF92bS5jb25maWcuTF9CVE5fU0laRSArIFwicHhcIixcbiAgICAgIGhlaWdodDogX3ZtLmNvbmZpZy5MX0JUTl9TSVpFICsgXCJweFwiLFxuICAgICAgbWFyZ2luOiBfdm0uY29uZmlnLkxfQlROX01BUkdJTlxuICAgIH0sXG4gICAgYXR0cnM6IHsgc3JjOiBfdm0uYmFzZTY0LCBpZDogX3ZtLnV1aWQgfSxcbiAgICBvbjogeyBjbGljazogX3ZtLm9uY2xpY2sgfVxuICB9KVxufVxudmFyIExlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzFhZDg3MzYyX3N0YXRpY1JlbmRlckZucyA9IFtdXG5MZWdlbmRCdXR0b252dWVfdHlwZV90ZW1wbGF0ZV9pZF8xYWQ4NzM2Ml9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9MZWdlbmRCdXR0b24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFhZDg3MzYyJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvTGVnZW5kQnV0dG9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMZWdlbmRCdXR0b252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnTGVnZW5kQnV0dG9uJyxcbiAgcHJvcHM6IFsnaWQnLCAndHZfaWQnLCAnZ3JpZF9pZCcsICdvdl9pZCcsICdpbmRleCcsICdkaXNwbGF5JywgJ2ljb24nLCAnY29uZmlnJ10sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7fSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBiYXNlNjQ6IGZ1bmN0aW9uIGJhc2U2NCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmljb24gfHwgaWNvbnNfbmFtZXNwYWNlT2JqZWN0W3RoaXMuZmlsZV9uYW1lXTtcbiAgICB9LFxuICAgIGZpbGVfbmFtZTogZnVuY3Rpb24gZmlsZV9uYW1lKCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuaWQ7XG5cbiAgICAgIGlmICh0aGlzLiRwcm9wcy5pZCA9PT0gJ2Rpc3BsYXknKSB7XG4gICAgICAgIGlkID0gdGhpcy4kcHJvcHMuZGlzcGxheSA/ICdkaXNwbGF5X29uJyA6ICdkaXNwbGF5X29mZic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZCArICcucG5nJztcbiAgICB9LFxuICAgIHV1aWQ6IGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgICB2YXIgdHYgPSB0aGlzLiRwcm9wcy50dl9pZDtcbiAgICAgIHZhciBnciA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgICB2YXIgb3YgPSB0aGlzLiRwcm9wcy5vdl9pZDtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0diwgXCItYnRuLWdcIikuY29uY2F0KGdyLCBcIi1cIikuY29uY2F0KG92KTtcbiAgICB9LFxuICAgIGRhdGFfdHlwZTogZnVuY3Rpb24gZGF0YV90eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmdyaWRfaWQgPT09IDAgPyBcIm9uY2hhcnRcIiA6IFwib2ZmY2hhcnRcIjtcbiAgICB9LFxuICAgIGRhdGFfaW5kZXg6IGZ1bmN0aW9uIGRhdGFfaW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuaW5kZXg7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25jbGljazogZnVuY3Rpb24gb25jbGljaygpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2xlZ2VuZC1idXR0b24tY2xpY2snLCB7XG4gICAgICAgIGJ1dHRvbjogdGhpcy4kcHJvcHMuaWQsXG4gICAgICAgIHR5cGU6IHRoaXMuZGF0YV90eXBlLFxuICAgICAgICBkYXRhSW5kZXg6IHRoaXMuZGF0YV9pbmRleCxcbiAgICAgICAgZ3JpZDogdGhpcy4kcHJvcHMuZ3JpZF9pZCxcbiAgICAgICAgb3ZlcmxheTogdGhpcy4kcHJvcHMub3ZfaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9MZWdlbmRCdXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19MZWdlbmRCdXR0b252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTGVnZW5kQnV0dG9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvTGVnZW5kQnV0dG9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIExlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjkpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTGVnZW5kQnV0dG9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9MZWdlbmRCdXR0b24udnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgTGVnZW5kQnV0dG9uX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19MZWdlbmRCdXR0b252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIExlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzFhZDg3MzYyX3JlbmRlcixcbiAgTGVnZW5kQnV0dG9udnVlX3R5cGVfdGVtcGxhdGVfaWRfMWFkODczNjJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBMZWdlbmRCdXR0b25fYXBpOyB9XG5MZWdlbmRCdXR0b25fY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9MZWdlbmRCdXR0b24udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTGVnZW5kQnV0dG9uID0gKExlZ2VuZEJ1dHRvbl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQnV0dG9uR3JvdXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQnV0dG9uR3JvdXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQnV0dG9uR3JvdXAnLFxuICBwcm9wczogWydidXR0b25zJywgJ3R2X2lkJywgJ292X2lkJywgJ2dyaWRfaWQnLCAnaW5kZXgnLCAnZGlzcGxheScsICdjb25maWcnXSxcbiAgY29tcG9uZW50czoge1xuICAgIExlZ2VuZEJ1dHRvbjogTGVnZW5kQnV0dG9uXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBidXR0b25fY2xpY2s6IGZ1bmN0aW9uIGJ1dHRvbl9jbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnbGVnZW5kLWJ1dHRvbi1jbGljaycsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQnV0dG9uR3JvdXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19CdXR0b25Hcm91cHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChCdXR0b25Hcm91cHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0J1dHRvbkdyb3VwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIEJ1dHRvbkdyb3VwdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4Nik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQnV0dG9uR3JvdXAudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgQnV0dG9uR3JvdXBfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0J1dHRvbkdyb3VwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBCdXR0b25Hcm91cHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzZmODI2NDI2X3JlbmRlcixcbiAgQnV0dG9uR3JvdXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF82ZjgyNjQyNl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEJ1dHRvbkdyb3VwX2FwaTsgfVxuQnV0dG9uR3JvdXBfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCdXR0b25Hcm91cCA9IChCdXR0b25Hcm91cF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9TcGlubmVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zOTQzMmY5OSZcbnZhciBTcGlubmVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzk0MzJmOTlfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJ0dmpzLXNwaW5uZXJcIiB9LFxuICAgIF92bS5fbCg0LCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBrZXk6IGksIHN0eWxlOiB7IGJhY2tncm91bmQ6IF92bS5jb2xvcnMudGV4dCB9IH0pXG4gICAgfSksXG4gICAgMFxuICApXG59XG52YXIgU3Bpbm5lcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5NDMyZjk5X3N0YXRpY1JlbmRlckZucyA9IFtdXG5TcGlubmVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzk0MzJmOTlfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU3Bpbm5lci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Mzk0MzJmOTkmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9TcGlubmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3Bpbm5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTcGlubmVyJyxcbiAgcHJvcHM6IFsnY29sb3JzJ11cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU3Bpbm5lci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1NwaW5uZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU3Bpbm5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1NwaW5uZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgU3Bpbm5lcnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU3Bpbm5lci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU3Bpbm5lci52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBTcGlubmVyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19TcGlubmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTcGlubmVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzk0MzJmOTlfcmVuZGVyLFxuICBTcGlubmVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzk0MzJmOTlfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTcGlubmVyX2FwaTsgfVxuU3Bpbm5lcl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1NwaW5uZXIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3Bpbm5lciA9IChTcGlubmVyX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9MZWdlbmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTGVnZW5kdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0NoYXJ0TGVnZW5kJyxcbiAgcHJvcHM6IFsnY29tbW9uJywgJ3ZhbHVlcycsICdncmlkX2lkJywgJ21ldGFfcHJvcHMnXSxcbiAgY29tcG9uZW50czoge1xuICAgIEJ1dHRvbkdyb3VwOiBCdXR0b25Hcm91cCxcbiAgICBTcGlubmVyOiBTcGlubmVyXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgb2hsY3Y6IGZ1bmN0aW9uIG9obGN2KCkge1xuICAgICAgaWYgKCF0aGlzLiRwcm9wcy52YWx1ZXMgfHwgIXRoaXMuJHByb3BzLnZhbHVlcy5vaGxjdikge1xuICAgICAgICByZXR1cm4gQXJyYXkoNikuZmlsbCgnbi9hJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmVjID0gdGhpcy5sYXlvdXQucHJlYzsgLy8gVE9ETzogbWFpbiB0aGUgbWFpbiBsZWdlbmQgbW9yZSBjdXN0b21pemFibGVcblxuICAgICAgdmFyIGlkID0gdGhpcy5tYWluX3R5cGUgKyAnXzAnO1xuICAgICAgdmFyIG1ldGEgPSB0aGlzLiRwcm9wcy5tZXRhX3Byb3BzW2lkXSB8fCB7fTtcblxuICAgICAgaWYgKG1ldGEubGVnZW5kKSB7XG4gICAgICAgIHJldHVybiAobWV0YS5sZWdlbmQoKSB8fCBbXSkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3RoaXMuJHByb3BzLnZhbHVlcy5vaGxjdlsxXS50b0ZpeGVkKHByZWMpLCB0aGlzLiRwcm9wcy52YWx1ZXMub2hsY3ZbMl0udG9GaXhlZChwcmVjKSwgdGhpcy4kcHJvcHMudmFsdWVzLm9obGN2WzNdLnRvRml4ZWQocHJlYyksIHRoaXMuJHByb3BzLnZhbHVlcy5vaGxjdls0XS50b0ZpeGVkKHByZWMpLCB0aGlzLiRwcm9wcy52YWx1ZXMub2hsY3ZbNV0gPyB0aGlzLiRwcm9wcy52YWx1ZXMub2hsY3ZbNV0udG9GaXhlZCgyKSA6ICduL2EnXTtcbiAgICB9LFxuICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciB7IGdyaWQ6IHsgaWQgOiBOIH19XG4gICAgaW5kaWNhdG9yczogZnVuY3Rpb24gaW5kaWNhdG9ycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLiRwcm9wcy52YWx1ZXM7XG4gICAgICB2YXIgZiA9IHRoaXMuZm9ybWF0O1xuICAgICAgdmFyIHR5cGVzID0ge307XG4gICAgICByZXR1cm4gdGhpcy5qc29uX2RhdGEuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnNldHRpbmdzLmxlZ2VuZCAhPT0gZmFsc2UgJiYgIXgubWFpbjtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoISh4LnR5cGUgaW4gdHlwZXMpKSB0eXBlc1t4LnR5cGVdID0gMDtcbiAgICAgICAgdmFyIGlkID0geC50eXBlICsgXCJfXCIuY29uY2F0KHR5cGVzW3gudHlwZV0rKyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogJ2Rpc3BsYXknIGluIHguc2V0dGluZ3MgPyB4LnNldHRpbmdzLmRpc3BsYXkgOiB0cnVlLFxuICAgICAgICAgIG5hbWU6IHgubmFtZSB8fCBpZCxcbiAgICAgICAgICBpbmRleDogKF90aGlzLm9mZl9kYXRhIHx8IF90aGlzLmpzb25fZGF0YSkuaW5kZXhPZih4KSxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgdmFsdWVzOiB2YWx1ZXMgPyBmKGlkLCB2YWx1ZXMpIDogX3RoaXMubl9hKDEpLFxuICAgICAgICAgIHVuazogIShpZCBpbiAoX3RoaXMuJHByb3BzLm1ldGFfcHJvcHMgfHwge30pKSxcbiAgICAgICAgICBsb2FkaW5nOiB4LmxvYWRpbmdcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2FsY19zdHlsZTogZnVuY3Rpb24gY2FsY19zdHlsZSgpIHtcbiAgICAgIHZhciB0b3AgPSB0aGlzLmxheW91dC5oZWlnaHQgPiAxNTAgPyAxMCA6IDU7XG4gICAgICB2YXIgZ3JpZHMgPSB0aGlzLiRwcm9wcy5jb21tb24ubGF5b3V0LmdyaWRzO1xuICAgICAgdmFyIHcgPSBncmlkc1swXSA/IGdyaWRzWzBdLndpZHRoIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBcIlwiLmNvbmNhdCh0aGlzLmxheW91dC5vZmZzZXQgKyB0b3AsIFwicHhcIiksXG4gICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3IC0gMjAsIFwicHhcIilcbiAgICAgIH07XG4gICAgfSxcbiAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuY29tbW9uLmxheW91dC5ncmlkc1tpZF07XG4gICAgfSxcbiAgICBqc29uX2RhdGE6IGZ1bmN0aW9uIGpzb25fZGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5jb21tb24uZGF0YTtcbiAgICB9LFxuICAgIG9mZl9kYXRhOiBmdW5jdGlvbiBvZmZfZGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5jb21tb24ub2ZmY2hhcnQ7XG4gICAgfSxcbiAgICBtYWluX3R5cGU6IGZ1bmN0aW9uIG1haW5fdHlwZSgpIHtcbiAgICAgIHZhciBmID0gdGhpcy5jb21tb24uZGF0YS5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4Lm1haW47XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmID8gZi50eXBlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2hvd192YWx1ZXM6IGZ1bmN0aW9uIHNob3dfdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbW9uLmN1cnNvci5tb2RlICE9PSAnZXhwbG9yZSc7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQoaWQsIHZhbHVlcykge1xuICAgICAgdmFyIG1ldGEgPSB0aGlzLiRwcm9wcy5tZXRhX3Byb3BzW2lkXSB8fCB7fTsgLy8gTWF0Y2hlcyBPdmVybGF5LmRhdGFfY29sb3JzIHdpdGggdGhlIGRhdGEgdmFsdWVzXG4gICAgICAvLyAoc2VlIFNwbGluZS52dWUpXG5cbiAgICAgIGlmICghdmFsdWVzW2lkXSkgcmV0dXJuIHRoaXMubl9hKDEpOyAvLyBDdXN0b20gZm9ybWF0dGVyXG5cbiAgICAgIGlmIChtZXRhLmxlZ2VuZCkgcmV0dXJuIG1ldGEubGVnZW5kKHZhbHVlc1tpZF0pO1xuICAgICAgcmV0dXJuIHZhbHVlc1tpZF0uc2xpY2UoMSkubWFwKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgIHZhciBjcyA9IG1ldGEuZGF0YV9jb2xvcnMgPyBtZXRhLmRhdGFfY29sb3JzKCkgOiBbXTtcblxuICAgICAgICBpZiAodHlwZW9mIHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBTaG93IDggZGlnaXRzIGZvciBzbWFsbCB2YWx1ZXNcbiAgICAgICAgICB4ID0geC50b0ZpeGVkKE1hdGguYWJzKHgpID4gMC4wMDEgPyA0IDogOCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgIGNvbG9yOiBjcyA/IGNzW2kgJSBjcy5sZW5ndGhdIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG5fYTogZnVuY3Rpb24gbl9hKGxlbikge1xuICAgICAgcmV0dXJuIEFycmF5KGxlbikuZmlsbCh7XG4gICAgICAgIHZhbHVlOiAnbi9hJ1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBidXR0b25fY2xpY2s6IGZ1bmN0aW9uIGJ1dHRvbl9jbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnbGVnZW5kLWJ1dHRvbi1jbGljaycsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTGVnZW5kLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfTGVnZW5kdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKExlZ2VuZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0xlZ2VuZC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBMZWdlbmR2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjAwKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0xlZ2VuZC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTGVnZW5kLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIExlZ2VuZF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfTGVnZW5kdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBMZWdlbmR2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zNDcyNDg4Nl9yZW5kZXIsXG4gIExlZ2VuZHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM0NzI0ODg2X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgTGVnZW5kX2FwaTsgfVxuTGVnZW5kX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTGVnZW5kLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExlZ2VuZCA9IChMZWdlbmRfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9zaGFkZXJzLmpzXG5mdW5jdGlvbiBzaGFkZXJzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBzaGFkZXJzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBzaGFkZXJzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gc2hhZGVyc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gc2hhZGVyc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gc2hhZGVyc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBQYXJzZXIgZm9yIHNoYWRlciBldmVudHNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgc2hhZGVycyA9ICh7XG4gIG1ldGhvZHM6IHtcbiAgICAvLyBJbml0IHNoYWRlcnMgZnJvbSBleHRlbnNpb25zXG4gICAgaW5pdF9zaGFkZXJzOiBmdW5jdGlvbiBpbml0X3NoYWRlcnMoc2tpbiwgcHJldikge1xuICAgICAgaWYgKHNraW4gIT09IHByZXYpIHtcbiAgICAgICAgaWYgKHByZXYpIHRoaXMuc2hhZGVycyA9IHRoaXMuc2hhZGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5vd25lciAhPT0gcHJldi5pZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IHNoYWRlcnNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihza2luLnNoYWRlcnMpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIFNoYWRlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHNoYWRlciA9IG5ldyBTaGFkZXIoKTtcbiAgICAgICAgICAgIHNoYWRlci5vd25lciA9IHNraW4uaWQ7XG4gICAgICAgICAgICB0aGlzLnNoYWRlcnMucHVzaChzaGFkZXIpO1xuICAgICAgICAgIH0gLy8gVE9ETzogU29ydCBieSB6SW5kZXhcblxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uX3NoYWRlcl9ldmVudDogZnVuY3Rpb24gb25fc2hhZGVyX2V2ZW50KGQsIHRhcmdldCkge1xuICAgICAgaWYgKGQuZXZlbnQgPT09ICduZXctc2hhZGVyJykge1xuICAgICAgICBpZiAoZC5hcmdzWzBdLnRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgZC5hcmdzWzBdLmlkID0gXCJcIi5jb25jYXQoZC5hcmdzWzFdLCBcIi1cIikuY29uY2F0KGQuYXJnc1syXSk7XG4gICAgICAgICAgdGhpcy5zaGFkZXJzLnB1c2goZC5hcmdzWzBdKTtcbiAgICAgICAgICB0aGlzLnJlcmVuZGVyKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGQuZXZlbnQgPT09ICdyZW1vdmUtc2hhZGVycycpIHtcbiAgICAgICAgdmFyIGlkID0gZC5hcmdzLmpvaW4oJy0nKTtcbiAgICAgICAgdGhpcy5zaGFkZXJzID0gdGhpcy5zaGFkZXJzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LmlkICE9PSBpZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHNraW46IGZ1bmN0aW9uIHNraW4obiwgcCkge1xuICAgICAgdGhpcy5pbml0X3NoYWRlcnMobiwgcCk7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaGFkZXJzOiBbXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1NlY3Rpb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTZWN0aW9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0dyaWRTZWN0aW9uJyxcbiAgcHJvcHM6IFsnY29tbW9uJywgJ2dyaWRfaWQnXSxcbiAgbWl4aW5zOiBbc2hhZGVyc10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBHcmlkOiBjb21wb25lbnRzX0dyaWQsXG4gICAgU2lkZWJhcjogY29tcG9uZW50c19TaWRlYmFyLFxuICAgIENoYXJ0TGVnZW5kOiBMZWdlbmRcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLmluaXRfc2hhZGVycyh0aGlzLiRwcm9wcy5jb21tb24uc2tpbik7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICByYW5nZV9jaGFuZ2VkOiBmdW5jdGlvbiByYW5nZV9jaGFuZ2VkKHIpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3JhbmdlLWNoYW5nZWQnLCByKTtcbiAgICB9LFxuICAgIGN1cnNvcl9jaGFuZ2VkOiBmdW5jdGlvbiBjdXJzb3JfY2hhbmdlZChjKSB7XG4gICAgICBjLmdyaWRfaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgICAgdGhpcy4kZW1pdCgnY3Vyc29yLWNoYW5nZWQnLCBjKTtcbiAgICB9LFxuICAgIGN1cnNvcl9sb2NrZWQ6IGZ1bmN0aW9uIGN1cnNvcl9sb2NrZWQoc3RhdGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1cnNvci1sb2NrZWQnLCBzdGF0ZSk7XG4gICAgfSxcbiAgICBzaWRlYmFyX3RyYW5zZm9ybTogZnVuY3Rpb24gc2lkZWJhcl90cmFuc2Zvcm0ocykge1xuICAgICAgdGhpcy4kZW1pdCgnc2lkZWJhci10cmFuc2Zvcm0nLCBzKTtcbiAgICB9LFxuICAgIGVtaXRfbWV0YV9wcm9wczogZnVuY3Rpb24gZW1pdF9tZXRhX3Byb3BzKGQpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLm1ldGFfcHJvcHMsIGQubGF5ZXJfaWQsIGQpO1xuICAgICAgdGhpcy4kZW1pdCgnbGF5ZXItbWV0YS1wcm9wcycsIGQpO1xuICAgIH0sXG4gICAgZW1pdF9jdXN0b21fZXZlbnQ6IGZ1bmN0aW9uIGVtaXRfY3VzdG9tX2V2ZW50KGQpIHtcbiAgICAgIHRoaXMub25fc2hhZGVyX2V2ZW50KGQsICdzaWRlYmFyJyk7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCBkKTtcbiAgICB9LFxuICAgIGJ1dHRvbl9jbGljazogZnVuY3Rpb24gYnV0dG9uX2NsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdsZWdlbmQtYnV0dG9uLWNsaWNrJywgZXZlbnQpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJfa2I6IGZ1bmN0aW9uIHJlZ2lzdGVyX2tiKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdyZWdpc3Rlci1rYi1saXN0ZW5lcicsIGV2ZW50KTtcbiAgICB9LFxuICAgIHJlbW92ZV9rYjogZnVuY3Rpb24gcmVtb3ZlX2tiKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdyZW1vdmUta2ItbGlzdGVuZXInLCBldmVudCk7XG4gICAgfSxcbiAgICByZXpvb21fcmFuZ2U6IGZ1bmN0aW9uIHJlem9vbV9yYW5nZShldmVudCkge1xuICAgICAgdmFyIGlkID0gJ3NiLScgKyBldmVudC5ncmlkX2lkO1xuXG4gICAgICBpZiAodGhpcy4kcmVmc1tpZF0pIHtcbiAgICAgICAgdGhpcy4kcmVmc1tpZF0ucmVuZGVyZXIucmV6b29tX3JhbmdlKGV2ZW50LnosIGV2ZW50LmRpZmYxLCBldmVudC5kaWZmMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBnaGFzaDogZnVuY3Rpb24gZ2hhc2godmFsKSB7XG4gICAgICAvLyBNZWFzdXJlcyBncmlkIGhlaWdodHMgY29uZmlndXJhdGlvblxuICAgICAgdmFyIGhzID0gdmFsLmxheW91dC5ncmlkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguaGVpZ2h0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgIH0sICcnKTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgLy8gQ29tcG9uZW50LXNwZWNpZmljIHByb3BzIHN1YnNldHM6XG4gICAgZ3JpZF9wcm9wczogZnVuY3Rpb24gZ3JpZF9wcm9wcygpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgICB2YXIgcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJHByb3BzLmNvbW1vbik7IC8vIFNwbGl0IG9mZmNoYXJ0IGRhdGEgYmV0d2VlbiBvZmZjaGFydCBncmlkc1xuXG4gICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgIHZhciBfcCRkYXRhO1xuXG4gICAgICAgIHZhciBhbGwgPSBwLmRhdGE7XG4gICAgICAgIHAuZGF0YSA9IFtwLmRhdGFbaWQgLSAxXV07IC8vIE1lcmdlIG9mZmNoYXJ0IG92ZXJsYXlzIHdpdGggY3VzdG9tIGlkcyB3aXRoXG4gICAgICAgIC8vIHRoZSBleGlzdGluZyBvbnNlIChieSBjb21wYXJpbmcgdGhlIGdyaWQgaWRzKVxuXG4gICAgICAgIChfcCRkYXRhID0gcC5kYXRhKS5wdXNoLmFwcGx5KF9wJGRhdGEsIF90b0NvbnN1bWFibGVBcnJheShhbGwuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHguZ3JpZCAmJiB4LmdyaWQuaWQgPT09IGlkO1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICBwLndpZHRoID0gcC5sYXlvdXQuZ3JpZHNbaWRdLndpZHRoO1xuICAgICAgcC5oZWlnaHQgPSBwLmxheW91dC5ncmlkc1tpZF0uaGVpZ2h0O1xuICAgICAgcC55X3RyYW5zZm9ybSA9IHAueV90c1tpZF07XG4gICAgICBwLnNoYWRlcnMgPSB0aGlzLmdyaWRfc2hhZGVycztcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgc2lkZWJhcl9wcm9wczogZnVuY3Rpb24gc2lkZWJhcl9wcm9wcygpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgICB2YXIgcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJHByb3BzLmNvbW1vbik7XG4gICAgICBwLndpZHRoID0gcC5sYXlvdXQuZ3JpZHNbaWRdLnNiO1xuICAgICAgcC5oZWlnaHQgPSBwLmxheW91dC5ncmlkc1tpZF0uaGVpZ2h0O1xuICAgICAgcC55X3RyYW5zZm9ybSA9IHAueV90c1tpZF07XG4gICAgICBwLnNoYWRlcnMgPSB0aGlzLnNiX3NoYWRlcnM7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHNlY3Rpb25fdmFsdWVzOiBmdW5jdGlvbiBzZWN0aW9uX3ZhbHVlcygpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgICB2YXIgcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJHByb3BzLmNvbW1vbik7XG4gICAgICBwLndpZHRoID0gcC5sYXlvdXQuZ3JpZHNbaWRdLndpZHRoO1xuICAgICAgcmV0dXJuIHAuY3Vyc29yLnZhbHVlc1tpZF07XG4gICAgfSxcbiAgICBsZWdlbmRfcHJvcHM6IGZ1bmN0aW9uIGxlZ2VuZF9wcm9wcygpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgICB2YXIgcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJHByb3BzLmNvbW1vbik7IC8vIFNwbGl0IG9mZmNoYXJ0IGRhdGEgYmV0d2VlbiBvZmZjaGFydCBncmlkc1xuXG4gICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgIHZhciBfcCRkYXRhMjtcblxuICAgICAgICB2YXIgYWxsID0gcC5kYXRhO1xuICAgICAgICBwLm9mZmNoYXJ0ID0gYWxsO1xuICAgICAgICBwLmRhdGEgPSBbcC5kYXRhW2lkIC0gMV1dO1xuXG4gICAgICAgIChfcCRkYXRhMiA9IHAuZGF0YSkucHVzaC5hcHBseShfcCRkYXRhMiwgX3RvQ29uc3VtYWJsZUFycmF5KGFsbC5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5ncmlkICYmIHguZ3JpZC5pZCA9PT0gaWQ7XG4gICAgICAgIH0pKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgZ2V0X21ldGFfcHJvcHM6IGZ1bmN0aW9uIGdldF9tZXRhX3Byb3BzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWV0YV9wcm9wcztcbiAgICB9LFxuICAgIGdyaWRfc2hhZGVyczogZnVuY3Rpb24gZ3JpZF9zaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhZGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudGFyZ2V0ID09PSAnZ3JpZCc7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNiX3NoYWRlcnM6IGZ1bmN0aW9uIHNiX3NoYWRlcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFkZXJzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50YXJnZXQgPT09ICdzaWRlYmFyJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIodmFsLCBvbGRfdmFsKSB7XG4gICAgICAgIHZhciBuZXdoYXNoID0gdGhpcy5naGFzaCh2YWwpO1xuXG4gICAgICAgIGlmIChuZXdoYXNoICE9PSB0aGlzLmxhc3RfZ2hhc2gpIHtcbiAgICAgICAgICB0aGlzLnJlcmVuZGVyKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsLmRhdGEubGVuZ3RoICE9PSBvbGRfdmFsLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gTG9vayBhdCB0aGlzIG5hc3R5IHRyaWNrIVxuICAgICAgICAgIHRoaXMucmVyZW5kZXIrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdF9naGFzaCA9IG5ld2hhc2g7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YV9wcm9wczoge30sXG4gICAgICByZXJlbmRlcjogMCxcbiAgICAgIGxhc3RfZ2hhc2g6ICcnXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TZWN0aW9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfU2VjdGlvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTZWN0aW9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvU2VjdGlvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBTZWN0aW9udnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NlY3Rpb24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NlY3Rpb24udnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgU2VjdGlvbl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfU2VjdGlvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU2VjdGlvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzhmYmU5MzM2X3JlbmRlcixcbiAgU2VjdGlvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzhmYmU5MzM2X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU2VjdGlvbl9hcGk7IH1cblNlY3Rpb25fY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9TZWN0aW9uLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNlY3Rpb24gPSAoU2VjdGlvbl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9ib3RiYXIuanNcblxuXG5cbmZ1bmN0aW9uIGJvdGJhcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gYm90YmFyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBib3RiYXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBib3RiYXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGJvdGJhcl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gYm90YmFyX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuXG52YXIgYm90YmFyX01JTlVURTE1ID0gY29uc3RhbnRzLk1JTlVURTE1LFxuICAgIGJvdGJhcl9NSU5VVEUgPSBjb25zdGFudHMuTUlOVVRFLFxuICAgIGJvdGJhcl9IT1VSID0gY29uc3RhbnRzLkhPVVIsXG4gICAgYm90YmFyX0RBWSA9IGNvbnN0YW50cy5EQVksXG4gICAgYm90YmFyX1dFRUsgPSBjb25zdGFudHMuV0VFSyxcbiAgICBib3RiYXJfTU9OVEggPSBjb25zdGFudHMuTU9OVEgsXG4gICAgYm90YmFyX1lFQVIgPSBjb25zdGFudHMuWUVBUixcbiAgICBib3RiYXJfTU9OVEhNQVAgPSBjb25zdGFudHMuTU9OVEhNQVA7XG5cbnZhciBCb3RiYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCb3RiYXIoY2FudmFzLCBjb21wKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm90YmFyKTtcblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5jb21wID0gY29tcDtcbiAgICB0aGlzLiRwID0gY29tcC4kcHJvcHM7XG4gICAgdGhpcy5kYXRhID0gdGhpcy4kcC5zdWI7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuJHAucmFuZ2U7XG4gICAgdGhpcy5sYXlvdXQgPSB0aGlzLiRwLmxheW91dDtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKEJvdGJhciwgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuZ3JpZF8wID0gdGhpcy5sYXlvdXQuZ3JpZHNbMF07XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmxheW91dC5ib3RiYXIud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5sYXlvdXQuYm90YmFyLmhlaWdodDtcbiAgICAgIHZhciBzYiA9IHRoaXMubGF5b3V0LmdyaWRzWzBdLnNiOyAvL3RoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuJHAuY29sb3JzLmJhY2tcblxuICAgICAgdGhpcy5jdHguZm9udCA9IHRoaXMuJHAuZm9udDsgLy90aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuXG4gICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnNjYWxlO1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgMC41KTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyhNYXRoLmZsb29yKHdpZHRoICsgMSksIDAuNSk7XG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnRleHQ7XG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IGJvdGJhcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMubGF5b3V0LmJvdGJhci54cyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgbGJsID0gdGhpcy5mb3JtYXRfZGF0ZShwKTtcbiAgICAgICAgICBpZiAocFswXSA+IHdpZHRoIC0gc2IpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhwWzBdIC0gMC41LCAwKTtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lVG8ocFswXSAtIDAuNSwgNC41KTtcblxuICAgICAgICAgIGlmICghdGhpcy5sYmxfaGlnaGxpZ2h0KHBbMV1bMF0pKSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IDAuODU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQobGJsLCBwWzBdLCAxOCk7XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5hcHBseV9zaGFkZXJzKCk7XG4gICAgICBpZiAodGhpcy4kcC5jdXJzb3IueCAmJiB0aGlzLiRwLmN1cnNvci50ICE9PSB1bmRlZmluZWQpIHRoaXMucGFuZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlfc2hhZGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseV9zaGFkZXJzKCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0LmdyaWRzWzBdO1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgY3Vyc29yOiB0aGlzLiRwLmN1cnNvclxuICAgICAgfTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBib3RiYXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbXAuYm90X3NoYWRlcnMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcyA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgICAgcy5kcmF3KHRoaXMuY3R4LCBwcm9wcyk7XG4gICAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuZWwoKSB7XG4gICAgICB2YXIgbGJsID0gdGhpcy5mb3JtYXRfY3Vyc29yX3goKTtcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnBhbmVsO1xuICAgICAgdmFyIG1lYXN1cmUgPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYmwgKyAnICAgICcpO1xuICAgICAgdmFyIHBhbndpZHRoID0gTWF0aC5mbG9vcihtZWFzdXJlLndpZHRoKTtcbiAgICAgIHZhciBjdXJzb3IgPSB0aGlzLiRwLmN1cnNvci54O1xuICAgICAgdmFyIHggPSBNYXRoLmZsb29yKGN1cnNvciAtIHBhbndpZHRoICogMC41KTtcbiAgICAgIHZhciB5ID0gLTAuNTtcbiAgICAgIHZhciBwYW5oZWlnaHQgPSB0aGlzLmNvbXAuY29uZmlnLlBBTkhFSUdIVDtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgsIHksIHBhbndpZHRoLCBwYW5oZWlnaHQgKyAwLjUpO1xuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy4kcC5jb2xvcnMudGV4dEhMO1xuICAgICAgdGhpcy5jdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0aGlzLmN0eC5maWxsVGV4dChsYmwsIGN1cnNvciwgeSArIDE2KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0X2RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0X2RhdGUocCkge1xuICAgICAgdmFyIHQgPSBwWzFdWzBdO1xuICAgICAgdCA9IHRoaXMuZ3JpZF8wLnRpX21hcC5pMnQodCk7XG4gICAgICB2YXIgdGkgPSB0aGlzLiRwLmxheW91dC5ncmlkc1swXS50aV9tYXAudGY7IC8vIEVuYWJsZSB0aW1lem9uZXMgb25seSBmb3IgdGYgPCAxRFxuXG4gICAgICB2YXIgayA9IHRpIDwgYm90YmFyX0RBWSA/IDEgOiAwO1xuICAgICAgdmFyIHRaID0gdCArIGsgKiB0aGlzLiRwLnRpbWV6b25lICogYm90YmFyX0hPVVI7IC8vdCArPSBuZXcgRGF0ZSh0KS5nZXRUaW1lem9uZU9mZnNldCgpICogTUlOVVRFXG5cbiAgICAgIHZhciBkID0gbmV3IERhdGUodFopO1xuXG4gICAgICBpZiAocFsyXSA9PT0gYm90YmFyX1lFQVIgfHwgdXRpbHMueWVhcl9zdGFydCh0KSA9PT0gdCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocFsyXSA9PT0gYm90YmFyX01PTlRIIHx8IHV0aWxzLm1vbnRoX3N0YXJ0KHQpID09PSB0KSB7XG4gICAgICAgIHJldHVybiBib3RiYXJfTU9OVEhNQVBbZC5nZXRVVENNb250aCgpXTtcbiAgICAgIH0gLy8gVE9ETygqKSBzZWUgZ3JpZF9tYWtlci5qc1xuXG5cbiAgICAgIGlmICh1dGlscy5kYXlfc3RhcnQodFopID09PSB0WikgcmV0dXJuIGQuZ2V0VVRDRGF0ZSgpO1xuICAgICAgdmFyIGggPSB1dGlscy5hZGRfemVybyhkLmdldFVUQ0hvdXJzKCkpO1xuICAgICAgdmFyIG0gPSB1dGlscy5hZGRfemVybyhkLmdldFVUQ01pbnV0ZXMoKSk7XG4gICAgICByZXR1cm4gaCArIFwiOlwiICsgbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0X2N1cnNvcl94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdF9jdXJzb3JfeCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy4kcC5jdXJzb3IudDtcbiAgICAgIHQgPSB0aGlzLmdyaWRfMC50aV9tYXAuaTJ0KHQpOyAvL2xldCB0aSA9IHRoaXMuJHAuaW50ZXJ2YWxcblxuICAgICAgdmFyIHRpID0gdGhpcy4kcC5sYXlvdXQuZ3JpZHNbMF0udGlfbWFwLnRmOyAvLyBFbmFibGUgdGltZXpvbmVzIG9ubHkgZm9yIHRmIDwgMURcblxuICAgICAgdmFyIGsgPSB0aSA8IGJvdGJhcl9EQVkgPyAxIDogMDsgLy90ICs9IG5ldyBEYXRlKHQpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBNSU5VVEVcblxuICAgICAgdmFyIGQgPSBuZXcgRGF0ZSh0ICsgayAqIHRoaXMuJHAudGltZXpvbmUgKiBib3RiYXJfSE9VUik7XG5cbiAgICAgIGlmICh0aSA9PT0gYm90YmFyX1lFQVIpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpIDwgYm90YmFyX1lFQVIpIHtcbiAgICAgICAgdmFyIHlyID0gJ2AnICsgXCJcIi5jb25jYXQoZC5nZXRVVENGdWxsWWVhcigpKS5zbGljZSgtMik7XG4gICAgICAgIHZhciBtbyA9IGJvdGJhcl9NT05USE1BUFtkLmdldFVUQ01vbnRoKCldO1xuICAgICAgICB2YXIgZGQgPSAnMDEnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGkgPD0gYm90YmFyX1dFRUspIGRkID0gZC5nZXRVVENEYXRlKCk7XG4gICAgICB2YXIgZGF0ZSA9IFwiXCIuY29uY2F0KGRkLCBcIiBcIikuY29uY2F0KG1vLCBcIiBcIikuY29uY2F0KHlyKTtcbiAgICAgIHZhciB0aW1lID0gJyc7XG5cbiAgICAgIGlmICh0aSA8IGJvdGJhcl9EQVkpIHtcbiAgICAgICAgdmFyIGggPSB1dGlscy5hZGRfemVybyhkLmdldFVUQ0hvdXJzKCkpO1xuICAgICAgICB2YXIgbSA9IHV0aWxzLmFkZF96ZXJvKGQuZ2V0VVRDTWludXRlcygpKTtcbiAgICAgICAgdGltZSA9IGggKyBcIjpcIiArIG07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChkYXRlLCBcIiAgXCIpLmNvbmNhdCh0aW1lKTtcbiAgICB9IC8vIEhpZ2hsaWdodHMgdGhlIGJlZ2luaW5nIG9mIGEgdGltZSBpbnRlcnZhbFxuICAgIC8vIFRPRE86IGltcHJvdmUuIFByb2JsZW06IGxldCdzIHNheSB3ZSBoYXZlIGEgbmV3IG1vbnRoLFxuICAgIC8vIGJ1dCBpZiB0aGVyZSBpcyBubyBncmlkIGxpbmUgaW4gcGxhY2UsIHRoZXJlXG4gICAgLy8gd2lsbCBiZSBubyBtb250aCBuYW1lIG9uIHQtYXhpcy4gU2FkLlxuICAgIC8vIFNvbHV0aW9uOiBtYW5pcHVsYXRlIHRoZSBncmlkLCBza2V3IGl0LCB5b3Uga25vd1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGJsX2hpZ2hsaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYmxfaGlnaGxpZ2h0KHQpIHtcbiAgICAgIHZhciB0aSA9IHRoaXMuJHAuaW50ZXJ2YWw7XG4gICAgICBpZiAodCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodXRpbHMubW9udGhfc3RhcnQodCkgPT09IHQpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHV0aWxzLmRheV9zdGFydCh0KSA9PT0gdCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGkgPD0gYm90YmFyX01JTlVURTE1ICYmIHQgJSBib3RiYXJfSE9VUiA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZW1vdmUoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlb3V0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZXVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNldXAoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZWRvd24oKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIEJvdGJhcjtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQm90YmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIFRoZSBib3R0b20gYmFyICh5ZXAsIHRoYXQgdGhpbmcgd2l0aCBhIGJ1bmNoIG9mIGRhdGVzKVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQm90YmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0JvdGJhcicsXG4gIHByb3BzOiBbJ3N1YicsICdsYXlvdXQnLCAncmFuZ2UnLCAnaW50ZXJ2YWwnLCAnY3Vyc29yJywgJ2NvbG9ycycsICdmb250JywgJ3dpZHRoJywgJ2hlaWdodCcsICdyZXJlbmRlcicsICd0dl9pZCcsICdjb25maWcnLCAnc2hhZGVycycsICd0aW1lem9uZSddLFxuICBtaXhpbnM6IFtjYW52YXNdLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBlbCA9IHRoaXMuJHJlZnNbJ2NhbnZhcyddO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgQm90YmFyKGVsLCB0aGlzKTtcbiAgICB0aGlzLnNldHVwKCk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciBzZXR0ID0gdGhpcy4kcHJvcHMubGF5b3V0LmJvdGJhcjtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVfY2FudmFzKGgsICdib3RiYXInLCB7XG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiBzZXR0Lm9mZnNldCB8fCAwXG4gICAgICB9LFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgcmVyZW5kZXI6IHRoaXMuJHByb3BzLnJlcmVuZGVyLFxuICAgICAgICB3aWR0aDogc2V0dC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzZXR0LmhlaWdodFxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy4kcHJvcHMuY29sb3JzLmJhY2tcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBib3Rfc2hhZGVyczogZnVuY3Rpb24gYm90X3NoYWRlcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2hhZGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudGFyZ2V0ID09PSAnYm90YmFyJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICByYW5nZToge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfSxcbiAgICBjdXJzb3I6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH0sXG4gICAgcmVyZW5kZXI6IGZ1bmN0aW9uIHJlcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVkcmF3KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQm90YmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfQm90YmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEJvdGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0JvdGJhci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBCb3RiYXJ2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI0KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0JvdGJhci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQm90YmFyLnZ1ZVxudmFyIEJvdGJhcl9yZW5kZXIsIEJvdGJhcl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIEJvdGJhcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfQm90YmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBCb3RiYXJfcmVuZGVyLFxuICBCb3RiYXJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBCb3RiYXJfYXBpOyB9XG5Cb3RiYXJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9Cb3RiYXIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19Cb3RiYXIgPSAoQm90YmFyX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9LZXlib2FyZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLZXlib2FyZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdLZXlib2FyZCcsXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd24pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMua2V5dXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMua2V5cHJlc3MpO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmtleXVwKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLmtleXByZXNzKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHJldHVybiBoKCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzLl9saXN0ZW5lcnNbaWRdO1xuXG4gICAgICAgIGlmIChsICYmIGwua2V5ZG93bikge1xuICAgICAgICAgIGwua2V5ZG93bihldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gJ2tleWRvd24nIGxpc3RlbmVyIGZvciBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAga2V5dXA6IGZ1bmN0aW9uIGtleXVwKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzLl9saXN0ZW5lcnNbaWRdO1xuXG4gICAgICAgIGlmIChsICYmIGwua2V5dXApIHtcbiAgICAgICAgICBsLmtleXVwKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyAna2V5dXAnIGxpc3RlbmVyIGZvciBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAga2V5cHJlc3M6IGZ1bmN0aW9uIGtleXByZXNzKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzLl9saXN0ZW5lcnNbaWRdO1xuXG4gICAgICAgIGlmIChsICYmIGwua2V5cHJlc3MpIHtcbiAgICAgICAgICBsLmtleXByZXNzKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyAna2V5cHJlc3MnIGxpc3RlbmVyIGZvciBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnNbbGlzdGVuZXIuaWRdID0gbGlzdGVuZXI7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShsaXN0ZW5lcikge1xuICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tsaXN0ZW5lci5pZF07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfS2V5Ym9hcmR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoS2V5Ym9hcmR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0tleWJvYXJkLnZ1ZVxudmFyIEtleWJvYXJkX3JlbmRlciwgS2V5Ym9hcmRfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgS2V5Ym9hcmRfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0tleWJvYXJkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBLZXlib2FyZF9yZW5kZXIsXG4gIEtleWJvYXJkX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgS2V5Ym9hcmRfYXBpOyB9XG5LZXlib2FyZF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0tleWJvYXJkLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtleWJvYXJkID0gKEtleWJvYXJkX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvZGF0YXRyYWNrLmpzXG4vLyBEYXRhIHRyYWNrZXIvd2F0Y2hlclxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGRhdGF0cmFjayA9ICh7XG4gIG1ldGhvZHM6IHtcbiAgICBkYXRhX2NoYW5nZWQ6IGZ1bmN0aW9uIGRhdGFfY2hhbmdlZCgpIHtcbiAgICAgIHZhciBuID0gdGhpcy5vaGxjdjtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLl9kYXRhX24wICE9PSBuWzBdICYmIHRoaXMuX2RhdGFfbGVuICE9PSBuLmxlbmd0aCkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGVja19hbGxfZGF0YShjaGFuZ2VkKTtcblxuICAgICAgaWYgKHRoaXMudGlfbWFwLmliKSB7XG4gICAgICAgIHRoaXMucmVpbmRleF9kZWx0YShuWzBdLCB0aGlzLl9kYXRhX24wKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGF0YV9uMCA9IG5bMF07XG4gICAgICB0aGlzLl9kYXRhX2xlbiA9IG4ubGVuZ3RoO1xuICAgICAgdGhpcy5zYXZlX2RhdGFfdCgpO1xuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcbiAgICBjaGVja19hbGxfZGF0YTogZnVuY3Rpb24gY2hlY2tfYWxsX2RhdGEoY2hhbmdlZCkge1xuICAgICAgLy8gSWYgbGVuZ3RoIG9mIGRhdGEgaW4gdGhlIFN0cnVjdHVyZSBjaGFuZ2VkIGJ5ID4gMSBwb2ludFxuICAgICAgLy8gZW1pdCBhIHNwZWNpYWwgZXZlbnQgZm9yIERDIHRvIHJlY2FsYyB0aGUgc2NyaXB0c1xuICAgICAgLy8gVE9ETzogY2hlY2sgb3ZlcmxheXMgZGF0YSB0b29cbiAgICAgIHZhciBsZW4gPSB0aGlzLl9kYXRhX2xlbiB8fCAwO1xuXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy5vaGxjdi5sZW5ndGggLSBsZW4pID4gMSB8fCB0aGlzLl9kYXRhX24wICE9PSB0aGlzLm9obGN2WzBdKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgICBldmVudDogJ2RhdGEtbGVuLWNoYW5nZWQnLFxuICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVpbmRleF9kZWx0YTogZnVuY3Rpb24gcmVpbmRleF9kZWx0YShuLCBwKSB7XG4gICAgICBuID0gbiB8fCBbWzBdXTtcbiAgICAgIHAgPSBwIHx8IFtbMF1dO1xuICAgICAgdmFyIGR0ID0gblswXSAtIHBbMF07XG5cbiAgICAgIGlmIChkdCAhPT0gMCAmJiB0aGlzLl9kYXRhX3QpIHtcbiAgICAgICAgLy8gQ29udmVydCB0IGJhY2sgdG8gaW5kZXhcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBNb3JlIHByZWNpc2UgbWV0aG9kIGZpcnN0XG4gICAgICAgICAgdmFyIG50ID0gdGhpcy5fZGF0YV90ICsgMC4wMTsgLy8gZml4IGZvciB0aGUgZmlsdGVyIGxpYlxuXG4gICAgICAgICAgdmFyIHJlcyA9IHV0aWxzLmZhc3RfbmVhcmVzdCh0aGlzLm9obGN2LCBudCk7XG4gICAgICAgICAgdmFyIGNuZGwgPSB0aGlzLm9obGN2W3Jlc1swXV07XG4gICAgICAgICAgdmFyIG9mZiA9IChudCAtIGNuZGxbMF0pIC8gdGhpcy5pbnRlcnZhbF9tcztcbiAgICAgICAgICB0aGlzW1wiZ290b1wiXShyZXNbMF0gKyBvZmYpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpc1tcImdvdG9cIl0odGhpcy50aV9tYXAudDJpKHRoaXMuX2RhdGFfdCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzYXZlX2RhdGFfdDogZnVuY3Rpb24gc2F2ZV9kYXRhX3QoKSB7XG4gICAgICB0aGlzLl9kYXRhX3QgPSB0aGlzLnRpX21hcC5pMnQodGhpcy5yYW5nZVsxXSk7IC8vIHNhdmUgYXMgdFxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2RhdGFfbjA6IG51bGwsXG4gICAgICBfZGF0YV9sZW46IDAsXG4gICAgICBfZGF0YV90OiAwXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy90aV9tYXBwaW5nLmpzXG5cblxuXG5cbi8vIFRpbWUtaW5kZXggbWFwcGluZyAoZm9yIG5vbi1saW5lYXIgdC1heGlzKVxuXG52YXIgTUFYX0FSUiA9IE1hdGgucG93KDIsIDMyKTsgLy8gMyBNT0RFUyBvZiBpbmRleCBjYWxjdWxhdGlvbiBmb3Igb3ZlcmxheXMvc3ViY2hhcnRzOlxuLy8gOjo6IGluZGV4U3JjIDo6OlxuLy8gKiBcIm1hcFwiICAgICAgLT4gdXNlIFRJIG1hcHBpbmcgZnVuY3Rpb25zIHRvIGRldGVjdCBpbmRleFxuLy8gICAgICAgICAgICAgICAgIChzbG93ZXN0LCBmb3Igc3RvY2tzIG9ubHkuIERFRkFVTFQpXG4vL1xuLy8gKiBcImNhbGNcIiAgICAgLT4gY2FsY3VsYXRlIHNoaWZ0IGJldHdlZW4gc3ViICYgZGF0YVxuLy8gICAgICAgICAgICAgICAgIChmYXN0ZXIsIGJ1dCBvdmVybGF5IGRhdGEgc2hvdWxkIGJlIHBlcmZlY3RseVxuLy8gICAgICAgICAgICAgICAgICBhbGlnbiB3aXRoIHRoZSBtYWluIGNoYXJ0LFxuLy8gICAgICAgICAgICAgICAgICAxLTEgY2FuZGxlL2RhdGEgcG9pbnQuIFN1cHBvcnRzIFJlbmtvKVxuLy9cbi8vICogXCJkYXRhXCIgICAgIC0+IG92ZXJsYXkgZGF0YSBzaG91bGQgY29tZSB3aXRoIGNhbmRsZSBpbmRleFxuLy8gICAgICAgICAgICAgICAgIChmYXN0ZXN0LCBzdXBwb3J0cyBSZW5rbylcblxudmFyIFRJID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVEkoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgVEkpO1xuXG4gICAgdGhpcy5pYiA9IGZhbHNlO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoVEksIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChwYXJhbXMsIHJlcykge1xuICAgICAgdmFyIHN1YiA9IHBhcmFtcy5zdWIsXG4gICAgICAgICAgaW50ZXJ2YWwgPSBwYXJhbXMuaW50ZXJ2YWwsXG4gICAgICAgICAgbWV0YSA9IHBhcmFtcy5tZXRhLFxuICAgICAgICAgICRwID0gcGFyYW1zLiRwcm9wcyxcbiAgICAgICAgICBpbnRlcnZhbF9tcyA9IHBhcmFtcy5pbnRlcnZhbF9tcyxcbiAgICAgICAgICBzdWJfc3RhcnQgPSBwYXJhbXMuc3ViX3N0YXJ0LFxuICAgICAgICAgIGliID0gcGFyYW1zLmliO1xuICAgICAgdGhpcy50aV9tYXAgPSBbXTtcbiAgICAgIHRoaXMuaXRfbWFwID0gW107XG4gICAgICB0aGlzLnN1Yl9pID0gW107XG4gICAgICB0aGlzLmliID0gaWI7XG4gICAgICB0aGlzLnN1YiA9IHJlcztcbiAgICAgIHRoaXMuc3MgPSBzdWJfc3RhcnQ7XG4gICAgICB0aGlzLnRmID0gaW50ZXJ2YWxfbXM7XG4gICAgICB2YXIgc3RhcnQgPSBtZXRhLnN1Yl9zdGFydDsgLy8gU2tpcCBtYXBwaW5nIGZvciB0aGUgcmVndWxhciBtb2RlXG5cbiAgICAgIGlmICh0aGlzLmliKSB7XG4gICAgICAgIHRoaXMubWFwX3N1YihyZXMpO1xuICAgICAgfVxuICAgIH0gLy8gTWFrZSBtYXBzIGZvciB0aGUgbWFpbiBzdWJzZXRcblxuICB9LCB7XG4gICAga2V5OiBcIm1hcF9zdWJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwX3N1YihyZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gcmVzW2ldWzBdO1xuXG4gICAgICAgIHZhciBfaSA9IHRoaXMuc3MgKyBpO1xuXG4gICAgICAgIHRoaXMudGlfbWFwW3RdID0gX2k7XG4gICAgICAgIHRoaXMuaXRfbWFwW19pXSA9IHQ7IC8vIE92ZXJ3cml0ZSB0IHdpdGggaVxuXG4gICAgICAgIHZhciBjb3B5ID0gX3RvQ29uc3VtYWJsZUFycmF5KHJlc1tpXSk7XG5cbiAgICAgICAgY29weVswXSA9IF9pO1xuICAgICAgICB0aGlzLnN1Yl9pLnB1c2goY29weSk7XG4gICAgICB9XG4gICAgfSAvLyBNYXAgb3ZlcmxheSBkYXRhXG4gICAgLy8gVE9ETzogcGFyc2UoKSBjYWxsZWQgMyB0aW1lcyBpbnN0ZWFkIG9mIDIgZm9yICdzcHhfc2FtcGxlLmpzb24nXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShkYXRhLCBtb2RlKSB7XG4gICAgICBpZiAoIXRoaXMuaWIgfHwgIXRoaXMuc3ViWzBdIHx8IG1vZGUgPT09ICdkYXRhJykgcmV0dXJuIGRhdGE7XG4gICAgICB2YXIgcmVzID0gW107XG4gICAgICB2YXIgayA9IDA7IC8vIENhbmRsZXN0aWNrIGluZGV4XG5cbiAgICAgIGlmIChtb2RlID09PSAnY2FsYycpIHtcbiAgICAgICAgdmFyIHNoaWZ0ID0gdXRpbHMuaW5kZXhfc2hpZnQodGhpcy5zdWIsIGRhdGEpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfaSA9IHRoaXMuc3MgKyBpO1xuXG4gICAgICAgICAgdmFyIGNvcHkgPSBfdG9Db25zdW1hYmxlQXJyYXkoZGF0YVtpXSk7XG5cbiAgICAgICAgICBjb3B5WzBdID0gX2kgKyBzaGlmdDtcbiAgICAgICAgICByZXMucHVzaChjb3B5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IC8vIElmIGluZGljYXRvciBkYXRhIHN0YXJ0cyBhZnRlciBvaGxjdiwgY2FsYyB0aGUgZmlyc3QgaW5kZXhcblxuXG4gICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgazEgPSB1dGlscy5mYXN0X25lYXJlc3QodGhpcy5zdWIsIGRhdGFbMF1bMF0pWzBdO1xuICAgICAgICAgIGlmIChrMSAhPT0gbnVsbCAmJiBrMSA+PSAwKSBrID0gazE7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIHZhciB0MCA9IHRoaXMuc3ViWzBdWzBdO1xuICAgICAgdmFyIHROID0gdGhpcy5zdWJbdGhpcy5zdWIubGVuZ3RoIC0gMV1bMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2NvcHkgPSBfdG9Db25zdW1hYmxlQXJyYXkoZGF0YVtpXSk7XG5cbiAgICAgICAgdmFyIHRrID0gdGhpcy5zdWJba11bMF07XG4gICAgICAgIHZhciB0ID0gZGF0YVtpXVswXTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy50aV9tYXBbdF07XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBMaW5lYXIgZXh0cmFwb2xhdGlvblxuICAgICAgICAgIGlmICh0IDwgdDAgfHwgdCA+IHROKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuc3MgKyBrIC0gKHRrIC0gdCkgLyB0aGlzLnRmO1xuICAgICAgICAgICAgdCA9IGRhdGFbaSArIDFdID8gZGF0YVtpICsgMV1bMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdGsyID0gdGhpcy5zdWJbayArIDFdWzBdO1xuICAgICAgICAgICAgICBpbmRleCA9IHRrID09PSB0azIgPyB0aGlzLnNzICsgayA6IHRoaXMuc3MgKyBrICsgKHQgLSB0aykgLyAodGsyIC0gdGspO1xuICAgICAgICAgICAgICB0ID0gZGF0YVtpICsgMV0gPyBkYXRhW2kgKyAxXVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBSYWNlIG9mIGRhdGEgcG9pbnRzICYgc3ViIHBvaW50cyAob2hsY3YpXG4gICAgICAgIC8vIChsaWtlIHR1cm4gYmFzZWQgaW5jcmVtZW50cylcblxuXG4gICAgICAgIHdoaWxlIChrICsgMSA8IHRoaXMuc3ViLmxlbmd0aCAtIDEgJiYgdCA+IHRoaXMuc3ViW2sgKyAxXVswXSkge1xuICAgICAgICAgIGsrKztcbiAgICAgICAgICB0ayA9IHRoaXMuc3ViW2tdWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NvcHlbMF0gPSBpbmRleDtcbiAgICAgICAgcmVzLnB1c2goX2NvcHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gaW5kZXggPT4gdGltZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaTJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGkydChpKSB7XG4gICAgICBpZiAoIXRoaXMuaWIgfHwgIXRoaXMuc3ViLmxlbmd0aCkgcmV0dXJuIGk7IC8vIFJlZ3VsYXIgbW9kZVxuICAgICAgLy8gRGlzY3JldGUgbWFwcGluZ1xuXG4gICAgICB2YXIgcmVzID0gdGhpcy5pdF9tYXBbaV07XG4gICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHJldHVybiByZXM7IC8vIExpbmVhciBleHRyYXBvbGF0aW9uXG4gICAgICBlbHNlIGlmIChpID49IHRoaXMuc3MgKyB0aGlzLnN1Yl9pLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBkaSA9IGkgLSAodGhpcy5zcyArIHRoaXMuc3ViX2kubGVuZ3RoKSArIDE7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnN1Ylt0aGlzLnN1Yi5sZW5ndGggLSAxXTtcbiAgICAgICAgICByZXR1cm4gbGFzdFswXSArIGRpICogdGhpcy50ZjtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgdGhpcy5zcykge1xuICAgICAgICAgIHZhciBfZGkgPSBpIC0gdGhpcy5zcztcblxuICAgICAgICAgIHJldHVybiB0aGlzLnN1YlswXVswXSArIF9kaSAqIHRoaXMudGY7XG4gICAgICAgIH0gLy8gTGluZWFyIEludGVycG9sYXRpb25cblxuICAgICAgdmFyIGkxID0gTWF0aC5mbG9vcihpKSAtIHRoaXMuc3M7XG4gICAgICB2YXIgaTIgPSBpMSArIDE7XG4gICAgICB2YXIgbGVuID0gdGhpcy5zdWIubGVuZ3RoO1xuICAgICAgaWYgKGkyID49IGxlbikgaTIgPSBsZW4gLSAxO1xuICAgICAgdmFyIHN1YjEgPSB0aGlzLnN1YltpMV07XG4gICAgICB2YXIgc3ViMiA9IHRoaXMuc3ViW2kyXTtcblxuICAgICAgaWYgKHN1YjEgJiYgc3ViMikge1xuICAgICAgICB2YXIgdDEgPSBzdWIxWzBdO1xuICAgICAgICB2YXIgdDIgPSBzdWIyWzBdO1xuICAgICAgICByZXR1cm4gdDEgKyAodDIgLSB0MSkgKiAoaSAtIGkxIC0gdGhpcy5zcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBNYXAgb3IgYnlwYXNzIGRlcGVuZGluZyBvbiB0aGUgbW9kZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaTJ0X21vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaTJ0X21vZGUoaSwgbW9kZSkge1xuICAgICAgcmV0dXJuIG1vZGUgPT09ICdkYXRhJyA/IGkgOiB0aGlzLmkydChpKTtcbiAgICB9IC8vIHRpbWUgPT4gaW5kZXhcbiAgICAvLyBUT0RPOiB3aGVuIHN3aXRjaCBmcm9tIElCIG1vZGUgdG8gcmVndWxhciB0b29sc1xuICAgIC8vIGRpc2FwcGVhciAoYmMgdGhlcmUgaXMgbm8gbW9yZSBtYXBwaW5nKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwidDJpXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHQyaSh0KSB7XG4gICAgICBpZiAoIXRoaXMuc3ViLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDsgLy8gRGlzY3JldGUgbWFwcGluZ1xuXG4gICAgICB2YXIgcmVzID0gdGhpcy50aV9tYXBbdF07XG4gICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHJldHVybiByZXM7XG4gICAgICB2YXIgdDAgPSB0aGlzLnN1YlswXVswXTtcbiAgICAgIHZhciB0TiA9IHRoaXMuc3ViW3RoaXMuc3ViLmxlbmd0aCAtIDFdWzBdOyAvLyBMaW5lYXIgZXh0cmFwb2xhdGlvblxuXG4gICAgICBpZiAodCA8IHQwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNzIC0gKHQwIC0gdCkgLyB0aGlzLnRmO1xuICAgICAgfSBlbHNlIGlmICh0ID4gdE4pIHtcbiAgICAgICAgdmFyIGsgPSB0aGlzLnN1Yi5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5zcyArIGsgLSAodE4gLSB0KSAvIHRoaXMudGY7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIExpbmVhciBJbnRlcnBvbGF0aW9uXG4gICAgICAgIHZhciBpID0gdXRpbHMuZmFzdF9uZWFyZXN0KHRoaXMuc3ViLCB0KTtcbiAgICAgICAgdmFyIHRrID0gdGhpcy5zdWJbaVswXV1bMF07XG4gICAgICAgIHZhciB0azIgPSB0aGlzLnN1YltpWzFdXVswXTtcblxuICAgICAgICB2YXIgX2sgPSAodCAtIHRrKSAvICh0azIgLSB0ayk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3MgKyBpWzBdICsgX2sgKiAoaVsxXSAtIGlbMF0pO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIEF1dG8gZGV0ZWN0OiBpcyBpdCB0aW1lIG9yIGluZGV4P1xuICAgIC8vIEFzc3VtaW5nIHRoYXQgaW5kZXgtYmFzZWQgbW9kZSBpcyBPTlxuXG4gIH0sIHtcbiAgICBrZXk6IFwic210aDJpXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNtdGgyaShzbXRoKSB7XG4gICAgICBpZiAoc210aCA+IE1BWF9BUlIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudDJpKHNtdGgpOyAvLyBpdCB3YXMgdGltZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc210aDsgLy8gaXQgd2FzIGFuIGluZGV4XG4gICAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic210aDJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNtdGgydChzbXRoKSB7XG4gICAgICBpZiAoc210aCA8IE1BWF9BUlIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaTJ0KHNtdGgpOyAvLyBpdCB3YXMgYW4gaW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNtdGg7IC8vIGl0IHdhcyB0aW1lXG4gICAgICAgIH1cbiAgICB9IC8vIEdsb2JhbCBUaW1lID0+IEluZGV4ICh1c2VzIGFsbCBkYXRhLCBhcHByb3guIG1ldGhvZClcbiAgICAvLyBVc2VkIGJ5IHR2LmdvdG8oKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3QyaVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBndDJpKHNtdGgsIG9obGN2KSB7XG4gICAgICBpZiAoc210aCA+IE1BWF9BUlIpIHtcbiAgICAgICAgdmFyIEUgPSAwLjE7IC8vIEZpeGVzIHRoZSBhcnJheXNsaWNlciBidWdcblxuICAgICAgICB2YXIgX1V0aWxzJGZhc3RfbmVhcmVzdCA9IHV0aWxzLmZhc3RfbmVhcmVzdChvaGxjdiwgc210aCArIEUpLFxuICAgICAgICAgICAgX1V0aWxzJGZhc3RfbmVhcmVzdDIgPSBfc2xpY2VkVG9BcnJheShfVXRpbHMkZmFzdF9uZWFyZXN0LCAyKSxcbiAgICAgICAgICAgIGkxID0gX1V0aWxzJGZhc3RfbmVhcmVzdDJbMF0sXG4gICAgICAgICAgICBpMiA9IF9VdGlscyRmYXN0X25lYXJlc3QyWzFdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaTEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGkxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnQyaShzbXRoKTsgLy8gZmFsbGJhY2tcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc210aDsgLy8gaXQgd2FzIGFuIGluZGV4XG4gICAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVEk7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0NoYXJ0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ2hhcnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ2hhcnQnLFxuICBwcm9wczogWyd0aXRsZV90eHQnLCAnZGF0YScsICd3aWR0aCcsICdoZWlnaHQnLCAnZm9udCcsICdjb2xvcnMnLCAnb3ZlcmxheXMnLCAndHZfaWQnLCAnY29uZmlnJywgJ2J1dHRvbnMnLCAndG9vbGJhcicsICdpYicsICdza2luJywgJ3RpbWV6b25lJ10sXG4gIG1peGluczogW3NoYWRlcnMsIGRhdGF0cmFja10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBHcmlkU2VjdGlvbjogU2VjdGlvbixcbiAgICBCb3RiYXI6IGNvbXBvbmVudHNfQm90YmFyLFxuICAgIEtleWJvYXJkOiBLZXlib2FyZFxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIC8vIENvbnRleHQgZm9yIHRleHQgbWVhc3VyZW1lbnRzXG4gICAgdGhpcy5jdHggPSBuZXcgY29udGV4dCh0aGlzLiRwcm9wcyk7IC8vIEluaXRpYWwgbGF5b3V0IChBbGwgbWVhc3VybWVudHMgZm9yIHRoZSBjaGFydClcblxuICAgIHRoaXMuaW5pdF9yYW5nZSgpO1xuICAgIHRoaXMuc3ViID0gdGhpcy5zdWJzZXQoKTtcbiAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgdGhpcy5yYW5nZSk7IC8vIEZpeCBmb3IgSUIgbW9kZVxuXG4gICAgdGhpcy5fbGF5b3V0ID0gbmV3IGxheW91dCh0aGlzKTsgLy8gVXBkYXRlcyBjdXJyZW50IGN1cnNvciB2YWx1ZXNcblxuICAgIHRoaXMudXBkYXRlciA9IG5ldyB1cGRhdGVyKHRoaXMpO1xuICAgIHRoaXMudXBkYXRlX2xhc3RfdmFsdWVzKCk7XG4gICAgdGhpcy5pbml0X3NoYWRlcnModGhpcy5za2luKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHJhbmdlX2NoYW5nZWQ6IGZ1bmN0aW9uIHJhbmdlX2NoYW5nZWQocikge1xuICAgICAgLy8gT3ZlcndpdGUgJiBrZWVwIHRoZSBvcmlnaW5hbCByZWZlcmVuY2VzXG4gICAgICAvLyBRdWljayBmaXggZm9yIElCIG1vZGUgKHN3aXRjaCAyIG5leHQgbGluZXMpXG4gICAgICAvLyBUT0RPOiB3dGY/XG4gICAgICB2YXIgc3ViID0gdGhpcy5zdWJzZXQocik7XG4gICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgcik7XG4gICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5zdWIsIHN1Yik7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQoKTtcbiAgICAgIHRoaXMuJGVtaXQoJ3JhbmdlLWNoYW5nZWQnLCByKTtcbiAgICAgIGlmICh0aGlzLiRwcm9wcy5pYikgdGhpcy5zYXZlX2RhdGFfdCgpO1xuICAgIH0sXG4gICAgXCJnb3RvXCI6IGZ1bmN0aW9uIGdvdG8odCkge1xuICAgICAgdmFyIGR0ID0gdGhpcy5yYW5nZVsxXSAtIHRoaXMucmFuZ2VbMF07XG4gICAgICB0aGlzLnJhbmdlX2NoYW5nZWQoW3QgLSBkdCwgdF0pO1xuICAgIH0sXG4gICAgc2V0UmFuZ2U6IGZ1bmN0aW9uIHNldFJhbmdlKHQxLCB0Mikge1xuICAgICAgdGhpcy5yYW5nZV9jaGFuZ2VkKFt0MSwgdDJdKTtcbiAgICB9LFxuICAgIGN1cnNvcl9jaGFuZ2VkOiBmdW5jdGlvbiBjdXJzb3JfY2hhbmdlZChlKSB7XG4gICAgICBpZiAoZS5tb2RlKSB0aGlzLmN1cnNvci5tb2RlID0gZS5tb2RlO1xuXG4gICAgICBpZiAodGhpcy5jdXJzb3IubW9kZSAhPT0gJ2V4cGxvcmUnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlci5zeW5jKGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faG9va194Y2hhbmdlZCkgdGhpcy5jZSgnP3gtY2hhbmdlZCcsIGUpO1xuICAgIH0sXG4gICAgY3Vyc29yX2xvY2tlZDogZnVuY3Rpb24gY3Vyc29yX2xvY2tlZChzdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuY3Vyc29yLnNjcm9sbF9sb2NrICYmIHN0YXRlKSByZXR1cm47XG4gICAgICB0aGlzLmN1cnNvci5sb2NrZWQgPSBzdGF0ZTtcbiAgICAgIGlmICh0aGlzLl9ob29rX3hsb2NrZWQpIHRoaXMuY2UoJz94LWxvY2tlZCcsIHN0YXRlKTtcbiAgICB9LFxuICAgIGNhbGNfaW50ZXJ2YWw6IGZ1bmN0aW9uIGNhbGNfaW50ZXJ2YWwoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdGYgPSB1dGlscy5wYXJzZV90Zih0aGlzLmZvcmNlZF90Zik7XG4gICAgICBpZiAodGhpcy5vaGxjdi5sZW5ndGggPCAyICYmICF0ZikgcmV0dXJuO1xuICAgICAgdGhpcy5pbnRlcnZhbF9tcyA9IHRmIHx8IHV0aWxzLmRldGVjdF9pbnRlcnZhbCh0aGlzLm9obGN2KTtcbiAgICAgIHRoaXMuaW50ZXJ2YWwgPSB0aGlzLiRwcm9wcy5pYiA/IDEgOiB0aGlzLmludGVydmFsX21zO1xuICAgICAgdXRpbHMud2FybihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy4kcHJvcHMuaWIgJiYgIV90aGlzLmNoYXJ0LnRmO1xuICAgICAgfSwgY29uc3RhbnRzLklCX1RGX1dBUk4sIGNvbnN0YW50cy5TRUNPTkQpO1xuICAgIH0sXG4gICAgc2V0X3l0cmFuc2Zvcm06IGZ1bmN0aW9uIHNldF95dHJhbnNmb3JtKHMpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLnlfdHJhbnNmb3Jtc1tzLmdyaWRfaWRdIHx8IHt9O1xuICAgICAgT2JqZWN0LmFzc2lnbihvYmosIHMpO1xuICAgICAgdGhpcy4kc2V0KHRoaXMueV90cmFuc2Zvcm1zLCBzLmdyaWRfaWQsIG9iaik7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQoKTtcbiAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCB0aGlzLnJhbmdlKTtcbiAgICB9LFxuICAgIGRlZmF1bHRfcmFuZ2U6IGZ1bmN0aW9uIGRlZmF1bHRfcmFuZ2UoKSB7XG4gICAgICB2YXIgZGwgPSB0aGlzLiRwcm9wcy5jb25maWcuREVGQVVMVF9MRU47XG4gICAgICB2YXIgbWwgPSB0aGlzLiRwcm9wcy5jb25maWcuTUlOSU1VTV9MRU4gKyAwLjU7XG4gICAgICB2YXIgbCA9IHRoaXMub2hsY3YubGVuZ3RoIC0gMTtcbiAgICAgIGlmICh0aGlzLm9obGN2Lmxlbmd0aCA8IDIpIHJldHVybjtcblxuICAgICAgaWYgKHRoaXMub2hsY3YubGVuZ3RoIDw9IGRsKSB7XG4gICAgICAgIHZhciBzID0gMCxcbiAgICAgICAgICAgIGQgPSBtbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBsIC0gZGwsIGQgPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy4kcHJvcHMuaWIpIHtcbiAgICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIFt0aGlzLm9obGN2W3NdWzBdIC0gdGhpcy5pbnRlcnZhbCAqIGQsIHRoaXMub2hsY3ZbbF1bMF0gKyB0aGlzLmludGVydmFsICogbWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCBbcyAtIHRoaXMuaW50ZXJ2YWwgKiBkLCBsICsgdGhpcy5pbnRlcnZhbCAqIG1sXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdWJzZXQ6IGZ1bmN0aW9uIHN1YnNldChyYW5nZSkge1xuICAgICAgaWYgKHJhbmdlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkZmlsdGVyID0gdGhpcy5maWx0ZXIodGhpcy5vaGxjdiwgcmFuZ2VbMF0gLSB0aGlzLmludGVydmFsLCByYW5nZVsxXSksXG4gICAgICAgICAgX3RoaXMkZmlsdGVyMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGZpbHRlciwgMiksXG4gICAgICAgICAgcmVzID0gX3RoaXMkZmlsdGVyMlswXSxcbiAgICAgICAgICBpbmRleCA9IF90aGlzJGZpbHRlcjJbMV07XG5cbiAgICAgIHRoaXMudGlfbWFwID0gbmV3IFRJKCk7XG5cbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgdGhpcy5zdWJfc3RhcnQgPSBpbmRleDtcbiAgICAgICAgdGhpcy50aV9tYXAuaW5pdCh0aGlzLCByZXMpO1xuICAgICAgICBpZiAoIXRoaXMuJHByb3BzLmliKSByZXR1cm4gcmVzIHx8IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy50aV9tYXAuc3ViX2k7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGNvbW1vbl9wcm9wczogZnVuY3Rpb24gY29tbW9uX3Byb3BzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGl0bGVfdHh0OiB0aGlzLmNoYXJ0Lm5hbWUgfHwgdGhpcy4kcHJvcHMudGl0bGVfdHh0LFxuICAgICAgICBsYXlvdXQ6IHRoaXMuX2xheW91dCxcbiAgICAgICAgc3ViOiB0aGlzLnN1YixcbiAgICAgICAgcmFuZ2U6IHRoaXMucmFuZ2UsXG4gICAgICAgIGludGVydmFsOiB0aGlzLmludGVydmFsLFxuICAgICAgICBjdXJzb3I6IHRoaXMuY3Vyc29yLFxuICAgICAgICBjb2xvcnM6IHRoaXMuJHByb3BzLmNvbG9ycyxcbiAgICAgICAgZm9udDogdGhpcy4kcHJvcHMuZm9udCxcbiAgICAgICAgeV90czogdGhpcy55X3RyYW5zZm9ybXMsXG4gICAgICAgIHR2X2lkOiB0aGlzLiRwcm9wcy50dl9pZCxcbiAgICAgICAgY29uZmlnOiB0aGlzLiRwcm9wcy5jb25maWcsXG4gICAgICAgIGJ1dHRvbnM6IHRoaXMuJHByb3BzLmJ1dHRvbnMsXG4gICAgICAgIG1ldGE6IHRoaXMubWV0YSxcbiAgICAgICAgc2tpbjogdGhpcy4kcHJvcHMuc2tpblxuICAgICAgfTtcbiAgICB9LFxuICAgIG92ZXJsYXlfc3Vic2V0OiBmdW5jdGlvbiBvdmVybGF5X3N1YnNldChzb3VyY2UsIHNpZGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gc291cmNlLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICB2YXIgcmVzID0gdXRpbHMuZmFzdF9maWx0ZXIoZC5kYXRhLCBfdGhpczIudGlfbWFwLmkydF9tb2RlKF90aGlzMi5yYW5nZVswXSAtIF90aGlzMi5pbnRlcnZhbCwgZC5pbmRleFNyYyksIF90aGlzMi50aV9tYXAuaTJ0X21vZGUoX3RoaXMyLnJhbmdlWzFdLCBkLmluZGV4U3JjKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogZC50eXBlLFxuICAgICAgICAgIG5hbWU6IHV0aWxzLmZvcm1hdF9uYW1lKGQpLFxuICAgICAgICAgIGRhdGE6IF90aGlzMi50aV9tYXAucGFyc2UocmVzWzBdIHx8IFtdLCBkLmluZGV4U3JjIHx8ICdtYXAnKSxcbiAgICAgICAgICBzZXR0aW5nczogZC5zZXR0aW5ncyB8fCBfdGhpczIuc2V0dGluZ3Nfb3YsXG4gICAgICAgICAgZ3JpZDogZC5ncmlkIHx8IHt9LFxuICAgICAgICAgIHRmOiB1dGlscy5wYXJzZV90ZihkLnRmKSxcbiAgICAgICAgICBpMDogcmVzWzFdLFxuICAgICAgICAgIGxvYWRpbmc6IGQubG9hZGluZyxcbiAgICAgICAgICBsYXN0OiAoX3RoaXMyLmxhc3RfdmFsdWVzW3NpZGVdIHx8IFtdKVtpXVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZWN0aW9uX3Byb3BzOiBmdW5jdGlvbiBzZWN0aW9uX3Byb3BzKGkpIHtcbiAgICAgIHJldHVybiBpID09PSAwID8gdGhpcy5tYWluX3NlY3Rpb24gOiB0aGlzLnN1Yl9zZWN0aW9uO1xuICAgIH0sXG4gICAgaW5pdF9yYW5nZTogZnVuY3Rpb24gaW5pdF9yYW5nZSgpIHtcbiAgICAgIHRoaXMuY2FsY19pbnRlcnZhbCgpO1xuICAgICAgdGhpcy5kZWZhdWx0X3JhbmdlKCk7XG4gICAgfSxcbiAgICBsYXllcl9tZXRhX3Byb3BzOiBmdW5jdGlvbiBsYXllcl9tZXRhX3Byb3BzKGQpIHtcbiAgICAgIC8vIFRPRE86IGNoZWNrIHJlYWN0aXZpdHkgd2hlbiBsYXlvdXQgaXMgY2hhbmdlZFxuICAgICAgaWYgKCEoZC5ncmlkX2lkIGluIHRoaXMubGF5ZXJzX21ldGEpKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmxheWVyc19tZXRhLCBkLmdyaWRfaWQsIHt9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kc2V0KHRoaXMubGF5ZXJzX21ldGFbZC5ncmlkX2lkXSwgZC5sYXllcl9pZCwgZCk7IC8vIFJlcmVuZGVyXG5cbiAgICAgIHRoaXMudXBkYXRlX2xheW91dCgpO1xuICAgIH0sXG4gICAgcmVtb3ZlX21ldGFfcHJvcHM6IGZ1bmN0aW9uIHJlbW92ZV9tZXRhX3Byb3BzKGdyaWRfaWQsIGxheWVyX2lkKSB7XG4gICAgICBpZiAoZ3JpZF9pZCBpbiB0aGlzLmxheWVyc19tZXRhKSB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxheWVyc19tZXRhW2dyaWRfaWRdLCBsYXllcl9pZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0X2N1c3RvbV9ldmVudDogZnVuY3Rpb24gZW1pdF9jdXN0b21fZXZlbnQoZCkge1xuICAgICAgdGhpcy5vbl9zaGFkZXJfZXZlbnQoZCwgJ2JvdGJhcicpO1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50JywgZCk7XG5cbiAgICAgIGlmIChkLmV2ZW50ID09PSAncmVtb3ZlLWxheWVyLW1ldGEnKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlX21ldGFfcHJvcHMuYXBwbHkodGhpcywgX3RvQ29uc3VtYWJsZUFycmF5KGQuYXJncykpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlX2xheW91dDogZnVuY3Rpb24gdXBkYXRlX2xheW91dChjbGFjX3RmKSB7XG4gICAgICBpZiAoY2xhY190ZikgdGhpcy5jYWxjX2ludGVydmFsKCk7XG4gICAgICB2YXIgbGF5ID0gbmV3IGxheW91dCh0aGlzKTtcbiAgICAgIHV0aWxzLmNvcHlfbGF5b3V0KHRoaXMuX2xheW91dCwgbGF5KTtcbiAgICAgIGlmICh0aGlzLl9ob29rX3VwZGF0ZSkgdGhpcy5jZSgnP2NoYXJ0LXVwZGF0ZScsIGxheSk7XG4gICAgfSxcbiAgICBsZWdlbmRfYnV0dG9uX2NsaWNrOiBmdW5jdGlvbiBsZWdlbmRfYnV0dG9uX2NsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdsZWdlbmQtYnV0dG9uLWNsaWNrJywgZXZlbnQpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJfa2I6IGZ1bmN0aW9uIHJlZ2lzdGVyX2tiKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuJHJlZnMua2V5Ym9hcmQpIHJldHVybjtcbiAgICAgIHRoaXMuJHJlZnMua2V5Ym9hcmQucmVnaXN0ZXIoZXZlbnQpO1xuICAgIH0sXG4gICAgcmVtb3ZlX2tiOiBmdW5jdGlvbiByZW1vdmVfa2IoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy4kcmVmcy5rZXlib2FyZCkgcmV0dXJuO1xuICAgICAgdGhpcy4kcmVmcy5rZXlib2FyZC5yZW1vdmUoZXZlbnQpO1xuICAgIH0sXG4gICAgdXBkYXRlX2xhc3RfdmFsdWVzOiBmdW5jdGlvbiB1cGRhdGVfbGFzdF92YWx1ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5sYXN0X2NhbmRsZSA9IHRoaXMub2hsY3YgPyB0aGlzLm9obGN2W3RoaXMub2hsY3YubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RfdmFsdWVzID0ge1xuICAgICAgICBvbmNoYXJ0OiBbXSxcbiAgICAgICAgb2ZmY2hhcnQ6IFtdXG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNoYXJ0LmZvckVhY2goZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgdmFyIGQgPSB4LmRhdGEgfHwgW107XG4gICAgICAgIF90aGlzMy5sYXN0X3ZhbHVlcy5vbmNoYXJ0W2ldID0gZFtkLmxlbmd0aCAtIDFdO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9mZmNoYXJ0LmZvckVhY2goZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgdmFyIGQgPSB4LmRhdGEgfHwgW107XG4gICAgICAgIF90aGlzMy5sYXN0X3ZhbHVlcy5vZmZjaGFydFtpXSA9IGRbZC5sZW5ndGggLSAxXTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gSG9vayBldmVudHMgZm9yIGV4dGVuc2lvbnNcbiAgICBjZTogZnVuY3Rpb24gY2UoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdF9jdXN0b21fZXZlbnQoe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gU2V0IGhvb2tzIGxpc3QgKGNhbGxlZCBmcm9tIGFuIGV4dGVuc2lvbilcbiAgICBob29rczogZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBsaXN0ID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGxpc3RbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBfdGhpczRbXCJfaG9va19cIi5jb25jYXQoeCldID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAvLyBDb21wb25lbnQtc3BlY2lmaWMgcHJvcHMgc3Vic2V0czpcbiAgICBtYWluX3NlY3Rpb246IGZ1bmN0aW9uIG1haW5fc2VjdGlvbigpIHtcbiAgICAgIHZhciBwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21tb25fcHJvcHMoKSk7XG4gICAgICBwLmRhdGEgPSB0aGlzLm92ZXJsYXlfc3Vic2V0KHRoaXMub25jaGFydCwgJ29uY2hhcnQnKTtcbiAgICAgIHAuZGF0YS5wdXNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5jaGFydC50eXBlIHx8ICdDYW5kbGVzJyxcbiAgICAgICAgbWFpbjogdHJ1ZSxcbiAgICAgICAgZGF0YTogdGhpcy5zdWIsXG4gICAgICAgIGkwOiB0aGlzLnN1Yl9zdGFydCxcbiAgICAgICAgc2V0dGluZ3M6IHRoaXMuY2hhcnQuc2V0dGluZ3MgfHwgdGhpcy5zZXR0aW5nc19vaGxjdixcbiAgICAgICAgZ3JpZDogdGhpcy5jaGFydC5ncmlkIHx8IHt9LFxuICAgICAgICBsYXN0OiB0aGlzLmxhc3RfY2FuZGxlXG4gICAgICB9KTtcbiAgICAgIHAub3ZlcmxheXMgPSB0aGlzLiRwcm9wcy5vdmVybGF5cztcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgc3ViX3NlY3Rpb246IGZ1bmN0aW9uIHN1Yl9zZWN0aW9uKCkge1xuICAgICAgdmFyIHAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbW1vbl9wcm9wcygpKTtcbiAgICAgIHAuZGF0YSA9IHRoaXMub3ZlcmxheV9zdWJzZXQodGhpcy5vZmZjaGFydCwgJ29mZmNoYXJ0Jyk7XG4gICAgICBwLm92ZXJsYXlzID0gdGhpcy4kcHJvcHMub3ZlcmxheXM7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIGJvdGJhcl9wcm9wczogZnVuY3Rpb24gYm90YmFyX3Byb3BzKCkge1xuICAgICAgdmFyIHAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbW1vbl9wcm9wcygpKTtcbiAgICAgIHAud2lkdGggPSBwLmxheW91dC5ib3RiYXIud2lkdGg7XG4gICAgICBwLmhlaWdodCA9IHAubGF5b3V0LmJvdGJhci5oZWlnaHQ7XG4gICAgICBwLnJlcmVuZGVyID0gdGhpcy5yZXJlbmRlcjtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgb2Zmc3ViOiBmdW5jdGlvbiBvZmZzdWIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdmVybGF5X3N1YnNldCh0aGlzLm9mZmNoYXJ0LCAnb2ZmY2hhcnQnKTtcbiAgICB9LFxuICAgIC8vIERhdGFzZXRzOiBjYW5kbGVzLCBvbmNoYXJ0LCBvZmZjaGFydCBpbmRpY2F0b3JzXG4gICAgb2hsY3Y6IGZ1bmN0aW9uIG9obGN2KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmRhdGEub2hsY3YgfHwgdGhpcy5jaGFydC5kYXRhIHx8IFtdO1xuICAgIH0sXG4gICAgY2hhcnQ6IGZ1bmN0aW9uIGNoYXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmRhdGEuY2hhcnQgfHwge1xuICAgICAgICBncmlkOiB7fVxuICAgICAgfTtcbiAgICB9LFxuICAgIG9uY2hhcnQ6IGZ1bmN0aW9uIG9uY2hhcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuZGF0YS5vbmNoYXJ0IHx8IFtdO1xuICAgIH0sXG4gICAgb2ZmY2hhcnQ6IGZ1bmN0aW9uIG9mZmNoYXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmRhdGEub2ZmY2hhcnQgfHwgW107XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5pYiA/IHV0aWxzLmZhc3RfZmlsdGVyX2kgOiB1dGlscy5mYXN0X2ZpbHRlcjtcbiAgICB9LFxuICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLiRwcm9wcy50b29sYmFyID8gdGhpcy4kcHJvcHMuY29uZmlnLlRPT0xCQVIgOiAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21hcmdpbi1sZWZ0JzogXCJcIi5jb25jYXQodywgXCJweFwiKVxuICAgICAgfTtcbiAgICB9LFxuICAgIG1ldGE6IGZ1bmN0aW9uIG1ldGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXN0OiB0aGlzLmxhc3RfY2FuZGxlLFxuICAgICAgICBzdWJfc3RhcnQ6IHRoaXMuc3ViX3N0YXJ0LFxuICAgICAgICBhY3RpdmF0ZWQ6IHRoaXMuYWN0aXZhdGVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgZm9yY2VkX3RmOiBmdW5jdGlvbiBmb3JjZWRfdGYoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFydC50ZjtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIEN1cnJlbnQgZGF0YSBzbGljZVxuICAgICAgc3ViOiBbXSxcbiAgICAgIC8vIFRpbWUgcmFuZ2VcbiAgICAgIHJhbmdlOiBbXSxcbiAgICAgIC8vIENhbmRsZXN0aWNrIGludGVydmFsXG4gICAgICBpbnRlcnZhbDogMCxcbiAgICAgIC8vIENyb3NzaGFpciBzdGF0ZXNcbiAgICAgIGN1cnNvcjoge1xuICAgICAgICB4OiBudWxsLFxuICAgICAgICB5OiBudWxsLFxuICAgICAgICB0OiBudWxsLFxuICAgICAgICB5JDogbnVsbCxcbiAgICAgICAgZ3JpZF9pZDogbnVsbCxcbiAgICAgICAgbG9ja2VkOiBmYWxzZSxcbiAgICAgICAgdmFsdWVzOiB7fSxcbiAgICAgICAgc2Nyb2xsX2xvY2s6IGZhbHNlLFxuICAgICAgICBtb2RlOiB1dGlscy54bW9kZSgpXG4gICAgICB9LFxuICAgICAgLy8gQSB0cmljayB0byByZS1yZW5kZXIgYm90YmFyXG4gICAgICByZXJlbmRlcjogMCxcbiAgICAgIC8vIExheWVycyBtZXRhLXByb3BzIChjaGFuZ2luZyBiZWhhdmlvdXIpXG4gICAgICBsYXllcnNfbWV0YToge30sXG4gICAgICAvLyBZLXRyYW5zZm9ybXMgKGZvciB5LXpvb20gYW5kIC1zaGlmdClcbiAgICAgIHlfdHJhbnNmb3Jtczoge30sXG4gICAgICAvLyBEZWZhdWx0IE9ITENWIHNldHRpbmdzICh3aGVuIHVzaW5nIERhdGFTdHJ1Y3R1cmUgdjEuMClcbiAgICAgIHNldHRpbmdzX29obGN2OiB7fSxcbiAgICAgIC8vIERlZmF1bHQgb3ZlcmxheSBzZXR0aW5nc1xuICAgICAgc2V0dGluZ3Nfb3Y6IHt9LFxuICAgICAgLy8gTWV0YSBkYXRhXG4gICAgICBsYXN0X2NhbmRsZTogW10sXG4gICAgICBsYXN0X3ZhbHVlczoge30sXG4gICAgICBzdWJfc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgIGFjdGl2YXRlZDogZmFsc2VcbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aCgpIHtcbiAgICAgIHRoaXMudXBkYXRlX2xheW91dCgpO1xuICAgICAgaWYgKHRoaXMuX2hvb2tfcmVzaXplKSB0aGlzLmNlKCc/Y2hhcnQtcmVzaXplJyk7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICAgIHRoaXMudXBkYXRlX2xheW91dCgpO1xuICAgICAgaWYgKHRoaXMuX2hvb2tfcmVzaXplKSB0aGlzLmNlKCc/Y2hhcnQtcmVzaXplJyk7XG4gICAgfSxcbiAgICBpYjogZnVuY3Rpb24gaWIobncpIHtcbiAgICAgIGlmICghbncpIHtcbiAgICAgICAgLy8gQ2hhbmdlIHJhbmdlIGluZGV4ID0+IHRpbWVcbiAgICAgICAgdmFyIHQxID0gdGhpcy50aV9tYXAuaTJ0KHRoaXMucmFuZ2VbMF0pO1xuICAgICAgICB2YXIgdDIgPSB0aGlzLnRpX21hcC5pMnQodGhpcy5yYW5nZVsxXSk7XG4gICAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCBbdDEsIHQyXSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsX21zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbml0X3JhbmdlKCk7IC8vIFRPRE86IGNhbGMgaW5kZXggcmFuZ2UgaW5zdGVhZFxuXG4gICAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCB0aGlzLnJhbmdlKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWIgPSB0aGlzLnN1YnNldCgpO1xuICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMuc3ViLCBzdWIpO1xuICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KCk7XG4gICAgfSxcbiAgICB0aW1lem9uZTogZnVuY3Rpb24gdGltZXpvbmUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQoKTtcbiAgICB9LFxuICAgIGNvbG9yczogZnVuY3Rpb24gY29sb3JzKCkge1xuICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIHRoaXMucmFuZ2UpO1xuICAgIH0sXG4gICAgZm9yY2VkX3RmOiBmdW5jdGlvbiBmb3JjZWRfdGYobiwgcCkge1xuICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KHRydWUpO1xuICAgICAgdGhpcy5jZSgnZXhlYy1hbGwtc2NyaXB0cycpO1xuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihuLCBwKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWIubGVuZ3RoKSB0aGlzLmluaXRfcmFuZ2UoKTtcbiAgICAgICAgdmFyIHN1YiA9IHRoaXMuc3Vic2V0KCk7IC8vIEZpeGVzIEluZmluaXRlIGxvb3Agd2Fybiwgd2hlbiB0aGUgc3Vic2V0IGlzIGVtcHR5XG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIHJlbW92aW5nICdzdWInIGZyb20gZGF0YSBlbnRpcmVseVxuXG4gICAgICAgIGlmICh0aGlzLnN1Yi5sZW5ndGggfHwgc3ViLmxlbmd0aCkge1xuICAgICAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnN1Yiwgc3ViKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudyA9IHRoaXMuZGF0YV9jaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMudXBkYXRlX2xheW91dChudyk7XG4gICAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCB0aGlzLnJhbmdlKTtcbiAgICAgICAgdGhpcy5jdXJzb3Iuc2Nyb2xsX2xvY2sgPSAhIW4uc2Nyb2xsTG9jaztcblxuICAgICAgICBpZiAobi5zY3JvbGxMb2NrICYmIHRoaXMuY3Vyc29yLmxvY2tlZCkge1xuICAgICAgICAgIHRoaXMuY3Vyc29yLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hvb2tfZGF0YSkgdGhpcy5jZSgnP2NoYXJ0LWRhdGEnLCBudyk7XG4gICAgICAgIHRoaXMudXBkYXRlX2xhc3RfdmFsdWVzKCk7IC8vIFRPRE86IHVwZGF0ZSBsZWdlbmQgdmFsdWVzIGZvciBvdmVyYWx5c1xuXG4gICAgICAgIHRoaXMucmVyZW5kZXIrKztcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NoYXJ0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfQ2hhcnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ2hhcnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NoYXJ0LnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBDaGFydF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfQ2hhcnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIENoYXJ0dnVlX3R5cGVfdGVtcGxhdGVfaWRfNGQwNmE0ZGVfcmVuZGVyLFxuICBDaGFydHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRkMDZhNGRlX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQ2hhcnRfYXBpOyB9XG5DaGFydF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0NoYXJ0LnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENoYXJ0ID0gKENoYXJ0X2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTAyMTg4N2ZiJlxudmFyIFRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wMjE4ODdmYl9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBrZXk6IF92bS50b29sX2NvdW50LFxuICAgICAgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtdG9vbGJhclwiLFxuICAgICAgc3R5bGU6IF92bS5zdHlsZXNcbiAgICB9LFxuICAgIF92bS5fbChfdm0uZ3JvdXBzLCBmdW5jdGlvbih0b29sLCBpKSB7XG4gICAgICByZXR1cm4gdG9vbC5pY29uICYmICF0b29sLmhpZGRlblxuICAgICAgICA/IF9jKFwidG9vbGJhci1pdGVtXCIsIHtcbiAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGRhdGE6IHRvb2wsXG4gICAgICAgICAgICAgIHN1YnM6IF92bS5zdWJfbWFwLFxuICAgICAgICAgICAgICBkYzogX3ZtLmRhdGEsXG4gICAgICAgICAgICAgIGNvbmZpZzogX3ZtLmNvbmZpZyxcbiAgICAgICAgICAgICAgY29sb3JzOiBfdm0uY29sb3JzLFxuICAgICAgICAgICAgICBzZWxlY3RlZDogX3ZtLmlzX3NlbGVjdGVkKHRvb2wpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHsgXCJpdGVtLXNlbGVjdGVkXCI6IF92bS5zZWxlY3RlZCB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfdm0uX2UoKVxuICAgIH0pLFxuICAgIDFcbiAgKVxufVxudmFyIFRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wMjE4ODdmYl9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuVG9vbGJhcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzAyMTg4N2ZiX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTAyMTg4N2ZiJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Ub29sYmFySXRlbS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjI3YjNjMmUmXG52YXIgVG9vbGJhckl0ZW12dWVfdHlwZV90ZW1wbGF0ZV9pZF8yMjdiM2MyZV9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBjbGFzczogW1widHJhZGluZy12dWUtdGJpdGVtXCIsIF92bS5zZWxlY3RlZCA/IFwic2VsZWN0ZWQtaXRlbVwiIDogXCJcIl0sXG4gICAgICBzdHlsZTogX3ZtLml0ZW1fc3R5bGUsXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF92bS5lbWl0X3NlbGVjdGVkKFwiY2xpY2tcIilcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vkb3duOiBfdm0ubW91c2Vkb3duLFxuICAgICAgICB0b3VjaHN0YXJ0OiBfdm0ubW91c2Vkb3duLFxuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF92bS5lbWl0X3NlbGVjdGVkKFwidG91Y2hcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX2MoXCJkaXZcIiwge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS10Ymljb24gdHZqcy1waXhlbGF0ZWRcIixcbiAgICAgICAgc3R5bGU6IF92bS5pY29uX3N0eWxlXG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uZGF0YS5ncm91cFxuICAgICAgICA/IF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtdGJpdGVtLWV4cFwiLFxuICAgICAgICAgICAgICBzdHlsZTogX3ZtLmV4cF9zdHlsZSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogX3ZtLmV4cF9jbGljayxcbiAgICAgICAgICAgICAgICBtb3VzZWRvd246IF92bS5leHBtb3VzZWRvd24sXG4gICAgICAgICAgICAgICAgbW91c2VvdmVyOiBfdm0uZXhwbW91c2VvdmVyLFxuICAgICAgICAgICAgICAgIG1vdXNlbGVhdmU6IF92bS5leHBtb3VzZWxlYXZlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl92KFwiXFxuICAgICAgICDhkLNcXG4gICAgXCIpXVxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uc2hvd19leHBfbGlzdFxuICAgICAgICA/IF9jKFwiaXRlbS1saXN0XCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGNvbmZpZzogX3ZtLmNvbmZpZyxcbiAgICAgICAgICAgICAgaXRlbXM6IF92bS5kYXRhLml0ZW1zLFxuICAgICAgICAgICAgICBjb2xvcnM6IF92bS5jb2xvcnMsXG4gICAgICAgICAgICAgIGRjOiBfdm0uZGNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBcImNsb3NlLWxpc3RcIjogX3ZtLmNsb3NlX2xpc3QsXG4gICAgICAgICAgICAgIFwiaXRlbS1zZWxlY3RlZFwiOiBfdm0uZW1pdF9zZWxlY3RlZF9zdWJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBUb29sYmFySXRlbXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzIyN2IzYzJlX3N0YXRpY1JlbmRlckZucyA9IFtdXG5Ub29sYmFySXRlbXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzIyN2IzYzJlX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXJJdGVtLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yMjdiM2MyZSZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvSXRlbUxpc3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWM1MGIyM2ZlJlxudmFyIEl0ZW1MaXN0dnVlX3R5cGVfdGVtcGxhdGVfaWRfYzUwYjIzZmVfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwidHZqcy1pdGVtLWxpc3RcIixcbiAgICAgIHN0eWxlOiBfdm0ubGlzdF9zdHlsZSgpLFxuICAgICAgb246IHsgbW91c2Vkb3duOiBfdm0udGhpc21vdXNlZG93biB9XG4gICAgfSxcbiAgICBfdm0uX2woX3ZtLml0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gIWl0ZW0uaGlkZGVuXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzczogX3ZtLml0ZW1fY2xhc3MoaXRlbSksXG4gICAgICAgICAgICAgIHN0eWxlOiBfdm0uaXRlbV9zdHlsZShpdGVtKSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5pdGVtX2NsaWNrKGUsIGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtdGJpY29uIHR2anMtcGl4ZWxhdGVkXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IF92bS5pY29uX3N0eWxlKGl0ZW0pXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcImRpdlwiLCBbX3ZtLl92KF92bS5fcyhpdGVtLnR5cGUpKV0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgfSksXG4gICAgMFxuICApXG59XG52YXIgSXRlbUxpc3R2dWVfdHlwZV90ZW1wbGF0ZV9pZF9jNTBiMjNmZV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuSXRlbUxpc3R2dWVfdHlwZV90ZW1wbGF0ZV9pZF9jNTBiMjNmZV9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9JdGVtTGlzdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YzUwYjIzZmUmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9JdGVtTGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEl0ZW1MaXN0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0l0ZW1MaXN0JyxcbiAgcHJvcHM6IFsnY29uZmlnJywgJ2l0ZW1zJywgJ2NvbG9ycycsICdkYyddLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9ubW91c2Vkb3duKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbm1vdXNlZG93bik7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsaXN0X3N0eWxlOiBmdW5jdGlvbiBsaXN0X3N0eWxlKCkge1xuICAgICAgdmFyIGNvbmYgPSB0aGlzLiRwcm9wcy5jb25maWc7XG4gICAgICB2YXIgdyA9IGNvbmYuVE9PTEJBUjtcbiAgICAgIHZhciBicmQgPSB0aGlzLmNvbG9ycy50Ykxpc3RCb3JkZXIgfHwgdGhpcy5jb2xvcnMuZ3JpZDtcbiAgICAgIHZhciBic3RsID0gXCIxcHggc29saWQgXCIuY29uY2F0KGJyZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdCh3LCBcInB4XCIpLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLmNvbG9ycy5iYWNrLFxuICAgICAgICBib3JkZXJUb3A6IGJzdGwsXG4gICAgICAgIGJvcmRlclJpZ2h0OiBic3RsLFxuICAgICAgICBib3JkZXJCb3R0b206IGJzdGxcbiAgICAgIH07XG4gICAgfSxcbiAgICBpdGVtX2NsYXNzOiBmdW5jdGlvbiBpdGVtX2NsYXNzKGl0ZW0pIHtcbiAgICAgIGlmICh0aGlzLmRjLnRvb2wgPT09IGl0ZW0udHlwZSkge1xuICAgICAgICByZXR1cm4gXCJ0dmpzLWl0ZW0tbGlzdC1pdGVtIHNlbGVjdGVkLWl0ZW1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwidHZqcy1pdGVtLWxpc3QtaXRlbVwiO1xuICAgIH0sXG4gICAgaXRlbV9zdHlsZTogZnVuY3Rpb24gaXRlbV9zdHlsZShpdGVtKSB7XG4gICAgICB2YXIgY29uZiA9IHRoaXMuJHByb3BzLmNvbmZpZztcbiAgICAgIHZhciBoID0gY29uZi5UQl9JQ09OICsgY29uZi5UQl9JVEVNX00gKiAyICsgODtcbiAgICAgIHZhciBzZWwgPSB0aGlzLmRjLnRvb2wgPT09IGl0ZW0udHlwZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaCwgXCJweFwiKSxcbiAgICAgICAgY29sb3I6IHNlbCA/IHVuZGVmaW5lZCA6IFwiIzg4ODg4OFwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgaWNvbl9zdHlsZTogZnVuY3Rpb24gaWNvbl9zdHlsZShkYXRhKSB7XG4gICAgICB2YXIgY29uZiA9IHRoaXMuJHByb3BzLmNvbmZpZztcbiAgICAgIHZhciBiciA9IGNvbmYuVEJfSUNPTl9CUkk7XG4gICAgICB2YXIgaW0gPSBjb25mLlRCX0lURU1fTTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogXCJ1cmwoXCIuY29uY2F0KGRhdGEuaWNvbiwgXCIpXCIpLFxuICAgICAgICAnd2lkdGgnOiAnMjVweCcsXG4gICAgICAgICdoZWlnaHQnOiAnMjVweCcsXG4gICAgICAgICdtYXJnaW4nOiBcIlwiLmNvbmNhdChpbSwgXCJweFwiKSxcbiAgICAgICAgJ2ZpbHRlcic6IFwiYnJpZ2h0bmVzcyhcIi5jb25jYXQoYnIsIFwiKVwiKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGl0ZW1fY2xpY2s6IGZ1bmN0aW9uIGl0ZW1fY2xpY2soZSwgaXRlbSkge1xuICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgdGhpcy4kZW1pdCgnaXRlbS1zZWxlY3RlZCcsIGl0ZW0pO1xuICAgICAgdGhpcy4kZW1pdCgnY2xvc2UtbGlzdCcpO1xuICAgIH0sXG4gICAgb25tb3VzZWRvd246IGZ1bmN0aW9uIG9ubW91c2Vkb3duKCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xvc2UtbGlzdCcpO1xuICAgIH0sXG4gICAgdGhpc21vdXNlZG93bjogZnVuY3Rpb24gdGhpc21vdXNlZG93bihlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHt9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9JdGVtTGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0l0ZW1MaXN0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEl0ZW1MaXN0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvSXRlbUxpc3QudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgSXRlbUxpc3R2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oODA3KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0l0ZW1MaXN0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9JdGVtTGlzdC52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBJdGVtTGlzdF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfSXRlbUxpc3R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEl0ZW1MaXN0dnVlX3R5cGVfdGVtcGxhdGVfaWRfYzUwYjIzZmVfcmVuZGVyLFxuICBJdGVtTGlzdHZ1ZV90eXBlX3RlbXBsYXRlX2lkX2M1MGIyM2ZlX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgSXRlbUxpc3RfYXBpOyB9XG5JdGVtTGlzdF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0l0ZW1MaXN0LnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEl0ZW1MaXN0ID0gKEl0ZW1MaXN0X2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Ub29sYmFySXRlbS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRvb2xiYXJJdGVtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1Rvb2xiYXJJdGVtJyxcbiAgcHJvcHM6IFsnZGF0YScsICdzZWxlY3RlZCcsICdjb2xvcnMnLCAndHZfaWQnLCAnY29uZmlnJywgJ2RjJywgJ3N1YnMnXSxcbiAgY29tcG9uZW50czoge1xuICAgIEl0ZW1MaXN0OiBJdGVtTGlzdFxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIGlmICh0aGlzLmRhdGEuZ3JvdXApIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5zdWJzW3RoaXMuZGF0YS5ncm91cF07XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuZGF0YS5pdGVtcy5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnR5cGUgPT09IHR5cGU7XG4gICAgICB9KTtcbiAgICAgIGlmIChpdGVtKSB0aGlzLnN1Yl9pdGVtID0gaXRlbTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNsaWNrX3N0YXJ0ID0gdXRpbHMubm93KCk7XG4gICAgICB0aGlzLmNsaWNrX2lkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnNob3dfZXhwX2xpc3QgPSB0cnVlO1xuICAgICAgfSwgdGhpcy5jb25maWcuVEJfSUNPTl9IT0xEKTtcbiAgICB9LFxuICAgIGV4cG1vdXNlb3ZlcjogZnVuY3Rpb24gZXhwbW91c2VvdmVyKCkge1xuICAgICAgdGhpcy5leHBfaG92ZXIgPSB0cnVlO1xuICAgIH0sXG4gICAgZXhwbW91c2VsZWF2ZTogZnVuY3Rpb24gZXhwbW91c2VsZWF2ZSgpIHtcbiAgICAgIHRoaXMuZXhwX2hvdmVyID0gZmFsc2U7XG4gICAgfSxcbiAgICBleHBtb3VzZWRvd246IGZ1bmN0aW9uIGV4cG1vdXNlZG93bihlKSB7XG4gICAgICBpZiAodGhpcy5zaG93X2V4cF9saXN0KSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG4gICAgZW1pdF9zZWxlY3RlZDogZnVuY3Rpb24gZW1pdF9zZWxlY3RlZChzcmMpIHtcbiAgICAgIGlmICh1dGlscy5ub3coKSAtIHRoaXMuY2xpY2tfc3RhcnQgPiB0aGlzLmNvbmZpZy5UQl9JQ09OX0hPTEQpIHJldHVybjtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrX2lkKTsgLy9pZiAoVXRpbHMuaXNfbW9iaWxlICYmIHNyYyA9PT0gJ2NsaWNrJykgcmV0dXJuXG4gICAgICAvLyBUT0RPOiBkb3VibGUgZmlyaW5nXG5cbiAgICAgIGlmICghdGhpcy5kYXRhLmdyb3VwKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2l0ZW0tc2VsZWN0ZWQnLCB0aGlzLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnN1Yl9pdGVtIHx8IHRoaXMuZGF0YS5pdGVtc1swXTtcbiAgICAgICAgdGhpcy4kZW1pdCgnaXRlbS1zZWxlY3RlZCcsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdF9zZWxlY3RlZF9zdWI6IGZ1bmN0aW9uIGVtaXRfc2VsZWN0ZWRfc3ViKGl0ZW0pIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2l0ZW0tc2VsZWN0ZWQnLCBpdGVtKTtcbiAgICAgIHRoaXMuc3ViX2l0ZW0gPSBpdGVtO1xuICAgIH0sXG4gICAgZXhwX2NsaWNrOiBmdW5jdGlvbiBleHBfY2xpY2soZSkge1xuICAgICAgaWYgKCF0aGlzLmRhdGEuZ3JvdXApIHJldHVybjtcbiAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2hvd19leHBfbGlzdCA9ICF0aGlzLnNob3dfZXhwX2xpc3Q7XG4gICAgfSxcbiAgICBjbG9zZV9saXN0OiBmdW5jdGlvbiBjbG9zZV9saXN0KCkge1xuICAgICAgdGhpcy5zaG93X2V4cF9saXN0ID0gZmFsc2U7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1fc3R5bGU6IGZ1bmN0aW9uIGl0ZW1fc3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy4kcHJvcHMuZGF0YS50eXBlID09PSAnU3lzdGVtOlNwbGl0dGVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdHRlcjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbmYgPSB0aGlzLiRwcm9wcy5jb25maWc7XG4gICAgICB2YXIgaW0gPSBjb25mLlRCX0lURU1fTTtcbiAgICAgIHZhciBtID0gKGNvbmYuVE9PTEJBUiAtIGNvbmYuVEJfSUNPTikgKiAwLjUgLSBpbTtcbiAgICAgIHZhciBzID0gY29uZi5UQl9JQ09OICsgaW0gKiAyO1xuICAgICAgdmFyIGIgPSB0aGlzLmV4cF9ob3ZlciA/IDAgOiAzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3dpZHRoJzogXCJcIi5jb25jYXQocywgXCJweFwiKSxcbiAgICAgICAgJ2hlaWdodCc6IFwiXCIuY29uY2F0KHMsIFwicHhcIiksXG4gICAgICAgICdtYXJnaW4nOiBcIjhweCBcIi5jb25jYXQobSwgXCJweCAwcHggXCIpLmNvbmNhdChtLCBcInB4XCIpLFxuICAgICAgICAnYm9yZGVyLXJhZGl1cyc6IFwiM3B4IFwiLmNvbmNhdChiLCBcInB4IFwiKS5jb25jYXQoYiwgXCJweCAzcHhcIilcbiAgICAgIH07XG4gICAgfSxcbiAgICBpY29uX3N0eWxlOiBmdW5jdGlvbiBpY29uX3N0eWxlKCkge1xuICAgICAgaWYgKHRoaXMuJHByb3BzLmRhdGEudHlwZSA9PT0gJ1N5c3RlbTpTcGxpdHRlcicpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgY29uZiA9IHRoaXMuJHByb3BzLmNvbmZpZztcbiAgICAgIHZhciBiciA9IGNvbmYuVEJfSUNPTl9CUkk7XG4gICAgICB2YXIgc3ogPSBjb25mLlRCX0lDT047XG4gICAgICB2YXIgaW0gPSBjb25mLlRCX0lURU1fTTtcbiAgICAgIHZhciBpYyA9IHRoaXMuc3ViX2l0ZW0gPyB0aGlzLnN1Yl9pdGVtLmljb24gOiB0aGlzLiRwcm9wcy5kYXRhLmljb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IFwidXJsKFwiLmNvbmNhdChpYywgXCIpXCIpLFxuICAgICAgICAnd2lkdGgnOiBcIlwiLmNvbmNhdChzeiwgXCJweFwiKSxcbiAgICAgICAgJ2hlaWdodCc6IFwiXCIuY29uY2F0KHN6LCBcInB4XCIpLFxuICAgICAgICAnbWFyZ2luJzogXCJcIi5jb25jYXQoaW0sIFwicHhcIiksXG4gICAgICAgICdmaWx0ZXInOiBcImJyaWdodG5lc3MoXCIuY29uY2F0KGJyLCBcIilcIilcbiAgICAgIH07XG4gICAgfSxcbiAgICBleHBfc3R5bGU6IGZ1bmN0aW9uIGV4cF9zdHlsZSgpIHtcbiAgICAgIHZhciBjb25mID0gdGhpcy4kcHJvcHMuY29uZmlnO1xuICAgICAgdmFyIGltID0gY29uZi5UQl9JVEVNX007XG4gICAgICB2YXIgcyA9IGNvbmYuVEJfSUNPTiAqIDAuNSArIGltO1xuICAgICAgdmFyIHAgPSAoY29uZi5UT09MQkFSIC0gcyAqIDIpIC8gNDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZGRpbmc6IFwiXCIuY29uY2F0KHMsIFwicHggXCIpLmNvbmNhdChwLCBcInB4XCIpLFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMuc2hvd19leHBfbGlzdCA/IFwic2NhbGUoLTAuNiwgMSlcIiA6IFwic2NhbGVYKDAuNilcIlxuICAgICAgfTtcbiAgICB9LFxuICAgIHNwbGl0dGVyOiBmdW5jdGlvbiBzcGxpdHRlcigpIHtcbiAgICAgIHZhciBjb25mID0gdGhpcy4kcHJvcHMuY29uZmlnO1xuICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuJHByb3BzLmNvbG9ycztcbiAgICAgIHZhciBjID0gY29sb3JzLmdyaWQ7XG4gICAgICB2YXIgaW0gPSBjb25mLlRCX0lURU1fTTtcbiAgICAgIHZhciBtID0gKGNvbmYuVE9PTEJBUiAtIGNvbmYuVEJfSUNPTikgKiAwLjUgLSBpbTtcbiAgICAgIHZhciBzID0gY29uZi5UQl9JQ09OICsgaW0gKiAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3dpZHRoJzogXCJcIi5jb25jYXQocywgXCJweFwiKSxcbiAgICAgICAgJ2hlaWdodCc6ICcxcHgnLFxuICAgICAgICAnbWFyZ2luJzogXCI4cHggXCIuY29uY2F0KG0sIFwicHggOHB4IFwiKS5jb25jYXQobSwgXCJweFwiKSxcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBjXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwX2hvdmVyOiBmYWxzZSxcbiAgICAgIHNob3dfZXhwX2xpc3Q6IGZhbHNlLFxuICAgICAgc3ViX2l0ZW06IG51bGxcbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXJJdGVtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfVG9vbGJhckl0ZW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVG9vbGJhckl0ZW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Ub29sYmFySXRlbS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBUb29sYmFySXRlbXZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDEpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVG9vbGJhckl0ZW0udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXJJdGVtLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFRvb2xiYXJJdGVtX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19Ub29sYmFySXRlbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVG9vbGJhckl0ZW12dWVfdHlwZV90ZW1wbGF0ZV9pZF8yMjdiM2MyZV9yZW5kZXIsXG4gIFRvb2xiYXJJdGVtdnVlX3R5cGVfdGVtcGxhdGVfaWRfMjI3YjNjMmVfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBUb29sYmFySXRlbV9hcGk7IH1cblRvb2xiYXJJdGVtX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvVG9vbGJhckl0ZW0udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVG9vbGJhckl0ZW0gPSAoVG9vbGJhckl0ZW1fY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVG9vbGJhcicsXG4gIHByb3BzOiBbJ2RhdGEnLCAnaGVpZ2h0JywgJ2NvbG9ycycsICd0dl9pZCcsICdjb25maWcnXSxcbiAgY29tcG9uZW50czoge1xuICAgIFRvb2xiYXJJdGVtOiBUb29sYmFySXRlbVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge30sXG4gIG1ldGhvZHM6IHtcbiAgICBzZWxlY3RlZDogZnVuY3Rpb24gc2VsZWN0ZWQodG9vbCkge1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogJ3Rvb2wtc2VsZWN0ZWQnLFxuICAgICAgICBhcmdzOiBbdG9vbC50eXBlXVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0b29sLmdyb3VwKSB7XG4gICAgICAgIC8vIFRPRE86IGVtaXQgdGhlIHN1YiBtYXAgdG8gREMgKHNhdmUpXG4gICAgICAgIHRoaXMuc3ViX21hcFt0b29sLmdyb3VwXSA9IHRvb2wudHlwZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzX3NlbGVjdGVkOiBmdW5jdGlvbiBpc19zZWxlY3RlZCh0b29sKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodG9vbC5ncm91cCkge1xuICAgICAgICByZXR1cm4gISF0b29sLml0ZW1zLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC50eXBlID09PSBfdGhpcy5kYXRhLnRvb2w7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9vbC50eXBlID09PSB0aGlzLmRhdGEudG9vbDtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc3R5bGVzOiBmdW5jdGlvbiBzdHlsZXMoKSB7XG4gICAgICB2YXIgY29sb3JzID0gdGhpcy4kcHJvcHMuY29sb3JzO1xuICAgICAgdmFyIGIgPSB0aGlzLiRwcm9wcy5jb25maWcuVEJfQk9SREVSO1xuICAgICAgdmFyIHcgPSB0aGlzLiRwcm9wcy5jb25maWcuVE9PTEJBUiAtIGI7XG4gICAgICB2YXIgYyA9IGNvbG9ycy5ncmlkO1xuICAgICAgdmFyIGNiID0gY29sb3JzLnRiQmFjayB8fCBjb2xvcnMuYmFjaztcbiAgICAgIHZhciBicmQgPSBjb2xvcnMudGJCb3JkZXIgfHwgY29sb3JzLnNjYWxlO1xuICAgICAgdmFyIHN0ID0gdGhpcy4kcHJvcHMuY29uZmlnLlRCX0JfU1RZTEU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnd2lkdGgnOiBcIlwiLmNvbmNhdCh3LCBcInB4XCIpLFxuICAgICAgICAnaGVpZ2h0JzogXCJcIi5jb25jYXQodGhpcy4kcHJvcHMuaGVpZ2h0IC0gMywgXCJweFwiKSxcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBjYixcbiAgICAgICAgJ2JvcmRlci1yaWdodCc6IFwiXCIuY29uY2F0KGIsIFwicHggXCIpLmNvbmNhdChzdCwgXCIgXCIpLmNvbmNhdChicmQpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ3JvdXBzOiBmdW5jdGlvbiBncm91cHMoKSB7XG4gICAgICB2YXIgYXJyID0gW107XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmRhdGEudG9vbHMgfHwgW10pLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB0b29sID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBpZiAoIXRvb2wuZ3JvdXApIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHRvb2wpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGcgPSBhcnIuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHguZ3JvdXAgPT09IHRvb2wuZ3JvdXA7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWcpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHtcbiAgICAgICAgICAgICAgZ3JvdXA6IHRvb2wuZ3JvdXAsXG4gICAgICAgICAgICAgIGljb246IHRvb2wuaWNvbixcbiAgICAgICAgICAgICAgaXRlbXM6IFt0b29sXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGcuaXRlbXMucHVzaCh0b29sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgZGF0YToge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihuKSB7XG4gICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBWdWUuanMgZG9lc24ndCB3YW50IHRvXG4gICAgICAgIC8vIHVwZGF0ZSAndG9vbHMnIGF1dG9tYXRpY2FsbHkgd2hlbiBuZXcgaXRlbVxuICAgICAgICAvLyBpcyBwdXNoZWQvcmVtb3ZlZC4gWW8sIFZ1ZSwgSSBoZXJkIHlvdVxuICAgICAgICAvLyB5b3Ugd2FudCBtb3JlIGRpcnR5IHRyaWNrcz9cbiAgICAgICAgaWYgKG4udG9vbHMpIHRoaXMudG9vbF9jb3VudCA9IG4udG9vbHMubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xfY291bnQ6IDAsXG4gICAgICBzdWJfbWFwOiB7fVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVG9vbGJhci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1Rvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgVG9vbGJhcnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVG9vbGJhci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVG9vbGJhci52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBUb29sYmFyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19Ub29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBUb29sYmFydnVlX3R5cGVfdGVtcGxhdGVfaWRfMDIxODg3ZmJfcmVuZGVyLFxuICBUb29sYmFydnVlX3R5cGVfdGVtcGxhdGVfaWRfMDIxODg3ZmJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBUb29sYmFyX2FwaTsgfVxuVG9vbGJhcl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1Rvb2xiYXIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVG9vbGJhciA9IChUb29sYmFyX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1dpZGdldHMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVmZTQzMTJmJlxudmFyIFdpZGdldHN2dWVfdHlwZV90ZW1wbGF0ZV9pZF81ZmU0MzEyZl9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXdpZGdldHNcIixcbiAgICAgIHN0eWxlOiB7IHdpZHRoOiBfdm0ud2lkdGggKyBcInB4XCIsIGhlaWdodDogX3ZtLmhlaWdodCArIFwicHhcIiB9XG4gICAgfSxcbiAgICBfdm0uX2woT2JqZWN0LmtleXMoX3ZtLm1hcCksIGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gX2MoX3ZtLmluaXR3KGlkKSwge1xuICAgICAgICBrZXk6IGlkLFxuICAgICAgICB0YWc6IFwiY29tcG9uZW50XCIsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG1haW46IF92bS5tYXBbaWRdLmN0cmwsXG4gICAgICAgICAgZGF0YTogX3ZtLm1hcFtpZF0uZGF0YSxcbiAgICAgICAgICB0djogX3ZtLnR2LFxuICAgICAgICAgIGRjOiBfdm0uZGNcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAxXG4gIClcbn1cbnZhciBXaWRnZXRzdnVlX3R5cGVfdGVtcGxhdGVfaWRfNWZlNDMxMmZfc3RhdGljUmVuZGVyRm5zID0gW11cbldpZGdldHN2dWVfdHlwZV90ZW1wbGF0ZV9pZF81ZmU0MzEyZl9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9XaWRnZXRzLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZmU0MzEyZiZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1dpZGdldHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBXaWRnZXRzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1dpZGdldHMnLFxuICBwcm9wczogWyd3aWR0aCcsICdoZWlnaHQnLCAnbWFwJywgJ3R2JywgJ2RjJ10sXG4gIG1ldGhvZHM6IHtcbiAgICBpbml0dzogZnVuY3Rpb24gaW5pdHcoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5tYXBbaWRdLmNscztcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvV2lkZ2V0cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1dpZGdldHN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoV2lkZ2V0c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1dpZGdldHMudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgV2lkZ2V0c3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1dpZGdldHMudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1dpZGdldHMudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgV2lkZ2V0c19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfV2lkZ2V0c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgV2lkZ2V0c3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzVmZTQzMTJmX3JlbmRlcixcbiAgV2lkZ2V0c3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzVmZTQzMTJmX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgV2lkZ2V0c19hcGk7IH1cbldpZGdldHNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9XaWRnZXRzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFdpZGdldHMgPSAoV2lkZ2V0c19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9UaGVUaXAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTJjMTc3MGNjJlxudmFyIFRoZVRpcHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzJjMTc3MGNjX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidHZqcy10aGUtdGlwXCIsXG4gICAgc3R5bGU6IF92bS5zdHlsZSxcbiAgICBkb21Qcm9wczogeyBpbm5lckhUTUw6IF92bS5fcyhfdm0uZGF0YS50ZXh0KSB9LFxuICAgIG9uOiB7XG4gICAgICBtb3VzZWRvd246IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICByZXR1cm4gX3ZtLiRlbWl0KFwicmVtb3ZlLW1lXCIpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxudmFyIFRoZVRpcHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzJjMTc3MGNjX3N0YXRpY1JlbmRlckZucyA9IFtdXG5UaGVUaXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yYzE3NzBjY19yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9UaGVUaXAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTJjMTc3MGNjJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVGhlVGlwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVGhlVGlwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1RoZVRpcCcsXG4gIHByb3BzOiBbJ2RhdGEnXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuJGVtaXQoJ3JlbW92ZS1tZScpO1xuICAgIH0sIDMwMDApO1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRoaXMuZGF0YS5jb2xvclxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVGhlVGlwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfVGhlVGlwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFRoZVRpcHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1RoZVRpcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBUaGVUaXB2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDc3KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1RoZVRpcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVGhlVGlwLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFRoZVRpcF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfVGhlVGlwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBUaGVUaXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yYzE3NzBjY19yZW5kZXIsXG4gIFRoZVRpcHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzJjMTc3MGNjX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVGhlVGlwX2FwaTsgfVxuVGhlVGlwX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvVGhlVGlwLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRoZVRpcCA9IChUaGVUaXBfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy94Y29udHJvbC5qc1xuZnVuY3Rpb24geGNvbnRyb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IHhjb250cm9sX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiB4Y29udHJvbF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHhjb250cm9sX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiB4Y29udHJvbF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24geGNvbnRyb2xfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gZXh0ZW5zaW9ucyBjb250cm9sXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHhjb250cm9sID0gKHtcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLmN0cmxsaXN0KCk7XG4gICAgdGhpcy5za2luX3N0eWxlcygpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgLy8gQnVpbGQgLyByZWJ1aWxkIGNvbXBvbmVudCBsaXN0XG4gICAgY3RybGxpc3Q6IGZ1bmN0aW9uIGN0cmxsaXN0KCkge1xuICAgICAgdGhpcy5jdHJsX2Rlc3Ryb3koKTtcbiAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IHhjb250cm9sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZXh0ZW5zaW9ucyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHggPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHguTWFpbi5fX25hbWVfXztcblxuICAgICAgICAgIGlmICghdGhpcy54U2V0dGluZ3NbbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnhTZXR0aW5ncywgbmFtZSwge30pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuYyA9IG5ldyB4Lk1haW4odGhpcywgLy8gdHYgaW5zdFxuICAgICAgICAgIHRoaXMuZGF0YSwgLy8gZGNcbiAgICAgICAgICB0aGlzLnhTZXR0aW5nc1tuYW1lXSAvLyBzZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5jb250cm9sbGVycy5wdXNoKG5jKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVycztcbiAgICB9LFxuICAgIC8vIFRPRE86IHByZXZlbnREZWZhdWx0XG4gICAgcHJlX2RjOiBmdW5jdGlvbiBwcmVfZGMoZSkge1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSB4Y29udHJvbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY29udHJvbGxlcnMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY3RybCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIGlmIChjdHJsLnVwZGF0ZSkge1xuICAgICAgICAgICAgY3RybC51cGRhdGUoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBvc3RfZGM6IGZ1bmN0aW9uIHBvc3RfZGMoZSkge1xuICAgICAgdmFyIF9pdGVyYXRvcjMgPSB4Y29udHJvbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY29udHJvbGxlcnMpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY3RybCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIGlmIChjdHJsLnBvc3RfdXBkYXRlKSB7XG4gICAgICAgICAgICBjdHJsLnBvc3RfdXBkYXRlKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjdHJsX2Rlc3Ryb3k6IGZ1bmN0aW9uIGN0cmxfZGVzdHJveSgpIHtcbiAgICAgIHZhciBfaXRlcmF0b3I0ID0geGNvbnRyb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbnRyb2xsZXJzKSxcbiAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGN0cmwgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgICAgaWYgKGN0cmwuZGVzdHJveSkgY3RybC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2tpbl9zdHlsZXM6IGZ1bmN0aW9uIHNraW5fc3R5bGVzKCkge1xuICAgICAgdmFyIGlkID0gJ3R2anMtc2tpbi1zdHlsZXMnO1xuICAgICAgdmFyIHN0YnIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgIGlmIChzdGJyKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBzdGJyLnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChzdGJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2tpbl9wcm90byAmJiB0aGlzLnNraW5fcHJvdG8uc3R5bGVzKSB7XG4gICAgICAgIHZhciBzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHNoZWV0LnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICAgICAgc2hlZXQuaW5uZXJIVE1MID0gdGhpcy5za2luX3Byb3RvLnN0eWxlcztcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoc2hlZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICB3czogZnVuY3Rpb24gd3MoKSB7XG4gICAgICB2YXIgd3MgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjUgPSB4Y29udHJvbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY29udHJvbGxlcnMpLFxuICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY3RybCA9IF9zdGVwNS52YWx1ZTtcblxuICAgICAgICAgIGlmIChjdHJsLndpZGdldHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGN0cmwud2lkZ2V0cykge1xuICAgICAgICAgICAgICB3c1tpZF0gPSBjdHJsLndpZGdldHNbaWRdO1xuICAgICAgICAgICAgICB3c1tpZF0uY3RybCA9IGN0cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdzO1xuICAgIH0sXG4gICAgc2tpbnM6IGZ1bmN0aW9uIHNraW5zKCkge1xuICAgICAgdmFyIHNrcyA9IHt9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IHhjb250cm9sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZXh0ZW5zaW9ucyksXG4gICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB4ID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaWQgaW4geC5za2lucyB8fCB7fSkge1xuICAgICAgICAgICAgc2tzW2lkXSA9IHguc2tpbnNbaWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBza3M7XG4gICAgfSxcbiAgICBza2luX3Byb3RvOiBmdW5jdGlvbiBza2luX3Byb3RvKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpbnNbdGhpcy4kcHJvcHMuc2tpbl07XG4gICAgfSxcbiAgICBjb2xvcnBhY2s6IGZ1bmN0aW9uIGNvbG9ycGFjaygpIHtcbiAgICAgIHZhciBzZWwgPSB0aGlzLnNraW5zW3RoaXMuJHByb3BzLnNraW5dO1xuICAgICAgcmV0dXJuIHNlbCA/IHNlbC5jb2xvcnMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgZmFzdCAmIGRpcnR5IGZpeCwgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGUgYWN0dWFsIHJlYWN0aXZpdHkgcHJvYmxlbVxuICAgIHNraW46IGZ1bmN0aW9uIHNraW4obiwgcCkge1xuICAgICAgaWYgKG4gIT09IHApIHRoaXMucmVzZXRDaGFydCgpO1xuICAgICAgdGhpcy5za2luX3N0eWxlcygpO1xuICAgIH0sXG4gICAgZXh0ZW5zaW9uczogZnVuY3Rpb24gZXh0ZW5zaW9ucygpIHtcbiAgICAgIHRoaXMuY3RybGxpc3QoKTtcbiAgICB9LFxuICAgIHhTZXR0aW5nczoge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihuLCBwKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3I3ID0geGNvbnRyb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbnRyb2xsZXJzKSxcbiAgICAgICAgICAgIF9zdGVwNztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgY3RybCA9IF9zdGVwNy52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGN0cmwub25zZXR0aW5ncykge1xuICAgICAgICAgICAgICBjdHJsLm9uc2V0dGluZ3MobiwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyb2xsZXJzOiBbXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9UcmFkaW5nVnVlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5mdW5jdGlvbiBUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1RyYWRpbmdWdWUnLFxuICBjb21wb25lbnRzOiB7XG4gICAgQ2hhcnQ6IENoYXJ0LFxuICAgIFRvb2xiYXI6IFRvb2xiYXIsXG4gICAgV2lkZ2V0czogV2lkZ2V0cyxcbiAgICBUaGVUaXA6IFRoZVRpcFxuICB9LFxuICBtaXhpbnM6IFt4Y29udHJvbF0sXG4gIHByb3BzOiB7XG4gICAgdGl0bGVUeHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnVHJhZGluZ1Z1ZS5qcydcbiAgICB9LFxuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJ3RyYWRpbmctdnVlLWpzJ1xuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIFwiZGVmYXVsdFwiOiA4MDBcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgXCJkZWZhdWx0XCI6IDQyMVxuICAgIH0sXG4gICAgY29sb3JUaXRsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjNDJiODgzJ1xuICAgIH0sXG4gICAgY29sb3JCYWNrOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyMxMjE4MjYnXG4gICAgfSxcbiAgICBjb2xvckdyaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzJmMzI0MCdcbiAgICB9LFxuICAgIGNvbG9yVGV4dDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjZGVkZGRkJ1xuICAgIH0sXG4gICAgY29sb3JUZXh0SEw6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnI2ZmZidcbiAgICB9LFxuICAgIGNvbG9yU2NhbGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzgzODM4MydcbiAgICB9LFxuICAgIGNvbG9yQ3Jvc3M6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzgwOTFhMCdcbiAgICB9LFxuICAgIGNvbG9yQ2FuZGxlVXA6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzIzYTc3NidcbiAgICB9LFxuICAgIGNvbG9yQ2FuZGxlRHc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnI2U1NDE1MCdcbiAgICB9LFxuICAgIGNvbG9yV2lja1VwOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyMyM2E3NzY4OCdcbiAgICB9LFxuICAgIGNvbG9yV2lja0R3OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyNlNTQxNTA4OCdcbiAgICB9LFxuICAgIGNvbG9yV2lja1NtOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJ3RyYW5zcGFyZW50JyAvLyBkZXByZWNhdGVkXG5cbiAgICB9LFxuICAgIGNvbG9yVm9sVXA6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzc5OTk5ZTQyJ1xuICAgIH0sXG4gICAgY29sb3JWb2xEdzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjZWY1MzUwNDInXG4gICAgfSxcbiAgICBjb2xvclBhbmVsOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyM1NjVjNjgnXG4gICAgfSxcbiAgICBjb2xvclRiQmFjazoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcbiAgICBjb2xvclRiQm9yZGVyOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyM4MjgyODI3ZCdcbiAgICB9LFxuICAgIGNvbG9yczoge1xuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogY29uc3RhbnRzLkNoYXJ0Q29uZmlnLkZPTlRcbiAgICB9LFxuICAgIHRvb2xiYXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICAvLyBZb3VyIG92ZXJsYXkgY2xhc3NlcyBoZXJlXG4gICAgb3ZlcmxheXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBPdmVyd3JpdGVzIENoYXJ0Q29uZmlnIHZhbHVlcyxcbiAgICAvLyBzZWUgY29uc3RhbnRzLmpzXG4gICAgY2hhcnRDb25maWc6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVnZW5kQnV0dG9uczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluZGV4QmFzZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICB4U2V0dGluZ3M6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgc2tpbjoge1xuICAgICAgdHlwZTogU3RyaW5nIC8vIFNraW4gTmFtZVxuXG4gICAgfSxcbiAgICB0aW1lem9uZToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgLy8gQ29weSBhIHN1YnNldCBvZiBUcmFkaW5nVnVlIHByb3BzXG4gICAgY2hhcnRfcHJvcHM6IGZ1bmN0aW9uIGNoYXJ0X3Byb3BzKCkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuJHByb3BzLnRvb2xiYXIgPyB0aGlzLmNoYXJ0X2NvbmZpZy5UT09MQkFSIDogMDtcbiAgICAgIHZhciBjaGFydF9wcm9wcyA9IHtcbiAgICAgICAgdGl0bGVfdHh0OiB0aGlzLiRwcm9wcy50aXRsZVR4dCxcbiAgICAgICAgb3ZlcmxheXM6IHRoaXMuJHByb3BzLm92ZXJsYXlzLmNvbmNhdCh0aGlzLm1vZF9vdnMpLFxuICAgICAgICBkYXRhOiB0aGlzLmRlY3ViZWQsXG4gICAgICAgIHdpZHRoOiB0aGlzLiRwcm9wcy53aWR0aCAtIG9mZnNldCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLiRwcm9wcy5oZWlnaHQsXG4gICAgICAgIGZvbnQ6IHRoaXMuZm9udF9jb21wLFxuICAgICAgICBidXR0b25zOiB0aGlzLiRwcm9wcy5sZWdlbmRCdXR0b25zLFxuICAgICAgICB0b29sYmFyOiB0aGlzLiRwcm9wcy50b29sYmFyLFxuICAgICAgICBpYjogdGhpcy4kcHJvcHMuaW5kZXhCYXNlZCB8fCB0aGlzLmluZGV4X2Jhc2VkIHx8IGZhbHNlLFxuICAgICAgICBjb2xvcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJHByb3BzLmNvbG9ycyB8fCB0aGlzLmNvbG9ycGFjayksXG4gICAgICAgIHNraW46IHRoaXMuc2tpbl9wcm90byxcbiAgICAgICAgdGltZXpvbmU6IHRoaXMuJHByb3BzLnRpbWV6b25lXG4gICAgICB9O1xuICAgICAgdGhpcy5wYXJzZV9jb2xvcnMoY2hhcnRfcHJvcHMuY29sb3JzKTtcbiAgICAgIHJldHVybiBjaGFydF9wcm9wcztcbiAgICB9LFxuICAgIGNoYXJ0X2NvbmZpZzogZnVuY3Rpb24gY2hhcnRfY29uZmlnKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbnN0YW50cy5DaGFydENvbmZpZywgdGhpcy4kcHJvcHMuY2hhcnRDb25maWcpO1xuICAgIH0sXG4gICAgZGVjdWJlZDogZnVuY3Rpb24gZGVjdWJlZCgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy4kcHJvcHMuZGF0YTtcblxuICAgICAgaWYgKGRhdGEuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIERhdGFDdWJlIGRldGVjdGVkXG4gICAgICAgIGRhdGEuaW5pdF90dmpzKHRoaXMpO1xuICAgICAgICByZXR1cm4gZGF0YS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbmRleF9iYXNlZDogZnVuY3Rpb24gaW5kZXhfYmFzZWQoKSB7XG4gICAgICB2YXIgYmFzZSA9IHRoaXMuJHByb3BzLmRhdGE7XG5cbiAgICAgIGlmIChiYXNlLmNoYXJ0KSB7XG4gICAgICAgIHJldHVybiBiYXNlLmNoYXJ0LmluZGV4QmFzZWQ7XG4gICAgICB9IGVsc2UgaWYgKGJhc2UuZGF0YSkge1xuICAgICAgICByZXR1cm4gYmFzZS5kYXRhLmNoYXJ0LmluZGV4QmFzZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG1vZF9vdnM6IGZ1bmN0aW9uIG1vZF9vdnMoKSB7XG4gICAgICB2YXIgYXJyID0gW107XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5leHRlbnNpb25zKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgeCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGFyci5wdXNoLmFwcGx5KGFyciwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC52YWx1ZXMoeC5vdmVybGF5cykpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgZm9udF9jb21wOiBmdW5jdGlvbiBmb250X2NvbXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5za2luX3Byb3RvICYmIHRoaXMuc2tpbl9wcm90by5mb250ID8gdGhpcy5za2luX3Byb3RvLmZvbnQgOiB0aGlzLmZvbnQ7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXNldDogMCxcbiAgICAgIHRpcDogbnVsbFxuICAgIH07XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5jdXN0b21fZXZlbnQoe1xuICAgICAgZXZlbnQ6ICdiZWZvcmUtZGVzdHJveSdcbiAgICB9KTtcbiAgICB0aGlzLmN0cmxfZGVzdHJveSgpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgLy8gVE9ETzogcmVzZXQgZXh0ZW5zaW9ucz9cbiAgICByZXNldENoYXJ0OiBmdW5jdGlvbiByZXNldENoYXJ0KHJlc2V0UmFuZ2UpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXNldFJhbmdlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmVzZXRSYW5nZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzZXQrKztcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcblxuICAgICAgaWYgKCFyZXNldFJhbmdlICYmIHJhbmdlWzBdICYmIHJhbmdlWzFdKSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0UmFuZ2UuYXBwbHkoX3RoaXMsIF90b0NvbnN1bWFibGVBcnJheShyYW5nZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY3VzdG9tX2V2ZW50KHtcbiAgICAgICAgICBldmVudDogJ2NoYXJ0LXJlc2V0JyxcbiAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgXCJnb3RvXCI6IGZ1bmN0aW9uIGdvdG8odCkge1xuICAgICAgLy8gVE9ETzogbGltaXQgZ290byAmIHNldFJhbmdlIChvdXQgb2YgZGF0YSBlcnJvcilcbiAgICAgIGlmICh0aGlzLmNoYXJ0X3Byb3BzLmliKSB7XG4gICAgICAgIHZhciB0aV9tYXAgPSB0aGlzLiRyZWZzLmNoYXJ0LnRpX21hcDtcbiAgICAgICAgdCA9IHRpX21hcC5ndDJpKHQsIHRoaXMuJHJlZnMuY2hhcnQub2hsY3YpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRyZWZzLmNoYXJ0W1wiZ290b1wiXSh0KTtcbiAgICB9LFxuICAgIHNldFJhbmdlOiBmdW5jdGlvbiBzZXRSYW5nZSh0MSwgdDIpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0X3Byb3BzLmliKSB7XG4gICAgICAgIHZhciB0aV9tYXAgPSB0aGlzLiRyZWZzLmNoYXJ0LnRpX21hcDtcbiAgICAgICAgdmFyIG9obGN2ID0gdGhpcy4kcmVmcy5jaGFydC5vaGxjdjtcbiAgICAgICAgdDEgPSB0aV9tYXAuZ3QyaSh0MSwgb2hsY3YpO1xuICAgICAgICB0MiA9IHRpX21hcC5ndDJpKHQyLCBvaGxjdik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJHJlZnMuY2hhcnQuc2V0UmFuZ2UodDEsIHQyKTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiBmdW5jdGlvbiBnZXRSYW5nZSgpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0X3Byb3BzLmliKSB7XG4gICAgICAgIHZhciB0aV9tYXAgPSB0aGlzLiRyZWZzLmNoYXJ0LnRpX21hcDsgLy8gVGltZSByYW5nZSA9PiBpbmRleCByYW5nZVxuXG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmNoYXJ0LnJhbmdlLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB0aV9tYXAuaTJ0KHgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuY2hhcnQucmFuZ2U7XG4gICAgfSxcbiAgICBnZXRDdXJzb3I6IGZ1bmN0aW9uIGdldEN1cnNvcigpIHtcbiAgICAgIHZhciBjdXJzb3IgPSB0aGlzLiRyZWZzLmNoYXJ0LmN1cnNvcjtcblxuICAgICAgaWYgKHRoaXMuY2hhcnRfcHJvcHMuaWIpIHtcbiAgICAgICAgdmFyIHRpX21hcCA9IHRoaXMuJHJlZnMuY2hhcnQudGlfbWFwO1xuICAgICAgICB2YXIgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnNvcik7XG4gICAgICAgIGNvcHkuaSA9IGNvcHkudDtcbiAgICAgICAgY29weS50ID0gdGlfbWFwLmkydChjb3B5LnQpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9LFxuICAgIHNob3dUaGVUaXA6IGZ1bmN0aW9uIHNob3dUaGVUaXAodGV4dCwgY29sb3IpIHtcbiAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbG9yID0gXCJvcmFuZ2VcIjtcbiAgICAgIH1cblxuICAgICAgdGhpcy50aXAgPSB7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgfTtcbiAgICB9LFxuICAgIGxlZ2VuZF9idXR0b246IGZ1bmN0aW9uIGxlZ2VuZF9idXR0b24oZXZlbnQpIHtcbiAgICAgIHRoaXMuY3VzdG9tX2V2ZW50KHtcbiAgICAgICAgZXZlbnQ6ICdsZWdlbmQtYnV0dG9uLWNsaWNrJyxcbiAgICAgICAgYXJnczogW2V2ZW50XVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjdXN0b21fZXZlbnQ6IGZ1bmN0aW9uIGN1c3RvbV9ldmVudChkKSB7XG4gICAgICBpZiAoJ2FyZ3MnIGluIGQpIHtcbiAgICAgICAgdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBbZC5ldmVudF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShkLmFyZ3MpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbWl0KGQuZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuJHByb3BzLmRhdGE7XG4gICAgICB2YXIgY3RybCA9IHRoaXMuY29udHJvbGxlcnMubGVuZ3RoICE9PSAwO1xuICAgICAgaWYgKGN0cmwpIHRoaXMucHJlX2RjKGQpO1xuXG4gICAgICBpZiAoZGF0YS50dikge1xuICAgICAgICAvLyBJZiB0aGUgZGF0YSBvYmplY3QgaXMgRGF0YUN1YmVcbiAgICAgICAgZGF0YS5vbl9jdXN0b21fZXZlbnQoZC5ldmVudCwgZC5hcmdzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0cmwpIHRoaXMucG9zdF9kYyhkKTtcbiAgICB9LFxuICAgIHJhbmdlX2NoYW5nZWQ6IGZ1bmN0aW9uIHJhbmdlX2NoYW5nZWQocikge1xuICAgICAgaWYgKHRoaXMuY2hhcnRfcHJvcHMuaWIpIHtcbiAgICAgICAgdmFyIHRpX21hcCA9IHRoaXMuJHJlZnMuY2hhcnQudGlfbWFwO1xuICAgICAgICByID0gci5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gdGlfbWFwLmkydCh4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVtaXQoJ3JhbmdlLWNoYW5nZWQnLCByKTtcbiAgICAgIHRoaXMuY3VzdG9tX2V2ZW50KHtcbiAgICAgICAgZXZlbnQ6ICdyYW5nZS1jaGFuZ2VkJyxcbiAgICAgICAgYXJnczogW3JdXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLm9ucmFuZ2UpIHRoaXMub25yYW5nZShyKTtcbiAgICB9LFxuICAgIHNldF9sb2FkZXI6IGZ1bmN0aW9uIHNldF9sb2FkZXIoZGMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLm9ucmFuZ2UgPSBmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIgcGYgPSBfdGhpczIuY2hhcnRfcHJvcHMuaWIgPyAnX21zJyA6ICcnO1xuICAgICAgICB2YXIgdGYgPSBfdGhpczIuJHJlZnMuY2hhcnRbJ2ludGVydmFsJyArIHBmXTtcbiAgICAgICAgZGMucmFuZ2VfY2hhbmdlZChyLCB0Zik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgcGFyc2VfY29sb3JzOiBmdW5jdGlvbiBwYXJzZV9jb2xvcnMoY29sb3JzKSB7XG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMuJHByb3BzKSB7XG4gICAgICAgIGlmIChrLmluZGV4T2YoJ2NvbG9yJykgPT09IDAgJiYgayAhPT0gJ2NvbG9ycycpIHtcbiAgICAgICAgICB2YXIgazIgPSBrLnJlcGxhY2UoJ2NvbG9yJywgJycpO1xuICAgICAgICAgIGsyID0gazJbMF0udG9Mb3dlckNhc2UoKSArIGsyLnNsaWNlKDEpO1xuICAgICAgICAgIGlmIChjb2xvcnNbazJdKSBjb250aW51ZTtcbiAgICAgICAgICBjb2xvcnNbazJdID0gdGhpcy4kcHJvcHNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKCkge1xuICAgICAgdGhpcy4kcmVmcy5jaGFydC5hY3RpdmF0ZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgbW91c2VsZWF2ZTogZnVuY3Rpb24gbW91c2VsZWF2ZSgpIHtcbiAgICAgIHRoaXMuJHJlZnMuY2hhcnQuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9UcmFkaW5nVnVlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHNyY19UcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvVHJhZGluZ1Z1ZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBUcmFkaW5nVnVldnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2Myk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvVHJhZGluZ1Z1ZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1RyYWRpbmdWdWUudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgVHJhZGluZ1Z1ZV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIHNyY19UcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVHJhZGluZ1Z1ZV9hcGk7IH1cblRyYWRpbmdWdWVfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvVHJhZGluZ1Z1ZS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUcmFkaW5nVnVlID0gKFRyYWRpbmdWdWVfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanNcbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xudmFyIHJlZ2VuZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTcpO1xudmFyIHJlZ2VuZXJhdG9yX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlZ2VuZXJhdG9yKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL3RtcC93dyQkJC5qc29uXG5jb25zdCB3dyQkJF9uYW1lc3BhY2VPYmplY3QgPSBKU09OLnBhcnNlKCdbXCJCVENVRjRENEc4RGNFTUJPQUNBTHVhQjJBckpnWE1LZ0RRQ21SQWRoREtnSFFrQWVBRGdQYUtvRE80NXdBYkg2QUY4aTJBQ3c4ODZhblNhc09HY2dGY0F0Z0dNbGpQQURNRjVGYWdDV3pic1JLaG9pRXFnV0p5YUFMUWtoN1ZJalVidHVnMGNLa3pGcXpab0FEd2tBUHgyQUl3U2tHRlJBQXdDaVVROG1BQWNCQ1lVVkhCSXlJaGN3Tmh4Y2FCRStnV2lQS1h3QlJGeEVhQUEzQjU2aHJic1BxYlErcHJBQUlTSU5QcnNBTXF5OEFCR0FEWWtBSUtJaVBBQW5nQXkrZ0RXSklTZ29LZ0FGb2pNQU83STVDUW5BS0lMck1BQVJBQ1M1QWhUK2dBbXlLL3dxUEMzVFQzOUpBQVBvRGFETnlBQnpmYVFPSUFNaGhmV0FKR1ErbHNxQUEybkVBTG83ZmFIRTVuUzdYUkIzUjdQTjdJOGl2QmkvUnI3WVkwVDdmY0RFT25zSWFVaGpnTWlzbWpzU3dBSVdZT2sraUgwSkE2cFI1S21ZNmlRSkhBdDBVU2dtSkVRdDNBektXakJJekUwYUQyOUtVS05nb1gwTkNWYmp3WnVjcm5VUkI1ZktRS2oyNEhndkpJVHIyOW9OYk9lTEU0MENFVXVzN0ZZWEFVVXltM3ZwWjNvcUNteDNEa2VqYk5qZFBCTHNVa1lFdEFZTERZbkhZUkRaakVPcUdZcUMxSkhkcUFBd2pMR0hMd0Mwdk1ZelA5YmkyMnJjK3BydGJxMExzRHNkVHVka0ZkRHNTSGs5NEM5M2tod2NvU09SVURUL05aVVQ2YU5MWlJabVNtbkRSU3hXSzFXYXlNUGE0WFYzdktoMjcxT3pwV2tZZTMyZFhxNzdpUndUeDBTU1RPNTJRQmNseFhOZExBM2ZWNlVkSzk5MVpROWozTFN0dFY1V1JteWZWc3dCeUZCMEZaVWhtUzNGRXFYb1JwMTBDSGxHVGRVTTJCQUc5dUhJSWhFRDhjQ3lPM0JzNVdBY2cwUklURUdLNDdFQkIyRk1hMEZZVWtERkNVRDJMSTh5MVBaQytWUUVUS1RFOFUwTThOcE1JUWJEOFBwQ2k4SjVRaUdCSTVqTjBOWTFtUm9NRklUMk9GMFN4UGloS1VlQjZGZ2N6TFAyR3kwVkJaY3JNaVRGN0xncVNFTms2dE5Fc1oxVk9mTnR1bDZPSU5XMHRrS0lzN3o5bEFVaVRMWkZRUXpETE1veDVOTUV5T0pOY3EzTk1EUXpJcVUwYWY1SWppcVUySXNId2VTTko0ZGpTeUNNcXkvSWNxRS9MRTI2dktHSFRGMDRrcS80SWxxcmNkMGJCcVdTM1J6bk5hNHoydTNUcUtvR3VNQ3ZpaGt2amROeTlraUhyQnJLek1JMks0WkdrMDVCNVI1UDFtSFlUek1TcTNwVERha0toVXBVSkNFbTFicXdNK2hEbzJ2clRvQm9haXRBREp2c1FLaTFwS3diTnVyVXNTRmdFSGpxNWMxQnNsSDBMdHljZ3R1ZzUxdDFuS1l2dUdlMG1qYTRNb2V5OWtpSkJ6YnlHa3BHVWYwY3FHYlRTU1N4a3BEcTNCU3dJb3d1OW9GUUd5dDFDMUJuVzJiR1VHdXlHcUtNZ0piQnkzc3VWQ2NpZHI0dkFjdmdybXoxNTFBQUNWNEFoZVZhTTZlOWdIR2pVNnQzTFlURVdoVzBVZW5reFlsdThwZE9MYk1xcHhCZ1hXb2JhVkZzSzlrUkpwTHZ5U21xTjkySEFhT2VXSUp5dUx5R0JCT05VUVVKSFlrTGRFdllGNFZDMmVqRUFBYWdhSkk2aWlTUm9Gb3E2ZkFMc29pSGdNeExzNEl2eUVnTnVJaUlaaFBmcTIyMFhZUHo5STVlZ2VQMGNtbHVZVUpXL0FOUDREUmZSTVF3VFIzdGVQQStnN3Y3TmVCeEhZRHdaZ2dqaVVKRUR3UkFEclRYZjk4UDR2ajRFWGZvVkNhc1ZDSmttaTJJZWoyQU8vUjYvQmgrbjl3NGgyR0xneE91RGM4Q3ozbm92WmVxOFJvYnlMTnZUZXlZejVheHpOSWZNSEIzU2VuNXVwUVdsMWNacTIrSEhRSVA5SXpQd29FUUVhRE05b0hWbXZTVzY3QkJCQ0NLSEVDUVVBaFlvTmtHeVlZWXcyQ1RCbVBNUllxd05nbTNRbGdwaUN0a0NtMEZtbFBvQ0poWXdsdU13Q1lBQXJFZ2VoMVJ2Z0hMSTRZQUF4RkUraFVDMnlTaENGS05sREZXVWdPQVdFTUl2SkdKZEJxQUFzbDhQWU5CTkFKaHVOWXF5b0FURjdTQ0NJQUFUQUFUaEVQNGxJQVNxZ0NHMkhDQ1JvaU53SWo2S2dZRThpbEVxTlhMMmJtR2lFbTBWZkdrajhLRTJDQ0cyRWtQZzRnSzZYU0VXcFc4WmhiZ0tENU1nRzAraFZIdXpJTGpBQThra3ZRMGtUemN3WWx3R2dleDREc0dhVWNjZ0FBRlE0Mm8yQkxES0FxVEpWc3F3RGhHRXNaVXpBcGloQVdVc3FZZUJBejEzQUdhUFJxb3Zpc0FTUUFBU09Yc3hZNVkxVEZoMlRRZnBTeGREM0gwZWN3NWdKYmduTnVmY3g1QnpMbGR6Tk9XRVlMZ1VUZ2dBQ3J3SEJNY281ZnlBVVFoQmVDVzR6UmhGR0dRQW9Ub1dSekJMVmFjbzlwVkpOQW9oSUtNNWc0ekt3b3B5Rk1CUUpCTmFrQ1ZQczZZNUsrZ2pXbE9RSEZpNUZnMHFnVVFJNG9wdmlzcnBRSmUwZkVjeUlDV05BWkZXemJpL0FFSS9jV3dkQllLRXdiZVVncUtLWjhTNElrS3UwcUZVRjBicmtjb0pBNFFJeDF0cUNremdqWjV3SEl3ZStlQkdEYkl4Y2s3Y0ZndmhiRE5FRmJtcFJPQS9ndU1BSDJnSkhaanpFVzZBQStzYVpnbXc1WEdBMVZxbEErUk5BRU5zS2JUK0Rkb3Flcml2Nm9jZUpSeUVrbkhjQUE0c3VmWkZ6a1RzQ0FsTWUxcndsaDVCME9RUUZOSi9qNUExSzhjMnR3dnhIRFVUczFOSTU0QXh1UVBjTUFBZ2w3RWdaa29Td2V4bUN2QjJSUUc1aUJ3U3VrYUkwQ050U2VsVWhtT0NCMVQxZ0IwS3dzZ0x1ZGkxMVpGWGN3YzJYY05Td0ZBQXlnd2lnU0NkdVlJa0RzYVlXMERxSFNPMEFETStRcmg2ZjZsOTZBR1lMa2FDUUtZTlNPeE5ydlRRUWQreEgySnRyYzJOdEp4OGl2SEhkK2htcnhoaU5pbFJjZWdlZEdBWVMvWk93UXY2K1MzRFNrQmtEdzdYaHdpL1JNUkFDZ01OM0FJM0I3REpGd0QrdmRyS2xRS0xLQ3JzVkt3UnlVd1cwS0JvQzY4REM2akJoQlhsR1hqQzQ0ckh0UFNpTWxNYVNWa3J3R0p5ZFJCWGhDYzFneUlUaVJHM0RtYlhGWGozTTRSSnRnL2UwRG82dE40bHVMUnFkaW53VDBQQ2EvWXMxUmUwSXRzQ3h6SWxBaGFDclJRcklXVlk4QWNjUUZ4aXpDNEpDRTJJVTAraGtyWGJSSnNENTdVZm5BUDEwblJJUkl5Q09Yd0VZT0FQWTd0TkFLbllOVTdVSEpYai9LUUt1SWdVeGN2NWVYRlNWNEFCTk1VVXhYZ1dmOVFxQmdLaUZCbnRoY3BoVVUwWmo2TWEwUUZ5Z1o0WGxOc0l3VENUbVJ2SUNXT05xdVNoeHVYU25VTjhFYUo0QUwxTnRGOUtBaDNickhBRGE5cGV0OFdJU3JNMHpRN0x3RHJEaE9zWUFWMkFCeXdBZlU3RWFFY09FUnhsYmtEaElNUit4Q2poZndNMU9vNG9kY2dUSEFFb0RwUjN0VGdFWUdENEt1MjJtMEJVUGEvUndBYlBEY2lzZ2VnMnhvQm9rVklOQ3pabmpoNDRJNWlaeHJBTGp3QWxzQVUyWFJrV1pFcDg1ekhGTXR5QnFlTUdyWTNKQkE3QUVvSUt1c3d6YVYyYzZjWUE4Yml5ZHpuY3h3Z2M4ZUxFQWJ1eHdEeXM5TlZqblM2YXpSQWN0T09lREp0cW1nNFNKTXhhdVdaL1k5VGE1aEo5cCtwM2JqK3Y5ZkFJNDhBOUcvSHZqUUN3b1lwaXdDMkpvR2dsdnJlMjd2SHh2WXk0YUwwOEZ0d0hIY1lMUC8xRjd5dW5JM01mQjRTK0gvZFhPOERWaWQ4czEzbFBRQysvOTFIeUttUDFlempKZnVEb2V3T2RFR3p3TERiZ3Y4Zk52dENMaFBuUG1EQUdzNElTNitnQTcwbVo3QVZub2FmQ01YNTVOK0FtRTJvL2kyR1g5U1pCUjdRRERZZ0JWbzh1Y0NEYXVVZlFwcE0vY0hnRi9VQlBhSnRvKzNhL09kNGNoaWZJdVdpWXp4SEhvMXJpbDBmNENIZjBrR1hmb2lxVmZDTVB2clltMmdaeXZtTytNZ1prL0k2RlEwYXcxT21RRHZsa0VRSS9vbk1Ccy92YkJCTEFJMEQvcVpnbGdBVndHT0VDbFdCT0RjTGNFQ243c2lJZnF3QjhNd09LS2NCV01nTWVMQUc4RWlQQU1nQUFPUk5xVUhJQkVZanJpcHRTd0FDQXQ3Z0FzYlQ1djQ0SFQ0QUYvQVBpQVp4Uy9LSzVENFFFbVlLZ0lFVHBUcG1nTGpqcUxxMzRPb1ZRd0dYUTFCU0dUcWRyd0NoQnVncVpuQ2ZTY1MwQk80UmlvQTNid0NEb0x4dWdhNU5Mb3h4am1ScGdyRE1BcUNnRUVadllpSEViZjdPRy80aDZsYUlHbUF5RTM1Mzd5amRUSHFnSUVCd0ZpSGFZV2FJRS9nb0hhaG9GVGp2NzVyNkZUQ29BRnFFRkpGR3licHc2L0ErRkxyeUVCSGM0QzdOS1k2bElZQXVDckIyRVNBWWlZaGJZUkFVaG9BR1kveFNxMkVxRE1ob2dSRFloRUMrSTFHeUtJak9Jb2hFeWxGTkhvaStJOFRWandDYUNQS05ITkVBRE1iUlBJSlJGd0s0b280b1I0MVN3Y3BnVytyWXlBSXdoUnVRMTByRTZndldiUXdJUTIxWTNNQ281QW5HczRGbXNoK2lWMEVoOW9leGpBQnhSZ1hJNnhiUTQ0bU9zeGdxOHhBS0trYUlIbS9SZm1od0ZZdHdBZ1V1Sk9pQVpPRXN6U0tZbU05SVR1bGcvUUpRcnhpS2QyZ3MvdzJDT016UnEycTZsQXdoWDJ4TWJzSFlNeTZpT1NhWXFVUzBxQXE2ZlF3d1JocUpwaUtVYzY1UUIwbkFWYzNBWmdmYXdBalFoY2hjK2dRUTdpK3dzNk5hb1dCSlpRVUJnUURNNWh6Ujg4TWhRbTRBYThGQW5hRXArZThvRmhXaDhvZEtGQVcyYlVxWWcwNEE3QWlRYVVrK2cwZUE5d3FxQXUzYUcyY201S1pBYXBVQ0JwUzBTdzBPcHhFd3JFNUFOb0NnZWdZWVNnUkFvT0RLN3BucCtRa3lqcGlHN0FqeHl3UmhnNjRBeUszcHpBb0JPYVp3VHlpQVdpem1tUmIrN0E4WmVhckF5WkkyM2VHSjBzMHlLWkJ1NzR0UlZpcnAvcEZ5TWEwaXVxTUlpSWNVU3dDU0daaVoyWmtVTGEzUklaWVpTd0VaUUlnSTFZNUF4aHBnZ2c5eGpraUFPMlVTWG1FRWUydEE4a2gyd1VKMm9RazVOWU01M01KMlBnU2c0TWhBSHUvcVFVbHVJT1JBTk9uY2NadWFUWktaZ2t0QXpxVllzT2V1ZHFIb1NPRXdrb1FZTnlhV0dXWTVocG51TnVlaXlXUWdHT3N3VHBpdVJBUDU1NTJvZmNhMjlPRmVBVXRBc3c3QWR5S2dEeW1aK1Fzdzl4N3lUUlZPcEMwKzhhamN6QTVJc1VHbzhBQm1OUStLUm9mSWdPS0FicVk0dk9xeHFGb3BYOG5hYVpqWlh5elptR29Bb1E3QWVBT3BjWVlBSytBZTBla2lGSjZtMmh0QTVockZsaHFBUGFuT1JBR09kNWU1d0FFd0I1dHdkRkZ5bVJFd0sySUYwZVlGUG9RZ0xwa0tvb0VJM2VHMnR3YUlDaWV1eUE4bHJBbUlJSjl4bXdTd0xKZ2VjNjhvanN6UU53T0NuUm9BQ01LeEhFdnFFRXllU01xb2ZJWUFxdUF1YkpsY053UDY5SldXZSthTUxBWTJ2Qm5xemx3aGtwM0JmRjZwSGM1QTgrUzBDR3NwR3BLVkQ1NWhuQU4yUkFGd3Y1RU8wQWZwTGdIcEZ5ZUFGd0RFNG9sZ1dnTmxyK1c0MjhGaUlNVFZEb3k0T0VUT0g2WElRa2FwY3BIYzVFdmhPUndNVFV6K1p4dU9RazRtM0lXNGN4Q3g0azRKa0p3Y0l3cFFjU29BSEpUbEtJN1VvQWphUUd6b1NBc3dJbEpRSDJ3cEpDbEFjSTFKN0F0SndBaGN6NnVjV3dEUW5pTlpySXgrQzhheHhZNVk3Z29GUXNXY0dWY1E3czdWOUkwMVB4OTBXSUR4VHg1QXN1WVJ0VWZHaXVUYWFBRWhORlc0aUF6d1FnN1pYd3pvcUc2R3JZdFYzRjVzNUVRbVVHYUE3c3VDV01WYytnbnFvcDQ1Z1F6QVVORU9qK25jRWgrNGJNdXBhRnJoOUJwbXQ2bG1YSVMxMUp2YWpsdVFOUW54U3czeGl4YklsQ0VRalE4QTVpUDFkZ2RnQ2FUY1cwQU53dHlsbmNlcElObGdiUTdHUUordUdvYklKUmpSNUpZaXBOdHdWVzFhdlFPdGdxalJRUVcwMjhZdTA4UjFSWXR3a1dld2pSbVJMb3B1eEM5dE9LZlprWS9SSnRqZWNJeGU5VjlJMjhRUUdVcU5UdGRoK3RFRXBOb2REUmRoUkFkSzBWUEl3ZGJJbnRmUmV0QythNlBSWHRVdy9ST0dmNlNJL3dDZ09ORFZGZ3NBSWRoTXNkS2drZGdRMGRGZHpvalI4ZFNKdUdKQWlhZlF4ZU1ON3FmNGphZ3F0UzN3K2lnNks0eUFSd2VpdzY3V3lBanRtNktBcWQzdHZ0U2RwZDVkMDlPZDZkUzB0ZGk5dWRLV1Fna3dGR0dHV05PZWRzUVZ4SU9DOHRYeE0xU3hvdHNCa3RqUTB0N21yQkF0UXQ0a1QxcTZ2eTV0ZGhsdGM5U01oMStKUXVvQmE5enQ5MTc5WmRab3Y5RWRHNnloalE1R0hvNndpUXVGTlp0d0VEOEE2d0xhOFNMeVVtNTZTRDkxYm91dHI5WEllcWx0Ym93REtnZUZZTTdzbkE2aGJvUFdhdFJnbXlXcFMwT3RGNS84OU5aQTZoejhiaGJOWTFmc3JvV2RhZGNkZ1Ixc2p4bGdXd2RDUWdGRCtpdTlBc3ZnaWFZQlZzMU5wZ01OdEEzNkJHOERpRGtOM01DU3FEWktTRE1qcXMwY09FRWhnSnhrbWozTW4wUElpTnM0VzA0bThqU213MW9oK0dCanpWUnRsSXZ3Zm01eEFXbHhLalZZZXFCbUhEM2h6QnF1dWk3QWV3WWpJaUI5d0FSUmQ5cDlJdHlVKzBZdEpBbDkwdFhRUjk0VGdOZkVPSlhEM3RFeFZzMWQ2VXF0U09ETUlqYlFjR1l4cW9ldFJBV3hsQUEyU1FqdFFURlNJVFlUVTFKOWdOb1ZrUVA2Y1REZ2M2Uk4vMURUaXQzRXFUV0RUUm1URzZYVU9UNnRBR0VOcWNNampKdHQzNlpUZ2dDK2lRSGRZNE1SZHcrZ2tZY2hVdzQ5WWRRRXFBL2RHRzRxeW1BMStpZFd2Nks4RWlxRmFsT2tCejhvM1FYQmVBcUpwUUNSaGgvWkZLTmhaUmlBUWdIaFNEYzB6K1hqVzRFMXBRekJRWWRtYkNCWVRRSlJhS3ZNQ1pYeStzT2dCZ2taamdqdG1PREY2aytHaE90K1I1VUxNTCtnZzZ5QTRBZVF2d0ljS1dlRVEyckpucTVzSkFhSWlBMklyMEZMeE9lWTdDN3NPcU5MR0FkTEJZMURORFlpNklsTDM5Wm9MTEhBSUJQTE1nQllBZ2JNeklMQ1lUSmlsdTRvZGlJNkVZWVFZQVVBdEEySzhBQmhCQVZBbEp3aHJ3aUlSQTBBOEFTZXZLamdNaDRBWnNMQ3ExdVFLQTYxcGdETURlWkFqRXAxVnJQZTkxQzUyS3VLK0toSzAyeEEwKzBBeTRTNExLTXdiS2VzU2VOTEFrUWdWclJyZHNVQUM1Z0YxWWZTQXlReXJycW9sWVIxZHNwZThyTUFWU05TZFNEU1ZjSWwrOUhFcDBHbzNac1QvSnhlZFJya1VUVFFwcktBdU1JMFhVWkZDd3l3SWNzQklRc0IzSnFVVDF6UjVBajBiVWJ6VmNiT3FLL3dsK0Q0ZFNFSWFpMlNWMFdUYUFXcmJHWWNsNXRxVWJmR3pBL3kybDRJUjFwZ3ZJTjF3QXFRUkFrUUhsTmd0d2s1TGFpQWVxWlpwVkFaQm0rUUQ4Umc1WnJBNW8vWnBRdHdEaWpBaDdDU0Y0V3QwOG9RZkN5d3ppaHdjMnBnZm04d2k0QTlIQXo3Z0lBQTlBQUhyQUNoQjRBQUNxK2dnSTl3VDZJbDBIcVFnSUVRUEFnSWt4dmlvQVVIZUF0WVV3eGgybzlhSDc5YlN3QUFKS0IzeHVLQ0pZeEtyRk8rREozbGhXYVpOdjJoWGxUdWJKKzQ2Y01KeHlIQk95SldzZTVjQ0dPUjJNS0NRSjdTUUkxcWtuTW5xR3NoTU1zbkNMSjhzZ2ZuQlRVWk9kc0JPNXg5K3pLQVVvSnoyYnArdHA5V21wRWFnVjNhU0xPT1NGOERzMGtlV0xVb2pQQU84T2NlUUhZTy9qU2thdDhMb05XQUFEcmtDUENUMVVqWVRNRElBcWpZSFVvekJFQ0VGT2RJRDhMcEY2NkZwS0RWSkpGOUt1NUFUSUJvaUtkVERLZUptWWhnQjBIUDQwRGlvOW9rMDF4c2QxWC9DYWZjZWtmcWNVeDJhZ0JDZUI0U01pY2NqaWVTY2ttYkdMSnlkVEFLZnRkS2R4RzRIclZxZDNqdFBnQ096ZElhbmxEeWsxQ01mdkEvVmd1VnUxTEszb2pwZVpkZkxaZE5BSWo1QnJyZ0JVMXBoZ0FaNXFuM1VjVExFQk9aM21GTFhka1VKUlBLeW1EMFlKMk5BU3BoMlk3amNqVDgyOXE5SGUzL0htREp6NXRiZWY0S3pBaFUxcFNGZHZjNTJKcWp3dzN3RDJsaUpaWEZmQWkyeFpCMWVxV0dmZmpJRW1lWnJUaGtqempiTWtEcURXZUJkVWpsbldCSWlPZk9lZkt1Y29qR29lYzBEZWUrZXNEK2RvQ0JmQmN1ZGhjUmN5MmtjeGZKSnhjSmZJQkpma0dwZExlOWRjdWdDNWNtYjVmNUo1SDk2c1pBTEM3cnBndVhSZHpvaXJacnFsQ3lwVTNtSDNkU29NNUxSVGVDNTNnQ0JVMXFuM3lON2d3RVhEQmVYTzVwNUYyY1ZvWGk5bzRkQThWaUlHZDFPa3k0ekFSQWZzQ0tsamdtKytXajdlRFc4YnFjRHlPTUNQSFRiaGFvNGJFTjZDd0Q1RmhvVUhrS0NnSHMyNjlWdzA1bUJSOVMreCtnRng2Q0FON2E5SW1jN0ltMkFSOE5lOUF5SnVjbXJGa0RrTE1uQlJFa0JMTzNDMWhHem5GSkg0a3BjcUFFZnNDRnI5SXBlWkkyOGJIN2xkQnpmVnROdlZoN1F0dUZ6aFhrdWRza1IwQlVxK3Z5aUREZXVEcXovQWp5bWZaR0JNcldBOExxa2pTM0RtRzNEclZIczFtREFjcDZLYjl5a2xCRUJPdGljdXRqSUp2dXNNUTBDV1VNVDBKcXFzWVY3VmswNkZWa0RlSHZZd2o3bmxPb0FzRmNnVFJiZ0RnRXdDbEFjc2JNWUFGWFRENXZFQ1NHMllBT1ZrZkFqWlIyMG5OcnVzaDF4UVYxa0tBdzNHZ0k2N0xjTGtvUUY4aFNWUUVBRHFtVVVDbURybUpKanQwdUppRXFoUmdESnhRYUJWaVpXRXR5amFoQmJnbUFqcnJjQWtBa0NCSUJTS3VQNmo1eUE5bXNDNWFjZ2FoSUFuWUVlZTlDUmhURTNMYmxtczNJUGdYYkh6NGZCTUlqWFoxbWNFYXhGa0J3K3NNVGpNRDBETDlkQkxpVzFIUUxLcFpNMTRxNkl3Zm9QaHhYdFQyVTVQcEd1U2tSaTBpU2haVnJ2aW5vQkxCekJNM1R6RzFFRkRMSVBRRE1lZHVZUk94SFVyQkpnMndmUUpFcCtDWmdSc0lnQ054OTZCVXVjUzFCSUFpM3Q0eElJZ3pITkhMQUZmNFUxdUFMa1RWa3hUQ0h0SlRCZWdNZ1RrSm5iSDVUb1hiSTdrNG5TekI4eWExM1ZnZ1NHQUJJc2pBTkFDWUlSQnVSQjhjNkRyWGRvckRoQ0NEUDRnUThRYVVIMEFDUXVoOVE3cUs3emFwQ05Mb0dXQ0lDUUVtSkVBbGc0QUhnQ1FCRUErbHdBa3hFZ05nQ0lCVHAvRU93b2dEdGdpQ3BCRGhoVVNZbXNOMkhBNFJBQUFLaCt6MEJ3QXZpVzRUOWxtRGdCTUFOdy82SFluQUMzQ0VLelNMWVR3R3dBZkRTbUdBRVlQeURzVDNBYnNlQUhnQ05GQkYySlpnQUFEVHdBUkJRT0kwSUZNMG1hUXJCK1Fzd2ZXSGdGd0JFQWdVL0lmMVBjRnJETkpJUnZpWFlRU0tKRkFvTGdkaWYxSFlpaEg0akNSeEkwa2Y2bjVENng3Z1NJeGtVU0pKRTNaL1VBQUNReEVBQVJQQUg0bFJHRWorUXpTZldJS0l1QTRpTzRsSXdrU01DQlExWVZnRndQekNwaXg3OVkwUkdJLzFDU0pXQXJBOEFtQWZLdkNPR1N6QWJzd29tZ0JFRjJHMWhUUmdvbFVRQUhVOEFOQUhnRVFDelRzakJSaUl1b0NORmRIM0JCUk5XRVVZYUlsRUVqc1JlQVh4RnV4TkUzWStSRndlNEZtajVGQW9ReHZpSWdOS0swU3pBWU9Ld0lGUDZoVkdRaWlnUkFjRVRkbnVCMklZT3RJek1iaUp6RVFqL1VBQUxYUkgwanlST1loRVJXS3JGSWpGaFJBQUFHb1lpUmcxb2xVWTZNdEZFQVlPOEkvMU0waE5HMWg3Z1NveDBmNGlJQ1ZqbWt0SXV4TTBtbEh4WllBRm1GWUt5S0JTOGlSZzl3Y3NhcU44UWR4RngvSVpjWFNPeEZab0lSZm1Pd0R3RVlEMEJrQWNRWkFNZU5QSG5pTE03WS9XQmlNWEYyakl4RndmVWJjRzNodFVMTVdpVWtYR051QVJBSWcxNG1XdDBKSUIyQW9LemdiSGtRSDVBdkJ5QTZ3QnhDb0FXUmdTbEFXaUl3TVFHODdJQTBKbXhXL1BnV1FBd2Q3Z1JBZldBb2hQQVg4UEJFTEhzUk1CaFp4OTYrSzRPVU1tRlFub1NkRWl3VFlrYkNMQ0NqRGc1SUVZRXhLSUI4amYwcnVBd0kvR1FBM1lTQVpLSWdMUkxRbnNBbUpJRTFVRDBCQktOQVNxNDRFRVJjQjVIQ2lyVXVZbUR0U0x3Q1RJVkoxSTdBSGdHOUthU0xnbG92QU9DRkxFM1pWSkZ3U1lrd25XQ2NUbWtNSEhFVDlnRkUyU1JBZUFHU29LTm1CK2ovb2RvaTRCY0FBRFNlQUJDdE9KdXhBbytSZUFPeEVRQnF3WEJneDBKZnlZRkxoSERJOEEyT0FBRkpHdzhjV2lFZ0JNRHh3T0pMa3R3V1lLV0hTbkxBOGM4VW5RUGxJakI0NVpnQ2dUckxjQXZCUHRRQ3pTVlJLQVJ1ek1CNXhvQlFVU29sdUE4UWdVK1lpNE8yTm1BcWlSZ2NVdW9EY09oS0Fqb1NreEFhZTBWR25Ra2VBTndrS2JjSkNralNRcHZpS2FUbUtJQ1dpZ1IvVS82TzhQK2lBai9vSTAvNkF0UCtqL1FJZ0MwbjdKTkord2pTZnNvZ000VWNMMkhKQkRoM3BRNmVzT1dFOFF5T1hVbnFYRkpvQnhCZGhGb29nRFFBVEUvVFBwbjByZGgzQVRIWUFlSXRZUHBHd0hyQ01vV1llQUVZRDZYU3orb2RBSDVhQUwrUFlEY0NyVXR3YkFLak54Rk5qZnhjUUxHUXNJMkczQmZFZU03Z2I0Z2VtM0J6SldNN1lZVElpQktCdUJreUNtWFRLUkduRENaMkFKbWQ2Vi9Gc3p1QlJraW1YRUNabVdUZnhmSTdnVDlpSmxDeVF4ZHcwQXBNVEZsblRRQ0lnTVdUSlYvRytJeFpJZ0xEb2NOL0dDanVCLzBYOFhhTzRFSVZmeGRpYmdTRk4vRTFadUJ6U0lRUGNFSkZBb3RFL3FPMGRpTWhHM0E3UmZ1V3dOVWtCUmRwK1FkQkVkRWlDV0JDaGFrbzlCckxaeFVROUF5MHNMTVRvc0d4YkFCcUNtZ1dnamlobUR2QjFxbEJIYW13Rm9LR1Zra3BRQ3NIN2tRREQwYWszc2hRQnMxc0I2d2dJenMyTU5xRDBBU2NndUpBSkxvWUdzRFNUTG9OMmNBS0J3U0hJQkFRT0hORUdSMW1CMkJ5eC9xUHlIRURzRCtKMjVuY3NqcDV4b0NZZ2Job0FORUo1MzdnM0RRZ25uRUFEUUNubWdCUE9vQVVEdUNDeFpFQjdnOWMrN0czSTdsZHlNUXZjL3VmNmtIbkR6UjU0OHllZFBMUkQzWndPdHdjRHA1elJEWHpNUW1JUXVLRUFYbVlobDVxOHhSQnZNODZ2QXgrd0FUemtjRkhuTHp2U1FLREFGdGlyZ3JCTWNOMkN5UDBsUUNQQWlJRmlScE9BQWdXdFpYTTBWTG9PUzFhSjhaUlFjMlVvT1N5R0lZS3NXWUFUdE9TMm1KNEtzRnZJUjRub2p1Q2dFTThqa01iQWtNMTRjc1NGb2xXWnNaRWRncURCUjlDaUNGT1EzWnY0aDRLNVc0TWpOQUNBSlFRVUNtQlF3RDRVQ0JmZ1BmTjRyV0Q1dzU4TDhwYk1WS1VIdUNRTG5Bb2loNFQ5UlV3YnBjWXlpcEJaTEN2emhWT0k2Q2dGRmdxbVNjUmNGeGlnaFIyRGlBdHA0T2dJYWFIeUVlQWlWUjRRUWJBQ2VtUW5TWUwwN0FZZWhyMTd5UHc4TXZXYmdYNHBJQTc4a0FnUy9wTUVvSXg0QjFHamdKUWdxRnVDdWxKVVpOZlNyOEFTVmZBdFdGdVEyaG5nWlNKTFA0Rm1aQUNrdXlWcExwOHZ3TXlxQzNNZ1dBd3llY0RpQlVTL2lOMUVnUndBMERNSGNvMFVWQldpUjdrT3loU3dwdEJINFBqdkF0b0JhVkFVQkMxNk91M3FSczRhWVlpaDhBSXNBVEQ4UkZ2Q2g4QklzNXhWd1lPc2l6RW1MUzhWNklKWVhRSUpSd080RzR3Q3FJd0JTYVNNRkhnTjdVNndHU2VFdHVCTXk5bE5BUFNTY3NnYm5LOE1ZczY1ZlpQMWgzS0VHRHk0SlJyTTFqZ0FDcUxrbXJHOHJPWGJLZFozeWdxaDVPOGtBcVBsRDdYWlQ4cHVYZmkrUkVLN1pTYkpCVTBBd3AySTFLbUluc1VrQkhGMndHNFNsU3JqREoybGR3SlVDcURWRGRMQndGTVZkRUNnZWdUc3FWcUFSNklvaFVYUUtoNGNDb29neXQwVnV4WG9uMFdsUXZHV1ZvTGhpYUlJWXFVRzVVTWRNSzAzRlFRQUVjaEJGSlF1TGNEc0MzQkM0MVlVTWk4QkVxM0FnZ2NxalBKRlVLNEM1K1FLeXF0c0FvY3FIMHpXemxXcHRxaHFLY1JLV3dDdmxKUzAyb1VSWHdPeWIvRFMwbHpORktXa3VKb09hdUp3VVF1UUV1U2x0dEcrRE1Lb2VLZy9XT1VORlhuakU0MytDeEJXMTVxUm9tcTVRWXRzMDBRQ1cxVzhjNkdvQTRuMkRPSlhFeElUMUR5U1huWWRWMEN2UHlKMnd2d1RzTzArYXA2aUVFUGl1Z3I0NVFlQUpFSFJXZVUrU3lsSjZob1ZBVEZ3VkJmSTdZdm1SK29EOWpWNkpKNnI2cGdib2hPMi9haW9pNVVMamdBQUFYaExpSFVVUVIxTnd3ZFI2cDJpaFU2MWhDRlFaT3NGaHpjN0tQRVhHQTlHNlEvVUx1TmlXZEJ1bktDQkNDVWZsR29NVEZIanNZNU8vZ3BLWEZBYmhGeHZoUDZmT3NpQTZYTHNXMDk2c2RRdExOQWo5bTZMNm9sY29CSlh2clVvWTYxSUUrdi9RUGdVNXFpTzlYQ0JxZ0Z0eGw5QUZjcVBCV3BScmFrTlJWeXNkMUhpaWxBaGJsZlFNQlg5VVFRZTJBdU1qcnFvOWh4cU80NGNSK2dNRmg0VkZJQWlBQ29xckJxRWh4eWloYXh3RlhDelNENWpJSEVNY0lLSWRRWjQ5WVFLTEZsc0NrV0lvN1JzaWtOZGhSd1kxa2txeEZEMk5qbU9oNDRDb2VPVnZuZEdDV2dGTzgzR1luSDlCWEljcWxvcHNQM3JFcDVDVzVVQW1nUzNHM2paQ1c0M2dwbXhmTUNDV0Q5S1NHS3NXelE5QXFMSHhHZzZ5alh2MEVNMytwVUFjUVMzTUNIMERtSlBOM215M0lYQWJnL042UU9nQUpqMEJFcVRFM3N6RlBBT2YwQzArYm1zK2daemdBRklHNHFLSUplZU5ZcVFCSHFXSU1MVURRWGgwSUVWNFM1QUZFSFlCOGtmUUZSQXJSVVQxSk5BbEdIeTVBTDRrempEQmF0N3ZCclZsc21JdGJDdFk2L1VqeUQyaGJSTGNZSVh6WUNHd0NaQ05pTldISWNNb3MydkFkeUpnVGNzTnVhejBSV05BdWNzU1JyQnJxQ3IrbWc3QWNXWFM1ZmRJd1ZzTkx0MXd5NEM5c1FpYWNydXdCNDUzaGdRSEVYTWtYdzgxWk4yTXc3THBhMXp2QnRSbXhac1Ftck8zYVR6c0JsRUlKTmhuaHppakxOMjI3Qm9JMEgzWVpFdzFwWkVvUmNuRFUyQzNTZGdtOW4yVUhUUlVIMjZXTzlDKzBzQjNvTk9wSExUbk5rSklQZ0FPSUVZRG9uR0JBUWRjT2NIQkRraDF3Nm9kME9tSGJEcmgzdzZFY0pPVEZUamhSeW83T0IzS0U3RDdjb1BVNnc4YklPdVlsYXFCMjBhSlFxWmdIL29RQzRBeWI4ZzBDWFNrTmtOSXNVaGhaUWl2SWdBQzJoVlFnMEFXMGp5azJSYTZPNGdsVGx0eVVxSkNCeVVZNU9Sa0lFMEJXaDVtMm1kTk1nR3I2MTh6T2dFU3p0and3ejA4UXU1eUlua1lCSjZoY0M2Q09zdmxUeDg0RjlFQWRQR3pvejFKN005aWVVWFpZT3p6MENjOW5BM1BlQU1sd29KSGIxaytBMHlqbDFacWk5QUJLQU5mSndBMUpkd0xCQ3U1WFpQbWFMODh1Q3EzRU5rWHN1aWZwaEtReTJodVpEVkwyaGpkWlF3V1BudWU3TWh6ZFJlc0Z1d0gyM2xZZWthVVpPTDl3M0JBOXM2UXFmNFB1bkI0YjBxNFBPaVJubXdPMWNoWWV1V3NYYVcyTGFSckRWZXFtdGtnUk9BOGRydTVBWnR1UUZiWjBiQzE4Nnp0RzgwdWp3amh1OGlBckhqbmsyZ0ZGTm9CWlRYaGpVM0xKV3BSQWVLWEx1emIwZEUwRWZIMEdUQ0VodkFla2J3SVNNWnZBQUVxR1l4bTJFaW5RdUxWNiswamthaEd5RkJTUWdMeVg2Y0VJZ2UxQUpKbUFld0tZQ29FYWs4aGg2bElQcURRRHdNcVlmc3pzRlpsTUdYU01BM1VQUlNNQlFaZmhad2RvWFZQQlBBQzgwWGtSb1RVVzNMakdrUURvT0RmKzE0QThLWU9CbytEZmxXWWpRc3RXekVjczRobXpmMHRPenNHVVFCV3ZqRGxsczBLSDcyR0JyQS9PSW1qMGdFRC9HTU9GTWpXM3dqUVdubURrdGFBSVhyZHJrYkpQYmtKa1BXUFZaVWd3Y3dndkVtMWlwVWxPYkFpTEJndHdGS2pBaVNvdW5FSm1KVmFGQXhPUzNKb0hJQTdsUk5sdkRvWlNHZmhvZy9ERUJ5SS80YTgwbWJtczRoeElLa1BiQjBCK0J3UFVmYzRrM3dkaHBRakFKWUo4MDBNb0h0RGZOSzVIb1lNTkNvT1NiSUNVSTBBUkExQlV3dTNSS29lc3VnS0F6TmtSemhuWWZBQU9INGxoUzV3L1NFQU51R3NsSGh0SlY0WjlRcGdZam01WXpYTnFtcWFBa2pEM1FXR3lGdGpjNTBqMEFGT29WeFEzRFJHZ2V3U3JUcEVYVWo4OWdyYkVRK2xrOGowSHZnYUlQWU4zUHZtWllCQUxnNUFXU3A1QmFHUEdEMVNhQW1ENUFkRzdnWFJ3WXowWTRTdUgvVUQrNEphVUJHTlNobmoxWUFJMEVZU08vTkNqVllJU0w4ZkdQeEg1YW1nQ0E4Qmc0UG13NGtVeHFER2p2V3JHYmZaUW9mMmNGdzBFU2M0VVNoektNNEJsRCtwSElLSWVLTzdBR0xISFo0ZGtMRUkwQ1VQb0FWQWRnRlFLbHZFTkNSS01qSWZPTURBWk9sQWxEaVVWUTlnZjdXaFVtcWZKeGRRS2RnQkNuR0FibE5FQXlhRWdFcGx3TlNua01kRVZOYmdDb0twK2tMOGZWTytobGtGUmZpTXV0c0Rxby9pbGxQekJ5WWRRV1pCS3B6TG9BUm5GUDVINERFSjdVTm8zQzJNQk9UL3FjVTJiRDh3NUc4akdodTA2Z2JDQThoVFQraUg0d1NqdjUvc2tCTFpXNCtDZDlPT20yUUFaa2dEOFlTN2FjN1llQUhQa2tHZ0RHbXFrenBoMUs2Y3dQWUh6VHlwWnZSSXhWSlNHK01YMi9TSHdkYzNlTFhZMUpsZzlxRE1CWmFtRUE3WExkU2FPUGJIdmdUVFZvaU9xY0h1eHc0VzRJZzhjSHZoMkJjRGhFWTRJWEhFTko0U0lkZ2FlS3lhbU1NdHdBUWFwZzAveWZvQmJxVFl1cnM3RXBJQ0Z3R1QwYUVnRnNlMU1aY2pOU1cwYzFNZmtQcWJhdEpRQTFhRTF5QzU2Um9QeVJvSHZDWU9oVTd6cmJaWTcxU1l4YlFaMXpBTS9MMEFVREg0K01nbXpFT1lnYmdOYWVROHBobUNDY3R5TjVmem9GNFlnaWVPaWJsQWpFRm44d3pHT2d3V2hJQlVlQzZDY2dzVUpqZ3FGd0V5cG93dUlYZnp2eDNDMXVIVTBFWEJCU0ZtZ09wcGd0WEhUYXlKeTJGdEJqbmtIMHM3QVU2cklkeExHUUxCbDBGMEhoYjVBVkV6Tk5BVUMrUmVBQmVodkNTcGxtRTRuQXVDRFJMQ0o5QzFKWkV1K0FvVFFKNFN6SmFFaGtYNUxJME5ZdnFaNVJDQTB6SkFKWUNhY3pPQm5QVGVaMGxDYnZxNm9MNTlnSUJrNldhbW8wTDdJUFoxczdQRTdaVEpFdFZtNHZyWXRpWTdJanovMWVFeWF1ejF3TDRBTGk4V3MrY2Vyd2psS3hPQ0xRYURHS2hOeE5nZ055d29JY0RUbmZMOW1oOCtmUVN2ZW5oMS9jYXJZOGYrcjJXRXJSVzdwRXdidzIwWFNXSEpHb0Q5U0N2WUFRclkvVDZxMXZDdXJaemowOEZiTVhFcUsvcjBTb3NNZzdRZVEzRWdLcjR0WUsvQUZDdFZhR3I5ODJyYnhiNVdFczlMQmxqTXk2YUpQbGc2WkEyZk01YWJNQkZuckxkbXhKaTRlSWh1YXF6VGxtczFzdEswTm5pK2FWOHRsMmNiUEZYanJOaVh5SjJjNHRpMFoyUTUvQTBjQUhQM1hpRFBsbldoYm92UW53cHo0aDJjL09lcE9Mbi9nL205OHpzWk9zM1dMejY1emM5SWF1UWpkYno5NWxjeVAyWURQbW1qUU5rNDUrZFhTVVdRNUFGMTBLQUFhMGxnM0tSZFVxNUV4c1RMOEdMcEJtZ3l4ZEFEY1hQWXlsK1M4VnVicHJ4bFlwTjVpNVFZTXc4V25qS21rZFpTYXB2NFdEenBtdm9Db0FYMXNGWHJDaDR4bXpiNUEwQW9yVVdrU3dpZWhNODNFckpBWksyOWZCampYYXRld2JTd2tGMHZwbUtJZ2grZ0taZmt5TzljZzZBSWJOdGVsU1JuK00yeW0wMWFDT3Vpd29EdGxaR3pTY2VqVmtlQVYzZFhaTVF2eWhWNURNQnI0R0lVRTI3d0NzUkFZNkdWbU9CRUJmanlaNS9VcmV0dXVOMEFqYUgyNkJid0RIUThBQlVLSlVDZER2Y1lCQURXcFZpcTJkaFFIdmJnNkpPeXBwQktNNTZRbnRxY3VRcFZWK1lNOGZhZWFseFJ6emhZdlc3dG1FSXF0THVVS1VsbGQ4bk1IRG9WV21LU3lxRktwemxQS0pBWmk0U0N0Z0xpOG5yYjJNb25acmlMcGs3SGFlOWgyMHZYQlRPMWxkY2RGWGZoTnNCdTI0eGxycmRON2NaQ2UyZExKNzVLcGFBQUVWUHRSOVNOdUlJWFpMdEFVQU9rWlZVcTNZN3R3ZEI3S0hmRHV2WUg5YnRUOXhIWU1HUjNYY093ajdESFM4bGZiWTYyb21uVFFEK3owV0U3SjB4TzFHYVRyQTZRZG9PbE94RGl1QnAxb2NNT1dISER0QnlaM3FBV2RKSGZoT3p2MFNjN0tBRTdJKzd6c0c3ODZyRWd1Z0RjTHR1Tmk3SjhYaktYZDJaalZ5NzJXRzRaWTFhQW9CRjd1MmF1dmFCcnExMEpBZGRxbWVVdnJvcGFHNmtnNWw3R2tqeE9BQURWY2x1bk1OYnVNN1JGVE9BRUN6bGp4eDZ1NjRpSHVwemt6eDkwVTg4NC91bW5rSHRWQ3U3UTkzdThMaEhyWjZRYU9BZEJMbmp6eFM3SjY4QnAyOVBYbDNGUktFcmtlZTE4NFhvTTY0SWJIUFhNdlQybFlmNjJ0SWpOZGluMFBuU0tzaE1qZTBnTTNyTUN0N3RrRWppM1FaeTcwejIrOXhrQWZZRDBXTWo2djkrTkNIaWxpcmlFT1o5S2NRdG92cjJnSGRkaWhUc0c1aVEzMC9odDlicXZmUWZ2YmJIN3UyV2V0QU9nQU00ZjZ1ZzMrMG1IZUNFakxnWElrMUtDUEtGczFDUVJnZG91RWNOMlJIT2pmRW9ITVp4TStXa1RPcGNXNFJVZEtPYkgrb0xnd3lFWU9BQVdHUkEyRGN6b0ZBczRyRnJQZ0pHd3d6WDlDODJMQVZBNndRWmZoc0NDR21wcmZtWm5FUkdPZms0em5JN1JhMlpjcjBHMjhJQzVBN09JTzAwK2hTZ3VNRWV4ODhzQ0RJUmtOL0NaRjJRNkFEbGFRaGhtNE0raE1PUzdJQk93Qm8rRlFFcktrS3pHeTRPTDRvdVV3N1dBWVN2RE1CeWlVWEtPQXhtbkY4RXJFbjdGZ2wrTHZETGM0WUQzUFRuVmFDbDhFcTgzc0EzZ3hMakpTeS85VHpqNlhGdWV6ck52MEFzdkU1cTRUbHg0ZkJrQ3Z6Ym1nVFFQeTVaZVlEQWw3aTg5QTA5alZNNXVYZ2FNbW85UjlWL2J3UXUzS3FEVm90V3o1MWVVV1NmS2tjVDVMR0dZdlFXek5xM1ROVzVYZ1BMM1d5SStrRUpOTVNZQzd3dVVCa1h5aDJGM2hMVFBTREFnRzBydW9RYklhMElManVVbkQ5MmVlRHNIZ1JUQlV6NXJqZ015K2VkNjJMTGVsZDQ3b0RTWEVCVlY2cXdOMXBiTmY2V2Judkw2TnphL0VhZDJvZXAwWHNOV1hsQ1NiZ1RnaHkzQVpqNkNsdkZ0dnNjeEZXK1hDVzRpbkMyK3R3a2NMaXVMRzlHdGpOeGJrYWtXblkzdVEwNEFXK1pBMlFyWUVyTXQvNmdyZTBBaHR6YmdXeE8vOVNMYUR1TTd4YlZ5RmJmM2tPMzAxNER0bTRMT0NHaUFjUjgyRHU4THM2MW5BdlFZZ0hFZTNkdkFaTk1zZWtGMDc0enQ4MFFnaHJ0a3REQ0Rrc3NReklBZ0JlL21OUEJyMzkwTzk4TnpwV2tCTnlsbTVySUlld1hodk8zaEx6UU5hNExOa0FnUFdpcmFGZTQ0QmZ1M2c5N3FIcFBHRXQzZ0NBcjlyY0hCNXZmZnZxVi83MmJZQjhBTmdXNGpPNUFsZC8zSXZnQlJORHRJRXlrckNPYXQ4SG1wVmQzNWxKZjhNSVBscDBoTkI3dXVZZVAzOEgyOTRoNVAySHhVUDY1Sk5EeUN3OElmWGdDOFhEek5wM0pidkJnUm0yRTZBZnVia2ZSTmE3V2o2UzN1WWdmcHI1QWNkYXg5N2RENXZ1eURWQUtrbnZqQWdtRUFBeGo0cUIrQWJ1aUIrYnVmUVo5U1FhZm5HNEhxejdwNVhyc0FkRWxhSkhIZUZWaWgyc0szcjhsTFNRYyszQnVYT243aWdxZzQrWWxETmtielZsdTZDK1d2TWlqbDFNQVBpOCswa1FzVW4vMUtyR2MzRUI1WE1ZQWZLWUZDQXBmUzNBSCsrTTVvK3NVa3BxSFFJdUVNUHVKeWVHM2dYdkxHbE9jK2hlb1BaN21ENUY2WmZSZStqOVgrTDF0RDdMYkI4djhBU0VUTzZLKzJSTVFFZ1Z5eVZGeTlNVUN2ZUh5M01WNnhEam45MzE3ejFNNTFJUXp1SmpLYVFML0YwU0loZmJYcDdsL0J0ZmJ4UmZnQU1YcmI2dUh1WTlla3ZVM2diNmw5SGNaZjV2V1hpN3lISDYrUWpDditIdWI2TjlLOGN0eXZucUc0VlY3Vy94SDZFNmI2YTRobTdkTFdMTGUzb2JtMTdlREhlK2pJUDdyM2xFdS9QZWJ2dzN6TCtONXk5UGZwdmFYOTd3dDdLLy9VS3ZvSFA3ekNkcS9tZXpnbldIdDZGL0MvNWtvZkhYMXc2VDh5SWRORXZmWGxMME43ZThqZUpBOE5QSDhBRHNETGJxdnhIamIrWjhtQ296R3ZlOUN2S210cUVUQTdlZ1A2NTBGK2xCQy95Zkl2dnQyTDV1U3krQ2s1bnBsK0NDOW83ZmMzR0ZMQ3ZJcWszQUw3MnNaMjArNkY1RGd5Sk9kQVYzQ3VCRmk5UDNRNFJqZ1FqbjBBWVlRSkxNVFg5cTI1aGplS0llcktYK21mVjllMHBKd3YzTjZpamtVYWdKZHVNUU1JYjZNdkJMTXJZdGdKbktGZUFXKzJxWGpFZHdCNW9jamZKUTF2eW80cXFxeDNCMkFEdnAzNzc4dUp1L2ZNTnBIYUpyRG53QytwZ2prTFgxZ2cxUkFKb1BjM2JMK1pxTzh4Zlp3amtPNEttOUFKVUxBMzlFUEhBTVlUYzBjcUZraTdaRXI1Y1RNQm9YTnd4RUR1MWRSY2hRTzArTHVDTkZsUWpSMWpteGk5SHNkcXVYUW1pU3Z2TUZ6NGlCVFRIRVI0WTRDSlpscnRFbDV3QUJhVXI1WUJIQWQwMkhSN0FqYllKN2t4MTZJWUNkRXhIa3FCOVR5MERnSTNsQTZ4bFA0LzM0bjBENzh4K2tGRUdyOGFtTnFDVjhnQXRzRUM4ZG9jZ0JBRHlCSmFIQUQzT1ZYd0FDZ3ZGd0ZnQ2ZBTGR4M2NOMGVVRGlNRWtjSWtHMW0vUG95K0Fwd1FOeVRkTnFRU0FTOXArQ1UxajhMQVY0RGswSkxlTjBTVlRBRWVGZzhQM2FnSWs1c2NSVFZUZFFBSGlINW91UEtnTE45YUFxajN6c3VBbmlBRDV2dmNoRzNkd0RUdEVLMUh2T2pWYUltS09qU3hCbk9aelNWOTVvWUFGVUNuSVQxQXFKbEFyRUJ6RjkvUVh5MENsQTJlSGtEU2djQUlsOGhjYlFPTURzUUJFMWNZZDBYZkNnRFlBTW56QjlFZU9iblFCcGhGY0VKc3JJUENBcWRLdURwMEg1ZDlTa24zMHgrQ2ZsTUp3SE4za2ZvRVlVOVZYMUx6YU5WbDBmcVhrbUg0b21LcUFQMHgxY2xubmdUOVVEa1NDYkVPcnhSQTg0TkFPUGNXdkozaWI5MnZHSDFjTW1YRHpqQUFhUVdSQlo5eTNCNm1hSXNRR1RRWjhsdkhQbDhCRlNNYTFDQW1FUXhRZmxrcVFMd21BR3ZlWDBEOTZJU256eUI4QWtvSmk4K2c5djI2TjBsTHZ5bUNlL01nTkdFOFlOdjB5QkdJYUp5M0JuQUtrR3lGbGdzZVN4QmNWR05EbmdnRERvRncwc1FFTFFZZ1pWQ0lERHdpZkZOQU9DTEFvd05PQ2laQzRKcThVMEkzV1FDK2c2dkFHQ2EvSnBBaDlCbVVZT2g5eGdpWUN2OEdBdEpUSUJlL2J2MEg5QklSdjE1QWxnaFZFWWdhbFhnS2doVUFEWUpSUVlRbllMQnBGdlQvd1dsNEFBbnlBUS8vZm54ZUN4L2JqQUQ5Z21LUkRpUkF2RlFCVUFzM2Q0UGxSbXZmYndpOG1jQWdOY015UXcyZzc5ZmdJZndvRDJBS0VQQ3cwZkJLQ1JoWCtiWkFsd2xBeFFPeEFHNWQ2Uldramc3RUE1OEQzWUFEWHg2SUhFTzk5TzNQT0JXWjhnMFgzMzhGUXVBVkpDK2tZMkh5Q3d2UW9QRTA5ZldzakIwRHZZb04rQytqSGFtTmhKZ2o0M1NWNWdpVUtXOFJ2UWMzc2daUXk0TGxEcHJOUUdZQXRRNmtNaDg2UXNZSk5DbEFCdkVCRCtPTUVQTzhwUURVTjVnZkFaS2dXRFppQ3J4bzBMRVErR2MxeUVHVlU2eFpRMVlNNTlCUXlXZzZDOEFPd0VGQ0tBR1ZRSkRFd3NRS2dobEFiK2lhUXpnMzRCcVY1ZU5ZSUxDMThJc1B1RHRncEQwNFZ2dlQwUW45MzRmZEFia0FFZmRGVzlIUTBrT1lBbkFsNXpZOTYvRkRTYURHWFkwSVpDZlE4MFA3OUxRMWtMeGdDd3R6QnJDcGtOdlVxdG0yUWF6SDU5QVIvMlVvSi9RYXpCMDBRam9HYzVaL2RzTWVDblFqMDFZQkxrU2tNU0Z6UFdYeVZERmZGVUx1Z2tBNlh3Unc3b09YMmNEZHZZWUlIRDZRKy9VT0IyK2VIeG8wbjNURUZTUVdpQUN6NVZyUXovMjRKZWZkYjMzQ0hhTjhOREJYY0k4SWZEQS9KOEorQ2FmVjhMdkNHcFlYVUREUHduSzNSQldpUzJuL0ROd3NtZ2RDOXcwa1BBalJPS0NKN0R3ZldDT3A5U2doQ1BiNUNJajhLeEFRZ05DTi9EYTNYOElBaUt2WGNMNTlRSXpLQVd0anc5QU1LQ2RpT0NQSWlIYVpRSHA5NWFEb0UwdGdJZ0h6YURuM1BLRFhVUjFJV3kwOXFsZVFJWTlrQXo0RzlsTkFIMEpYQTlnYzhLSHh1TkIxRUlCaXpIM0QxaFZKV3NCNDBrY1VDS1VqZFFJNEJJQVNBUkJrSkRRQXRLaTBqUFBYU0w0MUxBQXlKNDFwc1FSUXlGelBEWUxkQ3ZnZ2ZsNGlZdlJFTDlEeHc4Z01XQ2t2Y05CcVZ5Z09jUDZzTDBSY05BQmx3OEFETUM3ZVpTZ3pDZ25DTUtGeE1nbGlKQWpBdlY0Q05BdklqQVBBTld2VDBLSERRQ0xLS1pDcGdwTnhtQ0xRNEVQbUR1a0hBSmVRTE1DRUt2YzJBd1FQazFBM1JpQjRDV0EvZ0xqOE9BZ25CYWp1QXE1Q0RDallFTU0vaGtxWXNKbkN5d21NRnZ3V0dVMEpEQzE4WWFPckNzZ0dwVmxRVW9oc0pZWmV2T2hDUjkyQVNBR1lBNFFEYUlQZ1dLYy9uMzBLWkpySEFOL2JJU0l0aGlnQ2Z3UjlnQWZkQ1I5bUFTQUZZc1lRVzZJUGhtQWVMVitjWlZFUUNPajRUWU95MmhiQXo0bjZCa3FTUU0ralg0R1ZXd0JNaUNReXpoOUFUWUlSbzIvT1BpQmpiZ0hnRXlKN0NBNk5TQk1pY3JISWdJWWxobHNDdlFXR013QUVZck1OdUIvRVRJakJOTkRTMTBwd3lzUEdMcUFTd3VrelNnV3pOa0IrajZ3ODZQaWpLY2JRS21BUjFCdVFrMTB2S0lDdUNEb3Y4UStqc0ZjbU44UlFZc3JHZURwZmJIa3M5T0l6SUZJaUNvK0NLTm8yL0FLTXFpSnc4WjBSQmk0Y01QRUQwb3NTSVh3eHJDYndzRDVBNk0waENRbzhMR2MxRUFPZFFxSkM0QzJDU2k1MUVxRW5WY05lU0xHRnpQUE1BMGo0QS9mMjM5ZGVjejAwQWlZS3RHc2l3MGQwUDh0U05LV0w0aTNZeU1FR1U1WWdNS0tzd290WnlxZ1FnWXVHU0NsdzNvRlYwcFNLbGx4OUpRK1Vsd2pXSXBpTVJJMVkvLzJsOGNVZWdEN0lZQXoyTUpWTG90UHg2c1lncTZIRGlkell0aC9SVzJmNEJSTjBmSi8yc0NoWU1heFNZbEdkL3pNOWtBMGYyeGQ4NHdXQkg4TTFhOFBUTmpvYWpoeWlXdkh5TElpWXZmdU01MWc0bGtLQ2pJZ0ZFVm5DSTRpOUdYQ3grZEVIbmhhTmM5bmpqa283N3lBalpRd0x6SGpVQUNZQ1FCN3c0aUthOXZJL3NOOGkrakhlTDNpb1lVY01ZQ1E0L0lHbmk0ZzdaSG5Db28vWTJVb1Y0dy9peEptQW1YR3dpVnZGT0l5anpQUFlDcjlPNDdVSnBDOVZFZUxQalpZNWtLcWo4Z2J1TEg5aVFFZ0ZBNXNPS1pDVjlEZ1lVSFVEOS9kZ0hGVnFJQWNpVEMyUVU3eFlZamdLRU80SVJvOW9oQUk4d3RrSHdUOVl2R0lGaTA1U2NJbUFwUWtYQU9qSmlUMXpyRDZRY2hLdWk2NEE2UGVqUUkwZWlJaVkzVVIwMGlUZ0l5TnRnSEltZ0gwaWdVV3NENUVoUVMrTkFpZWdKejNGancwUHQycUNadk1kenFDMC9lMEF0UXNxWkFQV0FWQUx5TnJoY292eTJEOXA0VmVOdTViNlAySmk4dEVxK0tCRE8vZHd6SENlL2NxTEhEaWxLcUpxQWFvc1ZENmkrQTAzMDZqYmdacUttQ0c0SGlER2ozM0RxSm9DdW81dEVEY2ZFdmNsZzhPUXNvQ0lUWGFYV0pjQS9veUpQdUNBWThPMDU5Q3RPd0dZQXdvbVZVWVRSSWh0eStpUlBOdjFFdDRremhMMkNZWTc3eC9OamdsUUFxSmNWZUpKQmlza3E0SlNqU2t6RUdaTUtrK2lHWEM0WWg0TllqaFk5TXkwUzNnNkNJK0RLS1BSSjE5cHVPS0JmdDhnWXhPMVJUNDF3eTZTTEUvMEpCRFpncXhMNzlFbEJ4S0g4NFF0a0hNUzNNSUJGdUF1azNtTFRpcFEzOE1zQ0JWYzR5WGw3Yk1LSnFUUUlxQ1FzQnV3M2hOMjhoZ25VTjE4US9jTlhQTk9QUTd5OURYRE01SW1pSjRxMElYZG0zT0tQMzgxQXo1TkJNVFBWb05ZSTJQZHpGMFlnZEtwVTBzTThVdWg4b2hOUkUxb1VON2FtTzVCS2lSN0IwTjQwSnFrNEFiekpxa1g4VG8rbERnVU9TWXB5U0NWQVp0aFVCbnphdVBSQVZBQk9MRVJhU2JMR2FKeVVrSzJiQWFsQUJIcFRXaUIvM3BTZGd6UUZMQ3gxZGxMWlRmdy8yMjVKMy9jb0hZQlFPZmFDVFFSTEc0V1lBWmFHNFRvUUc1UFlCdUVGQUNWSWJoUUFHNFV4Q3ZRSTJJM0pSYWJuMEVVeGhWL2pUalA0RGdnN0R6UEJNQXVTYzNJa01kaTAxUTFON2pPM1ExSXBqTzQ1VUxOU3V3dW9BdFRwckFxQUhqQUU3Mk9IalRFdm8yZFR4NGlCSW5Ea1JPSUxuam80M1lFbHdnZ1laTFhpMDR6ZVAxVGtBcjFOM2o5NHdlSmZ4M1VwNU1LamJnYU5JdmlPZ2Q1TjlTWjQ4S0lmaklvbXF5RFRWc0VOTlhqODFLWkUvakU0cGIyL2lUa3piM0p4K3NPUk0rRHA4WVlJaERCdzZXTWNnVkFUVmpsajVrdEpVb0FXb2tPT1dTNkFDSkphVHpnNmYxeVNRbzVwSmxVcUVoYm5MRGFFblBYaVRHRTVYbkNTQjhXTWpRbzNvcGhKc0FES1BjaUVoNnZOaExqNFdra0dPNERLMG5XM3pqMlNGRFRjQ3dnbVlWQ3B2QXV0aFhzL0F1QlFDRFIrRnluYlozQWpnRWZwaGxUVlZNQ2ZrcHlBbUVlaE1YMThCTnZFZENEazNRc3dDVU1YMFZ0SjlERU1UUUNXQlVreUNJSTQ4amJWZ1VBRkFONERHOGNVWTVoWXBIQVVDTElreFhKbDNIVlZOR3RMTUEva25ja2NCelBKUUJ4UTQwajBNVFNtMG5GQ21UQW93TUxjVEdvcWkyV1F1UTdjR0RDNGVXYUlIVFlRcmFGd1MwS1MyZ1BoVFBHcFFPaXgwMGhPQXdEQ01ta0JzdU04b2wwQ0dFeklqOFRlUUNzSTFRbDAyZElkQUN3b3NDckNkMGs2Sno1clEzcnlMb2J0Vm16aEltWFRkTHhqNFltc0lSTlAvTDBCL2lBZlRiMkFDRDBuMk9QVEFPVTlMMmh6MHJmVjhEZm5hOUw1SmIwa0lOZEFUMGp3S2ZTSDNBL3lpbzlBdE5XYWdQMDZiQy9TMDNhWDJhaDJzTERKNlNiSXFIanNpaEV0YXo0eEhJMUFBTWk3RWFURndkTjhaQUo5Q09JaUxLOWl2Z3cwSTl3WHd5NVcwNTAweDdHd2piUXV1SXpqY1FrTE9RbDFJbTFMN2Nmd1FSSjBqWXN2U0tjaXhFNlZqVWpVc204T0ZjMEFzd0VDOGhYRXJCMFRzczNVTHVTYXlNUHdFaFp6ZUlPZWdyTFNWWDNaZEFEckloOTdRWlAzdzhETVdOVTNKZFFUUUhrZ1J0TmczcUMyaUM3U3UxLzZPaU9CbzB2UmJNMnpsczlETXNCMXMrMEhNZ2FGYXUzTHdGRWlvaVNGNDZFVHcvY2VzdGdENGhrMUhwRzVoR2dhNGlKNFpHY2RESTRvS05TTFA1eDBkZ0RPZEdBV2tqUDU3TmJiSWN6MkJMR1RGUUJMSzl5ZXk2NCtRQ2VadVFYekhnQVgyY2hUT0I1VklzRTk4UnVlU0E2d1dLTitEejhPQVZlQTdod1FVVUJYZ0dZVW5MZUFqaUZMSDBBYmhjQUMzTjNZTHVBaHpMMHBpaGxOK2xIa21Kd3BnNGtFRzQ0cEJreDVKN1FSNkdJMEhzaVUzaHkrSWZ0UWp4elBGYklsZFhVOWp4dVRCa3diTnUxdy9QQ0c3SkpzazdIRmNac29EMUd5ODFlYk5xQ2hjY3lFdHdWc3RiUDlRQVVuQ0JIVi95SmUwdTBITWp5SHkwckVDb2lVVERza2IyT3pWczA3T056QVFEYk5vQkxzdWhUU0V5SVc3SjJBbHFZWE1Fc3hYZmx4ZXpRR043S3JBUHNtL0J1SXdEU0V3Wmhmc3U1SDJBQWM1OUdCelFjdWxIQnlMY25iS2h6dUJHSElEeXBjNFYyVlJKOEpIUHRBVWN0SEtnbGdsUXVDeHpTL0hITXNBOGNpbEZ6OVJRRERCWXA1U1NuUEp5UkVzbk9wenIwT25JWnk1ZWNBR1p5RzJMenpaeStNRG5KYWoxT1huUFp6Zi9RWEpZWTRjb1BMenp1SWNYSVR4SmMzUUdvOXFzNGtJRHlhTWp3eUJNdkdHN1hRQXR6VW9HQUErY25mTlMwQ1ZPOEExQWtTTlgycnpBVUErTXVUcnMxZktxeFNUWDlMQXpnQVpZM1B5SVFGaWdBRlNnQmNuNlJmZlNmTllEWEFHc0JaQlFJdzNLeDBaYzZEM1JJbEV2amlkeWpjeGcxc3RTTXZpTUFLVlZIMUtDalAvWGZCUDBJQ2wzSzZvM21BMU54UXhJVUNBc3pBdk00RGxBYlFJMkNzak9JcnJKSjhDY0N6TUI1YXMzalJFVExBQVRVSFEyczlNM0dRODRCWWlJTE9zd01ITTlHQUNHUFRsNkFtWE91VDQwbERRb0RHMHZpTTRMTzhJYUFvemdRdXhNU1U1Z29meDFRcnFRQkg1b25xSzVCK29LdFZ2QUFRWTRxVUxmcGdLYmFMZXcrT2I3MXBKc1F4MExUaTE4UFZMd2lPQ3JndmpCeUNtdE5seitDdGZSR0RRRTF3eEVLS3dBcUhFSzVrMEVNbmlGZ2pjMzMwTzRCUXBjdDBVMXpTQ0JWQ3F1TjZBSmFab243aHRDa1AxMExPZmZRcE1MVTQ3Q09NS0swamdzc0xNc2poVUNBTC9RL3hkamtBMFVIS0NqVXlEMlBqYkM1OE9lU0hDWVlDRGlFQ2xDTjBEeWdad1Vqam5CSUlzOVJOQzROMndqazRrNUxUak1xQklzeUtBRXF3c2xpWUNtTDFzRENzODczSHhUb2lRTmxETzBNVU1lOXJZN0VGMWoyUWloTW9Cbk5ma0lmbGx2Qm9BdGlZd0syTi9DZGdIY050ak1pdXdtSXo4b3JvcjZORGdGakY2SzA0NWFKS3lYczBEbEt5VE16T1BUTmtFeHhtWHpUVXB4Q3VMTldESXVsOG9ZQ2tPU0tKWWxyMUpTdFkwd0dQWTB2RWpLTkRwWTU0dUFCL29Ud1JwQlpVVDBRMmM0Z0J1UWlBaGJFSDFmNFIxQVFHYnBpOWV3b2NJZE1nNHNlU01vUmpORENJZk1PSlNpTkFqSEdueDlvNHNKT1RzRXN0TlVDVVFNbWdKS0VrM01PK2kyL1QrQ3JDWjAwc09wS0I4U3NMeGpPRWhhSXNRNG9DZUU5RjR0T0tIWUEwd3NFczlGSVM4dk8vOExuYkprLzg0K0E2T3FTdDR0WDFDVmVDdmIwU1RCbWVqS0VLWXZNU1dJRFNvMXdxbUNKQzZ4S2tMdTBoakdNMWNBMXhNdmRXQWdRTG9DTXdBS05DVEpNaHFPTkxrMDdxTzhUZW94YU9veXJTMzR6Tkxlb3JUTWxDV2cvdE41aWNrNzczZExSMHowckJqT2ZIMHNPakVrc3JGT2pBeTk2T0RMQVBZelZDQkpMV2QyYmRJZ2RTVTRKVlFMckFMMGxvZjFITVFJZ1ZlTDJBZVVoaTNTOUlMTEVFZ0FmelZvaytoeWs1OXc3Z3VVaGVGeEsxMEJsSldMdWtVa3U0QTBrM1FMU1NUQWdnQkxLRjRBNkhMTHZrdnpMSktHeTN4SnJLb0V0OUl4eEN0WXNCV0xTZ0ZtSWtqMXlWc3JZSWVVc2NvWGdXWTVsSTdMMlUrU0lZdFd5ejZFSzFJQWNzb013T3lvY3BuTE95cHhHYWdFQkUyUEN3MDVDb2t0b1g3U2NvT2dzeTU5M0xMVmNXclI3S3lzTWEyVEtTZ2RjaDdLZ2dEY3BySU95dThwM0s2eWc4dU9Dank0Y3Z6TERFbXNrbktPNFM4cld3YWxMY3BxVWR5NGdGSFFFNlVvRmVCTk0yclNMZ1p5aWYzTEtrbzVhVGloV3kvMmlqQ2V5bG0xdkx0QTgvbGcwcHltM05BckxhUXJWd3JuM0hyU2ZMU2dWV3pQeUdVYXROZUtLOEtndnNpR3MrTElNaUx3T2lvbEFjZ2pYd2RpeEVKWHkvekhpbjMzTXp4WTIxS2NSeWd4MUtZOTJpMTRxQVREMC9JdkdUUUNTWXBjTDNDM2RWbmlFZ3dOSWZVbDQyc0xJZ040dEtQT0x5c24zd3dUU3NZU292QzAxZEJPb2dCS3p0M1dDa1lMWW9INHBlT1NvNEVFUW5rTjZMaVNoU3N5Qk1OZEZPVm9mcVBlQXZRRWJkZjF5QlpVVit3TW9lSVcrUHRzc3d4aUZjMHgxQlFGbFNXNDc3ejRxREt0ZEV5RFJoVm91bDlpVFowRDZ5NjA3aVBOWTdLdkxEbXdBb3haTUVnYWdJNHUwRCt0WTRHbzRPSUovak56K01uZUsxWmtRaHBPS3J6SXZCM0txcVkwdE0vOU1Rb3NGLzlJMDVLb0VqZ0NvZUpQaWtTamdRTENuS21YUlVybTJCZU9BMTQ0OE5MS3pRSXZMRUpRTEFhNG82TEFEVEFKeXlsU3pyMG93RTJXYXRiU1NBOVVvcWliNDNVczBCOVMrcUtOS1BFcnhJdERXbzRrc3RLUEV6Z0s1emVvL2pQT3JBa29RTHd3ZW8zeFBBQWFBUUVSdUNINWUyemt6RmkrQTFpU3F3ODRNU1NhbFYwcVc5eFU4VXQ5TGd5cWt5V0tSTEhsTkFxbWdVQ3IxSjZJbFFGQ0JLeTBDdUR0d1lVQ3VwU1VvaEd4QnFneW5keERMSklwbVBuS0syTnJWL0NnZ0ZaRy9McnlxWUhCaHl5OTJDSmpKUTJhUERLZDNUdEg5Uk5ZaUdxWnJtVXBtb2FEdDNXclVJcjJhekVHMmlhTkZaQ2lBY3luSzBLMGdnQkd2aktlYXVJU1dqazBlalZBcXRBSGpPQmpQU2dhSFZkL1VQVEpLVTZ2Y2hLMURoZ3Q5MXl6Q2lqZ1ExckhNOUVHbUl2cW1nRUdjNFJFMk1HSVI1SGtGTnJaZ1g4TkhOZnc0MnV0cjlrdTJwMkNyYW9aeHRycGlOT0o1OHBTNUFLbGR1cS9id0d6Sk5Xc25EOHZ0WDZIZ3FRUUQxTEtERmtYMmxEcXVBVHAxWURGa2U2RTdaSWkveE41QUU2dnRWak50Z09PcW9DMDZ5Zm1Oc0VCZFRtS29MbE14MjRFWjJIOEhpbFB0VmZKenFGNEdJcUs5QmdMVzFPSW9nT3VwMmc5ck9CUTYwTGxJWFRWQmo0VGZXUUJ5NjdxRzhJbTY3NEJicmZFRXJUd3hudGJnUk9JSkRicERMcTk4eFZqRk1jekNVMTBoKzYvdFJicUVnUmJ3YWlxNjZlQVloQXZkemg0cUlJSlgwUUR6S3RkMEUxLzA5Z3VRQ1E1WTFIVUEyQzdlcDRUalUrVkg2UzRBQU9xNkowQU5lSFBjN0sySklDalNBb2YxeGhuRWl6QW9EYnE5Z004VDZBN3YxNmlEcWdKSUFiTHFpME1vQTJvMWZNZExxUFlCdEVDNEZiVWtlOHJBLytoakNsQXNVT0NrQnl3d0lhU3hRM3pQRjlJd293SnJMR1lzVUpsb1J5NjRNVXpFazdlcVpjK3M0WU1FSzhzeU4wVXJKQ2p0SkRpSVFxYUtZeTdnNnhXcUJUbzRock55aTRYOFRhU1FJZzB2bU1sZ3pEeHBMVUtJaEp0WmZTbXNOT0xSR3BMMWthNkVndUF5VE1pU1J0dUJXU3BxcSs5a2tnd3RNTGtBelNIMEF5K0Urc0M5WUFHM0Nxa2pLd3hvMXEvYTM0cDFxazBveHZBU05TbmFwZ2E0L1dqS2pBSVFwQW9xVE13N21JRWFBZlp5ckVhcXdxaElxSVpHcUNEYjlwOE9rc3BqTkswVW82QnBRcGRLU3IwemN5TXNqZFFKWUV2Qnp3b29pWXFZc25reENwNUlBeUlrU1F3WUFCR2hjbXNoR3dVYXdPcko1Z21zd3lPMGpCRlNZanNCdWlVUk5LYlhJd3VDcUJVdE1BUyswVW1xcHBLYmt5U01CcXhMd1B5aEdnUkFJSnloS2tFNWVCQUJKL1NnRkE1VWdIZ0JFQWRoT3dFbUpUWWluSkthWElzQURxYlFBQnBxWGt3QlFMM01iNXFtd3BMaUNpcE5OWVRCcStod2lpZ3JKK044cVNLSTFtQWtHNEc0USt0ZXRTSlBmakpVNktzNTk5QUhjTjByUUlvNEJ5bEFFKytxS0NyRzZXT2ViVlNpME0vckJJYityMUxhb29xd2RLanFvQnRtQ1FHOXFQY1M3cWlCcHNUZW9udFAvckJBcDB2Z2FoRzNwQWt0U3FqZ2tVdEpNNk5PL3BrMmZ5cFNTUHFsc08wQ2V5OWVNNThHd3V3RGo0b1BjQTBDOEVtbVVxTXIrRTVBRHF6a0dIa3hvS0Vzc1JMYWFwZ0RwcVFCTjhBZXdJVmUySE5na1ljRU1leWE1Y1VMUVZhNDl0UUVCVGhGdVk3VlQxclZjN1hUeUhNdGV6dTFCMkI3VFNnZDdOOVZ1TUoyQkJ6dGd2dFUrMDZRendOVnl2c3dVcllGdnN3ZENIVDF3NzBXZ1FpRXlxVmdEaDBUMlNJU1IwNzJkakIvc29IQ3FTeDFFNEhIWDRROGRVQnp1QWlkTjNsL3R5ZFdCM2c1NEhaRGp3QmFkWkJ3WjAwSEFqZ3dkaU9OblVvNWNIRVNud2NoOFBsb0U1aUhIc2dGMDVFRHVyM3NWOWFoenFEcDJNMW5vY0RPUmh4aXhGZFh4dytwMkhNdGhzUXVIUGh4NGROZFBoejExOHpBM1VMaG5nMitxaWd6ZFNSMXRqSytXM1ZSNTBDQjNVVWNyT0ZSMFB3MUhMM1ZuNVMrU25tcDVBOVlQUVo0QzZNUFRJQVdlU1BUTFF6SFdQVVM0RTlYbms4Y1R0Ynh5RjRNOVJ4MktOcnpaV2hUTHZNRmluY2NTOUtWcnNkQnljZ0ZlZC9IR3ZTQ2NBK1JLakNkbTJ6SENpY1h1U1J6aWRQTWJ2WEZidnVCbUg3MXhXd2ZSc0JoOVBvblNjSjlMSndDb2syc3dGbjFlOWZKeFgxbDlNWFZLZDE5S2VvdlNHMkhmV3FjeCtRL1FYZzZuSmFGUDB6V2RBQWJrcTRadVUzbDk1YnVUM2x0NVErUkhreDVDZVJIbHA1V2VTbmtKNVVlVVhrQ2ZiMGowUU41YkRwYmxQT0xlVTdrL0laanFIa2U1UHVXM2xpTzhlVlFBN0FUemhRQlBPZWdGbUE0Z1R6Z1VCME9WSUZFNkZBWW1XS0IrTzZUdUtCWmdNVHVKbFF4SlRyaUFBa1ZUdDhRdEVWVHV3QXRPaFFITWxpZ01UcTBRTGdMUkMwUXlPbWVYdXdKNVR6aEdBUjVYanY0N0JPNFRxazZKT3FUcGs2ZTVWVHJpQkZPK1RwVTdQTy94QTA3ZE80bVIwNnhPL1RxazZqT2t6dUk2YU9sZVc5SXZiWnB3RngvUTl6RGFjWDRCRTNXRDZjcWNnUkRtY1BYQzQxeEhUNDFQSVhETkdGZ3pBREIwRmNCR0RMY0NGQlVBS1UzUUFIREVycks2TE1BRTJwTmh1V1p6eDhBd0lNRFdDRTZzUXpXQ0JBMk9wQXQyc01ydmFGbUFlZ0ZKTUVHVlVEWXlCdS8xRGs0TWNSVlZjQUVUZUhOYTc2UVhQSkt4Z0ZkL3l1ZDB6TWlSV1o2S3crSnp3Y000cnE2NzJzSHJyNjdISVRZRzV5ZjlCMEFFRGxoRHAwK3psb1NydTI3UnUvcnYyN0F2WFJFTXJraWpicG02dHVuaFFvVXBxL1JCTWFHS2grdHVUQjNPb0lUbzVzcXhDM0FKYkdLMWZyT3UwcnUyNk02MEZrbWhnekxWZzZkK3RMRmxlN0F2SUh2dTYxdWpDQmtxUzRwSWd4Tk51c0h0b0FrZTJLeXdwRE05dmlIQUd1aDZFdUNvNFlucnBWeGJOMG1pc1JLSFBsT1Q0ZTVIcXZ6MUlPZEQrbzJRQzdzcElOMVRvbUZOY00xM04yRUl3OWRCeXllUEhwbjNVcklOOUZqTC9rMGJVbXQwekV5MWRTQmswTlFMWlMyVVpKQVNzZTdyb055VHMxQUZNMGxZSDdwWVkyZXNheVVTN3ZVYjFmZ3VBWDJGUUwxZWxORm5OUWVzcnRZeWJMSy9Ed294MWNnQnVFZDhpZ0FIZDlBT0VHL1Z5MlRnR1VwaDhwRFRBMGtRT1doV3d5Z0IyMTFqRW9LVTJPNDZFYnJXSFVMckh5RmFJOVNTdE0yQVJ1M3JxU2FkaUNnRysxYUFUNTExYnRRYjUzaEQ2MGJwQmNTZFVFU2dCZFVBSUYzalpRWGZzZzZCOEhTRjNLTWJnWXd6VzVheU0wSE1ORVhaR1N4YzFRWldFMjVxd1U3blBZeDFCMmxzRmU2V2JRQ2o3YUhGbHFSZjBkM0hXRFJlUU4zdHAyaFFpRFhRaCsza0FSQ0Y1R0FMejVramJvQU5kVW5QOXFBWWUwV0pSaHk1dVF0QXhNT2tTZzJwenpZSFBnWnRkKys2SDdncUxXY0FwdGNnZVhtUDdnS00vcW1BZmV6ZEhBQkQrcTJEV0RmODNIT0FvSmkxL3VyemdLRUxHUEJLREcvdXhRNlVrSlJRQSsrMEFnSDZ0U3RKWGlrUmdVa1JuN2wySU9TdWo3MmJ6aTNhVUFXVkUzNlVOYmZ1eVpHb29uc3FOalNzSW9CNm9JSEFkaU1VL0dzZ1VCTysyU1JBSGJnQWZwb3p3QmtTbnRwRUI1Rk55QVhRVkFkc0wwQjJHZ29oOStqZENhSWxEV0EyZEIvVVY0RHQ0WERlNGhuVlQrbDFEelUydXh4cjRIN29jbE5BQTlqYnJHNzd5QnlnWUVDR1FHOTBvSnFCcUFWQUpLQ0JkVytBNkJuM28zUUpETEsySngzc3YwbjhGQ0RKQUdEd2pJOEpTU0lWQndOM054YUNZWUNSUWhXN2JUejR3V05xRDljYy9JZnVMQmp1eC9WdUFSSmRDVjhHL0JxZ21xUWtRVE5sUUJLQ1JvRzg0ZkIvd2Y4SFFPVURtUUIrUU9ETVNKbk9XTkdjeEMwS1VKZUJ3bE9oQWlISWgzd2R5clFDY0lkc0FzaHlJZWlIa0FhVmxlQlpXRklkbUJoa2U0R1FBWWhsRUVlUTNZdk9BeUg4aGdvYjhIVkI5Z3pqNlFNc29iOHB2QjhnRXlIbWhvb2JvTHFxWVdsNkdDaDFRYmo1dWg0WWF5R2lod1VYMEFMQVBRQStBZG9OQUhZQUpoeUlka2tLSVNnZW42S0laWWY4SFpKY1V3VUh4Qjl2a0V0NTYvdFMyR1doOXRKRW92UWNZYWFIbWg5Q1NLR1JnUW5Nb0pDMFgvb1RaeElaQUNGd1BQT2Z1dUhUaGtKTnlHZWhxNGMrR2lock5BVEE5NHY5Qk9IZkIyU1Z4eUw4OVlhbUJoK3ovdTJaUVI5Q1ZrbE1UWEZob3pqTmVFYlFsWkpSWUdOZzlobWdNZHdCb2tnRHlIUGgzd2NIZzlFQWZ0S0NCK3lnazFwS0NJWGlnQmtBYUFEUkd2aDBxSkxvU0FNYkJlNzFlOWdBbTZmaHdrZlFrQkFBa2E1SGxvV00xSkhCRGNrY3BIcVJ5QUZwSDZSc0VlNzZraVpFY1VHUktENGI1SEpSaEhUZDFzUjgzek9Rd0FDVWZRbFdocGtaWkh4YlowM2ZRT1I3b1lWR2VSMzRZVkdrNk82R2xIWGhvVWR4WUtSc2Z4Q0hSUjhVYitHK1JyVWFEb0tsRGNuOUEyUmcwZnBIalJ6NGNrVmRYYVZBcnhYQmpnWGNIR292SEhwSEtDUUlkN3BSUVBRRkNINlI0a1l0R2N1R2tjREJZeHdIc2o5U1IrMGFUSEhSNW9iTkc0OVhGZ1RHeFJqTVo5SFRYRUxPRzZPaG1ZRXZ5NzI1bnJpVm9PcTZCcUl1QmtkRG9RNnh2Z2JGejBzRjNvZXBTQnVRZVpEMWg0REhyRzBRRlFiT0gwbERRYTZGY05Qa0doR2hnY1QxVEpPKzdRZXE0T0NpcFhQQ283VHpsUUFGeHRDVjZ4a0FMY2dzQTlRWEZnQUFETWptZ0JCREFRRFZWNVZBcnBVQnhiUGtIOVErMEUyT1RkTnh4QWRITXlnWVJWVVZtVkg2aUtJTkZaZ0JnODlFYVFCVVF2V20ranphdWd4aFFXQ3pGUjZFNGdQYTY0M0ROVTRKb0FSTFlsQm1EK2dycU8zSzAwSHdPNEVoNnMreVhGVDhHcWMwZXppYTRJZ0c1SnZDUWEyK0ZSaE84YVpWWUZUSndFQUdsRlpuemdnbkdSU1RkMWcvMUhGUkVpdzkzMEI5MHF3dmN3NXVDZ0wxZ3JjU2RINEdpN2JGRVJCOWtoRjFzeUlRNmFEYW8vY1BrSEJjemNudEpZbUZ3ZGdIOVJmRUlYR245ZG9KSUlxMUVBY0tySDQzUUVQdURnZCtjVFdYVGJBWlNiY3BLQ05jYkU0WlZLT1ZCQ1ZCcWtjbEJQOFNwVWRSNUsxTHJsajlrMEFuZ21Ra21nRVVSTUtZUEhDNU1pZHdzQzkrSnRTT3FweXhpSng5ajVRY2hGNnBkMUVpRDVKSHpJdUhVTGJnTzRGcWdhV1Q2QTNOQzRaUG9UcHk3SkJocFk5VWFXZ29BNFFDVFJlaGVLZXJ4dEFjbTA0STNDS1NRTDAwQnNVWGVxMHJFSmluclZjR0N6dHpFbTJKeFBxcDhFYU5GajY3bE5NNEU5UTNZR1pYdkhZRlI4Y3hKcXdkbFNDZEFKZ3djd1VPS1RoeDZteUZaVldidHFGZExDdXlUVWhoUXNVT2NDdXhXWkhrY2FjaXlOd0RKUmE0ZnVpM0NKY0diUlBGWVZ6UFNxZkJBSkpnV09xeU4xWlBwRzRzMGlxMmNjTzRmUFE3aFpVZVVtWDhncDNZMWJZd3BoS2JPTkZzN2tsSUFidE95ajJNVEF3ZndpbkhwbUVCUzA3QVVBbXh3dnAzbXBoQkZ3MEFqTXBBWnVFQnJVL3AyNEJVSHdabXNsejA2RUlnQ01uWVpxNkxsSTJ3MjRFM0dIcG9HY2J3NVNMd3p4d0diVTQweEJnUUNJR1ZoYkZWSE1CQlgyNWdHQkFGQUVoeTRubys0ek1ZMXZDTjZkYXRTZ0NUVmJIcXlXbVlYaDZabFNaRGh2QTA2RzZuWVUrYWU0QTgzVGhXdnNSaWJvVHY1WUUzdXhtbkVpVlVFRm1VaThnRkE1YjVVanNMaEtPTHFmTDlNaXVxWitNRXdESEp1S29zazRGMEZ3UVZEQjFIUXdhd0R6aDdpRnhGQlFoR00vTXBBNzgwRE9neWpLd0RPejk4c3UyWWd6VlFLRElzeGhVT0RKWGd5elB4aVF6a3NlaEc1YTNWWGdEU0FtZ2NFYWFkUzJ6alJTYjRzZ1laOGNLd1hNa1lyUGVIOWxONDVaMnUyMUphQ3dUUks2WWU2YWEyeDVFRnhqRkFxSlZzRFlhOStiZ0hhd0ZRY2UyRmFza1ZBVDdOSHJhdWVvWUR1TGd3VDBXWUQvSG1nZ1VJVUdkQmhrUnlZNEJsK1BvRDdKU0NPL0J2WWxBZGdBY1I2QVZ1WTlJOWdEdWRxSFgyM09mTEF4NTQxRFlCaTVwRkdRWnR1d1VUc0ppZFVlZWRBRE1GVEhZaTJxUGNsb0FWNTdlWlhCMTU0dkJrMTJzR0FVUlE5Z1lEcTBWQld2RXhGYnFCYWV6ZmJiUFZkdWxhRjdYb0Y3ejNXV3JrQkJidERlMUpUSHREc0RIcjFXdHFEMEJqN1RFaDFid2NFNGtYWk9sQTFvM1pqV3BvRk5ia2tjMXVoMUxXczlpR3p6SUp2dHZZVWRSMXZSMW5XLyt6ZGJBSFhIV0FkRXpWSFI5YVpoUDFwZ2RZT1FOdXAwVU9KQjNwMVVIUERramFpT1ZuVkk0Y0hVcW9UYWxvSUJhSWNkZ0VoMWtSRlFjaDFKVlh0S2h3bDFQMGFYWHphUHFRdHZJQm1ISlhRTTR5MjR0a3JhemdPMGw0YzVGL2gzcmJCSFJ0dUVkdkoxdG90MTIybVJ4UjQ1SE5IaDdiTWVQdHBzNVZIRm5nMGNSMjdSekhhL09mUnhEMHAyb3gxbmJUSE9IRVhiNDlSUFQ1NWoyOWR1RjVpTVRQU2NjZDI4NmRrd0QyajZnOGM1N0xMaDhjejJ2eHpRQWVrSGJpdmI2OVVKd2tjNzJsdlFCekgyMkp3K3A0bkIrZDcwUDJwSnkvYVVuVjdqU2N4OURKMG4wQmNkaGR5ZHZ1Y0RxWDE5ZkZmV3JIcTJXRHZzeVY3QkRvdlFnZ3R0aVAxUE1zUkhRNnA2VERxdWlDc1FFR09oQVFBcUVCQmZqUUVIVTBjT1QrVy9sZjVmK1hCQnZTUklnM2wxQ0Z3RUJBdWswSUVCQmlvOG1hUUJ5WjFhcllCMXF3RUMrYUJscitXbmsvNUJlWFlBYmhHZVFBVkpBamVXZzVNRFh4QTZXc0RTWWtCQUJUSHBvQVVaSmJ2dGVCRGJURlc4bWlnNVBxbkpYQUhQb0NqSUpqejMxSDdDYm9kVUdHWURrMitXZmh2NVlQOW5BYjVZclk4SnRSU2FwRWlSbFVoV1JvTHpSaFdIeGo3SmZIL2dHb0RHSjN4OWdoMkJFMGUyM1dvR1RRbnVpVlp6WEZmdWg3YmV3eDJUZEFuMUNxaExnOEFHV1ZaNElZbnJnMFFhWWxHRWxQSFpPWlNFNkNmdkNNZFhZaWFhVVpjVFJSUlhkUzlGYlU4c1Zpb2h4WCtsUEZabGNaTUpPbjNpNHpEZ0hmUkZrVWxiMU5PVnJZRzVXWHhwUWxYUnoxWE1Ib0FQeHhpQmlpSHdhSlJiUlFsdHdOdHFhVnJkVmRCOWt2TlZyR1V1MmJVZUpxa0xKaTc2VndEeFRoUTg2bEJzTHJjWFR1dXJBcVFTZzN1eEFHMDB0djF5Qys2dUNVZUE3aVpPNloreTFkSlI3b09sVHUxb1BKZ2tmcWFIRitxQU51Y3VVc29BdHNOdXJ3d2lBOGVvWkJtUmpvQk5LcXM2MHVydy9WbC9TTlhlVEMxYTNKUTFoNkFqV1d2UmJ5SUN1SW96RUVBUjY0SlMwUzAxOTFjeld2VjdOYnYwODFnTmNGVWcxeWlhdFd3MWxTbDI4WStTTmExNEE2MXNiMXkvdW5rRldUb1F1dUMzZEUxMnRZMlNWQVp0Q1R4MDFqMWF6V0ZOWDFhZEwyMXRva0F6VXU3dGRMVzJQZnRmTFhCMTc3dUhXbnVCRTBtVGxneWRjSThhMTVOZUNWaW9odFl6WFBWbS9SeldsTmFqM1hYQzE0TmVMWHFrSGRaSWo5MWpSb1NnalFGRkNuWEwxMDVVaFVWUzI5YVhYbTFsZGR6VzExdWxZN1hOMWtOWS9YdzEzZGErREZ2RlVxUkNFMXdEZnVWdGxhYXJXcmphQmRjYlg3MW5nc2ZYNzlaOWVnMk4xb3RlM1dFTnI5WmZ4a041WlpjQnMvTjR1cldrMW9EZTJVdm0wRGFiV0gxMXRhZzJDMXp0YTNXUzFpallwOXYxNWhMSVRTd0t0YXlBVXNYYm1pVWlKeHBVVlhCeVRGVVpjWlZwUUVnOHpBUE9zRmh0bEU1ZnBrUlZ0a0JPWFhqVHhLbUE5cGtZMEpYZWtYVGZJOHBGNHlCZXFKL0pRMlZOamdwUXpWTUdneGpZdzJMbEhNMFlTRXl6OTBNMlZBVjJ3Y05ITjZydEkyWE54emVNMkk1aFdCbnFVV2pNQk5qck40NEJDMzRjSUUxWmpKaU96ZmVWemJITTNlam5OK0QwT0dzREVRRzAycmxyemRmV2t0cTViODNFZU5LRCtsek4yZ0ZBdHd0b0xkQXFJYkN5REMyck5pTGZadGJOcElFYlhGTnJSVzZRTDV5V0ZtNGJnUVlDcU1FUVhHQS90NmpOVWthTXhrcFVqTXR0a1pjUG5qaStLVVBOWFAzVEZibHBDVjVTbGVNMThjbGZNMCtmRUF4NW41dGhDMmF4Uk5UK0ZaWFZQSzJiOUdHY1pmcXlXLzJ3WUJOY1VzTStkc0JZQVMrWUZiTnRDZXpKVXhXaVZxZm5UdERqamxhV2NoVnUvbWpyWCtkZlVxMEFCYVdncU1MVnBQczRjVC9uUHRJRnIraDl4RFdrSFR2czRGcURVR3kzN08xcGZ0Y0VXMXF0YVA3QjF1L3NzRmtQMHgwMzJEaXpFUWdIRUJ3SjF2Vzl6Skoxa2Q2QndwMEtGaEJ5b1c2ZEZCMFoxNkZ6QnhqYU9kZU5yRkpSc1lEcHE0UDU2c200V00yeWgwS2RzMnVGMkVYWmRBdHQ4V1dIRUpmODJDTkRoeWlaWkYybEdyYmRkRGR3YmFtMjlSZXQwWW5LUnc3YTdkZVJ3eDR0bVF4Y0M1akY0bmxNWHllZHpuTVdBOVN4WUM1eTVOM1UzNWpIVDNUbmJvOWN4M2k0NDlLeHlUMUFsbGJuc2NSZUpBYUFobkhERkwzYW1IUHhjUjRBbDF4Zm50Z2w4OXJDV0FuT1Vla0NvbHM0RnZidkpoOXZiMG4ycEpaZmFFbk5KYis0TWx6alJYNzN1SEpZQTd4dE40aSszQ2x1ZldLWENuU0RwS2NmSThwemc2UStLcDFxV2FuQnBjbjU2bldTVnMxTjlPaFhaSVl1ekNIaTdmOWRnd3l3dGtKZzJtNzVqRFZaVUJCREdHSHBCeFZNbEFMd1J1ZnFrU0ptRGR2Y0VsTjFkazBqOS9VUHZjNzM2dXpQMjJZRzltZnZrSTY5dWFIckhKOXJ0ZERYSjk0QXhUTlNrQlVqYWhGdXp0eVFVcmNTTURZS3E5Q2sxYjVMd0FZY3ptUlBKdmFBOXVxT2VyVU41RExmZi8xNUlJL2ZhdzEwU25BNHBoeUs3RWJraE5QdHhOZENEUllEaFQ2Y2Z2bUNwWjBQT3YxUWtZTkdESkpuVnBFRU9zTnlPN3ZmUSs2TFlBWEpMS08zbGhTL2N1dXpUQkhoQUZYZjhSaWNqRW93VlZBakZEblN0WnJRNUk5Q09NMGdQTHMwRmhvQVI5cklLc2haMGRWWS9IYUFNZzlOOUpiUjdHcmpZRC9TM2dPYUZEUEZaM2V5WFVsQTFtNDRaV1FQRFJQUWgwQUNGTExYd0JGV1JZQlJCaDlqdmZGQkJEMHJYU0FweVcvT05Sakl4clg4Uk9YSERlR1ZpVEtLa1NCc0ZhYWRLQTZnUFBtUUN0OWtjWWc5YnREb0EvM245d1djblk3WEt0alQ0YzlDa3kxd09LSjhqbG4xMVAvZEFCbE54bUJjaGFBRUEvck5MYkZobjVONTZuRE9Fb1VEN2c5NG90NlRBK293REdIQTVxUm10Sy9CVDZIK1pnNURocURPYWE5eXdLR29od1Qwc0xuRC8wdmwrUTlJbS9ENUE1NEJVRHhiMFhSQjYyZys1bXhMRzVBd09xTVd4Z1ZnYVFMTFdLUStNV0tBLzI0RHh0aUVPdkRqY2xRQnhvZnBUaUJ1dHZHbFlSa0Q5RGxRUHo4ZnBRaUJiK29TUnIyYVdiSTkxSS94UEk2Q095amxWVjFXaUFScHF5MC94TFFCdUFLQ2RhZ2hEN0xIMVhaSGp4My90ZmJ3L0ZZOXNCeVdTbGtXelBlNTRDNUJIVlZiQVFuRzk2ZzdtaERqYTFYdUplRDJ0YksxeEFXUVI2T3QyRXhnRU8yTUJZNWtPczRVUTZDTXlEaVNGYW9iWnpJNmtPSWpwaEcyVVZEaktiZXBOOFNVQmhJN3M2ejNqZ0Fza2hBZlNoR1FjaEZpbTk2cWRMaldRY3BjNTdOajEwajJyUDUxNWVQR0dVSExDVnlDVDlrRDBRdkdYa0YveklEelkvQUEybFVrN3U3VHlTaytQSFl6Q2s1eE9BVm1rN3BPbVQzVWM1TkdUbkUvZEhXVDMvUGRIdmwyazQzSStUODBjRWg3bG84RWxYTTZwcUhyR3NCN3NhYkdoMVJHSDlRdW5EUHdWUEU2NG5HVk91bkRjank3WU1OMkc3VWQrcnAyN3JFM0MvbCszUDhsM3hZWkdvN1ZsanNRTFAyM2p0eExETUVEc2pnY1BvS2hnN1pPM0dzQnNaWkhENzFOWlRIYjV3KzNTRlFBMkhMeklrY3prSU03RVJmb1I1Q0RBTGROazB4SGVZY1B0ak95QWRmSlUwN1NBNExvUUVUZkszRnN2WmxEb2NnNVQyVThWUGljQWtCVk9uZ05VNUF5TlQ5R0NPQWl6ellNelA4dWtnNnZkbHVockhLbnBySTMycXlpZzBRYWN0a3Q3QXpWT2ZEdFF5Rk5DbkRxemhJSzBRRkhsUFl6Y1EvNzNHTlpxZnpwdGlsSS9hSDZ4LzFHSFJnME5OT1ZPd0pKOWlvekRRRXNkblA1ejlZRVhQelJxQStaSE1pY29GT1lKOE9iajZzZ3JZWG9GSm9vemlFVjQzWUp1R1ZwVHQ1cmFoZGlRS21uYTNOdWJiazZPemdYcmVRR1ZhY3doQ3A3TFB3MG9DWis1a2VrbVpqRFhoYjFkdHRlbWdBcWFRN2ZLdEFyRU5NZk5vb3VqU3ZPYTEyWGo1bzdiRHM0WHFkb0s1RmtuTHJNNlpOWCs0TUpLWU9yS0ZobFlPVG9pd1NPN0hHN3lsZlFack0wMHBOVmNSL3B6WXlqRUptSDdZWFpDbk5BM3ppOURuUnlzWThlL1AvZ0djczJpUjFNaTV4R2t6bDR6RzVHOGVPZ2FCNjRSalFwcVNMa2FEVUtkQm5pNVBLaVcvRmRuaCs0Y0FERGRnTHZWM2R3RmpQYmZlNTNjUTdmMGhIa1BVaUFOY0w4NDNYVDN1blpMd3ZpOGRkTVVHaExwS2pLQlJMeXk3aDZqUU9VZlhUYjhpSHBjdkFUNkE1N1JGK293Wm1CeXQ5VnhkamJ1akkrZ1AwVDNZZ2NteVMzdjJ0Q0tNY2dFclFJUUVXM2J3bmNiNERZQXVRVEsyK0FnY3NTL1hKYlQ1Y0RTMnI5YncxZ3NKTGJUWnYwYXUra0UyZ0hETy9TS3VNb0lFMjAyblMzSzdVdGxrYlRmVTBNdDFNL24yZU42cEhuMzJ1bWZkNk1ETHpaMytvV3FOWU9Cei9KdDQraXZBVUFITm1KK2tIYkRJQUU2T3IxUzZVUU0xcGJPZUlndnFYSmpzSTl5Q2NQODl2Z3RPZW5Tb3hhdUVaMXVPU3E1RDRLNHN5QVQxdE84aGNVRUNYMnZsalFuSllvQ0w5aVpTUEdBTmc2aVl5c0tCUzNKVlFhTTRhcG5yMjhkVkJ3K3M1QWV2UVZ3TTltSmxNWnVvd3p5VUFRMEJ1R0lRYzRoQmljNE5tdG5adFpzNUlLNnJUUHp0OGtJeEFDZ3l5V3lQekR3STdXQXdSbEkvWGJrQzhMQVpuRDBSK3VqN3BSNm1leXpNNkpyajI2NVAycmp0YzhZQnFWSEc4S2tOM1dzbU1PbjlwQUJmMlduZHBpc1BhOE5kSzlCN0NLTUJWcllNWkdFWUJPMEQvZnNQRWprSmhuUm5EeXMybFJYRDZ3Z3hoUUQ3TFVPdTdnWTY3T0JUcnMwMjFZb3JtSy9CQTdTUnpNNTFzRkt5eXV1aUw5TEFSTmxUcUs5dG53WFZjK25PNHpVczduT3gvTGM3dUFsejk3djNPaHVtYzc0R3JiaGM5dHVkejVjOVRJcGI1MFVtNStPQmkvS3RlUVdGMUlaV0xoRng2M1FBTHVGOUJsU0J5RU9OUHpmODd1NnZMMll4VDR3THBZM3dZZTBlMHZiUHhUY1hNQnE1NWtTaThNQkw4M3dvdW83RDI2K2lzc0JZNjYxcTRxQVNDQmVNUXB6R09yQ0xEajZQZWdGazJ3QkZoWHNCS0J1ajhZOHdCSmpoaFI2UERSQ3NCeWJ3anBFQWlCOEFENHJoSnFPRXJBazVkdU51NnNJSWdmeEU3dVJaNEkvS1BzRHhyV251bGpnN3M2dkJ1cGt5eGlwcUtNalJCeVVyVXdBdXhzSDh5a0dyTHh4cHN1MkNlWEhiTVF5bjZpbUJZTGtmaW1BYW5LWUd5NXJ1WnJEdlBydUZyZUpCL1VBTzVyN1IwRCsvcjdRN3J1SGo5ekNLTytwdVk3aHFMTXZCQVJmby91dEw4QzQvdW9MbTRIS3dyN2dJc2ZNNzdwY0xSQUg3eHRtREJpVEpRSDY2NURQQWZOdnN6TlEyRU5WVGVudUJPa1FBSkNpVm5wOXcvR1BKaUI0Nnc1a3pPaS9RZUh6MEprL3ZxallBQXl3SlRYKzhzTXc3eUhDR09OcjJGTUNyL3p0bnBCVzVSN2Jld1FrN3RKd2xNOUwvdzhtSVo3cTllUUFMaEgvdExwL2hlNG04MVVGaDdpcUJnN0s5bU1IelU5by83dTVIcFErekgxZTQyOUxPZVpwT21ldTlTT1VlNThoSU5XK0d2NVNlVy9rUklNNVlEc0JiVklTR0xzQ2IzamthMFZaWlE4Y1pqNENFNmlDTkRtdkZ3ZzBRTkVHZEVMaGUrUzBQL0tQaEs4eTZoSG9Wd2drVGpuRFY5N2JtWHNUUURFOW1hMzVORGcwK3lZaExYSHZRaWZEZWtEZ3RzbndOYnFyS2V5TFJpdERhM0o0cXY4TEFwNUVCeW5weHVLZnFlaVhCQmtDZXVoRDU2KzFSNEppU2IzSWRYa3Nra2c5ekxQc244cnpMT3Vuc0NlZlVNbjg3b0t4RzQ1bElkUFlhaTJyUXNLdGxEdnBXeDk3Y0VpMkpJdEVHcWZhcnFDclJBUVpWTS9sT2VQVHA3NTkybmdaN1BITUxicDgvY25xWm1wNmZXbnc1NGdzNmVweTdZTE1yczg4QnFoTFNkM0Y3ZWVyY0Rnc0J0U1o2YmRubm1aNk9BdWUxVTJPQlBua2JSZWVOVFpTM2VmUmJPdHkrZWJvSlRsQmVhRUpUaWVmQVhxYTk2eTVybXFkNmR0bVhrRUp6ZUI1a1lGSk9WU3NyalV5QUVvSGkxTW9uNDlIT3lVTHlZTTUrenRrRm9QQ25DbStiMm40SVovQTF2RDM5RUtPSkRzWFdwZjMwWDlBWmVlOTRsOGlDb3FCRXdLUGU5aVE3cTc3K2prZ0VzUnp5bDZTREt4LzB5SDNhRGtwNTkzSlh6azFWOVhZcUF3SnVkRXZmRzJRY2MraDV3aGdRUFc1cjNIc04rOHpwbnovSURxTVE3emg0M1F1NFd3MGp1MDdtNjhDcVRvdUU3SWd0c2F1T0ptTlFYakRaN0JkSVREdFZuWDU3dVRnRzBCTTU0eEJMVDE1N0k1MEpvbEpwdXlFeGp4R1QvV2k5YktReThwTmFJTmplT1lVVDRqMldaRnVsVUFDdU53UnZTMmpEYzgrTFNlTzV1Z0ZlRmpKUGZZT0Y0d3IzQ2lGK2R6Z1YwMWdBV0tDQytteVNzUEFCMVZDM3g3S3JlMkFmMnpUbHA4NnQ5cmVCSGx0OGJmaThEUS9oTG4xTE4rRGdjMzNlSCt2dmdVTjBodkYrK1l6U00wbkZZeEZMbG9PYXhKTXlUSC9qN2ZIOCtESWRvWnN6M3dmTU03aWlGNVJNbk51S1ZlWWJoN28zUjBBZXlnNTdNZXFtOHNiN0xIcGdkZW5DTm5yOFB1WmdkNUw5aDNobUNMZjFZUjk0L2RFb1VXaVJUcXhvYXZLQnNjZUhMeHhadStlYTdaRUhrZmhDblhzM0RVcFpxeG4zVk9CS0E1U2puUXFETHAwYlVlbU04amNvQjN4dzI4VFFDVWZvMUs0SzB2d1NoMVlIRDdiTjMzeUc1N2Vha0pEK3pmNE0rOTkxWXRZYWQ1MnZMaTBlN1lCOFRDZ3M0c2E0OHpRU3VTc2VRMzlRV1BwSzlzZUVhTUc2blF1UG9Pak1lUm9TYS9NOExBSDBOZHgzMEM2NUN2ayt1ODdkZzlYbUZ4cjcvQ1lPNHNOM3o4Zmg0ZUk4M3JDUkFSanlsblV2L1IvVnlnZWpYVEkzaXMxZ3ZhN0thM0ozRzZNZjZ4ODhPUGZzbVVzL2xQU3pzWEtOdWRBRXM1N0haOGh6OGdDYUp3eDUwQVRieXo1UTFJUHZNK2FmWjlwc1pjK2R6cUs2Yy9BdnpVK0MrQkR3K3I4dzl1aTI0M1ByYjBsN3FvaWlJOS83RFNidzBGek9BdmpVNGVoajJibWI4L1RuaW50VTljdnBPcUNkOE14U09icUxBZHZabUg2UG95dWVXV2tYN1p5cDliMjY5cEJTTWNjK2lEV0NQNG5kOTkyUGtSV0Jhd1pzUkJJMm9tUzY0QityVHdQUE9TVTNvRWwwaVY3RUM1UGkzMDEraVA2djBrK0xlS1ZsU1lSUGRVcTZJRm1PN1Mwbmd5Y2VyMmFMeTRzRTRpckFORHYzTVNBa2JJQmxtbkUzMjEvSUErZ0JjbnErM1ZuYUJtbndqZGI3N2M5dmlIR2tadVlPZkNLeWxvS3U4RjJGQUVkNEl5dzZYZ1lTK212TkhxcjFVdnZENGJoeVhpUG9NR0x5QXRqNDVZK3VNeHRNTE12Zll3ZjVyYkIrVzE1YUlXMk0xYVFiayswaSs2LytoWE1OM3hkVzVtdUllNGlLM2RBMmdFczJ3U0d6YkJKTlRVbjZjYmRUVUNObUhad1p2Y0J1MkM0VjQvT3dsOXRTWU1sNU9vQkVCVWdYQUdkRnRhM0hNSU1LenNPVm5kNmVxa2tSQWJJR0lCMkJnTEloNmN2MzBmUUV3eWUwWUc0Vi81UVVjd1hZZEVEVmMxWUVFdzY2Z09UUHpBcmwvbWZoSDROdFp2NVVtdXYrMVVhZS8zSW43ekUyK3h4KzBCQ3cyK2RYbzVNRHZ6SDZvZ1JLTDNKa0ZlS1BqcE9JMGo0dGpoQXp1ODZ4Z254UGZ1M3ZJTlhXYkRPMmNZYSthMjE4VEs3ZnZtYnR5M1l1UVg1NEFEZm5WN1QrZlh0ZTNIK1pWYS81M2V3KzJ4RVNFR0FXOVZVQmVDaC90NWRpZ1hnZEdCZnZ0SWRDSGRoM2tGMSsycitMa2RCYS9zSHdKMXJ4MlhXMUhmZGF2MkFoZngwaUZuSGNnYzhkLzF2SVdxZEluWkRicUYwbllqYm1kYU5xWVhZMmxoWnAza0FQUDQ0V0dkdE5wNFhsUUNoMzRYV2R3UmRvY1oyVG5kRVh1ZHlSYjUzQWdPT0prV2EyeFJaRjNhMnNYWlVXSmQwM1NsMk85TFJhTTRkRm12bmwzek9BeGVkMWNlUFhhanpQZE5YZDkxUjJyWGRwNHJGeWRyMTJhVUEzYVJjZXhheGNDeHhtN1pkcldPZVA1cDZEZG9PT1p2RGJ0QUhJK0xOeHorTEk5b3A2RTlvVjZmVmJoTFFhQzE2TVJEWHRCdlF4TFFQYnhMWVBhSkxSSGpKTEZPQVI3RGNESk9hUGJhWEVIaHg3YTNTRVRGUVJ6L1pQWmdkQmZRUWRVcFpRZFRQYVZMWkFDVk9JZmkzcFpEb2RzTUpwNUFCcHpyQWNPWXVCQ3ZhMTJLdmF3OVZVeVBYRGt6Z0FkalFJbWYvUmtBWlA2VUFPSzZnL1dPcnlJZWVvdG9kbWF6RUM4aWRmYnI2OWZFTnplSEJnd0lZREM1YUFpSERSNVdzd0xkSHdCR21UdHlMOFhtQWhYVkM0ajhBZGlXTkdkUzBtSUtwMjJMaUJYV2Nvcm1RR09RSkhjNzVvQUU4bzkyTGhxMEFid0ZuZk9xakp2QUN4dk1YVjYxZE0wQ01qSnl4ZndJajRhZldyclVmVHR3RW9FK3JLYlNRR2dyYVFHeUF2OXhtMkM1VHlRYmdUMTdHNzdmQWU0Z00vTEF6eS9SWDcxYUpqWVhLUmREY0NmMzRSOUZ3eGdrRW9GTS9GWDRFS0s5YVhLU2RENUFyNWlUb01aVEZ2WW9FcUlSbjVsQW9UUXBZSGlCV0FwczVEN0ltQW4xRVo2bUFEc0EybUhRcmZCWjlCTjJlSlFsaFZvakp3UE5URHFHVm90NGFKeHJBelFiV0hXZUJZWEtQcFBWSlFEOGNKNmgrM0c0QlBuV0Z6bEFWODdHdlpUNGJvV1ZCbWdiODc5QVY5cjFKTzZJanFDR2FNYWZHd2lQU0p4aVBQOXFRWEpYNWJBeGxTWTNVZEN5QWplaUJ6ZGxEUDFOWlRUOUl3Q0RvZHZpZ29lVUJJVU1KWXdBRnc2SlFISUY0WVdNeE9QSmt3UWpGL0xxYlAvTDE2UmRRVVFHZFpJS0VDU0U1YmdTMWtVVXlEMWNyNXdaR2dJYmtSS0Rad0hZQ25VSTRCZEVla0VBNUVjYnU0ZDBaMkljVUJpU0VNS3hZY2xDMk1QdmJPQUp4NDdRSzRpbCtGREtaYkhMQkg1SVV4SWd6NkpLR0JNNDRndHN5SlFCTTVCcklvNXVVV2VxeWd4ZFFJekpReGI3V2w3NGdwdll5MFNNQ0VnK3ZKNHVVcENOQUVrSEtnNWd6a2d5cjRQRmNVR3FnMmtId2dla0VHWVJrRWFrWmtGQ1BOa0hRZ3prRWRmY2tIVWNma0hmQVFVSER2WVVGQnJZQXhpZzZrR0xxWTZKU2d2RVl5Z3pRaUxxZVVIcWcwL2FhZzFvR1VZQk1EMmNUMEUvQUZlNmJOWkk3VDlWa0hzZ21FR1A1RHI0VVFGRzd4ZzZyQWdrYW9EdmtKSWk5M2NTNG1nODM3UUFGY2E3RVFNRW5HU2Zpa2c1eXdMd0g4QkNBc3FwckVLVUY5QTBvR0EzUHlqMmdqdUJSZ2xSRGI3WW1BVkErellvZ3g0ak1BQk1HbGpjbHdyaktOQ0pmSGlMRXNGTDRZbWJWWjNBZWQ1MnFIL2g3OFphWmZqYU5SZ0tlZFJnVGR0Zy9nVndiVDRkaFNiZzZkNk9BS2tHNGcyNzcwbUQzSTlqTXNHSlFSRHpkMUhjSDA0WjJaNDRMd1l2QUJyejdneTBGdG1lZDQ3QVk4RXFndHN5QUdmcHhoVlZvRmpnaHdDVytBVnl4Z3lQeUpnN2dSQ0FySDZCbUorRDlPUzhHM2ZRUVluZ3RzemltT0VCS0dET3F3UXhDRytIR2RaNndSTUY1QTFpaHBnODBiT2dqa0ZiQUFkNWxnd0F5ZStPc0dlUVY4R3JZRWJLdEFpaUR5UVZKSlBzVUJCRmd6ZEFpVVVzR1VRc2NaamJDaURJUWswRVVRNnNGdWdSRHlDV01iQXdReWlFbVRYaUhvckxpSG9yUHNFdEF5b0ZEZ3prd1FaQ1NUYk1DL0pZZy8wR2ZnOE1GdG1ZTUY2RVVNRm9RdDBDUmdxZzVNL2RsNWFROU5ZOTdBY0d4YlhJRlZZT3dBZ1lHdFFvZ0plQktRMFVFcVFvVXpxUTNFYkd3TU1GQ21CTTR6ckVUNUlSUFVHTytQRnl0ZzBUNXhtT3ZKZVErQTY4UXdIeU96U2tCaHNYd0FzSVpUWjFtSXVvT1BjREsycVFWd3hRbEc2Y21GbHlLM1lDU1pIRmx3Z1pJT1N1ekpHNTVTVGx3QVF1S0dZYlFuTE8rRFh5WEVYQ0dqamRNRXVnb2lIdSthQ3BDZ3dqNDRjRG5BRUtBQUJRMFF3QUF4TFVoSkVubkJIMkp3VUlRRFpJVmdIcVIwWGtjQWZua2NCV0FQdDE3SmpkY2dBQT09XCJdJyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2x6LXN0cmluZy9saWJzL2x6LXN0cmluZy5qc1xudmFyIGx6X3N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oOTYxKTtcbnZhciBsel9zdHJpbmdfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obHpfc3RyaW5nKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL3NjcmlwdF93d19hcGkuanNcblxuXG5cblxuLy8gV2Vid29ya2VyIGludGVyZmFjZVxuLy8gQ29tcGlsZWQgd2Vid29ya2VyIChzZWUgd2VicGFjay93d19wbHVnaW4uanMpXG5cblxuXG4gLy8gRm9yIHdlYndvcmtlci1sb2FkZXIgdG8gZmluZCB0aGUgd3dcblxudmFyIFdlYldvcmsgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXZWJXb3JrKGRjKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViV29yayk7XG5cbiAgICB0aGlzLmRjID0gZGM7XG4gICAgdGhpcy50YXNrcyA9IHt9O1xuXG4gICAgdGhpcy5vbmV2ZW50ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB0aGlzLnN0YXJ0KCk7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhXZWJXb3JrLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLndvcmtlcikgdGhpcy53b3JrZXIudGVybWluYXRlKCk7IC8vIFVSTC5jcmVhdGVPYmplY3RVUkxcblxuICAgICAgd2luZG93LlVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgICAgIHZhciBkYXRhID0gbHpfc3RyaW5nX2RlZmF1bHQoKS5kZWNvbXByZXNzRnJvbUJhc2U2NCh3dyQkJF9uYW1lc3BhY2VPYmplY3RbMF0pO1xuICAgICAgdmFyIGJsb2I7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHtcbiAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICAgIHdpbmRvdy5CbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyO1xuICAgICAgICBibG9iID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgICAgIGJsb2IuYXBwZW5kKGRhdGEpO1xuICAgICAgICBibG9iID0gYmxvYi5nZXRCbG9iKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKTtcblxuICAgICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9ubWVzc2FnZShlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0X3NvY2tldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydF9zb2NrZXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmRjLnNldHQubm9kZV91cmwpIHJldHVybjtcbiAgICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLmRjLnNldHQubm9kZV91cmwpO1xuICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzMi5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UoZS5kYXRhKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tc2dfcXVldWUgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKG1zZywgdHhfa2V5cykge1xuICAgICAgaWYgKHRoaXMuZGMuc2V0dC5ub2RlX3VybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kX25vZGUobXNnLCB0eF9rZXlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR4X2tleXMpIHtcbiAgICAgICAgdmFyIHR4X29ianMgPSB0eF9rZXlzLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBtc2cuZGF0YVtrXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgdHhfb2Jqcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfVxuICAgIH0gLy8gU2VuZCB0byBub2RlLmpzIHZpYSB3ZWJzb2NrZXRcblxuICB9LCB7XG4gICAga2V5OiBcInNlbmRfbm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kX25vZGUobXNnLCB0eF9rZXlzKSB7XG4gICAgICBpZiAoIXRoaXMuc29ja2V0KSB0aGlzLnN0YXJ0X3NvY2tldCgpO1xuXG4gICAgICBpZiAodGhpcy5zb2NrZXQgJiYgdGhpcy5zb2NrZXQucmVhZHlTdGF0ZSkge1xuICAgICAgICAvLyBTZW5kIHRoZSBvbGQgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgd2hpbGUgKHRoaXMubXNnX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBtID0gdGhpcy5tc2dfcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KG0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1zZ19xdWV1ZS5wdXNoKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9ubWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbm1lc3NhZ2UoZSkge1xuICAgICAgaWYgKGUuZGF0YS5pZCBpbiB0aGlzLnRhc2tzKSB7XG4gICAgICAgIHRoaXMudGFza3NbZS5kYXRhLmlkXShlLmRhdGEuZGF0YSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhc2tzW2UuZGF0YS5pZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uZXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSAvLyBFeGVjdXRlIGEgdGFza1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXhlY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2V4ZWMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yX2RlZmF1bHQoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodHlwZSwgZGF0YSwgdHhfa2V5cykge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JfZGVmYXVsdCgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocnMsIHJqKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWQgPSB1dGlscy51dWlkKCk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICB9LCB0eF9rZXlzKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMzLnRhc2tzW2lkXSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcnMocmVzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZXhlYyhfeCwgX3gyLCBfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9leGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGVjO1xuICAgIH0oKSAvLyBFeGVjdXRlIGEgdGFzaywgYnV0IGp1c3QgZnVja2luZyBkbyBpdCxcbiAgICAvLyBkbyBub3Qgd2FpdCBmb3IgdGhlIHJlc3VsdFxuXG4gIH0sIHtcbiAgICBrZXk6IFwianVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqdXN0KHR5cGUsIGRhdGEsIHR4X2tleXMpIHtcbiAgICAgIHZhciBpZCA9IHV0aWxzLnV1aWQoKTtcbiAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSwgdHhfa2V5cyk7XG4gICAgfSAvLyBSZWxheSBhbiBldmVudCBmcm9tIGlmcmFtZSBwb3N0TWVzc2FnZVxuICAgIC8vIChmb3IgdGhlIGZ1dHVyZSlcblxuICB9LCB7XG4gICAga2V5OiBcInJlbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVsYXkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yX2RlZmF1bHQoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGV2ZW50LCBqdXN0KSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvcl9kZWZhdWx0KCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKGp1c3QgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAganVzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChycywgcmopIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzNC5zZW5kKGV2ZW50LCBldmVudC50eF9rZXlzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFqdXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzNC50YXNrc1tldmVudC5pZF0gPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcnMocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbGF5KF94NCwgX3g1KSB7XG4gICAgICAgIHJldHVybiBfcmVsYXkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbGF5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLndvcmtlcikgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYldvcms7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgc2NyaXB0X3d3X2FwaSA9IChXZWJXb3JrKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL3NjcmlwdF91dGlscy5qc1xuXG5cbnZhciBGREVGUyA9IC8oZnVuY3Rpb24gfCkoWyRBLVpfXVswLTlBLVpfJFxcLl0qKVtcXHNdKj9cXCgoLio/KVxcKS9nbWk7XG52YXIgU0JSQUNLRVRTID0gLyhbJEEtWl9dWzAtOUEtWl8kXFwuXSopW1xcc10qP1xcWyhbXlwiXlxcW15cXF1dKz8pXFxdL2dtaTtcbnZhciBURlNUUiA9IC8oXFxkKykoXFx3KikvZ207XG52YXIgQlVGX0lOQyA9IDU7XG52YXIgdGZfY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZfYXJncyhzcmMpIHtcbiAgRkRFRlMubGFzdEluZGV4ID0gMDtcbiAgdmFyIG0gPSBGREVGUy5leGVjKHNyYyk7XG5cbiAgaWYgKG0pIHtcbiAgICB2YXIgZmtleXdvcmQgPSBtWzFdLnRyaW0oKTtcbiAgICB2YXIgZm5hbWUgPSBtWzJdLnRyaW0oKTtcbiAgICB2YXIgZmFyZ3MgPSBtWzNdLnRyaW0oKTtcbiAgICByZXR1cm4gZmFyZ3Muc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnRyaW0oKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGZfYm9keShzcmMpIHtcbiAgcmV0dXJuIHNyYy5zbGljZShzcmMuaW5kZXhPZihcIntcIikgKyAxLCBzcmMubGFzdEluZGV4T2YoXCJ9XCIpKTtcbn1cbmZ1bmN0aW9uIHdyYXBfaWR4cyhzcmMsIHByZSkge1xuICBpZiAocHJlID09PSB2b2lkIDApIHtcbiAgICBwcmUgPSAnJztcbiAgfVxuXG4gIFNCUkFDS0VUUy5sYXN0SW5kZXggPSAwO1xuICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICB2YXIgbSA9IFNCUkFDS0VUUy5leGVjKHNyYyk7XG5cbiAgICBpZiAobSkge1xuICAgICAgdmFyIHZuYW1lID0gbVsxXS50cmltKCk7XG4gICAgICB2YXIgdmluZGV4ID0gbVsyXS50cmltKCk7XG5cbiAgICAgIGlmICh2aW5kZXggPT09ICcwJyB8fCBwYXJzZUludCh2aW5kZXgpIDwgQlVGX0lOQykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh2bmFtZSkge1xuICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICBjYXNlICd2YXInOlxuICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvL2xldCB3cmFwID0gYCR7cHJlfV92KCR7dm5hbWV9LCAke3ZpbmRleH0pWyR7dmluZGV4fV1gXG5cblxuICAgICAgdmFyIHdyYXAgPSBcIlwiLmNvbmNhdCh2bmFtZSwgXCJbXCIpLmNvbmNhdChwcmUsIFwiX2koXCIpLmNvbmNhdCh2aW5kZXgsIFwiLCBcIikuY29uY2F0KHZuYW1lLCBcIildXCIpO1xuICAgICAgc3JjID0gc3JjLnJlcGxhY2UobVswXSwgd3JhcCk7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0gd2hpbGUgKG0pO1xuXG4gIHJldHVybiBjaGFuZ2VkID8gc3JjIDogc3JjO1xufSAvLyBHZXQgYWxsIG1vZHVsZSBoZWxwZXIgY2xhc3Nlc1xuXG5mdW5jdGlvbiBtYWtlX21vZHVsZV9saWIobW9kKSB7XG4gIHZhciBsaWIgPSB7fTtcblxuICBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgIGlmIChrID09PSAnbWFpbicgfHwgayA9PT0gJ2lkJykgY29udGludWU7XG4gICAgdmFyIGEgPSBmX2FyZ3MobW9kW2tdKTtcbiAgICBsaWJba10gPSBuZXcgRnVuY3Rpb24oYSwgZl9ib2R5KG1vZFtrXSkpO1xuICB9XG5cbiAgcmV0dXJuIGxpYjtcbn1cbmZ1bmN0aW9uIGdldF9yYXdfc3JjKGYpIHtcbiAgaWYgKHR5cGVvZiBmID09PSAnc3RyaW5nJykgcmV0dXJuIGY7XG4gIHZhciBzcmMgPSBmLnRvU3RyaW5nKCk7XG4gIHJldHVybiBzcmMuc2xpY2Uoc3JjLmluZGV4T2YoXCJ7XCIpICsgMSwgc3JjLmxhc3RJbmRleE9mKFwifVwiKSk7XG59IC8vIEdldCB0ZiBpbiBtcyBmcm9tIHBhaXJzIHN1Y2ggKGAxNWAsIGBtYClcblxuZnVuY3Rpb24gdGZfZnJvbV9wYWlyKG51bSwgcGYpIHtcbiAgdmFyIG11bHQgPSAxO1xuXG4gIHN3aXRjaCAocGYpIHtcbiAgICBjYXNlICdzJzpcbiAgICAgIG11bHQgPSBDb25zdC5TRUNPTkQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ20nOlxuICAgICAgbXVsdCA9IENvbnN0Lk1JTlVURTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnSCc6XG4gICAgICBtdWx0ID0gQ29uc3QuSE9VUjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRCc6XG4gICAgICBtdWx0ID0gQ29uc3QuREFZO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdXJzpcbiAgICAgIG11bHQgPSBDb25zdC5XRUVLO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdNJzpcbiAgICAgIG11bHQgPSBDb25zdC5NT05USDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnWSc6XG4gICAgICBtdWx0ID0gQ29uc3QuWUVBUjtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KG51bSkgKiBtdWx0O1xufVxuZnVuY3Rpb24gdGZfZnJvbV9zdHIoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyID09PSAnbnVtYmVyJykgcmV0dXJuIHN0cjtcbiAgaWYgKHRmX2NhY2hlW3N0cl0pIHJldHVybiB0Zl9jYWNoZVtzdHJdO1xuICBURlNUUi5sYXN0SW5kZXggPSAwO1xuICB2YXIgbSA9IFRGU1RSLmV4ZWMoc3RyKTtcblxuICBpZiAobSkge1xuICAgIHRmX2NhY2hlW3N0cl0gPSB0Zl9mcm9tX3BhaXIobVsxXSwgbVsyXSk7XG4gICAgcmV0dXJuIHRmX2NhY2hlW3N0cl07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0X2ZuX2lkKHByZSwgaWQpIHtcbiAgcmV0dXJuIHByZSArICctJyArIGlkLnNwbGl0KCc8LScpLnBvcCgpO1xufSAvLyBBcHBseSBmaWx0ZXIgZm9yIGFsbCBuZXcgb3ZlcmxheXNcblxuZnVuY3Rpb24gb3ZmKG9iaiwgZikge1xuICB2YXIgbncgPSB7fTtcblxuICBmb3IgKHZhciBpZCBpbiBvYmopIHtcbiAgICBud1tpZF0gPSB7fTtcblxuICAgIGZvciAodmFyIGsgaW4gb2JqW2lkXSkge1xuICAgICAgaWYgKGsgPT09ICdkYXRhJykgY29udGludWU7XG4gICAgICBud1tpZF1ba10gPSBvYmpbaWRdW2tdO1xuICAgIH1cblxuICAgIG53W2lkXS5kYXRhID0gZihvYmpbaWRdLmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIG53O1xufSAvLyBSZXR1cm4gaW5kZXggb2YgdGhlIG5leHQgZWxlbWVudCBpblxuLy8gZGF0YXNldCAoc2luY2UgdCkuIEltcGw6IHNpbXBsZSBiaW5hcnkgc2VhcmNoXG4vLyBUT0RPOiBvcHRpbWl6ZSAocmVtZW1iZXIgdGhlIHBlbnVsdGltYXRlXG4vLyBpdGVyYXRpb24gYW5kIHN0YXJ0IGZyb20gdGhlcmUpXG5cbmZ1bmN0aW9uIG5leHR0KGRhdGEsIHQsIHRpKSB7XG4gIGlmICh0aSA9PT0gdm9pZCAwKSB7XG4gICAgdGkgPSAwO1xuICB9XG5cbiAgdmFyIGkwID0gMDtcbiAgdmFyIGlOID0gZGF0YS5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChpMCA8PSBpTikge1xuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChpMCArIGlOKSAvIDIpO1xuXG4gICAgaWYgKGRhdGFbbWlkXVt0aV0gPT09IHQpIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfSBlbHNlIGlmIChkYXRhW21pZF1bdGldIDwgdCkge1xuICAgICAgaTAgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpTiA9IG1pZCAtIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHQgPCBkYXRhW21pZF1bdGldID8gbWlkIDogbWlkICsgMTtcbn0gLy8gRXN0aW1hdGVkIHNpemUgb2YgZGF0YXNldHNcblxuZnVuY3Rpb24gc2l6ZV9vZl9kc3MoZGF0YSkge1xuICB2YXIgYnl0ZXMgPSAwO1xuXG4gIGZvciAodmFyIGlkIGluIGRhdGEpIHtcbiAgICBpZiAoZGF0YVtpZF0uZGF0YSAmJiBkYXRhW2lkXS5kYXRhWzBdKSB7XG4gICAgICB2YXIgczAgPSBzaXplX29mKGRhdGFbaWRdLmRhdGFbMF0pO1xuICAgICAgYnl0ZXMgKz0gczAgKiBkYXRhW2lkXS5kYXRhLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59IC8vIFVzZWQgdG8gbWVhc3VyZSB0aGUgc2l6ZSBvZiBkYXRhc2V0XG5cbmZ1bmN0aW9uIHNpemVfb2Yob2JqZWN0KSB7XG4gIHZhciBsaXN0ID0gW10sXG4gICAgICBzdGFjayA9IFtvYmplY3RdLFxuICAgICAgYnl0ZXMgPSAwO1xuXG4gIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdGFjay5wb3AoKTtcblxuICAgIHZhciB0eXBlID0gX3R5cGVvZih2YWx1ZSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBieXRlcyArPSA0O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVzICs9IHZhbHVlLmxlbmd0aCAqIDI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgYnl0ZXMgKz0gODtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIGxpc3QuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICBsaXN0LnB1c2godmFsdWUpO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSB7XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn0gLy8gVXBkYXRlIG9uY2hhcnQvb2ZmY2hhcnRcblxuZnVuY3Rpb24gdXBkYXRlKGRhdGEsIHZhbCkge1xuICB2YXIgaSA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgdmFyIGxhc3QgPSBkYXRhW2ldO1xuXG4gIGlmICghbGFzdCB8fCB2YWxbMF0gPiBsYXN0WzBdKSB7XG4gICAgZGF0YS5wdXNoKHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpXSA9IHZhbDtcbiAgfVxufVxuZnVuY3Rpb24gc2NyaXB0X3V0aWxzX25vdygpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvZGF0YXNldC5qc1xuXG5cblxuXG5cbmZ1bmN0aW9uIGRhdGFzZXRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IGRhdGFzZXRfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIGRhdGFzZXRfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBkYXRhc2V0X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBkYXRhc2V0X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBkYXRhc2V0X2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuLy8gRGF0YXNldCBwcm94eSBiZXR3ZWVuIHZ1ZWpzICYgV2ViV29ya2VyXG5cblxudmFyIERhdGFzZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRhc2V0KGRjLCBkZXNjKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YXNldCk7XG5cbiAgICAvLyBUT0RPOiBkYXRhc2V0IHVybCBhcnJvdyBmbiB0ZWxscyBXV1xuICAgIC8vIHRvIGxvYWQgdGhlIGRzIGRpcmVjdGx5IGZyb20gd2ViXG4gICAgdGhpcy50eXBlID0gZGVzYy50eXBlO1xuICAgIHRoaXMuaWQgPSBkZXNjLmlkO1xuICAgIHRoaXMuZGMgPSBkYzsgLy8gU2VuZCB0aGUgZGF0YSB0byBXV1xuXG4gICAgaWYgKGRlc2MuZGF0YSkge1xuICAgICAgdGhpcy5kYy53dy5qdXN0KCd1cGxvYWQtZGF0YScsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgdGhpcy5pZCwgZGVzYykpOyAvLyBSZW1vdmUgdGhlIGRhdGEgZnJvbSB0aGUgZGVzY3JpcHRvclxuXG4gICAgICBkZWxldGUgZGVzYy5kYXRhO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZGVzYywgcHJvdG8pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXNjLCAnZGMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGRjO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIFdhdGNoIGZvciB0aGUgY2hhbmdlcyBvZiBkZXNjcmlwdG9yc1xuXG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoRGF0YXNldCwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IC8vIFNldCBkYXRhIChvdmVyd3JpdGUgdGhlIHdob2xlIGRhdGFzZXQpXG4gICAgZnVuY3Rpb24gc2V0KGRhdGEsIGV4ZWMpIHtcbiAgICAgIGlmIChleGVjID09PSB2b2lkIDApIHtcbiAgICAgICAgZXhlYyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGMud3cuanVzdCgnZGF0YXNldC1vcCcsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBleGVjOiBleGVjXG4gICAgICB9KTtcbiAgICB9IC8vIFVwZGF0ZSB3aXRoIG5ldyBkYXRhIChhcnJheSBvZiBkYXRhIHBvaW50cylcblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoYXJyKSB7XG4gICAgICB0aGlzLmRjLnd3Lmp1c3QoJ3VwZGF0ZS1kYXRhJywgX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLmlkLCBhcnIpKTtcbiAgICB9IC8vIFNlbmQgV1cgYSBjaHVuayB0byBtZXJnZS4gVGhlIG1lcmdlIGFsZ29cbiAgICAvLyBoZXJlIGlzIHNpbXBsZXIgdGhhbiBpbiBEQy4gSXQganVzdCBhZGRzXG4gICAgLy8gZGF0YSBhdCB0aGUgYmVnaW5uaW5nIG9yL2FuZCB0aGUgZW5kIG9mIGRzXG5cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShkYXRhLCBleGVjKSB7XG4gICAgICBpZiAoZXhlYyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGV4ZWMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRjLnd3Lmp1c3QoJ2RhdGFzZXQtb3AnLCB7XG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICB0eXBlOiAnbXJnJyxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZXhlYzogZXhlY1xuICAgICAgfSk7XG4gICAgfSAvLyBSZW1vdmUgdGhlIGRzIGZyb20gV1dcblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoZXhlYykge1xuICAgICAgaWYgKGV4ZWMgPT09IHZvaWQgMCkge1xuICAgICAgICBleGVjID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYy5kZWwoXCJkYXRhc2V0cy5cIi5jb25jYXQodGhpcy5pZCkpO1xuICAgICAgdGhpcy5kYy53dy5qdXN0KCdkYXRhc2V0LW9wJywge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgIGV4ZWM6IGV4ZWNcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHRoaXMuZGMuZHNzW3RoaXMuaWRdO1xuICAgIH0gLy8gRmV0Y2ggZGF0YSBmcm9tIFdXXG5cbiAgfSwge1xuICAgIGtleTogXCJkYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JfZGVmYXVsdCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIGRzO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JfZGVmYXVsdCgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGMud3cuZXhlYygnZ2V0LWRhdGFzZXQnLCB0aGlzLmlkKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZHMgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRzKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZHMuZGF0YSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4gX2RhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSgpXG4gIH1dLCBbe1xuICAgIGtleTogXCJ3YXRjaGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhdGNoZXIobiwgcCkge1xuICAgICAgdmFyIG5pZHMgPSBuLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5pZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIHBpZHMgPSBwLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5pZDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gZGF0YXNldF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5pZHMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpZCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKCFwaWRzLmluY2x1ZGVzKGlkKSkge1xuICAgICAgICAgICAgdmFyIGRzID0gbi5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHguaWQgPT09IGlkO1xuICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICB0aGlzLmRzc1tpZF0gPSBuZXcgRGF0YXNldCh0aGlzLCBkcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gZGF0YXNldF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBpZHMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaWQgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBpZiAoIW5pZHMuaW5jbHVkZXMoaWQpICYmIHRoaXMuZHNzW2lkXSkge1xuICAgICAgICAgICAgdGhpcy5kc3NbaWRdLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfSAvLyBNYWtlIGFuIG9iamVjdCBmb3IgZGF0YSB0cmFuc2ZlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFrZV90eFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlX3R4KGRjLCB0eXBlcykge1xuICAgICAgdmFyIG1haW4gPSBkYy5kYXRhLmNoYXJ0LmRhdGE7XG4gICAgICB2YXIgYmFzZSA9IHt9O1xuXG4gICAgICBpZiAodHlwZXMuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50eXBlID09PSAnT0hMQ1YnO1xuICAgICAgfSkpIHtcbiAgICAgICAgYmFzZSA9IHtcbiAgICAgICAgICBvaGxjdjogbWFpblxuICAgICAgICB9O1xuICAgICAgfSAvLyBUT0RPOiBhZGQgbW9yZSBzb3BoaXN0aWNhdGVkIHNlYXJjaFxuICAgICAgLy8gKHVzaW5nICdzY3JpcHQuZGF0YXNldHMnIHBhcmFtZXJ0ZXIpXG5cbiAgICAgIC8qZm9yICh2YXIgcmVxIG9mIHR5cGVzKSB7XG4gICAgICAgICAgbGV0IGRzID0gT2JqZWN0LnZhbHVlcyhkYy5kc3MgfHwge30pXG4gICAgICAgICAgICAgIC5maW5kKHggPT4geC50eXBlID09PSByZXEudHlwZSlcbiAgICAgICAgICBpZiAoZHMgJiYgZHMuZGF0YSkge1xuICAgICAgICAgICAgICBiYXNlW2RzLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBkcy5pZCxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IGRzLnR5cGUsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBkcy5kYXRhXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9Ki9cbiAgICAgIC8vIFRPRE86IERhdGEgcmVxdWVzdCBjYWxsYmFjayA/XG5cblxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFzZXQ7XG59KCk7IC8vIERhdGFzZXQgcmVjaWV2ZXIgKGNyZWF0ZWQgb24gV1cpXG5cblxuXG52YXIgRGF0YXNldFdXID0gLyojX19QVVJFX18qLygvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0YXNldFdXKGlkLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFzZXRXVyk7XG5cbiAgICB0aGlzLmxhc3RfdXBkID0gbm93KCk7XG4gICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIC8vIFJlZ3VsYXIgYXJyYXlcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICBpZiAoaWQgPT09ICdvaGxjdicpIHRoaXMudHlwZSA9ICdPSExDVic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERhdGFzZXQgZGVzY3JpcHRvclxuICAgICAgdGhpcy5kYXRhID0gZGF0YS5kYXRhO1xuICAgICAgdGhpcy50eXBlID0gZGF0YS50eXBlO1xuICAgIH1cbiAgfSAvLyBVcGRhdGUgZnJvbSAndXBkYXRlLWRhdGEnIGV2ZW50XG4gIC8vIFRPRE86IGRzIHNpemUgbGltaXQgKGluIE1CIC8gZGF0YSBwb2ludHMpXG5cblxuICBfY3JlYXRlQ2xhc3MoRGF0YXNldFdXLCBbe1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShkYXRhKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5kYXRhLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdDAgPSB0aGlzLmRhdGFbMF1bMF07XG4gICAgICB2YXIgdE4gPSB0aGlzLmRhdGFbbGVuIC0gMV1bMF07XG4gICAgICB2YXIgbCA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4WzBdIDwgdDA7XG4gICAgICB9KTtcbiAgICAgIHZhciByID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhbMF0gPiB0TjtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kYXRhID0gbC5jb25jYXQodGhpcy5kYXRhLCByKTtcbiAgICB9IC8vIE9uIGRhdGFzZXQgb3BlcmF0aW9uXG5cbiAgfSwge1xuICAgIGtleTogXCJvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcChzZSwgX29wKSB7XG4gICAgICB0aGlzLmxhc3RfdXBkID0gbm93KCk7XG5cbiAgICAgIHN3aXRjaCAoX29wLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICB0aGlzLmRhdGEgPSBfb3AuZGF0YTtcbiAgICAgICAgICBzZS5yZWNhbGNfc2l6ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgICAgZGVsZXRlIHNlLmRhdGFbdGhpcy5pZF07XG4gICAgICAgICAgc2UucmVjYWxjX3NpemUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtcmcnOlxuICAgICAgICAgIHRoaXMubWVyZ2UoX29wLmRhdGEpO1xuICAgICAgICAgIHNlLnJlY2FsY19zaXplKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidXBkYXRlX2FsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVfYWxsKHNlLCBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGsgPT09ICdvaGxjdicpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgaWQgPSBrLnNwbGl0KCcuJylbMV0gfHwgaztcbiAgICAgICAgaWYgKCFzZS5kYXRhW2lkXSkgY29udGludWU7XG4gICAgICAgIHZhciBhcnIgPSBzZS5kYXRhW2lkXS5kYXRhO1xuICAgICAgICB2YXIgaU4gPSBhcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3QgPSBhcnJbaU5dO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gZGF0YXNldF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGFba10pLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBkcCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCFsYXN0IHx8IGRwWzBdID4gbGFzdFswXSkge1xuICAgICAgICAgICAgICBhcnIucHVzaChkcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlLmRhdGFbaWRdLmxhc3RfdXBkID0gbm93KCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFzZXRXVztcbn0oKSkpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvZGNfZXZlbnRzLmpzXG5cblxuXG5cblxuZnVuY3Rpb24gZGNfZXZlbnRzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBkY19ldmVudHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIGRjX2V2ZW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGRjX2V2ZW50c19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gZGNfZXZlbnRzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBkY19ldmVudHNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gRGF0YUN1YmUgZXZlbnQgaGFuZGxlcnNcblxuXG5cblxuXG52YXIgRENFdmVudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEQ0V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgRENFdmVudHMpO1xuXG4gICAgdGhpcy53dyA9IG5ldyBzY3JpcHRfd3dfYXBpKHRoaXMpOyAvLyBMaXN0ZW4gdG8gdGhlIHdlYi13b3JrZXIgZXZlbnRzXG5cbiAgICB0aGlzLnd3Lm9uZXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IGRjX2V2ZW50c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF90aGlzLnR2LmNvbnRyb2xsZXJzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY3RybCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChjdHJsLnd3KSBjdHJsLnd3KGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChlLmRhdGEudHlwZSkge1xuICAgICAgICBjYXNlICdyZXF1ZXN0LWRhdGEnOlxuICAgICAgICAgIC8vIFRPRE86IERhdGFUdW5uZWwgY2xhc3MgZm9yIHNtYXJ0ZXIgZGF0YSB0cmFuc2ZlclxuICAgICAgICAgIGlmIChfdGhpcy53dy5fZGF0YV91cGxvYWRpbmcpIGJyZWFrO1xuICAgICAgICAgIHZhciBkYXRhID0gRGF0YXNldC5tYWtlX3R4KF90aGlzLCBlLmRhdGEuZGF0YSk7XG5cbiAgICAgICAgICBfdGhpcy5zZW5kX21ldGFfMl93dygpO1xuXG4gICAgICAgICAgX3RoaXMud3cuanVzdCgndXBsb2FkLWRhdGEnLCBkYXRhKTtcblxuICAgICAgICAgIF90aGlzLnd3Ll9kYXRhX3VwbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnb3ZlcmxheS1kYXRhJzpcbiAgICAgICAgICBfdGhpcy5vbl9vdmVybGF5X2RhdGEoZS5kYXRhLmRhdGEpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnb3ZlcmxheS11cGRhdGUnOlxuICAgICAgICAgIF90aGlzLm9uX292ZXJsYXlfdXBkYXRlKGUuZGF0YS5kYXRhKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RhdGEtdXBsb2FkZWQnOlxuICAgICAgICAgIF90aGlzLnd3Ll9kYXRhX3VwbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2VuZ2luZS1zdGF0ZSc6XG4gICAgICAgICAgX3RoaXMuc2Vfc3RhdGUgPSBPYmplY3QuYXNzaWduKF90aGlzLnNlX3N0YXRlIHx8IHt9LCBlLmRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW9kaWZ5LW92ZXJsYXknOlxuICAgICAgICAgIF90aGlzLm1vZGlmeV9vdmVybGF5KGUuZGF0YS5kYXRhKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NjcmlwdC1zaWduYWwnOlxuICAgICAgICAgIF90aGlzLnR2LiRlbWl0KCdzaWduYWwnLCBlLmRhdGEuZGF0YSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBkY19ldmVudHNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihfdGhpcy50di5jb250cm9sbGVycyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjdHJsID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGlmIChjdHJsLnBvc3Rfd3cpIGN0cmwucG9zdF93dyhlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IC8vIENhbGxlZCB3aGVuIG92ZXJhbGF5L3R2IGVtaXRzICdjdXN0b20tZXZlbnQnXG5cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhEQ0V2ZW50cywgW3tcbiAgICBrZXk6IFwib25fY3VzdG9tX2V2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX2N1c3RvbV9ldmVudChldmVudCwgYXJncykge1xuICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICBjYXNlICdyZWdpc3Rlci10b29scyc6XG4gICAgICAgICAgdGhpcy5yZWdpc3Rlcl90b29scyhhcmdzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdleGVjLXNjcmlwdCc6XG4gICAgICAgICAgdGhpcy5leGVjX3NjcmlwdChhcmdzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdleGVjLWFsbC1zY3JpcHRzJzpcbiAgICAgICAgICB0aGlzLmV4ZWNfYWxsX3NjcmlwdHMoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXRhLWxlbi1jaGFuZ2VkJzpcbiAgICAgICAgICB0aGlzLmRhdGFfY2hhbmdlZChhcmdzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0b29sLXNlbGVjdGVkJzpcbiAgICAgICAgICBpZiAoIWFyZ3NbMF0pIGJyZWFrOyAvLyBUT0RPOiBRdWljayBmaXgsIGludmVzdGlnYXRlXG5cbiAgICAgICAgICBpZiAoYXJnc1swXS5zcGxpdCgnOicpWzBdID09PSAnU3lzdGVtJykge1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW1fdG9vbChhcmdzWzBdLnNwbGl0KCc6JylbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3Rvb2wnLCBhcmdzWzBdKTtcblxuICAgICAgICAgIGlmIChhcmdzWzBdID09PSAnQ3Vyc29yJykge1xuICAgICAgICAgICAgdGhpcy5kcmF3aW5nX21vZGVfb2ZmKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZ3JpZC1tb3VzZWRvd24nOlxuICAgICAgICAgIHRoaXMuZ3JpZF9tb3VzZWRvd24oYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZHJhd2luZy1tb2RlLW9mZic6XG4gICAgICAgICAgdGhpcy5kcmF3aW5nX21vZGVfb2ZmKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hhbmdlLXNldHRpbmdzJzpcbiAgICAgICAgICB0aGlzLmNoYW5nZV9zZXR0aW5ncyhhcmdzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyYW5nZS1jaGFuZ2VkJzpcbiAgICAgICAgICB0aGlzLnNjcmlwdHNfb25yYW5nZS5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Njcm9sbC1sb2NrJzpcbiAgICAgICAgICB0aGlzLm9uX3Njcm9sbF9sb2NrKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ29iamVjdC1zZWxlY3RlZCc6XG4gICAgICAgICAgdGhpcy5vYmplY3Rfc2VsZWN0ZWQoYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlLXRvb2wnOlxuICAgICAgICAgIHRoaXMuc3lzdGVtX3Rvb2woJ1JlbW92ZScpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JlZm9yZS1kZXN0cm95JzpcbiAgICAgICAgICB0aGlzLmJlZm9yZV9kZXN0cm95KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBUcmlnZ2VyZWQgd2hlbiBvbmUgb3IgbXVsdGlwbGUgc2V0dGluZ3MgYXJlIGNoYW5nZWRcbiAgICAvLyBXZSBzZWxlY3Qgb25seSB0aGUgY2hhbmdlZCBvbmVzICYgcmUtZXhlYyB0aGVtIG9uIHRoZVxuICAgIC8vIHdlYiB3b3JrZXJcblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NldHRpbmdzKHZhbHVlcywgcHJldikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5zZXR0LnNjcmlwdHMpIHJldHVybjtcbiAgICAgIHZhciBkZWx0YSA9IHt9O1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBuID0gdmFsdWVzW2ldO1xuICAgICAgICB2YXIgYXJyID0gcHJldi5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC52ID09PSBuLnY7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghYXJyLmxlbmd0aCAmJiBuLnAuc2V0dGluZ3MuJHByb3BzKSB7XG4gICAgICAgICAgdmFyIGlkID0gbi5wLnNldHRpbmdzLiR1dWlkO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzX3Njcl9wcm9wc191cGQobiwgcHJldikgJiYgdXRpbHMuZGVsYXllZF9leGVjKG4ucCkpIHtcbiAgICAgICAgICAgIGRlbHRhW2lkXSA9IG4udjtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBfdGhpczIudHYuJHNldChuLnAsICdsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCAmJiBPYmplY3Qua2V5cyhkZWx0YSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ZiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuaW50ZXJ2YWxfbXMgfHwgdGhpcy5kYXRhLmNoYXJ0LnRmO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnR2LmdldFJhbmdlKCk7XG4gICAgICAgIHRoaXMud3cuanVzdCgndXBkYXRlLW92LXNldHRpbmdzJywge1xuICAgICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgICB0ZjogdGYsXG4gICAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gV2hlbiB0aGUgc2V0IG9mICR1dWlkcyBpcyBjaGFuZ2VkXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9pZHNfY2hhbmdlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9pZHNfY2hhbmdlZCh2YWx1ZXMsIHByZXYpIHtcbiAgICAgIHZhciByZW0gPSBwcmV2LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCAhPT0gdW5kZWZpbmVkICYmICF2YWx1ZXMuaW5jbHVkZXMoeCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlbS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy53dy5qdXN0KCdyZW1vdmUtc2NyaXB0cycsIHJlbSk7XG4gICAgICB9XG4gICAgfSAvLyBDb21iaW5lIGFsbCB0b29scyBhbmQgdGhlaXIgbW9kc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJfdG9vbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJfdG9vbHModG9vbHMpIHtcbiAgICAgIHZhciBwcmVzZXQgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBkY19ldmVudHNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmRhdGEudG9vbHMgfHwgW10pLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdG9vbCA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICBwcmVzZXRbdG9vbC50eXBlXSA9IHRvb2w7XG4gICAgICAgICAgZGVsZXRlIHRvb2wudHlwZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICd0b29scycsIFtdKTtcbiAgICAgIHZhciBsaXN0ID0gW3tcbiAgICAgICAgdHlwZTogJ0N1cnNvcicsXG4gICAgICAgIGljb246IGljb25zX25hbWVzcGFjZU9iamVjdFtcImN1cnNvci5wbmdcIl1cbiAgICAgIH1dO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IGRjX2V2ZW50c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRvb2xzKSxcbiAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHRvb2wgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmFzc2lnbih7fSwgdG9vbC5pbmZvKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRvb2wuaW5mby50eXBlIHx8ICdEZWZhdWx0JztcbiAgICAgICAgICBwcm90by50eXBlID0gXCJcIi5jb25jYXQodG9vbC51c2VfZm9yLCBcIjpcIikuY29uY2F0KHR5cGUpO1xuICAgICAgICAgIHRoaXMubWVyZ2VfcHJlc2V0cyhwcm90bywgcHJlc2V0W3Rvb2wudXNlX2Zvcl0pO1xuICAgICAgICAgIHRoaXMubWVyZ2VfcHJlc2V0cyhwcm90bywgcHJlc2V0W3Byb3RvLnR5cGVdKTtcbiAgICAgICAgICBkZWxldGUgcHJvdG8ubW9kcztcbiAgICAgICAgICBsaXN0LnB1c2gocHJvdG8pO1xuXG4gICAgICAgICAgZm9yICh2YXIgbW9kIGluIHRvb2wuaW5mby5tb2RzKSB7XG4gICAgICAgICAgICB2YXIgbXAgPSBPYmplY3QuYXNzaWduKHt9LCBwcm90byk7XG4gICAgICAgICAgICBtcCA9IE9iamVjdC5hc3NpZ24obXAsIHRvb2wuaW5mby5tb2RzW21vZF0pO1xuICAgICAgICAgICAgbXAudHlwZSA9IFwiXCIuY29uY2F0KHRvb2wudXNlX2ZvciwgXCI6XCIpLmNvbmNhdChtb2QpO1xuICAgICAgICAgICAgdGhpcy5tZXJnZV9wcmVzZXRzKG1wLCBwcmVzZXRbdG9vbC51c2VfZm9yXSk7XG4gICAgICAgICAgICB0aGlzLm1lcmdlX3ByZXNldHMobXAsIHByZXNldFttcC50eXBlXSk7XG4gICAgICAgICAgICBsaXN0LnB1c2gobXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICd0b29scycsIGxpc3QpO1xuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3Rvb2wnLCAnQ3Vyc29yJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4ZWNfc2NyaXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4ZWNfc2NyaXB0KGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAmJiB0aGlzLnNldHQuc2NyaXB0cykge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXRfb3ZlcmxheShhcmdzWzBdKTtcbiAgICAgICAgaWYgKCFvYmogfHwgb2JqLnNjcmlwdHMgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKG9iai5zY3JpcHQgJiYgb2JqLnNjcmlwdC5zcmMpIHtcbiAgICAgICAgICBhcmdzWzBdLnNyYyA9IG9iai5zY3JpcHQuc3JjOyAvLyBvcHQsIG92ZXJyaWRlIHRoZSBzcmNcbiAgICAgICAgfSAvLyBQYXJzZSBzY3JpcHQgcHJvcHMgJiBnZXQgdGhlIHZhbHVlcyBmcm9tIHRoZSBvdlxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdW5uZWNlc3Nhcnkgc2NyaXB0IGluaXRpYWxpemF0aW9uc1xuXG5cbiAgICAgICAgdmFyIHMgPSBvYmouc2V0dGluZ3M7XG4gICAgICAgIHZhciBwcm9wcyA9IGFyZ3NbMF0uc3JjLnByb3BzIHx8IHt9O1xuICAgICAgICBpZiAoIXMuJHV1aWQpIHMuJHV1aWQgPSBcIlwiLmNvbmNhdChvYmoudHlwZSwgXCItXCIpLmNvbmNhdCh1dGlscy51dWlkMigpKTtcbiAgICAgICAgYXJnc1swXS51dWlkID0gcy4kdXVpZDtcbiAgICAgICAgYXJnc1swXS5zZXR0ID0gcztcblxuICAgICAgICBmb3IgKHZhciBrIGluIHByb3BzIHx8IHt9KSB7XG4gICAgICAgICAgdmFyIHByb3RvID0gcHJvcHNba107XG5cbiAgICAgICAgICBpZiAoc1trXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm90by52YWwgPSBzW2tdOyAvLyB1c2UgdGhlIGV4aXN0aW5nIHZhbFxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJvdG8uZGVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IG9mIGluZm8gLyBlcnJvcnMgdG8gdGhlIGxlZ2VuZFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk92ZXJsYXkgXCIuY29uY2F0KG9iai5pZCwgXCI6IHNjcmlwdCBwcm9wICdcIikuY29uY2F0KGssIFwiJyBcIikgKyBcImRvZXNuJ3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc1trXSA9IHByb3RvLnZhbCA9IHByb3RvLmRlZjsgLy8gc2V0IHRoZSBkZWZhdWx0XG4gICAgICAgIH0gLy8gUmVtb3ZlIG9sZCBwcm9wcyAoZHJvcHBlZCBieSB0aGUgY3VycmVudCBleGVjKVxuXG5cbiAgICAgICAgaWYgKHMuJHByb3BzKSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBzKSB7XG4gICAgICAgICAgICBpZiAocy4kcHJvcHMuaW5jbHVkZXMoaykgJiYgIShrIGluIHByb3BzKSkge1xuICAgICAgICAgICAgICBkZWxldGUgc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzLiRwcm9wcyA9IE9iamVjdC5rZXlzKGFyZ3NbMF0uc3JjLnByb3BzIHx8IHt9KTtcbiAgICAgICAgdGhpcy50di4kc2V0KG9iaiwgJ2xvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgdmFyIHRmID0gdGhpcy50di4kcmVmcy5jaGFydC5pbnRlcnZhbF9tcyB8fCB0aGlzLmRhdGEuY2hhcnQudGY7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMudHYuZ2V0UmFuZ2UoKTtcblxuICAgICAgICBpZiAob2JqLnNjcmlwdCAmJiBvYmouc2NyaXB0Lm91dHB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgYXJnc1swXS5vdXRwdXQgPSBvYmouc2NyaXB0Lm91dHB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud3cuanVzdCgnZXhlYy1zY3JpcHQnLCB7XG4gICAgICAgICAgczogYXJnc1swXSxcbiAgICAgICAgICB0ZjogdGYsXG4gICAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleGVjX2FsbF9zY3JpcHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4ZWNfYWxsX3NjcmlwdHMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2V0dC5zY3JpcHRzKSByZXR1cm47XG4gICAgICB0aGlzLnNldF9sb2FkaW5nKHRydWUpO1xuICAgICAgdmFyIHRmID0gdGhpcy50di4kcmVmcy5jaGFydC5pbnRlcnZhbF9tcyB8fCB0aGlzLmRhdGEuY2hhcnQudGY7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnR2LmdldFJhbmdlKCk7XG4gICAgICB0aGlzLnd3Lmp1c3QoJ2V4ZWMtYWxsLXNjcmlwdHMnLCB7XG4gICAgICAgIHRmOiB0ZixcbiAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2NyaXB0c19vbnJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcmlwdHNfb25yYW5nZShyKSB7XG4gICAgICBpZiAoIXRoaXMuc2V0dC5zY3JpcHRzKSByZXR1cm47XG4gICAgICB2YXIgZGVsdGEgPSB7fTtcbiAgICAgIHRoaXMuZ2V0KCcuJykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodi5zY3JpcHQgJiYgdi5zY3JpcHQuZXhlY09uUmFuZ2UgJiYgdi5zZXR0aW5ncy4kdXVpZCkge1xuICAgICAgICAgIC8vIFRPRE86IGV4ZWNJbnRlcnJ1cHQgZmxhZz9cbiAgICAgICAgICBpZiAodXRpbHMuZGVsYXllZF9leGVjKHYpKSB7XG4gICAgICAgICAgICBkZWx0YVt2LnNldHRpbmdzLiR1dWlkXSA9IHYuc2V0dGluZ3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKGRlbHRhKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRmID0gdGhpcy50di4kcmVmcy5jaGFydC5pbnRlcnZhbF9tcyB8fCB0aGlzLmRhdGEuY2hhcnQudGY7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMudHYuZ2V0UmFuZ2UoKTtcbiAgICAgICAgdGhpcy53dy5qdXN0KCd1cGRhdGUtb3Ytc2V0dGluZ3MnLCB7XG4gICAgICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgICAgIHRmOiB0ZixcbiAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBPdmVybGF5IG1vZGlmaWNhdGlvbiBmcm9tIFdXXG5cbiAgfSwge1xuICAgIGtleTogXCJtb2RpZnlfb3ZlcmxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2RpZnlfb3ZlcmxheSh1cGQpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLmdldF9vdmVybGF5KHVwZCk7XG5cbiAgICAgIGlmIChvYmopIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiB1cGQuZmllbGRzIHx8IHt9KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZl90eXBlb2Yob2JqW2tdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVyZ2UoXCJcIi5jb25jYXQodXBkLnV1aWQsIFwiLlwiKS5jb25jYXQoayksIHVwZC5maWVsZHNba10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR2LiRzZXQob2JqLCBrLCB1cGQuZmllbGRzW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YV9jaGFuZ2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFfY2hhbmdlZChhcmdzKSB7XG4gICAgICBpZiAoIXRoaXMuc2V0dC5zY3JpcHRzKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5zZXR0LmRhdGFfY2hhbmdlX2V4ZWMgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICB2YXIgbWFpbiA9IHRoaXMuZGF0YS5jaGFydC5kYXRhO1xuICAgICAgaWYgKHRoaXMud3cuX2RhdGFfdXBsb2FkaW5nKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMuc2Vfc3RhdGUuc2NyaXB0cykgcmV0dXJuO1xuICAgICAgdGhpcy5zZW5kX21ldGFfMl93dygpO1xuICAgICAgdGhpcy53dy5qdXN0KCd1cGxvYWQtZGF0YScsIHtcbiAgICAgICAgb2hsY3Y6IG1haW5cbiAgICAgIH0pO1xuICAgICAgdGhpcy53dy5fZGF0YV91cGxvYWRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5zZXRfbG9hZGluZyh0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0X2xvYWRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0X2xvYWRpbmcoZmxhZykge1xuICAgICAgdmFyIHNrcnIgPSB0aGlzLmdldCgnLicpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5zZXR0aW5ncy4kcHJvcHM7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBkY19ldmVudHNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihza3JyKSxcbiAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHMgPSBfc3RlcDUudmFsdWU7XG4gICAgICAgICAgdGhpcy5tZXJnZShcIlwiLmNvbmNhdChzLmlkKSwge1xuICAgICAgICAgICAgbG9hZGluZzogZmxhZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZF9tZXRhXzJfd3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZF9tZXRhXzJfd3coKSB7XG4gICAgICB2YXIgdGYgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0LmludGVydmFsX21zIHx8IHRoaXMuZGF0YS5jaGFydC50ZjtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMudHYuZ2V0UmFuZ2UoKTtcbiAgICAgIHRoaXMud3cuanVzdCgnc2VuZC1tZXRhLWluZm8nLCB7XG4gICAgICAgIHRmOiB0ZixcbiAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VfcHJlc2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZV9wcmVzZXRzKHByb3RvLCBwcmVzZXQpIHtcbiAgICAgIGlmICghcHJlc2V0KSByZXR1cm47XG5cbiAgICAgIGZvciAodmFyIGsgaW4gcHJlc2V0KSB7XG4gICAgICAgIGlmIChrID09PSAnc2V0dGluZ3MnKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihwcm90b1trXSwgcHJlc2V0W2tdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1trXSA9IHByZXNldFtrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncmlkX21vdXNlZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmlkX21vdXNlZG93bihhcmdzKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy8gVE9ETzogdG9vbCBzdGF0ZSBmaW5pc2hlZD9cbiAgICAgIHRoaXMub2JqZWN0X3NlbGVjdGVkKFtdKTsgLy8gUmVtb3ZlIHRoZSBwcmV2aW91cyBSYW5nZVRvb2xcblxuICAgICAgdmFyIHJlbSA9IGZ1bmN0aW9uIHJlbSgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5nZXQoJ1JhbmdlVG9vbCcpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LnNldHRpbmdzLnNoaWZ0TW9kZTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuZGVsKHguaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmRhdGEudG9vbCAmJiB0aGlzLmRhdGEudG9vbCAhPT0gJ0N1cnNvcicgJiYgIXRoaXMuZGF0YS5kcmF3aW5nTW9kZSkge1xuICAgICAgICAvLyBQcmV2ZW50IGZyb20gXCJudWxsXCIgdG9vbHMgKHRvb2wgY3JlYXRlZCB3aXRoIEhPREwpXG4gICAgICAgIGlmIChhcmdzWzFdLnR5cGUgIT09ICd0YXAnKSB7XG4gICAgICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ2RyYXdpbmdNb2RlJywgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5idWlsZF90b29sKGFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHYuc2hvd1RoZVRpcChcIjxiPkhvZGw8L2I+KzxiPkRydWc8L2I+IHRvIGNyZWF0ZSwgXCIgKyBcIjxiPlRhcDwvYj4gdG8gZmluaXNoIGEgdG9vbFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHQuc2hpZnRfbWVhc3VyZSAmJiBhcmdzWzFdLnNoaWZ0S2V5KSB7XG4gICAgICAgIHJlbSgpO1xuICAgICAgICB0aGlzLnR2LiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5idWlsZF90b29sKGFyZ3NbMF0sICdSYW5nZVRvb2w6U2hpZnRNb2RlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdpbmdfbW9kZV9vZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd2luZ19tb2RlX29mZigpIHtcbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdkcmF3aW5nTW9kZScsIGZhbHNlKTtcbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICd0b29sJywgJ0N1cnNvcicpO1xuICAgIH0gLy8gUGxhY2UgYSBuZXcgdG9vbFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRfdG9vbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZF90b29sKGdyaWRfaWQsIHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ID0gdGhpcy5kYXRhLnRvb2xzO1xuICAgICAgdHlwZSA9IHR5cGUgfHwgdGhpcy5kYXRhLnRvb2w7XG4gICAgICB2YXIgcHJvdG8gPSBsaXN0LmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudHlwZSA9PT0gdHlwZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwcm90bykgcmV0dXJuO1xuICAgICAgdmFyIHNldHQgPSBPYmplY3QuYXNzaWduKHt9LCBwcm90by5zZXR0aW5ncyB8fCB7fSk7XG4gICAgICB2YXIgZGF0YSA9IChwcm90by5kYXRhIHx8IFtdKS5zbGljZSgpO1xuICAgICAgaWYgKCEoJ2xlZ2VuZCcgaW4gc2V0dCkpIHNldHQubGVnZW5kID0gZmFsc2U7XG4gICAgICBpZiAoISgnei1pbmRleCcgaW4gc2V0dCkpIHNldHRbJ3otaW5kZXgnXSA9IDEwMDtcbiAgICAgIHNldHQuJHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHNldHQuJHN0YXRlID0gJ3dpcCc7XG4gICAgICB2YXIgc2lkZSA9IGdyaWRfaWQgPyAnb2ZmY2hhcnQnIDogJ29uY2hhcnQnO1xuICAgICAgdmFyIGlkID0gdGhpcy5hZGQoc2lkZSwge1xuICAgICAgICBuYW1lOiBwcm90by5uYW1lLFxuICAgICAgICB0eXBlOiB0eXBlLnNwbGl0KCc6JylbMF0sXG4gICAgICAgIHNldHRpbmdzOiBzZXR0LFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgaWQ6IGdyaWRfaWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZXR0LiR1dWlkID0gXCJcIi5jb25jYXQoaWQsIFwiLVwiKS5jb25jYXQodXRpbHMubm93KCkpO1xuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3NlbGVjdGVkJywgc2V0dC4kdXVpZCk7XG4gICAgICB0aGlzLmFkZF90cmFzaF9pY29uKCk7XG4gICAgfSAvLyBSZW1vdmUgc2VsZWN0ZWQgLyBSZW1vdmUgYWxsLCBldGNcblxuICB9LCB7XG4gICAga2V5OiBcInN5c3RlbV90b29sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RlbV90b29sKHR5cGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdSZW1vdmUnOlxuICAgICAgICAgIGlmICh0aGlzLmRhdGEuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsKHRoaXMuZGF0YS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZV90cmFzaF9pY29uKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdpbmdfbW9kZV9vZmYoKTtcbiAgICAgICAgICAgIHRoaXMub25fc2Nyb2xsX2xvY2soZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gQXBwbHkgbmV3IG92ZXJsYXkgc2V0dGluZ3NcblxuICB9LCB7XG4gICAga2V5OiBcImNoYW5nZV9zZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2Vfc2V0dGluZ3MoYXJncykge1xuICAgICAgdmFyIHNldHRpbmdzID0gYXJnc1swXTtcbiAgICAgIGRlbGV0ZSBzZXR0aW5ncy5pZDtcbiAgICAgIHZhciBncmlkX2lkID0gYXJnc1sxXTtcbiAgICAgIHRoaXMubWVyZ2UoXCJcIi5jb25jYXQoYXJnc1szXSwgXCIuc2V0dGluZ3NcIiksIHNldHRpbmdzKTtcbiAgICB9IC8vIExvY2sgdGhlIHNjcm9sbGluZyBtZWNoYW5pc21cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3Njcm9sbF9sb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3Njcm9sbF9sb2NrKGZsYWcpIHtcbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdzY3JvbGxMb2NrJywgZmxhZyk7XG4gICAgfSAvLyBXaGVuIG5ldyBvYmplY3QgaXMgc2VsZWN0ZWQgLyB1bnNlbGVjdGVkXG5cbiAgfSwge1xuICAgIGtleTogXCJvYmplY3Rfc2VsZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2JqZWN0X3NlbGVjdGVkKGFyZ3MpIHtcbiAgICAgIHZhciBxID0gdGhpcy5kYXRhLnNlbGVjdGVkO1xuXG4gICAgICBpZiAocSkge1xuICAgICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGRyYXdpbmcgaXMgZmluaXNoZWRcbiAgICAgICAgLy9sZXQgcmVzID0gdGhpcy5nZXRfb25lKGAke3F9LnNldHRpbmdzYClcbiAgICAgICAgLy9pZiAocmVzICYmIHJlcy4kc3RhdGUgIT09ICdmaW5pc2hlZCcpIHJldHVyblxuICAgICAgICB0aGlzLm1lcmdlKFwiXCIuY29uY2F0KHEsIFwiLnNldHRpbmdzXCIpLCB7XG4gICAgICAgICAgJHNlbGVjdGVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVfdHJhc2hfaWNvbigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnc2VsZWN0ZWQnLCBudWxsKTtcbiAgICAgIGlmICghYXJncy5sZW5ndGgpIHJldHVybjtcbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdzZWxlY3RlZCcsIGFyZ3NbMl0pO1xuICAgICAgdGhpcy5tZXJnZShcIlwiLmNvbmNhdChhcmdzWzJdLCBcIi5zZXR0aW5nc1wiKSwge1xuICAgICAgICAkc2VsZWN0ZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRfdHJhc2hfaWNvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRfdHJhc2hfaWNvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRfdHJhc2hfaWNvbigpIHtcbiAgICAgIHZhciB0eXBlID0gJ1N5c3RlbTpSZW1vdmUnO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLnRvb2xzLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudHlwZSA9PT0gdHlwZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhLnRvb2xzLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBpY29uOiBpY29uc19uYW1lc3BhY2VPYmplY3RbXCJ0cmFzaC5wbmdcIl1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVfdHJhc2hfaWNvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVfdHJhc2hfaWNvbigpIHtcbiAgICAgIC8vIFRPRE86IERvZXMgbm90IGNhbGwgVG9vbGJhciByZW5kZXIgKGRpc3RyIHZlcnNpb24pXG4gICAgICB2YXIgdHlwZSA9ICdTeXN0ZW06UmVtb3ZlJztcbiAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLmRhdGEudG9vbHMsIHRoaXMuZGF0YS50b29scy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudHlwZSAhPT0gdHlwZTtcbiAgICAgIH0pKTtcbiAgICB9IC8vIFNldCBvdmVybGF5IGRhdGEgZnJvbSB0aGUgd2ViLXdvcmtlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fb3ZlcmxheV9kYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX292ZXJsYXlfZGF0YShkYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5nZXQoJy4nKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh4LnNldHRpbmdzLiRzeW50aCkgX3RoaXM0LmRlbChcIlwiLmNvbmNhdCh4LmlkKSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjYgPSBkY19ldmVudHNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhKSxcbiAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG92ID0gX3N0ZXA2LnZhbHVlO1xuICAgICAgICAgIHZhciBvYmogPSB0aGlzLmdldF9vbmUoXCJcIi5jb25jYXQob3YuaWQpKTtcblxuICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMudHYuJHNldChvYmosICdsb2FkaW5nJywgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFvdi5kYXRhKSBjb250aW51ZTtcbiAgICAgICAgICAgIG9iai5kYXRhID0gb3YuZGF0YTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW92Lm5ld19vdnMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaWQgaW4gb3YubmV3X292cy5vbmNoYXJ0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0X29uZShcIm9uY2hhcnQuXCIuY29uY2F0KGlkKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGQoJ29uY2hhcnQnLCBvdi5uZXdfb3ZzLm9uY2hhcnRbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpZCBpbiBvdi5uZXdfb3ZzLm9mZmNoYXJ0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0X29uZShcIm9mZmNoYXJ0LlwiLmNvbmNhdChpZCkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkKCdvZmZjaGFydCcsIG92Lm5ld19vdnMub2ZmY2hhcnRbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuICAgIH0gLy8gUHVzaCBvdmVybGF5IHVwZGF0ZXMgZnJvbSB0aGUgd2ViLXdvcmtlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fb3ZlcmxheV91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25fb3ZlcmxheV91cGRhdGUoZGF0YSkge1xuICAgICAgdmFyIF9pdGVyYXRvcjcgPSBkY19ldmVudHNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhKSxcbiAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG92ID0gX3N0ZXA3LnZhbHVlO1xuICAgICAgICAgIGlmICghb3YuZGF0YSkgY29udGludWU7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0X29uZShcIlwiLmNvbmNhdChvdi5pZCkpO1xuXG4gICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgdGhpcy5mYXN0X21lcmdlKG9iai5kYXRhLCBvdi5kYXRhLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgIH1cbiAgICB9IC8vIENsZWFuLXVwIHVuZmluaXNoZWQgYnVzaW5lc3MgKHRvb2xzKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlX2Rlc3Ryb3koKSB7XG4gICAgICB2YXIgZiA9IGZ1bmN0aW9uIGYoeCkge1xuICAgICAgICByZXR1cm4gIXguc2V0dGluZ3MuJHN0YXRlIHx8IHguc2V0dGluZ3MuJHN0YXRlID09PSAnZmluaXNoZWQnO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5kYXRhLm9uY2hhcnQgPSB0aGlzLmRhdGEub25jaGFydC5maWx0ZXIoZik7XG4gICAgICB0aGlzLmRhdGEub2ZmY2hhcnQgPSB0aGlzLmRhdGEub2ZmY2hhcnQuZmlsdGVyKGYpO1xuICAgICAgdGhpcy5kcmF3aW5nX21vZGVfb2ZmKCk7XG4gICAgICB0aGlzLm9uX3Njcm9sbF9sb2NrKGZhbHNlKTtcbiAgICAgIHRoaXMub2JqZWN0X3NlbGVjdGVkKFtdKTtcbiAgICAgIHRoaXMud3cuZGVzdHJveSgpO1xuICAgIH0gLy8gR2V0IG92ZXJsYXkgYnkgZ3JpZC1sYXllciBpZFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0X292ZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X292ZXJsYXkob2JqKSB7XG4gICAgICB2YXIgaWQgPSBvYmouaWQgfHwgXCJnXCIuY29uY2F0KG9iai5ncmlkX2lkLCBcIl9cIikuY29uY2F0KG9iai5sYXllcl9pZCk7XG4gICAgICB2YXIgZGNpZCA9IG9iai51dWlkIHx8IHRoaXMuZ2xkY1tpZF07XG4gICAgICByZXR1cm4gdGhpcy5nZXRfb25lKFwiXCIuY29uY2F0KGRjaWQpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRENFdmVudHM7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvZGNfY29yZS5qc1xuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZGNfY29yZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gZGNfY29yZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gZGNfY29yZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGRjX2NvcmVfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGRjX2NvcmVfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGRjX2NvcmVfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gZGNfY29yZV9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZGNfY29yZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBkY19jb3JlX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8vIERhdGFDdWJlIFwicHJpdmF0ZVwiIG1ldGhvZHNcblxuXG5cblxudmFyIERDQ29yZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RDRXZlbnRzKSB7XG4gIF9pbmhlcml0cyhEQ0NvcmUsIF9EQ0V2ZW50cyk7XG5cbiAgdmFyIF9zdXBlciA9IGRjX2NvcmVfY3JlYXRlU3VwZXIoRENDb3JlKTtcblxuICBmdW5jdGlvbiBEQ0NvcmUoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgRENDb3JlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKERDQ29yZSwgW3tcbiAgICBrZXk6IFwiaW5pdF90dmpzXCIsXG4gICAgdmFsdWU6IC8vIFNldCBUViBpbnN0YW5jZSAob25jZSkuIENhbGxlZCBieSBUcmFkaW5nVnVlIGl0c2VsZlxuICAgIGZ1bmN0aW9uIGluaXRfdHZqcygkcm9vdCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnR2KSB7XG4gICAgICAgIHRoaXMudHYgPSAkcm9vdDtcbiAgICAgICAgdGhpcy5pbml0X2RhdGEoKTtcbiAgICAgICAgdGhpcy51cGRhdGVfaWRzKCk7IC8vIExpc3RlbiB0byBhbGwgc2V0dGluZyBjaGFuZ2VzXG4gICAgICAgIC8vIFRPRE86IHdvcmtzIG9ubHkgd2l0aCBtZXJnZSgpXG5cbiAgICAgICAgdGhpcy50di4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRfYnlfcXVlcnkoJy5zZXR0aW5ncycpO1xuICAgICAgICB9LCBmdW5jdGlvbiAobiwgcCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5vbl9zZXR0aW5ncyhuLCBwKTtcbiAgICAgICAgfSk7IC8vIExpc3RlbiB0byBhbGwgaW5kaWNlcyBjaGFuZ2VzXG5cbiAgICAgICAgdGhpcy50di4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQoJy4nKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4LnNldHRpbmdzLiR1dWlkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAobiwgcCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5vbl9pZHNfY2hhbmdlZChuLCBwKTtcbiAgICAgICAgfSk7IC8vIFdhdGNoIGZvciBhbGwgJ2RhdGFzZXRzJyBjaGFuZ2VzXG5cbiAgICAgICAgdGhpcy50di4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQoJ2RhdGFzZXRzJyk7XG4gICAgICAgIH0sIERhdGFzZXQud2F0Y2hlci5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9IC8vIEluaXQgRGF0YSBTdHJ1Y3R1cmUgdjEuMVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdF9kYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRfZGF0YSgkcm9vdCkge1xuICAgICAgaWYgKCEoJ2NoYXJ0JyBpbiB0aGlzLmRhdGEpKSB7XG4gICAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdjaGFydCcsIHtcbiAgICAgICAgICB0eXBlOiAnQ2FuZGxlcycsXG4gICAgICAgICAgZGF0YTogdGhpcy5kYXRhLm9obGN2IHx8IFtdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoISgnb25jaGFydCcgaW4gdGhpcy5kYXRhKSkge1xuICAgICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnb25jaGFydCcsIFtdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoJ29mZmNoYXJ0JyBpbiB0aGlzLmRhdGEpKSB7XG4gICAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdvZmZjaGFydCcsIFtdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmRhdGEuY2hhcnQuc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YS5jaGFydCwgJ3NldHRpbmdzJywge30pO1xuICAgICAgfSAvLyBSZW1vdmUgb2hsY3YgY3V6IHdlIGhhdmUgRGF0YSB2MS4xXlxuXG5cbiAgICAgIGRlbGV0ZSB0aGlzLmRhdGEub2hsY3Y7XG5cbiAgICAgIGlmICghKCdkYXRhc2V0cycgaW4gdGhpcy5kYXRhKSkge1xuICAgICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnZGF0YXNldHMnLCBbXSk7XG4gICAgICB9IC8vIEluaXQgZGF0YXNldCBwcm94aWVzXG5cblxuICAgICAgdmFyIF9pdGVyYXRvciA9IGRjX2NvcmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmRhdGEuZGF0YXNldHMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkcyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGlmICghdGhpcy5kc3MpIHRoaXMuZHNzID0ge307XG4gICAgICAgICAgdGhpcy5kc3NbZHMuaWRdID0gbmV3IERhdGFzZXQodGhpcywgZHMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSAvLyBSYW5nZSBjaGFuZ2UgY2FsbGJhY2sgKGNhbGxlZCBieSBUcmFkaW5nVnVlKVxuICAgIC8vIFRPRE86IGltcHJvdmUgKHJlbGlhYmxpdHkgKyBjaHVuayB3aXRoIGxpbWl0ZWQgc2l6ZSlcblxuICB9LCB7XG4gICAga2V5OiBcInJhbmdlX2NoYW5nZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yYW5nZV9jaGFuZ2VkID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0KCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJhbmdlLCB0ZiwgY2hlY2spIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGZpcnN0LCBwcm9tO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JfZGVmYXVsdCgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpcnN0ID0gdGhpcy5kYXRhLmNoYXJ0LmRhdGFbMF1bMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyYW5nZVswXSA8IGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMucGF1c2UoMjUwKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBiaWdnZXIgY2h1bmtzXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgICAgICAgICAgICByYW5nZVswXSA9IE1hdGguZmxvb3IocmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgIHJhbmdlWzFdID0gTWF0aC5mbG9vcihmaXJzdCk7XG4gICAgICAgICAgICAgICAgcHJvbSA9IHRoaXMubG9hZGVyKHJhbmdlLCB0ZiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrIHdheVxuICAgICAgICAgICAgICAgICAgX3RoaXMyLmNodW5rX2xvYWRlZChkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghKHByb20gJiYgcHJvbS50aGVuKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSB0aGlzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwLmNodW5rX2xvYWRlZC5jYWxsKF9jb250ZXh0LnQwLCBfY29udGV4dC50MSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrKSB0aGlzLmxhc3RfY2h1bmsgPSBbcmFuZ2UsIHRmXTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByYW5nZV9jaGFuZ2VkKF94LCBfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX3JhbmdlX2NoYW5nZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlX2NoYW5nZWQ7XG4gICAgfSgpIC8vIEEgbmV3IGNodW5rIG9mIGRhdGEgaXMgbG9hZGVkXG4gICAgLy8gVE9ETzogYnVsbGV0cHJvb2YgZmV0Y2hcblxuICB9LCB7XG4gICAga2V5OiBcImNodW5rX2xvYWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaHVua19sb2FkZWQoZGF0YSkge1xuICAgICAgLy8gVXBkYXRlcyBvbmx5IGNhbmRsZXN0aWNrIGRhdGEsIG9yXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICB0aGlzLm1lcmdlKCdjaGFydC5kYXRhJywgZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCdW5jaCBvZiBvdmVybGF5cywgaW5jbHVkaW5nIGNoYXJ0LmRhdGFcbiAgICAgICAgZm9yICh2YXIgayBpbiBkYXRhKSB7XG4gICAgICAgICAgdGhpcy5tZXJnZShrLCBkYXRhW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMubGFzdF9jaHVuaykge1xuICAgICAgICB0aGlzLnJhbmdlX2NoYW5nZWQuYXBwbHkodGhpcywgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMubGFzdF9jaHVuaykuY29uY2F0KFt0cnVlXSkpO1xuICAgICAgICB0aGlzLmxhc3RfY2h1bmsgPSBudWxsO1xuICAgICAgfVxuICAgIH0gLy8gVXBkYXRlIGlkcyBmb3IgYWxsIG92ZXJsYXlzXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVfaWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZV9pZHMoKSB7XG4gICAgICB0aGlzLmRhdGEuY2hhcnQuaWQgPSBcImNoYXJ0LlwiLmNvbmNhdCh0aGlzLmRhdGEuY2hhcnQudHlwZSk7XG4gICAgICB2YXIgY291bnQgPSB7fTsgLy8gZ3JpZF9pZCxsYXllcl9pZCA9PiBEQyBpZCBtYXBwaW5nXG5cbiAgICAgIHRoaXMuZ2xkYyA9IHt9LCB0aGlzLmRjZ2wgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBkY19jb3JlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5kYXRhLm9uY2hhcnQpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3YgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBpZiAoY291bnRbb3YudHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY291bnRbb3YudHlwZV0gPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpID0gY291bnRbb3YudHlwZV0rKztcbiAgICAgICAgICBvdi5pZCA9IFwib25jaGFydC5cIi5jb25jYXQob3YudHlwZSkuY29uY2F0KGkpO1xuICAgICAgICAgIGlmICghb3YubmFtZSkgb3YubmFtZSA9IG92LnR5cGUgKyBcIiBcIi5jb25jYXQoaSk7XG4gICAgICAgICAgaWYgKCFvdi5zZXR0aW5ncykgdGhpcy50di4kc2V0KG92LCAnc2V0dGluZ3MnLCB7fSk7IC8vIGdyaWRfaWQsbGF5ZXJfaWQgPT4gREMgaWQgbWFwcGluZ1xuXG4gICAgICAgICAgdGhpcy5nbGRjW1wiZzBfXCIuY29uY2F0KG92LnR5cGUsIFwiX1wiKS5jb25jYXQoaSldID0gb3YuaWQ7XG4gICAgICAgICAgdGhpcy5kY2dsW292LmlkXSA9IFwiZzBfXCIuY29uY2F0KG92LnR5cGUsIFwiX1wiKS5jb25jYXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA9IHt9O1xuICAgICAgdmFyIGdyaWRzID0gW3t9XTtcbiAgICAgIHZhciBnaWQgPSAwO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IGRjX2NvcmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmRhdGEub2ZmY2hhcnQpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3YgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICBpZiAoY291bnRbb3YudHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY291bnRbb3YudHlwZV0gPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfaSA9IGNvdW50W292LnR5cGVdKys7XG5cbiAgICAgICAgICBvdi5pZCA9IFwib2ZmY2hhcnQuXCIuY29uY2F0KG92LnR5cGUpLmNvbmNhdChfaSk7XG4gICAgICAgICAgaWYgKCFvdi5uYW1lKSBvdi5uYW1lID0gb3YudHlwZSArIFwiIFwiLmNvbmNhdChfaSk7XG4gICAgICAgICAgaWYgKCFvdi5zZXR0aW5ncykgdGhpcy50di4kc2V0KG92LCAnc2V0dGluZ3MnLCB7fSk7IC8vIGdyaWRfaWQsbGF5ZXJfaWQgPT4gREMgaWQgbWFwcGluZ1xuXG4gICAgICAgICAgZ2lkKys7XG4gICAgICAgICAgdmFyIHJnaWQgPSAob3YuZ3JpZCB8fCB7fSkuaWQgfHwgZ2lkOyAvLyByZWFsIGdyaWRfaWRcbiAgICAgICAgICAvLyBXaGVuIHdlIG1lcmdlIGdyaWQsIHNraXAgKytcblxuICAgICAgICAgIGlmICgob3YuZ3JpZCB8fCB7fSkuaWQpIGdpZC0tO1xuICAgICAgICAgIGlmICghZ3JpZHNbcmdpZF0pIGdyaWRzW3JnaWRdID0ge307XG5cbiAgICAgICAgICBpZiAoZ3JpZHNbcmdpZF1bb3YudHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZ3JpZHNbcmdpZF1bb3YudHlwZV0gPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByaSA9IGdyaWRzW3JnaWRdW292LnR5cGVdKys7XG4gICAgICAgICAgdGhpcy5nbGRjW1wiZ1wiLmNvbmNhdChyZ2lkLCBcIl9cIikuY29uY2F0KG92LnR5cGUsIFwiX1wiKS5jb25jYXQocmkpXSA9IG92LmlkO1xuICAgICAgICAgIHRoaXMuZGNnbFtvdi5pZF0gPSBcImdcIi5jb25jYXQocmdpZCwgXCJfXCIpLmNvbmNhdChvdi50eXBlLCBcIl9cIikuY29uY2F0KHJpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG4gICAgfSAvLyBUT0RPOiBjaGFydCByZWZpbmUgKGZyb20gdGhlIGV4Y2hhbmdlIGNoYXJ0KVxuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlX2NhbmRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVfY2FuZGxlKGRhdGEpIHtcbiAgICAgIHZhciBvaGxjdiA9IHRoaXMuZGF0YS5jaGFydC5kYXRhO1xuICAgICAgdmFyIGxhc3QgPSBvaGxjdltvaGxjdi5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBjYW5kbGUgPSBkYXRhWydjYW5kbGUnXTtcbiAgICAgIHZhciB0ZiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuaW50ZXJ2YWxfbXM7XG4gICAgICB2YXIgdF9uZXh0ID0gbGFzdFswXSArIHRmO1xuICAgICAgdmFyIG5vdyA9IGRhdGEudCB8fCB1dGlscy5ub3coKTtcbiAgICAgIHZhciB0ID0gbm93ID49IHRfbmV4dCA/IG5vdyAtIG5vdyAlIHRmIDogbGFzdFswXTsgLy8gVXBkYXRlIHRoZSBlbnRpcmUgY2FuZGxlXG5cbiAgICAgIGlmIChjYW5kbGUubGVuZ3RoID49IDYpIHtcbiAgICAgICAgdCA9IGNhbmRsZVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmRsZSA9IFt0XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNhbmRsZSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFnZy5wdXNoKCdvaGxjdicsIGNhbmRsZSk7XG4gICAgICB0aGlzLnVwZGF0ZV9vdmVybGF5cyhkYXRhLCB0LCB0Zik7XG4gICAgICByZXR1cm4gdCA+PSB0X25leHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZV90aWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZV90aWNrKGRhdGEpIHtcbiAgICAgIHZhciBvaGxjdiA9IHRoaXMuZGF0YS5jaGFydC5kYXRhO1xuICAgICAgdmFyIGxhc3QgPSBvaGxjdltvaGxjdi5sZW5ndGggLSAxXTtcbiAgICAgIHZhciB0aWNrID0gZGF0YVsncHJpY2UnXTtcbiAgICAgIHZhciB2b2x1bWUgPSBkYXRhWyd2b2x1bWUnXSB8fCAwO1xuICAgICAgdmFyIHRmID0gdGhpcy50di4kcmVmcy5jaGFydC5pbnRlcnZhbF9tcztcblxuICAgICAgaWYgKCF0Zikge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdEZWZpbmUgdGhlIG1haW4gdGltZWZyYW1lJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3cgPSBkYXRhLnQgfHwgdXRpbHMubm93KCk7XG4gICAgICBpZiAoIWxhc3QpIGxhc3QgPSBbbm93IC0gbm93ICUgdGZdO1xuICAgICAgdmFyIHRfbmV4dCA9IGxhc3RbMF0gKyB0ZjtcbiAgICAgIHZhciB0ID0gbm93ID49IHRfbmV4dCA/IG5vdyAtIG5vdyAlIHRmIDogbGFzdFswXTtcblxuICAgICAgaWYgKCh0ID49IHRfbmV4dCB8fCAhb2hsY3YubGVuZ3RoKSAmJiB0aWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQW5kIG5ldyB6ZXJvLWhlaWdodCBjYW5kbGVcbiAgICAgICAgdmFyIG5jID0gW3QsIHRpY2ssIHRpY2ssIHRpY2ssIHRpY2ssIHZvbHVtZV07XG4gICAgICAgIHRoaXMuYWdnLnB1c2goJ29obGN2JywgbmMsIHRmKTtcbiAgICAgICAgb2hsY3YucHVzaChuYyk7XG4gICAgICAgIHRoaXMuc2Nyb2xsX3RvKHQpO1xuICAgICAgfSBlbHNlIGlmICh0aWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIG9uZVxuICAgICAgICAvLyBUT0RPOiBtYWtlIGEgc2VwYXJhdGUgY2xhc3MgU2FtcGxlclxuICAgICAgICBsYXN0WzJdID0gTWF0aC5tYXgodGljaywgbGFzdFsyXSk7XG4gICAgICAgIGxhc3RbM10gPSBNYXRoLm1pbih0aWNrLCBsYXN0WzNdKTtcbiAgICAgICAgbGFzdFs0XSA9IHRpY2s7XG4gICAgICAgIGxhc3RbNV0gKz0gdm9sdW1lO1xuICAgICAgICB0aGlzLmFnZy5wdXNoKCdvaGxjdicsIGxhc3QsIHRmKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVfb3ZlcmxheXMoZGF0YSwgdCwgdGYpO1xuICAgICAgcmV0dXJuIHQgPj0gdF9uZXh0O1xuICAgIH0gLy8gVXBkYXRlcyBhbGwgb3ZlcmxheXMgd2l0aCBnaXZlbiB2YWx1ZXMuXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVfb3ZlcmxheXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlX292ZXJsYXlzKGRhdGEsIHQsIHRmKSB7XG4gICAgICBmb3IgKHZhciBrIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGsgPT09ICdwcmljZScgfHwgayA9PT0gJ3ZvbHVtZScgfHwgayA9PT0gJ2NhbmRsZScgfHwgayA9PT0gJ3QnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoay5pbmNsdWRlcygnZGF0YXNldHMuJykpIHtcbiAgICAgICAgICB0aGlzLmFnZy5wdXNoKGssIGRhdGFba10sIHRmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhW2tdKSkge1xuICAgICAgICAgIHZhciB2YWwgPSBbZGF0YVtrXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gZGF0YVtrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghay5pbmNsdWRlcygnLmRhdGEnKSkgayArPSAnLmRhdGEnO1xuICAgICAgICB0aGlzLmFnZy5wdXNoKGssIFt0XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHZhbCkpLCB0Zik7XG4gICAgICB9XG4gICAgfSAvLyBSZXR1cm5zIGFycmF5IG9mIG9iamVjdHMgbWF0Y2hpbmcgcXVlcnkuXG4gICAgLy8gT2JqZWN0IGNvbnRhaW5zIHsgcGFyZW50LCBpbmRleCwgdmFsdWUgfVxuICAgIC8vIFRPRE86IHF1ZXJ5IGNhY2hpbmdcblxuICB9LCB7XG4gICAga2V5OiBcImdldF9ieV9xdWVyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfYnlfcXVlcnkocXVlcnksIGNodWNrKSB7XG4gICAgICB2YXIgdHVwbGUgPSBxdWVyeS5zcGxpdCgnLicpO1xuXG4gICAgICBzd2l0Y2ggKHR1cGxlWzBdKSB7XG4gICAgICAgIGNhc2UgJ2NoYXJ0JzpcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jaGFydF9hc19waXYodHVwbGUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ29uY2hhcnQnOlxuICAgICAgICBjYXNlICdvZmZjaGFydCc6XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5xdWVyeV9zZWFyY2gocXVlcnksIHR1cGxlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXRhc2V0cyc6XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5xdWVyeV9zZWFyY2gocXVlcnksIHR1cGxlKTtcblxuICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gZGNfY29yZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJlc3VsdCksXG4gICAgICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgciA9IF9zdGVwNC52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoci5pID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICByLnYgPSB0aGlzLmRzc1tyLnAuaWRdLmRhdGEoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLyogU2hvdWxkIGdldCgnLicpIHJldHVybiBhbHNvIHRoZSBjaGFydD8gKi9cblxuICAgICAgICAgIC8qbGV0IGNoID0gdGhpcy5jaGFydF9hc19xdWVyeShbXG4gICAgICAgICAgICAgICdjaGFydCcsXG4gICAgICAgICAgICAgIHR1cGxlWzFdXG4gICAgICAgICAgXSkqL1xuICAgICAgICAgIHZhciBvbiA9IHRoaXMucXVlcnlfc2VhcmNoKHF1ZXJ5LCBbJ29uY2hhcnQnLCB0dXBsZVswXSwgdHVwbGVbMV1dKTtcbiAgICAgICAgICB2YXIgb2ZmID0gdGhpcy5xdWVyeV9zZWFyY2gocXVlcnksIFsnb2ZmY2hhcnQnLCB0dXBsZVswXSwgdHVwbGVbMV1dKTtcbiAgICAgICAgICByZXN1bHQgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9uKSwgX3RvQ29uc3VtYWJsZUFycmF5KG9mZikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gISh4LnYgfHwge30pLmxvY2tlZCB8fCBjaHVjaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGFydF9hc19waXZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhcnRfYXNfcGl2KHR1cGxlKSB7XG4gICAgICB2YXIgZmllbGQgPSB0dXBsZVsxXTtcbiAgICAgIGlmIChmaWVsZCkgcmV0dXJuIFt7XG4gICAgICAgIHA6IHRoaXMuZGF0YS5jaGFydCxcbiAgICAgICAgaTogZmllbGQsXG4gICAgICAgIHY6IHRoaXMuZGF0YS5jaGFydFtmaWVsZF1cbiAgICAgIH1dO2Vsc2UgcmV0dXJuIFt7XG4gICAgICAgIHA6IHRoaXMuZGF0YSxcbiAgICAgICAgaTogJ2NoYXJ0JyxcbiAgICAgICAgdjogdGhpcy5kYXRhLmNoYXJ0XG4gICAgICB9XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVlcnlfc2VhcmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5X3NlYXJjaChxdWVyeSwgdHVwbGUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgc2lkZSA9IHR1cGxlWzBdO1xuICAgICAgdmFyIHBhdGggPSB0dXBsZVsxXSB8fCAnJztcbiAgICAgIHZhciBmaWVsZCA9IHR1cGxlWzJdO1xuICAgICAgdmFyIGFyciA9IHRoaXMuZGF0YVtzaWRlXS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguaWQgPT09IHF1ZXJ5IHx8IHguaWQgJiYgeC5pZC5pbmNsdWRlcyhwYXRoKSB8fCB4Lm5hbWUgPT09IHF1ZXJ5IHx8IHgubmFtZSAmJiB4Lm5hbWUuaW5jbHVkZXMocGF0aCkgfHwgcXVlcnkuaW5jbHVkZXMoKHguc2V0dGluZ3MgfHwge30pLiR1dWlkKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcDogeCxcbiAgICAgICAgICAgIGk6IGZpZWxkLFxuICAgICAgICAgICAgdjogeFtmaWVsZF1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwOiBfdGhpczMuZGF0YVtzaWRlXSxcbiAgICAgICAgICBpOiBfdGhpczMuZGF0YVtzaWRlXS5pbmRleE9mKHgpLFxuICAgICAgICAgIHY6IHhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZV9vYmplY3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlX29iamVjdHMob2JqLCBkYXRhLCBuZXdfb2JqKSB7XG4gICAgICBpZiAobmV3X29iaiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG5ld19vYmogPSB7fTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIGdldCBWdWUgdG8gdXBkYXRlIGFsbCBzdHVmZlxuICAgICAgLy8gcmVhY3RpdmVseSBpcyB0byBjcmVhdGUgYSBicmFuZCBuZXcgb2JqZWN0LlxuICAgICAgLy8gVE9ETzogSXMgdGhlcmUgYSBzaW1wbGVyIGFwcHJvYWNoP1xuICAgICAgT2JqZWN0LmFzc2lnbihuZXdfb2JqLCBvYmoudik7XG4gICAgICBPYmplY3QuYXNzaWduKG5ld19vYmosIGRhdGEpO1xuICAgICAgdGhpcy50di4kc2V0KG9iai5wLCBvYmouaSwgbmV3X29iaik7XG4gICAgfSAvLyBNZXJnZSBvdmVybGFwcGluZyB0aW1lIHNlcmllc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VfdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2VfdHMob2JqLCBkYXRhKSB7XG4gICAgICAvLyBBc3N1bWUgdGhhdCBib3RoIGFycmF5cyBhcmUgcHJlLXNvcnRlZFxuICAgICAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuIG9iai52O1xuICAgICAgdmFyIHIxID0gW29iai52WzBdWzBdLCBvYmoudltvYmoudi5sZW5ndGggLSAxXVswXV07XG4gICAgICB2YXIgcjIgPSBbZGF0YVswXVswXSwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdWzBdXTsgLy8gT3ZlcmxhcFxuXG4gICAgICB2YXIgbyA9IFtNYXRoLm1heChyMVswXSwgcjJbMF0pLCBNYXRoLm1pbihyMVsxXSwgcjJbMV0pXTtcblxuICAgICAgaWYgKG9bMV0gPj0gb1swXSkge1xuICAgICAgICB2YXIgX29iaiR2LCBfZGF0YTtcblxuICAgICAgICB2YXIgX3RoaXMkdHNfb3ZlcmxhcCA9IHRoaXMudHNfb3ZlcmxhcChvYmoudiwgZGF0YSwgbyksXG4gICAgICAgICAgICBvZCA9IF90aGlzJHRzX292ZXJsYXAub2QsXG4gICAgICAgICAgICBkMSA9IF90aGlzJHRzX292ZXJsYXAuZDEsXG4gICAgICAgICAgICBkMiA9IF90aGlzJHRzX292ZXJsYXAuZDI7XG5cbiAgICAgICAgKF9vYmokdiA9IG9iai52KS5zcGxpY2UuYXBwbHkoX29iaiR2LCBfdG9Db25zdW1hYmxlQXJyYXkoZDEpKTtcblxuICAgICAgICAoX2RhdGEgPSBkYXRhKS5zcGxpY2UuYXBwbHkoX2RhdGEsIF90b0NvbnN1bWFibGVBcnJheShkMikpOyAvLyBEc3QgPT09IE92ZXJsYXAgPT09IFNyY1xuXG5cbiAgICAgICAgaWYgKCFvYmoudi5sZW5ndGggJiYgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy50di4kc2V0KG9iai5wLCBvYmouaSwgb2QpO1xuICAgICAgICAgIHJldHVybiBvYmoudjtcbiAgICAgICAgfSAvLyBJZiBzcmMgaXMgdG90YWxseSBjb250YWluZWQgaW4gZHN0XG5cblxuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgZGF0YSA9IG9iai52LnNwbGljZShkMVswXSk7XG4gICAgICAgIH0gLy8gSWYgZHN0IGlzIHRvdGFsbHkgY29udGFpbmVkIGluIHNyY1xuXG5cbiAgICAgICAgaWYgKCFvYmoudi5sZW5ndGgpIHtcbiAgICAgICAgICBvYmoudiA9IGRhdGEuc3BsaWNlKGQyWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHYuJHNldChvYmoucCwgb2JqLmksIHRoaXMuY29tYmluZShvYmoudiwgb2QsIGRhdGEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHYuJHNldChvYmoucCwgb2JqLmksIHRoaXMuY29tYmluZShvYmoudiwgW10sIGRhdGEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iai52O1xuICAgIH0gLy8gVE9ETzogcmV2aWV3IHBlcmZvcm1hbmNlLCBtb3ZlIHRvIHdvcmtlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwidHNfb3ZlcmxhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0c19vdmVybGFwKGFycjEsIGFycjIsIHJhbmdlKSB7XG4gICAgICB2YXIgdDEgPSByYW5nZVswXTtcbiAgICAgIHZhciB0MiA9IHJhbmdlWzFdO1xuICAgICAgdmFyIHRzID0ge307IC8vIHRpbWVzdGFtcCBtYXBcblxuICAgICAgdmFyIGExID0gYXJyMS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhbMF0gPj0gdDEgJiYgeFswXSA8PSB0MjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGEyID0gYXJyMi5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhbMF0gPj0gdDEgJiYgeFswXSA8PSB0MjtcbiAgICAgIH0pOyAvLyBJbmRpY2VzIG9mIHNlZ21lbnRzXG5cbiAgICAgIHZhciBpZDExID0gYXJyMS5pbmRleE9mKGExWzBdKTtcbiAgICAgIHZhciBpZDEyID0gYXJyMS5pbmRleE9mKGExW2ExLmxlbmd0aCAtIDFdKTtcbiAgICAgIHZhciBpZDIxID0gYXJyMi5pbmRleE9mKGEyWzBdKTtcbiAgICAgIHZhciBpZDIyID0gYXJyMi5pbmRleE9mKGEyW2EyLmxlbmd0aCAtIDFdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhMS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0c1thMVtpXVswXV0gPSBhMVtpXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhMi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0c1thMltpXVswXV0gPSBhMltpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRzX3NvcnRlZCA9IE9iamVjdC5rZXlzKHRzKS5zb3J0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZDogdHNfc29ydGVkLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB0c1t4XTtcbiAgICAgICAgfSksXG4gICAgICAgIGQxOiBbaWQxMSwgaWQxMiAtIGlkMTEgKyAxXSxcbiAgICAgICAgZDI6IFtpZDIxLCBpZDIyIC0gaWQyMSArIDFdXG4gICAgICB9O1xuICAgIH0gLy8gQ29tYmluZSBwYXJ0cyB0b2dldGhlcjpcbiAgICAvLyAoZGVzdGluYXRpb24sIG92ZXJsYXAsIHNvdXJjZSlcblxuICB9LCB7XG4gICAga2V5OiBcImNvbWJpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tYmluZShkc3QsIG8sIHNyYykge1xuICAgICAgZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV1bMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghZHN0Lmxlbmd0aCkge1xuICAgICAgICBkc3QgPSBvO1xuICAgICAgICBvID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICghc3JjLmxlbmd0aCkge1xuICAgICAgICBzcmMgPSBvO1xuICAgICAgICBvID0gW107XG4gICAgICB9IC8vIFRoZSBvdmVybGFwIHJpZ2h0IGluIHRoZSBtaWRkbGVcblxuXG4gICAgICBpZiAoc3JjWzBdWzBdID49IGRzdFswXVswXSAmJiBsYXN0KHNyYykgPD0gbGFzdChkc3QpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRzdCwgbyk7IC8vIFRoZSBvdmVybGFwIGlzIG9uIHRoZSByaWdodFxuICAgICAgfSBlbHNlIGlmIChsYXN0KHNyYykgPiBsYXN0KGRzdCkpIHtcbiAgICAgICAgLy8gUHNoKC4uLikgaXMgZmFzdGVyIGJ1dCBjYW4gb3ZlcmZsb3cgdGhlIHN0YWNrXG4gICAgICAgIGlmIChvLmxlbmd0aCA8IDEwMDAwMCAmJiBzcmMubGVuZ3RoIDwgMTAwMDAwKSB7XG4gICAgICAgICAgdmFyIF9kc3Q7XG5cbiAgICAgICAgICAoX2RzdCA9IGRzdCkucHVzaC5hcHBseShfZHN0LCBfdG9Db25zdW1hYmxlQXJyYXkobykuY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShzcmMpKSk7XG5cbiAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkc3QuY29uY2F0KG8sIHNyYyk7XG4gICAgICAgIH0gLy8gVGhlIG92ZXJsYXAgaXMgb24gdGhlIGxlZnRcblxuICAgICAgfSBlbHNlIGlmIChzcmNbMF1bMF0gPCBkc3RbMF1bMF0pIHtcbiAgICAgICAgLy8gUHVzaCguLi4pIGlzIGZhc3RlciBidXQgY2FuIG92ZXJmbG93IHRoZSBzdGFja1xuICAgICAgICBpZiAoby5sZW5ndGggPCAxMDAwMDAgJiYgc3JjLmxlbmd0aCA8IDEwMDAwMCkge1xuICAgICAgICAgIHZhciBfc3JjO1xuXG4gICAgICAgICAgKF9zcmMgPSBzcmMpLnB1c2guYXBwbHkoX3NyYywgX3RvQ29uc3VtYWJsZUFycmF5KG8pLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZHN0KSkpO1xuXG4gICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3JjLmNvbmNhdChvLCBkc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSAvLyBTaW1wbGUgZGF0YS1wb2ludCBtZXJnZSAoZmFzdGVyKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFzdF9tZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYXN0X21lcmdlKGRhdGEsIHBvaW50LCBtYWluKSB7XG4gICAgICBpZiAobWFpbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1haW4gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHJldHVybjtcbiAgICAgIHZhciBsYXN0X3QgPSAoZGF0YVtkYXRhLmxlbmd0aCAtIDFdIHx8IFtdKVswXTtcbiAgICAgIHZhciB1cGRfdCA9IHBvaW50WzBdO1xuXG4gICAgICBpZiAoIWRhdGEubGVuZ3RoIHx8IHVwZF90ID4gbGFzdF90KSB7XG4gICAgICAgIGRhdGEucHVzaChwb2ludCk7XG5cbiAgICAgICAgaWYgKG1haW4gJiYgdGhpcy5zZXR0LmF1dG9fc2Nyb2xsKSB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxfdG8odXBkX3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVwZF90ID09PSBsYXN0X3QpIHtcbiAgICAgICAgaWYgKG1haW4pIHtcbiAgICAgICAgICB0aGlzLnR2LiRzZXQoZGF0YSwgZGF0YS5sZW5ndGggLSAxLCBwb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsX3RvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbF90byh0KSB7XG4gICAgICBpZiAodGhpcy50di4kcmVmcy5jaGFydC5jdXJzb3IubG9ja2VkKSByZXR1cm47XG4gICAgICB2YXIgbGFzdCA9IHRoaXMudHYuJHJlZnMuY2hhcnQubGFzdF9jYW5kbGU7XG4gICAgICBpZiAoIWxhc3QpIHJldHVybjtcbiAgICAgIHZhciB0bCA9IGxhc3RbMF07XG4gICAgICB2YXIgZCA9IHRoaXMudHYuZ2V0UmFuZ2UoKVsxXSAtIHRsO1xuICAgICAgaWYgKGQgPiAwKSB0aGlzLnR2W1wiZ290b1wiXSh0ICsgZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERDQ29yZTtcbn0oRENFdmVudHMpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL3NldHRfcHJveHkuanNcbi8vIFNlbmRzIGFsbCBkYy5zZXR0IGNoYW5nZXMgdG8gdGhlIHdlYi13b3JrZXJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gZnVuY3Rpb24gc2V0dF9wcm94eShzZXR0LCB3dykge1xuICB2YXIgaCA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChzZXR0LCBrKSB7XG4gICAgICByZXR1cm4gc2V0dFtrXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHNldHQsIGssIHYpIHtcbiAgICAgIHNldHRba10gPSB2O1xuICAgICAgd3cuanVzdCgndXBkYXRlLWRjLXNldHRpbmdzJywgc2V0dCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHd3Lmp1c3QoJ3VwZGF0ZS1kYy1zZXR0aW5ncycsIHNldHQpO1xuICByZXR1cm4gbmV3IFByb3h5KHNldHQsIGgpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvYWdnX3Rvb2wuanNcblxuXG4vLyBUaWNrIGFnZ3JlZ2F0aW9uXG5cblxudmFyIEFnZ1Rvb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBZ2dUb29sKGRjLCBfaW50KSB7XG4gICAgaWYgKF9pbnQgPT09IHZvaWQgMCkge1xuICAgICAgX2ludCA9IDEwMDtcbiAgICB9XG5cbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBBZ2dUb29sKTtcblxuICAgIHRoaXMuc3ltYm9scyA9IHt9O1xuICAgIHRoaXNbXCJpbnRcIl0gPSBfaW50OyAvLyBJdGFydmFsIGluIG1zXG5cbiAgICB0aGlzLmRjID0gZGM7XG4gICAgdGhpcy5zdF9pZCA9IG51bGw7XG4gICAgdGhpcy5kYXRhX2NoYW5nZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKEFnZ1Rvb2wsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChzeW0sIHVwZCwgdGYpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIFN0YXJ0IGF1dG8gdXBkYXRlc1xuICAgICAgaWYgKCF0aGlzLnN0X2lkKSB7XG4gICAgICAgIHRoaXMuc3RfaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0ZiA9IHBhcnNlSW50KHRmKTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLnN5bWJvbHNbc3ltXTtcbiAgICAgIHZhciB0ID0gdXRpbHMubm93KCk7XG4gICAgICB2YXIgaXNkcyA9IHN5bS5pbmNsdWRlcygnZGF0YXNldHMuJyk7XG4gICAgICB0aGlzLmRhdGFfY2hhbmdlZCA9IHRydWU7XG5cbiAgICAgIGlmICghb2xkKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sc1tzeW1dID0ge1xuICAgICAgICAgIHVwZDogdXBkLFxuICAgICAgICAgIHQ6IHQsXG4gICAgICAgICAgZGF0YTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodXBkWzBdID49IG9sZC51cGRbMF0gKyB0ZiAmJiAhaXNkcykge1xuICAgICAgICAvLyBSZWZpbmUgdGhlIHByZXZpb3VzIGRhdGEgcG9pbnRcbiAgICAgICAgdGhpcy5yZWZpbmUoc3ltLCBvbGQudXBkLnNsaWNlKCkpO1xuICAgICAgICB0aGlzLnN5bWJvbHNbc3ltXSA9IHtcbiAgICAgICAgICB1cGQ6IHVwZCxcbiAgICAgICAgICB0OiB0LFxuICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaWNrIHVwZGF0ZXMgdGhlIGN1cnJlbnRcbiAgICAgICAgdGhpcy5zeW1ib2xzW3N5bV0udXBkID0gdXBkO1xuICAgICAgICB0aGlzLnN5bWJvbHNbc3ltXS50ID0gdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzZHMpIHtcbiAgICAgICAgdGhpcy5zeW1ib2xzW3N5bV0uZGF0YS5wdXNoKHVwZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG91dCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBzeW0gaW4gdGhpcy5zeW1ib2xzKSB7XG4gICAgICAgIHZhciB1cGQgPSB0aGlzLnN5bWJvbHNbc3ltXS51cGQ7XG5cbiAgICAgICAgc3dpdGNoIChzeW0pIHtcbiAgICAgICAgICBjYXNlICdvaGxjdic6XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGMuZGF0YS5jaGFydC5kYXRhO1xuICAgICAgICAgICAgdGhpcy5kYy5mYXN0X21lcmdlKGRhdGEsIHVwZCk7XG4gICAgICAgICAgICBvdXQub2hsY3YgPSBkYXRhLnNsaWNlKC0yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChzeW0uaW5jbHVkZXMoJ2RhdGFzZXRzLicpKSB7XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlX2RzKHN5bSwgb3V0KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYy5nZXRfb25lKFwiXCIuY29uY2F0KHN5bSkpO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMuZGMuZmFzdF9tZXJnZShkYXRhLCB1cGQsIGZhbHNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRPRE86IGZpbGwgZ2Fwc1xuXG5cbiAgICAgIGlmICh0aGlzLmRhdGFfY2hhbmdlZCkge1xuICAgICAgICB0aGlzLmRjLnd3Lmp1c3QoJ3VwZGF0ZS1kYXRhJywgb3V0KTtcbiAgICAgICAgdGhpcy5kYXRhX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudXBkYXRlKCk7XG4gICAgICB9LCB0aGlzW1wiaW50XCJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVmaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZmluZShzeW0sIHVwZCkge1xuICAgICAgaWYgKHN5bSA9PT0gJ29obGN2Jykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGMuZGF0YS5jaGFydC5kYXRhO1xuICAgICAgICB0aGlzLmRjLmZhc3RfbWVyZ2UoZGF0YSwgdXBkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYy5nZXRfb25lKFwiXCIuY29uY2F0KHN5bSkpO1xuICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcbiAgICAgICAgdGhpcy5kYy5mYXN0X21lcmdlKGRhdGEsIHVwZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVfZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlX2RzKHN5bSwgb3V0KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuc3ltYm9sc1tzeW1dLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgICBvdXRbc3ltXSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc3ltYm9sc1tzeW1dLmRhdGEgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLnN5bWJvbHMgPSB7fTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWdnVG9vbDtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy9kYXRhY3ViZS5qc1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGRhdGFjdWJlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBkYXRhY3ViZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gZGF0YWN1YmVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBkYXRhY3ViZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gZGF0YWN1YmVfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGRhdGFjdWJlX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGRhdGFjdWJlX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBkYXRhY3ViZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBkYXRhY3ViZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vLyBNYWluIERhdGFIZWxwZXIgY2xhc3MuIEEgY29udGFpbmVyIGZvciBkYXRhLFxuLy8gd2hpY2ggd29ya3MgYXMgYSBwcm94eSBhbmQgQ1JVRCBpbnRlcmZhY2VcblxuXG5cbiAvLyBJbnRlcmZhY2UgbWV0aG9kcy4gUHJpdmF0ZSBtZXRob2RzIGluIGRjX2NvcmUuanNcblxudmFyIERhdGFDdWJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRENDb3JlKSB7XG4gIF9pbmhlcml0cyhEYXRhQ3ViZSwgX0RDQ29yZSk7XG5cbiAgdmFyIF9zdXBlciA9IGRhdGFjdWJlX2NyZWF0ZVN1cGVyKERhdGFDdWJlKTtcblxuICBmdW5jdGlvbiBEYXRhQ3ViZShkYXRhLCBzZXR0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChzZXR0ID09PSB2b2lkIDApIHtcbiAgICAgIHNldHQgPSB7fTtcbiAgICB9XG5cbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhQ3ViZSk7XG5cbiAgICB2YXIgZGVmX3NldHQgPSB7XG4gICAgICBhZ2dyZWdhdGlvbjogMTAwLFxuICAgICAgLy8gVXBkYXRlIGFnZ3JlZ2F0aW9uIGludGVydmFsXG4gICAgICBzY3JpcHRfZGVwdGg6IDAsXG4gICAgICAvLyAwID09PSBFeGVjIG9uIGFsbCBkYXRhXG4gICAgICBhdXRvX3Njcm9sbDogdHJ1ZSxcbiAgICAgIC8vIEF1dG8gc2Nyb2xsIHRvIGEgbmV3IGNhbmRsZVxuICAgICAgc2NyaXB0czogdHJ1ZSxcbiAgICAgIC8vIEVuYWJsZSBvdmVybGF5cyBzY3JpcHRzLFxuICAgICAgd3dfcmFtX2xpbWl0OiAwLFxuICAgICAgLy8gV2ViV29ya2VyIFJBTSBsaW1pdCAoTUIpXG4gICAgICBub2RlX3VybDogbnVsbCxcbiAgICAgIC8vIFVzZSBub2RlLmpzIGluc3RlYWQgb2YgV1dcbiAgICAgIHNoaWZ0X21lYXN1cmU6IHRydWUgLy8gRHJhdyBtZWFzdXJtZW50IHNoaWZ0K2NsaWNrXG5cbiAgICB9O1xuICAgIHNldHQgPSBPYmplY3QuYXNzaWduKGRlZl9zZXR0LCBzZXR0KTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLnNldHQgPSBzZXR0O1xuICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgIF90aGlzLnNldHQgPSBzZXR0X3Byb3h5KHNldHQsIF90aGlzLnd3KTtcbiAgICBfdGhpcy5hZ2cgPSBuZXcgQWdnVG9vbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc2V0dC5hZ2dyZWdhdGlvbik7XG4gICAgX3RoaXMuc2Vfc3RhdGUgPSB7fTsgLy90aGlzLmFnZy51cGRhdGUgPSB0aGlzLmFnZ191cGRhdGUuYmluZCh0aGlzKVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vIEFkZCBuZXcgb3ZlcmxheVxuXG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoRGF0YUN1YmUsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoc2lkZSwgb3ZlcmxheSkge1xuICAgICAgaWYgKHNpZGUgIT09ICdvbmNoYXJ0JyAmJiBzaWRlICE9PSAnb2ZmY2hhcnQnICYmIHNpZGUgIT09ICdkYXRhc2V0cycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGFbc2lkZV0ucHVzaChvdmVybGF5KTtcbiAgICAgIHRoaXMudXBkYXRlX2lkcygpO1xuICAgICAgcmV0dXJuIG92ZXJsYXkuaWQ7XG4gICAgfSAvLyBHZXQgYWxsIG9iamVjdHMgbWF0Y2hpbmcgdGhlIHF1ZXJ5XG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRfYnlfcXVlcnkocXVlcnkpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC52O1xuICAgICAgfSk7XG4gICAgfSAvLyBHZXQgZmlyc3Qgb2JqZWN0IG1hdGNoaW5nIHRoZSBxdWVyeVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0X29uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfb25lKHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRfYnlfcXVlcnkocXVlcnkpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC52O1xuICAgICAgfSlbMF07XG4gICAgfSAvLyBTZXQgZGF0YSAocmVhY3RpdmVseSlcblxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQocXVlcnksIGRhdGEpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRfYnlfcXVlcnkocXVlcnkpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gZGF0YWN1YmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvYmplY3RzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb2JqID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGkgPSBvYmouaSAhPT0gdW5kZWZpbmVkID8gb2JqLmkgOiBvYmoucC5pbmRleE9mKG9iai52KTtcblxuICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy50di4kc2V0KG9iai5wLCBpLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVfaWRzKCk7XG4gICAgfSAvLyBNZXJnZSBvYmplY3Qgb3IgYXJyYXkgKHJlYWN0aXZlbHkpXG5cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShxdWVyeSwgZGF0YSkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldF9ieV9xdWVyeShxdWVyeSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gZGF0YWN1YmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvYmplY3RzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG9iaiA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai52KSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSBjb250aW51ZTsgLy8gSWYgYXJyYXkgaXMgYSB0aW1lc2VyaWVzLCBtZXJnZSBpdCBieSB0aW1lc3RhbXBcbiAgICAgICAgICAgIC8vIGVsc2UgbWVyZ2UgYnkgaXRlbSBpbmRleFxuXG4gICAgICAgICAgICBpZiAob2JqLnZbMF0gJiYgb2JqLnZbMF0ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXJnZV90cyhvYmosIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXJnZV9vYmplY3RzKG9iaiwgZGF0YSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mX3R5cGVvZihvYmoudikgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlX29iamVjdHMob2JqLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZV9pZHMoKTtcbiAgICB9IC8vIFJlbW92ZSBhbiBvdmVybGF5IGJ5IHF1ZXJ5IChpZC90eXBlL25hbWUvLi4uKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbChxdWVyeSkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldF9ieV9xdWVyeShxdWVyeSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gZGF0YWN1YmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvYmplY3RzKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG9iaiA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAvLyBGaW5kIGN1cnJlbnQgaW5kZXggb2YgdGhlIGZpZWxkIChpZiBub3QgZGVmaW5lZClcbiAgICAgICAgICB2YXIgaSA9IHR5cGVvZiBvYmouaSAhPT0gJ251bWJlcicgPyBvYmouaSA6IG9iai5wLmluZGV4T2Yob2JqLnYpO1xuXG4gICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnR2LiRkZWxldGUob2JqLnAsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlX2lkcygpO1xuICAgIH0gLy8gVXBkYXRlL2FwcGVuZCBkYXRhIHBvaW50LCBkZXBlbmRpbmcgb24gdGltZXN0YW1wXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhWydjYW5kbGUnXSkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVfY2FuZGxlKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlX3RpY2soZGF0YSk7XG4gICAgICB9XG4gICAgfSAvLyBMb2NrIG92ZXJsYXlzIGZyb20gYmVpbmcgcHVsbGVkIGJ5IHF1ZXJ5X3NlYXJjaFxuICAgIC8vIFRPRE86IHN1YmplY3QgdG8gcmV2aWV3XG5cbiAgfSwge1xuICAgIGtleTogXCJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2socXVlcnkpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRfYnlfcXVlcnkocXVlcnkpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh4LnYgJiYgeC52LmlkICYmIHgudi50eXBlKSB7XG4gICAgICAgICAgeC52LmxvY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gVW5sb2NrIG92ZXJsYXlzIGZyb20gYmVpbmcgcHVsbGVkIGJ5IHF1ZXJ5X3NlYXJjaFxuICAgIC8vXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmxvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5sb2NrKHF1ZXJ5KSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0X2J5X3F1ZXJ5KHF1ZXJ5LCB0cnVlKTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeC52ICYmIHgudi5pZCAmJiB4LnYudHlwZSkge1xuICAgICAgICAgIHgudi5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBTaG93IGluZGljYXRvclxuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KHF1ZXJ5KSB7XG4gICAgICBpZiAocXVlcnkgPT09ICdvZmZjaGFydCcgfHwgcXVlcnkgPT09ICdvbmNoYXJ0Jykge1xuICAgICAgICBxdWVyeSArPSAnLic7XG4gICAgICB9IGVsc2UgaWYgKHF1ZXJ5ID09PSAnLicpIHtcbiAgICAgICAgcXVlcnkgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZXJnZShxdWVyeSArICcuc2V0dGluZ3MnLCB7XG4gICAgICAgIGRpc3BsYXk6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gLy8gSGlkZSBpbmRpY2F0b3JcblxuICB9LCB7XG4gICAga2V5OiBcImhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZShxdWVyeSkge1xuICAgICAgaWYgKHF1ZXJ5ID09PSAnb2ZmY2hhcnQnIHx8IHF1ZXJ5ID09PSAnb25jaGFydCcpIHtcbiAgICAgICAgcXVlcnkgKz0gJy4nO1xuICAgICAgfSBlbHNlIGlmIChxdWVyeSA9PT0gJy4nKSB7XG4gICAgICAgIHF1ZXJ5ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVyZ2UocXVlcnkgKyAnLnNldHRpbmdzJywge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSAvLyBTZXQgZGF0YSBsb2FkZXIgY2FsbGJhY2tcblxuICB9LCB7XG4gICAga2V5OiBcIm9ucmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25yYW5nZShjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMubG9hZGVyID0gY2FsbGJhY2s7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi50di5zZXRfbG9hZGVyKGNhbGxiYWNrID8gX3RoaXMyIDogbnVsbCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YUN1YmU7XG59KERDQ29yZSk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9pbnRlcmZhY2UuanNcbi8vIEh0bWwgaW50ZXJmYWNlLCBzaG93biBvbiB0b3Agb2YgdGhlIGdyaWQuXG4vLyBDYW4gYmUgc3RhdGljIChhIHRvb2x0aXApIG9yIGludGVyYWN0aXZlLFxuLy8gZS5nLiBhIGNvbnRyb2wgcGFuZWwuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG1peGluc19pbnRlcmZhY2UgPSAoe1xuICBwcm9wczogWyd1eCcsICd1cGRhdGVyJywgJ2NvbG9ycycsICd3cmFwcGVyJ10sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5fJGVtaXQgPSB0aGlzLiRlbWl0O1xuICAgIHRoaXMuJGVtaXQgPSB0aGlzLmN1c3RvbV9ldmVudDtcbiAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQoKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6ICdjbG9zZS1pbnRlcmZhY2UnLFxuICAgICAgICBhcmdzOiBbdGhpcy4kcHJvcHMudXgudXVpZF1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gVE9ETzogZW1pdCBhbGwgdGhlIHdheSB0byB0aGUgdXhsaXN0XG4gICAgLy8gYWRkIGFwcGx5IHRoZSBjaGFuZ2VzIHRoZXJlXG4gICAgbW9kaWZ5OiBmdW5jdGlvbiBtb2RpZnkob2JqKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiAnbW9kaWZ5LWludGVyZmFjZScsXG4gICAgICAgIGFyZ3M6IFt0aGlzLiRwcm9wcy51eC51dWlkLCBvYmpdXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGN1c3RvbV9ldmVudDogZnVuY3Rpb24gY3VzdG9tX2V2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuc3BsaXQoJzonKVswXSA9PT0gJ2hvb2snKSByZXR1cm47XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuXyRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMudXgub3ZlcmxheTtcbiAgICB9LFxuICAgIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheS5sYXlvdXQ7XG4gICAgfSxcbiAgICB1eHI6IGZ1bmN0aW9uIHV4cigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy51eDtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbmRleC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHByaW1pdGl2ZXMgPSB7XG4gIENhbmRsZTogQ2FuZGxlRXh0LFxuICBWb2xiYXI6IFZvbGJhckV4dCxcbiAgTGluZTogTGluZSxcbiAgUGluOiBQaW4sXG4gIFByaWNlOiBQcmljZSxcbiAgUmF5OiBSYXksXG4gIFNlZzogU2VnXG59O1xuXG5UcmFkaW5nVnVlLmluc3RhbGwgPSBmdW5jdGlvbiAoVnVlKSB7XG4gIFZ1ZS5jb21wb25lbnQoVHJhZGluZ1Z1ZS5uYW1lLCBUcmFkaW5nVnVlKTtcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFRyYWRpbmdWdWUpO1xuICB3aW5kb3cuVHJhZGluZ1Z1ZUxpYiA9IHtcbiAgICBUcmFkaW5nVnVlOiBUcmFkaW5nVnVlLFxuICAgIE92ZXJsYXk6IG92ZXJsYXksXG4gICAgVXRpbHM6IHV0aWxzLFxuICAgIENvbnN0YW50czogY29uc3RhbnRzLFxuICAgIENhbmRsZTogQ2FuZGxlRXh0LFxuICAgIFZvbGJhcjogVm9sYmFyRXh0LFxuICAgIGxheW91dF9jbnY6IGxheW91dF9jbnYsXG4gICAgbGF5b3V0X3ZvbDogbGF5b3V0X3ZvbCxcbiAgICBEYXRhQ3ViZTogRGF0YUN1YmUsXG4gICAgVG9vbDogdG9vbCxcbiAgICBJbnRlcmZhY2U6IG1peGluc19pbnRlcmZhY2UsXG4gICAgcHJpbWl0aXZlczogcHJpbWl0aXZlc1xuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHNyYyA9IChUcmFkaW5nVnVlKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE4OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKiBBbml0LWJvb3N0cmFwIHRhY3RpeCAqL1xcbi50cmFkaW5nLXZ1ZSAqLCA6OmFmdGVyLCA6OmJlZm9yZSB7XFxuICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbn1cXG4udHJhZGluZy12dWUgaW1nIHtcXG4gICAgdmVydGljYWwtYWxpZ246IGluaXRpYWw7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk3Njpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnRyYWRpbmctdnVlLWJvdGJhciB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZSAhaW1wb3J0YW50O1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDk6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50LXZ1ZS1sYnRuLWdycCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwLjVlbTtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTA4OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy1pdGVtLWxpc3Qge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICBtYXJnaW4tdG9wOiAtNXB4O1xcbn1cXG4udHZqcy1pdGVtLWxpc3QtaXRlbSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDIwcHg7XFxuICAgIGZvbnQtc2l6ZTogMS4xNWVtO1xcbiAgICBsZXR0ZXItc3BhY2luZzogMC4wNWVtO1xcbn1cXG4udHZqcy1pdGVtLWxpc3QtaXRlbTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM3Njg3ODMxOTtcXG59XFxuLnR2anMtaXRlbS1saXN0LWl0ZW0gKiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZSAhaW1wb3J0YW50O1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODg6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50cmFkaW5nLXZ1ZS1sZWdlbmQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgZm9udC1zaXplOiAxLjI1ZW07XFxuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XFxufVxcbkBtZWRpYSAobWluLXJlc29sdXRpb246IDJ4KSB7XFxuLnRyYWRpbmctdnVlLWxlZ2VuZCB7XFxuICAgICAgICBmb250LXdlaWdodDogNDAwO1xcbn1cXG59XFxuLnRyYWRpbmctdnVlLW9obGN2IHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgIG1hcmdpbi1ib3R0b206IDAuNWVtO1xcbn1cXG4udC12dWUtbHNwYW4ge1xcbiAgICBmb250LXZhcmlhbnQtbnVtZXJpYzogdGFidWxhci1udW1zO1xcbiAgICBmb250LXNpemU6IDAuOTVlbTtcXG4gICAgY29sb3I6ICM5OTk5OTk7IC8qIFRPRE86IG1vdmUgPT4gcGFyYW1zICovXFxuICAgIG1hcmdpbi1sZWZ0OiAwLjFlbTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwLjJlbTtcXG59XFxuLnQtdnVlLXRpdGxlIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwLjI1ZW07XFxuICAgIGZvbnQtc2l6ZTogMS40NWVtO1xcbn1cXG4udC12dWUtaW5kIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDAuMmVtO1xcbiAgICBtYXJnaW4tYm90dG9tOiAwLjVlbTtcXG4gICAgZm9udC1zaXplOiAxLjBlbTtcXG4gICAgbWFyZ2luLXRvcDogMC4zZW07XFxufVxcbi50LXZ1ZS1pdmFsdWUge1xcbiAgICBtYXJnaW4tbGVmdDogMC41ZW07XFxufVxcbi50LXZ1ZS11bmtub3duIHtcXG4gICAgY29sb3I6ICM5OTk5OTk7IC8qIFRPRE86IG1vdmUgPT4gcGFyYW1zICovXFxufVxcbi50dmpzLWFwcGVhci1lbnRlci1hY3RpdmUsXFxuLnR2anMtYXBwZWFyLWxlYXZlLWFjdGl2ZVxcbntcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4yNXMgZWFzZTtcXG59XFxuLnR2anMtYXBwZWFyLWVudGVyLCAudHZqcy1hcHBlYXItbGVhdmUtdG9cXG57XFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQyMzpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnQtdnVlLWxidG4ge1xcbiAgICB6LWluZGV4OiAxMDA7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjYxOlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHJhZGluZy12dWUtc2VjdGlvbiB7XFxuICAgIGhlaWdodDogMDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNjg6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50dmpzLXNwaW5uZXIge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgd2lkdGg6IDIwcHg7XFxuICAgIGhlaWdodDogMTZweDtcXG4gICAgbWFyZ2luOiAtNHB4IDBweCAtMXB4IDBweDtcXG4gICAgb3BhY2l0eTogMC43O1xcbn1cXG4udHZqcy1zcGlubmVyIGRpdiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiA4cHg7XFxuICAgIHdpZHRoOiA0cHg7XFxuICAgIGhlaWdodDogNHB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigxLCAxLCAxLCAxKTtcXG59XFxuLnR2anMtc3Bpbm5lciBkaXY6bnRoLWNoaWxkKDEpIHtcXG4gICAgbGVmdDogMnB4O1xcbiAgICBhbmltYXRpb246IHR2anMtc3Bpbm5lcjEgMC42cyBpbmZpbml0ZTtcXG4gICAgb3BhY2l0eTogMC45O1xcbn1cXG4udHZqcy1zcGlubmVyIGRpdjpudGgtY2hpbGQoMikge1xcbiAgICBsZWZ0OiAycHg7XFxuICAgIGFuaW1hdGlvbjogdHZqcy1zcGlubmVyMiAwLjZzIGluZmluaXRlO1xcbn1cXG4udHZqcy1zcGlubmVyIGRpdjpudGgtY2hpbGQoMykge1xcbiAgICBsZWZ0OiA5cHg7XFxuICAgIGFuaW1hdGlvbjogdHZqcy1zcGlubmVyMiAwLjZzIGluZmluaXRlO1xcbn1cXG4udHZqcy1zcGlubmVyIGRpdjpudGgtY2hpbGQoNCkge1xcbiAgICBsZWZ0OiAxNnB4O1xcbiAgICBhbmltYXRpb246IHR2anMtc3Bpbm5lcjMgMC42cyBpbmZpbml0ZTtcXG4gICAgb3BhY2l0eTogMC45O1xcbn1cXG5Aa2V5ZnJhbWVzIHR2anMtc3Bpbm5lcjEge1xcbjAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxufVxcbjEwMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG59XFxufVxcbkBrZXlmcmFtZXMgdHZqcy1zcGlubmVyMyB7XFxuMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG59XFxuMTAwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbn1cXG59XFxuQGtleWZyYW1lcyB0dmpzLXNwaW5uZXIyIHtcXG4wJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTtcXG59XFxuMTAwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg3cHgsIDApO1xcbn1cXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjk6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50dmpzLWRyaWZ0LWVudGVyLWFjdGl2ZSB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG59XFxuLnR2anMtZHJpZnQtbGVhdmUtYWN0aXZlIHtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC44cyBjdWJpYy1iZXppZXIoMS4wLCAwLjUsIDAuOCwgMS4wKTtcXG59XFxuLnR2anMtZHJpZnQtZW50ZXIsIC50dmpzLWRyaWZ0LWxlYXZlLXRvXFxue1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTBweCk7XFxuICAgIG9wYWNpdHk6IDA7XFxufVxcbi50dmpzLXRoZS10aXAge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAyMDBweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICB6LWluZGV4OiAxMDAwMTtcXG4gICAgY29sb3I6ICNmZmZmZmY7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjE1ZW07XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgcmlnaHQ6IDcwcHg7XFxuICAgIHRvcDogMTBweDtcXG4gICAgdGV4dC1zaGFkb3c6IDFweCAxcHggYmxhY2s7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzNTpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnRyYWRpbmctdnVlLXRvb2xiYXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xcbiAgICB6LWluZGV4OiAxMDE7XFxuICAgIHBhZGRpbmctdG9wOiAzcHg7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzk6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50cmFkaW5nLXZ1ZS10Yml0ZW0ge1xcbn1cXG4udHJhZGluZy12dWUtdGJpdGVtOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzc2ODc4MzE5O1xcbn1cXG4udHJhZGluZy12dWUtdGJpdGVtLWV4cCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgcmlnaHQ6IC0zcHg7XFxuICAgIHBhZGRpbmc6IDE4LjVweCA1cHg7XFxuICAgIGZvbnQtc3RyZXRjaDogZXh0cmEtY29uZGVuc2VkO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgwLjYpO1xcbiAgICBmb250LXNpemU6IDAuNmVtO1xcbiAgICBvcGFjaXR5OiAwLjA7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICBsaW5lLWhlaWdodDogMDtcXG59XFxuLnRyYWRpbmctdnVlLXRiaXRlbTpob3Zlclxcbi50cmFkaW5nLXZ1ZS10Yml0ZW0tZXhwIHtcXG4gICAgb3BhY2l0eTogMC41O1xcbn1cXG4udHJhZGluZy12dWUtdGJpdGVtLWV4cDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM3Njg3ODMzMDtcXG4gICAgb3BhY2l0eTogMC45ICFpbXBvcnRhbnQ7XFxufVxcbi50cmFkaW5nLXZ1ZS10Ymljb24ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi50cmFkaW5nLXZ1ZS10Yml0ZW0uc2VsZWN0ZWQtaXRlbSA+IC50cmFkaW5nLXZ1ZS10Ymljb24sXFxuLnR2anMtaXRlbS1saXN0LWl0ZW0uc2VsZWN0ZWQtaXRlbSA+IC50cmFkaW5nLXZ1ZS10Ymljb24ge1xcbiAgICAgZmlsdGVyOiBicmlnaHRuZXNzKDEuNDUpIHNlcGlhKDEpIGh1ZS1yb3RhdGUoOTBkZWcpIHNhdHVyYXRlKDQuNSkgIWltcG9ydGFudDtcXG59XFxuLnR2anMtcGl4ZWxhdGVkIHtcXG4gICAgLW1zLWludGVycG9sYXRpb24tbW9kZTogbmVhcmVzdC1uZWlnaGJvcjtcXG4gICAgaW1hZ2UtcmVuZGVyaW5nOiAtd2Via2l0LW9wdGltaXplLWNvbnRyYXN0O1xcbiAgICBpbWFnZS1yZW5kZXJpbmc6IC13ZWJraXQtY3Jpc3AtZWRnZXM7XFxuICAgIGltYWdlLXJlbmRlcmluZzogLW1vei1jcmlzcC1lZGdlcztcXG4gICAgaW1hZ2UtcmVuZGVyaW5nOiAtby1jcmlzcC1lZGdlcztcXG4gICAgaW1hZ2UtcmVuZGVyaW5nOiBwaXhlbGF0ZWQ7XFxufVxcblxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcyOlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHJhZGluZy12dWUtdXgtd3JhcHBlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogZmxleDtcXG59XFxuLnR2anMtdXgtd3JhcHBlci1waW4ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiA5cHg7XFxuICAgIGhlaWdodDogOXB4O1xcbiAgICB6LWluZGV4OiAxMDA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyM2E3NzY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNnB4O1xcbiAgICBtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuLnR2anMtdXgtd3JhcHBlci1oZWFkIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBoZWlnaHQ6IDIzcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG4udHZqcy11eC13cmFwcGVyLWNsb3NlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTFweDtcXG4gICAgaGVpZ2h0OiAxMXB4O1xcbiAgICBmb250LXNpemU6IDEuNWVtO1xcbiAgICBsaW5lLWhlaWdodDogMC41ZW07XFxuICAgIHBhZGRpbmc6IDFweCAxcHggMXB4IDFweDtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgcmlnaHQ6IDVweDtcXG4gICAgdG9wOiA1cHg7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHotaW5kZXg6IDEwMDtcXG59XFxuLnR2anMtdXgtd3JhcHBlci1jbG9zZS1oYiB7XFxufVxcbi50dmpzLXV4LXdyYXBwZXItY2xvc2U6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkY2MDVDICFpbXBvcnRhbnQ7XFxuICAgIGNvbG9yOiAjNjkyMzI0ICFpbXBvcnRhbnQ7XFxufVxcbi50dmpzLXV4LXdyYXBwZXItZnVsbCB7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4Mzpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnR2anMtd2lkZ2V0cyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogMTAwMDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY0NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDA6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIEhhbW1lci5KUyAtIHYyLjAuNyAtIDIwMTYtMDQtMjJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG59XG5cbmluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcblxuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBtYW5pcHVsYXRpb25cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgIHZhciBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGFwczogMSxcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZCkge1xuICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG59IGVsc2Uge31cblxufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vKlxuICogSGFtc3Rlci5qcyB2MS4xLjJcbiAqIChjKSAyMDEzIE1vbm9zcGFjZWQgaHR0cDovL21vbm9zcGFjZWQuY29tXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogSGFtc3RlclxuICogdXNlIHRoaXMgdG8gY3JlYXRlIGluc3RhbmNlc1xuICogQHJldHVybnMge0hhbXN0ZXIuSW5zdGFuY2V9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEhhbXN0ZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgSGFtc3Rlci5JbnN0YW5jZShlbGVtZW50KTtcbn07XG5cbi8vIGRlZmF1bHQgZXZlbnQgbmFtZVxuSGFtc3Rlci5TVVBQT1JUID0gJ3doZWVsJztcblxuLy8gZGVmYXVsdCBET00gbWV0aG9kc1xuSGFtc3Rlci5BRERfRVZFTlQgPSAnYWRkRXZlbnRMaXN0ZW5lcic7XG5IYW1zdGVyLlJFTU9WRV9FVkVOVCA9ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbkhhbXN0ZXIuUFJFRklYID0gJyc7XG5cbi8vIHVudGlsIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIGhhdmUgYmVlbiBmaXhlZC4uLlxuSGFtc3Rlci5SRUFEWSA9IGZhbHNlO1xuXG5IYW1zdGVyLkluc3RhbmNlID0gZnVuY3Rpb24oZWxlbWVudCl7XG4gIGlmICghSGFtc3Rlci5SRUFEWSkge1xuICAgIC8vIGZpeCBicm93c2VyIGluY29uc2lzdGVuY2llc1xuICAgIEhhbXN0ZXIubm9ybWFsaXNlLmJyb3dzZXIoKTtcblxuICAgIC8vIEhhbXN0ZXIgaXMgcmVhZHkuLi4hXG4gICAgSGFtc3Rlci5SRUFEWSA9IHRydWU7XG4gIH1cblxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIC8vIHN0b3JlIGF0dGFjaGVkIGV2ZW50IGhhbmRsZXJzXG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcblxuICAvLyByZXR1cm4gaW5zdGFuY2VcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaGFtc3RlciBpbnN0YW5jZVxuICogYWxsIG1ldGhvZHMgc2hvdWxkIHJldHVybiB0aGUgaW5zdGFuY2UgaXRzZWxmLCBzbyBpdCBpcyBjaGFpbmFibGUuXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgICAgIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtIYW1zdGVyLkluc3RhbmNlfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbkhhbXN0ZXIuSW5zdGFuY2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogYmluZCBldmVudHMgdG8gdGhlIGluc3RhbmNlXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgaGFuZGxlclxuICAgKiBAcGFyYW0gICB7Qm9vbGVhbn0gICAgIHVzZUNhcHR1cmVcbiAgICogQHJldHVybnMge0hhbXN0ZXIuSW5zdGFuY2V9XG4gICAqL1xuICB3aGVlbDogZnVuY3Rpb24gb25FdmVudChoYW5kbGVyLCB1c2VDYXB0dXJlKXtcbiAgICBIYW1zdGVyLmV2ZW50LmFkZCh0aGlzLCBIYW1zdGVyLlNVUFBPUlQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXG4gICAgLy8gaGFuZGxlIE1vek1vdXNlUGl4ZWxTY3JvbGwgaW4gb2xkZXIgRmlyZWZveFxuICAgIGlmIChIYW1zdGVyLlNVUFBPUlQgPT09ICdET01Nb3VzZVNjcm9sbCcpIHtcbiAgICAgIEhhbXN0ZXIuZXZlbnQuYWRkKHRoaXMsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHVuYmluZCBldmVudHMgdG8gdGhlIGluc3RhbmNlXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgaGFuZGxlclxuICAgKiBAcGFyYW0gICB7Qm9vbGVhbn0gICAgIHVzZUNhcHR1cmVcbiAgICogQHJldHVybnMge0hhbXN0ZXIuSW5zdGFuY2V9XG4gICAqL1xuICB1bndoZWVsOiBmdW5jdGlvbiBvZmZFdmVudChoYW5kbGVyLCB1c2VDYXB0dXJlKXtcbiAgICAvLyBpZiBubyBoYW5kbGVyIGFyZ3VtZW50LFxuICAgIC8vIHVuYmluZCB0aGUgbGFzdCBib3VuZCBoYW5kbGVyIChpZiBleGlzdHMpXG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCAmJiAoaGFuZGxlciA9IHRoaXMuaGFuZGxlcnMuc2xpY2UoLTEpWzBdKSkge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIub3JpZ2luYWw7XG4gICAgfVxuXG4gICAgSGFtc3Rlci5ldmVudC5yZW1vdmUodGhpcywgSGFtc3Rlci5TVVBQT1JULCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblxuICAgIC8vIGhhbmRsZSBNb3pNb3VzZVBpeGVsU2Nyb2xsIGluIG9sZGVyIEZpcmVmb3hcbiAgICBpZiAoSGFtc3Rlci5TVVBQT1JUID09PSAnRE9NTW91c2VTY3JvbGwnKSB7XG4gICAgICBIYW1zdGVyLmV2ZW50LnJlbW92ZSh0aGlzLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5IYW1zdGVyLmV2ZW50ID0ge1xuICAvKipcbiAgICogY3Jvc3MtYnJvd3NlciAnYWRkV2hlZWxMaXN0ZW5lcidcbiAgICogQHBhcmFtICAge0luc3RhbmNlfSAgICBoYW1zdGVyXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgZXZlbnROYW1lXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgaGFuZGxlclxuICAgKiBAcGFyYW0gICB7Qm9vbGVhbn0gICAgIHVzZUNhcHR1cmVcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gYWRkKGhhbXN0ZXIsIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSl7XG4gICAgLy8gc3RvcmUgdGhlIG9yaWdpbmFsIGhhbmRsZXJcbiAgICB2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcblxuICAgIC8vIHJlZGVmaW5lIHRoZSBoYW5kbGVyXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uKG9yaWdpbmFsRXZlbnQpe1xuXG4gICAgICBpZiAoIW9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudCA9IHdpbmRvdy5ldmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIGEgbm9ybWFsaXNlZCBldmVudCBvYmplY3QsXG4gICAgICAvLyBhbmQgbm9ybWFsaXNlIFwiZGVsdGFzXCIgb2YgdGhlIG1vdXNlIHdoZWVsXG4gICAgICB2YXIgZXZlbnQgPSBIYW1zdGVyLm5vcm1hbGlzZS5ldmVudChvcmlnaW5hbEV2ZW50KSxcbiAgICAgICAgICBkZWx0YSA9IEhhbXN0ZXIubm9ybWFsaXNlLmRlbHRhKG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAvLyBmaXJlIHRoZSBvcmlnaW5hbCBoYW5kbGVyIHdpdGggbm9ybWFsaXNlZCBhcmd1bWVudHNcbiAgICAgIHJldHVybiBvcmlnaW5hbEhhbmRsZXIoZXZlbnQsIGRlbHRhWzBdLCBkZWx0YVsxXSwgZGVsdGFbMl0pO1xuXG4gICAgfTtcblxuICAgIC8vIGNyb3NzLWJyb3dzZXIgYWRkRXZlbnRMaXN0ZW5lclxuICAgIGhhbXN0ZXIuZWxlbWVudFtIYW1zdGVyLkFERF9FVkVOVF0oSGFtc3Rlci5QUkVGSVggKyBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xuXG4gICAgLy8gc3RvcmUgb3JpZ2luYWwgYW5kIG5vcm1hbGlzZWQgaGFuZGxlcnMgb24gdGhlIGluc3RhbmNlXG4gICAgaGFtc3Rlci5oYW5kbGVycy5wdXNoKHtcbiAgICAgIG9yaWdpbmFsOiBvcmlnaW5hbEhhbmRsZXIsXG4gICAgICBub3JtYWxpc2VkOiBoYW5kbGVyXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlbW92ZVdoZWVsTGlzdGVuZXJcbiAgICogQHBhcmFtICAge0luc3RhbmNlfSAgICBoYW1zdGVyXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgZXZlbnROYW1lXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgaGFuZGxlclxuICAgKiBAcGFyYW0gICB7Qm9vbGVhbn0gICAgIHVzZUNhcHR1cmVcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGhhbXN0ZXIsIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSl7XG4gICAgLy8gZmluZCB0aGUgbm9ybWFsaXNlZCBoYW5kbGVyIG9uIHRoZSBpbnN0YW5jZVxuICAgIHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyLFxuICAgICAgICBsb29rdXAgPSB7fSxcbiAgICAgICAgaGFuZGxlcnM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhhbXN0ZXIuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGxvb2t1cFtoYW1zdGVyLmhhbmRsZXJzW2ldLm9yaWdpbmFsXSA9IGhhbXN0ZXIuaGFuZGxlcnNbaV07XG4gICAgfVxuICAgIGhhbmRsZXJzID0gbG9va3VwW29yaWdpbmFsSGFuZGxlcl07XG4gICAgaGFuZGxlciA9IGhhbmRsZXJzLm5vcm1hbGlzZWQ7XG5cbiAgICAvLyBjcm9zcy1icm93c2VyIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICBoYW1zdGVyLmVsZW1lbnRbSGFtc3Rlci5SRU1PVkVfRVZFTlRdKEhhbXN0ZXIuUFJFRklYICsgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlIHx8IGZhbHNlKTtcblxuICAgIC8vIHJlbW92ZSBvcmlnaW5hbCBhbmQgbm9ybWFsaXNlZCBoYW5kbGVycyBmcm9tIHRoZSBpbnN0YW5jZVxuICAgIGZvciAodmFyIGggaW4gaGFtc3Rlci5oYW5kbGVycykge1xuICAgICAgaWYgKGhhbXN0ZXIuaGFuZGxlcnNbaF0gPT0gaGFuZGxlcnMpIHtcbiAgICAgICAgaGFtc3Rlci5oYW5kbGVycy5zcGxpY2UoaCwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiB0aGVzZSBob2xkIHRoZSBsb3dlc3QgZGVsdGFzLFxuICogdXNlZCB0byBub3JtYWxpc2UgdGhlIGRlbHRhIHZhbHVlc1xuICogQHR5cGUge051bWJlcn1cbiAqL1xudmFyIGxvd2VzdERlbHRhLFxuICAgIGxvd2VzdERlbHRhWFk7XG5cbkhhbXN0ZXIubm9ybWFsaXNlID0ge1xuICAvKipcbiAgICogZml4IGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzXG4gICAqL1xuICBicm93c2VyOiBmdW5jdGlvbiBub3JtYWxpc2VCcm93c2VyKCl7XG4gICAgLy8gZGV0ZWN0IGRlcHJlY2F0ZWQgd2hlZWwgZXZlbnRzXG4gICAgaWYgKCEoJ29ud2hlZWwnIGluIGRvY3VtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+PSA5KSkge1xuICAgICAgSGFtc3Rlci5TVVBQT1JUID0gZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21vdXNld2hlZWwnIDogLy8gd2Via2l0IGFuZCBJRSA8IDkgc3VwcG9ydCBhdCBsZWFzdCBcIm1vdXNld2hlZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RPTU1vdXNlU2Nyb2xsJzsgLy8gYXNzdW1lIHJlbWFpbmluZyBicm93c2VycyBhcmUgb2xkZXIgRmlyZWZveFxuICAgIH1cblxuICAgIC8vIGRldGVjdCBkZXByZWNhdGVkIGV2ZW50IG1vZGVsXG4gICAgaWYgKCF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgLy8gYXNzdW1lIElFIDwgOVxuICAgICAgSGFtc3Rlci5BRERfRVZFTlQgPSAnYXR0YWNoRXZlbnQnO1xuICAgICAgSGFtc3Rlci5SRU1PVkVfRVZFTlQgPSAnZGV0YWNoRXZlbnQnO1xuICAgICAgSGFtc3Rlci5QUkVGSVggPSAnb24nO1xuICAgIH1cblxuICB9LFxuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSBub3JtYWxpc2VkIGV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICAgIG9yaWdpbmFsRXZlbnRcbiAgICogQHJldHVybnMge09iamVjdH0gICAgICBldmVudFxuICAgKi9cbiAgIGV2ZW50OiBmdW5jdGlvbiBub3JtYWxpc2VFdmVudChvcmlnaW5hbEV2ZW50KXtcbiAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICAgICAgICB0YXJnZXQ6IG9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IG9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgICB0eXBlOiAnd2hlZWwnLFxuICAgICAgICAgIGRlbHRhTW9kZTogb3JpZ2luYWxFdmVudC50eXBlID09PSAnTW96TW91c2VQaXhlbFNjcm9sbCcgPyAwIDogMSxcbiAgICAgICAgICBkZWx0YVg6IDAsXG4gICAgICAgICAgZGVsdGFaOiAwLFxuICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LmNhbmNlbEJ1YmJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIGNhbGN1bGF0ZSBkZWx0YVkgKGFuZCBkZWx0YVgpIGFjY29yZGluZyB0byB0aGUgZXZlbnRcblxuICAgIC8vICdtb3VzZXdoZWVsJ1xuICAgIGlmIChvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgIGV2ZW50LmRlbHRhWSA9IC0gMS80MCAqIG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YTtcbiAgICB9XG4gICAgLy8gd2Via2l0XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVgpIHtcbiAgICAgIGV2ZW50LmRlbHRhWCA9IC0gMS80MCAqIG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVg7XG4gICAgfVxuXG4gICAgLy8gJ0RvbU1vdXNlU2Nyb2xsJ1xuICAgIGlmIChvcmlnaW5hbEV2ZW50LmRldGFpbCkge1xuICAgICAgZXZlbnQuZGVsdGFZID0gb3JpZ2luYWxFdmVudC5kZXRhaWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBub3JtYWxpc2UgJ2RlbHRhcycgb2YgdGhlIG1vdXNlIHdoZWVsXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgb3JpZ2luYWxFdmVudFxuICAgKiBAcmV0dXJucyB7QXJyYXl9ICAgICAgIGRlbHRhc1xuICAgKi9cbiAgZGVsdGE6IGZ1bmN0aW9uIG5vcm1hbGlzZURlbHRhKG9yaWdpbmFsRXZlbnQpe1xuICAgIHZhciBkZWx0YSA9IDAsXG4gICAgICBkZWx0YVggPSAwLFxuICAgICAgZGVsdGFZID0gMCxcbiAgICAgIGFic0RlbHRhID0gMCxcbiAgICAgIGFic0RlbHRhWFkgPSAwLFxuICAgICAgZm47XG5cbiAgICAvLyBub3JtYWxpc2UgZGVsdGFzIGFjY29yZGluZyB0byB0aGUgZXZlbnRcblxuICAgIC8vICd3aGVlbCcgZXZlbnRcbiAgICBpZiAob3JpZ2luYWxFdmVudC5kZWx0YVkpIHtcbiAgICAgIGRlbHRhWSA9IG9yaWdpbmFsRXZlbnQuZGVsdGFZICogLTE7XG4gICAgICBkZWx0YSAgPSBkZWx0YVk7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbEV2ZW50LmRlbHRhWCkge1xuICAgICAgZGVsdGFYID0gb3JpZ2luYWxFdmVudC5kZWx0YVg7XG4gICAgICBkZWx0YSAgPSBkZWx0YVggKiAtMTtcbiAgICB9XG5cbiAgICAvLyAnbW91c2V3aGVlbCcgZXZlbnRcbiAgICBpZiAob3JpZ2luYWxFdmVudC53aGVlbERlbHRhKSB7XG4gICAgICBkZWx0YSA9IG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YTtcbiAgICB9XG4gICAgLy8gd2Via2l0XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVkpIHtcbiAgICAgIGRlbHRhWSA9IG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVk7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFYKSB7XG4gICAgICBkZWx0YVggPSBvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFYICogLTE7XG4gICAgfVxuXG4gICAgLy8gJ0RvbU1vdXNlU2Nyb2xsJyBldmVudFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LmRldGFpbCkge1xuICAgICAgZGVsdGEgPSBvcmlnaW5hbEV2ZW50LmRldGFpbCAqIC0xO1xuICAgIH1cblxuICAgIC8vIERvbid0IHJldHVybiBOYU5cbiAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgbG93ZXN0IGRlbHRhIHRvIG5vcm1hbGl6ZSB0aGUgZGVsdGEgdmFsdWVzXG4gICAgYWJzRGVsdGEgPSBNYXRoLmFicyhkZWx0YSk7XG4gICAgaWYgKCFsb3dlc3REZWx0YSB8fCBhYnNEZWx0YSA8IGxvd2VzdERlbHRhKSB7XG4gICAgICBsb3dlc3REZWx0YSA9IGFic0RlbHRhO1xuICAgIH1cbiAgICBhYnNEZWx0YVhZID0gTWF0aC5tYXgoTWF0aC5hYnMoZGVsdGFZKSwgTWF0aC5hYnMoZGVsdGFYKSk7XG4gICAgaWYgKCFsb3dlc3REZWx0YVhZIHx8IGFic0RlbHRhWFkgPCBsb3dlc3REZWx0YVhZKSB7XG4gICAgICBsb3dlc3REZWx0YVhZID0gYWJzRGVsdGFYWTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGRlbHRhcyB0byB3aG9sZSBudW1iZXJzXG4gICAgZm4gPSBkZWx0YSA+IDAgPyAnZmxvb3InIDogJ2NlaWwnO1xuICAgIGRlbHRhICA9IE1hdGhbZm5dKGRlbHRhIC8gbG93ZXN0RGVsdGEpO1xuICAgIGRlbHRhWCA9IE1hdGhbZm5dKGRlbHRhWCAvIGxvd2VzdERlbHRhWFkpO1xuICAgIGRlbHRhWSA9IE1hdGhbZm5dKGRlbHRhWSAvIGxvd2VzdERlbHRhWFkpO1xuXG4gICAgcmV0dXJuIFtkZWx0YSwgZGVsdGFYLCBkZWx0YVldO1xuICB9XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdy5kZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgd2luZG93LmRlZmluZS5hbWQpIHtcbiAgLy8gQU1EXG4gIHdpbmRvdy5kZWZpbmUoJ2hhbXN0ZXInLCBbXSwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gSGFtc3RlcjtcbiAgfSk7XG59IGVsc2UgaWYgKHRydWUpIHtcbiAgLy8gQ29tbW9uSlNcbiAgbW9kdWxlLmV4cG9ydHMgPSBIYW1zdGVyO1xufSBlbHNlIHt9XG5cbn0pKHdpbmRvdywgd2luZG93LmRvY3VtZW50KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTYxOlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8vIENvcHlyaWdodCAoYykgMjAxMyBQaWVyb3h5IDxwaWVyb3h5QHBpZXJveHkubmV0PlxuLy8gVGhpcyB3b3JrIGlzIGZyZWUuIFlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbi8vIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgV1RGUEwsIFZlcnNpb24gMlxuLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIExJQ0VOU0UudHh0IG9yIGh0dHA6Ly93d3cud3RmcGwubmV0L1xuLy9cbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uLCB0aGUgaG9tZSBwYWdlOlxuLy8gaHR0cDovL3BpZXJveHkubmV0L2Jsb2cvcGFnZXMvbHotc3RyaW5nL3Rlc3RpbmcuaHRtbFxuLy9cbi8vIExaLWJhc2VkIGNvbXByZXNzaW9uIGFsZ29yaXRobSwgdmVyc2lvbiAxLjQuNFxudmFyIExaU3RyaW5nID0gKGZ1bmN0aW9uKCkge1xuXG4vLyBwcml2YXRlIHByb3BlcnR5XG52YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIga2V5U3RyQmFzZTY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xudmFyIGtleVN0clVyaVNhZmUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky0kXCI7XG52YXIgYmFzZVJldmVyc2VEaWMgPSB7fTtcblxuZnVuY3Rpb24gZ2V0QmFzZVZhbHVlKGFscGhhYmV0LCBjaGFyYWN0ZXIpIHtcbiAgaWYgKCFiYXNlUmV2ZXJzZURpY1thbHBoYWJldF0pIHtcbiAgICBiYXNlUmV2ZXJzZURpY1thbHBoYWJldF0gPSB7fTtcbiAgICBmb3IgKHZhciBpPTAgOyBpPGFscGhhYmV0Lmxlbmd0aCA7IGkrKykge1xuICAgICAgYmFzZVJldmVyc2VEaWNbYWxwaGFiZXRdW2FscGhhYmV0LmNoYXJBdChpKV0gPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZVJldmVyc2VEaWNbYWxwaGFiZXRdW2NoYXJhY3Rlcl07XG59XG5cbnZhciBMWlN0cmluZyA9IHtcbiAgY29tcHJlc3NUb0Jhc2U2NCA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICB2YXIgcmVzID0gTFpTdHJpbmcuX2NvbXByZXNzKGlucHV0LCA2LCBmdW5jdGlvbihhKXtyZXR1cm4ga2V5U3RyQmFzZTY0LmNoYXJBdChhKTt9KTtcbiAgICBzd2l0Y2ggKHJlcy5sZW5ndGggJSA0KSB7IC8vIFRvIHByb2R1Y2UgdmFsaWQgQmFzZTY0XG4gICAgZGVmYXVsdDogLy8gV2hlbiBjb3VsZCB0aGlzIGhhcHBlbiA/XG4gICAgY2FzZSAwIDogcmV0dXJuIHJlcztcbiAgICBjYXNlIDEgOiByZXR1cm4gcmVzK1wiPT09XCI7XG4gICAgY2FzZSAyIDogcmV0dXJuIHJlcytcIj09XCI7XG4gICAgY2FzZSAzIDogcmV0dXJuIHJlcytcIj1cIjtcbiAgICB9XG4gIH0sXG5cbiAgZGVjb21wcmVzc0Zyb21CYXNlNjQgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgaWYgKGlucHV0ID09IFwiXCIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBMWlN0cmluZy5fZGVjb21wcmVzcyhpbnB1dC5sZW5ndGgsIDMyLCBmdW5jdGlvbihpbmRleCkgeyByZXR1cm4gZ2V0QmFzZVZhbHVlKGtleVN0ckJhc2U2NCwgaW5wdXQuY2hhckF0KGluZGV4KSk7IH0pO1xuICB9LFxuXG4gIGNvbXByZXNzVG9VVEYxNiA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICByZXR1cm4gTFpTdHJpbmcuX2NvbXByZXNzKGlucHV0LCAxNSwgZnVuY3Rpb24oYSl7cmV0dXJuIGYoYSszMik7fSkgKyBcIiBcIjtcbiAgfSxcblxuICBkZWNvbXByZXNzRnJvbVVURjE2OiBmdW5jdGlvbiAoY29tcHJlc3NlZCkge1xuICAgIGlmIChjb21wcmVzc2VkID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgIGlmIChjb21wcmVzc2VkID09IFwiXCIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBMWlN0cmluZy5fZGVjb21wcmVzcyhjb21wcmVzc2VkLmxlbmd0aCwgMTYzODQsIGZ1bmN0aW9uKGluZGV4KSB7IHJldHVybiBjb21wcmVzc2VkLmNoYXJDb2RlQXQoaW5kZXgpIC0gMzI7IH0pO1xuICB9LFxuXG4gIC8vY29tcHJlc3MgaW50byB1aW50OGFycmF5IChVQ1MtMiBiaWcgZW5kaWFuIGZvcm1hdClcbiAgY29tcHJlc3NUb1VpbnQ4QXJyYXk6IGZ1bmN0aW9uICh1bmNvbXByZXNzZWQpIHtcbiAgICB2YXIgY29tcHJlc3NlZCA9IExaU3RyaW5nLmNvbXByZXNzKHVuY29tcHJlc3NlZCk7XG4gICAgdmFyIGJ1Zj1uZXcgVWludDhBcnJheShjb21wcmVzc2VkLmxlbmd0aCoyKTsgLy8gMiBieXRlcyBwZXIgY2hhcmFjdGVyXG5cbiAgICBmb3IgKHZhciBpPTAsIFRvdGFsTGVuPWNvbXByZXNzZWQubGVuZ3RoOyBpPFRvdGFsTGVuOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50X3ZhbHVlID0gY29tcHJlc3NlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgYnVmW2kqMl0gPSBjdXJyZW50X3ZhbHVlID4+PiA4O1xuICAgICAgYnVmW2kqMisxXSA9IGN1cnJlbnRfdmFsdWUgJSAyNTY7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH0sXG5cbiAgLy9kZWNvbXByZXNzIGZyb20gdWludDhhcnJheSAoVUNTLTIgYmlnIGVuZGlhbiBmb3JtYXQpXG4gIGRlY29tcHJlc3NGcm9tVWludDhBcnJheTpmdW5jdGlvbiAoY29tcHJlc3NlZCkge1xuICAgIGlmIChjb21wcmVzc2VkPT09bnVsbCB8fCBjb21wcmVzc2VkPT09dW5kZWZpbmVkKXtcbiAgICAgICAgcmV0dXJuIExaU3RyaW5nLmRlY29tcHJlc3MoY29tcHJlc3NlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJ1Zj1uZXcgQXJyYXkoY29tcHJlc3NlZC5sZW5ndGgvMik7IC8vIDIgYnl0ZXMgcGVyIGNoYXJhY3RlclxuICAgICAgICBmb3IgKHZhciBpPTAsIFRvdGFsTGVuPWJ1Zi5sZW5ndGg7IGk8VG90YWxMZW47IGkrKykge1xuICAgICAgICAgIGJ1ZltpXT1jb21wcmVzc2VkW2kqMl0qMjU2K2NvbXByZXNzZWRbaSoyKzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBidWYuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGYoYykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIExaU3RyaW5nLmRlY29tcHJlc3MocmVzdWx0LmpvaW4oJycpKTtcblxuICAgIH1cblxuICB9LFxuXG5cbiAgLy9jb21wcmVzcyBpbnRvIGEgc3RyaW5nIHRoYXQgaXMgYWxyZWFkeSBVUkkgZW5jb2RlZFxuICBjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBMWlN0cmluZy5fY29tcHJlc3MoaW5wdXQsIDYsIGZ1bmN0aW9uKGEpe3JldHVybiBrZXlTdHJVcmlTYWZlLmNoYXJBdChhKTt9KTtcbiAgfSxcblxuICAvL2RlY29tcHJlc3MgZnJvbSBhbiBvdXRwdXQgb2YgY29tcHJlc3NUb0VuY29kZWRVUklDb21wb25lbnRcbiAgZGVjb21wcmVzc0Zyb21FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICBpZiAoaW5wdXQgPT0gXCJcIikgcmV0dXJuIG51bGw7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC8gL2csIFwiK1wiKTtcbiAgICByZXR1cm4gTFpTdHJpbmcuX2RlY29tcHJlc3MoaW5wdXQubGVuZ3RoLCAzMiwgZnVuY3Rpb24oaW5kZXgpIHsgcmV0dXJuIGdldEJhc2VWYWx1ZShrZXlTdHJVcmlTYWZlLCBpbnB1dC5jaGFyQXQoaW5kZXgpKTsgfSk7XG4gIH0sXG5cbiAgY29tcHJlc3M6IGZ1bmN0aW9uICh1bmNvbXByZXNzZWQpIHtcbiAgICByZXR1cm4gTFpTdHJpbmcuX2NvbXByZXNzKHVuY29tcHJlc3NlZCwgMTYsIGZ1bmN0aW9uKGEpe3JldHVybiBmKGEpO30pO1xuICB9LFxuICBfY29tcHJlc3M6IGZ1bmN0aW9uICh1bmNvbXByZXNzZWQsIGJpdHNQZXJDaGFyLCBnZXRDaGFyRnJvbUludCkge1xuICAgIGlmICh1bmNvbXByZXNzZWQgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgdmFyIGksIHZhbHVlLFxuICAgICAgICBjb250ZXh0X2RpY3Rpb25hcnk9IHt9LFxuICAgICAgICBjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZT0ge30sXG4gICAgICAgIGNvbnRleHRfYz1cIlwiLFxuICAgICAgICBjb250ZXh0X3djPVwiXCIsXG4gICAgICAgIGNvbnRleHRfdz1cIlwiLFxuICAgICAgICBjb250ZXh0X2VubGFyZ2VJbj0gMiwgLy8gQ29tcGVuc2F0ZSBmb3IgdGhlIGZpcnN0IGVudHJ5IHdoaWNoIHNob3VsZCBub3QgY291bnRcbiAgICAgICAgY29udGV4dF9kaWN0U2l6ZT0gMyxcbiAgICAgICAgY29udGV4dF9udW1CaXRzPSAyLFxuICAgICAgICBjb250ZXh0X2RhdGE9W10sXG4gICAgICAgIGNvbnRleHRfZGF0YV92YWw9MCxcbiAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uPTAsXG4gICAgICAgIGlpO1xuXG4gICAgZm9yIChpaSA9IDA7IGlpIDwgdW5jb21wcmVzc2VkLmxlbmd0aDsgaWkgKz0gMSkge1xuICAgICAgY29udGV4dF9jID0gdW5jb21wcmVzc2VkLmNoYXJBdChpaSk7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250ZXh0X2RpY3Rpb25hcnksY29udGV4dF9jKSkge1xuICAgICAgICBjb250ZXh0X2RpY3Rpb25hcnlbY29udGV4dF9jXSA9IGNvbnRleHRfZGljdFNpemUrKztcbiAgICAgICAgY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGVbY29udGV4dF9jXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHRfd2MgPSBjb250ZXh0X3cgKyBjb250ZXh0X2M7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRleHRfZGljdGlvbmFyeSxjb250ZXh0X3djKSkge1xuICAgICAgICBjb250ZXh0X3cgPSBjb250ZXh0X3djO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZSxjb250ZXh0X3cpKSB7XG4gICAgICAgICAgaWYgKGNvbnRleHRfdy5jaGFyQ29kZUF0KDApPDI1Nikge1xuICAgICAgICAgICAgZm9yIChpPTAgOyBpPGNvbnRleHRfbnVtQml0cyA7IGkrKykge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSk7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgZm9yIChpPTAgOyBpPDggOyBpKyspIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgKHZhbHVlJjEpO1xuICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgICAgIGZvciAoaT0wIDsgaTxjb250ZXh0X251bUJpdHMgOyBpKyspIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgdmFsdWU7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT1iaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBjb250ZXh0X3cuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGZvciAoaT0wIDsgaTwxNiA7IGkrKykge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCAodmFsdWUmMSk7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dF9lbmxhcmdlSW4tLTtcbiAgICAgICAgICBpZiAoY29udGV4dF9lbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICAgICAgY29udGV4dF9lbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBjb250ZXh0X251bUJpdHMpO1xuICAgICAgICAgICAgY29udGV4dF9udW1CaXRzKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZVtjb250ZXh0X3ddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dF9kaWN0aW9uYXJ5W2NvbnRleHRfd107XG4gICAgICAgICAgZm9yIChpPTAgOyBpPGNvbnRleHRfbnVtQml0cyA7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgKHZhbHVlJjEpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHRfZW5sYXJnZUluLS07XG4gICAgICAgIGlmIChjb250ZXh0X2VubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgICAgY29udGV4dF9lbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBjb250ZXh0X251bUJpdHMpO1xuICAgICAgICAgIGNvbnRleHRfbnVtQml0cysrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB3YyB0byB0aGUgZGljdGlvbmFyeS5cbiAgICAgICAgY29udGV4dF9kaWN0aW9uYXJ5W2NvbnRleHRfd2NdID0gY29udGV4dF9kaWN0U2l6ZSsrO1xuICAgICAgICBjb250ZXh0X3cgPSBTdHJpbmcoY29udGV4dF9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdXRwdXQgdGhlIGNvZGUgZm9yIHcuXG4gICAgaWYgKGNvbnRleHRfdyAhPT0gXCJcIikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZSxjb250ZXh0X3cpKSB7XG4gICAgICAgIGlmIChjb250ZXh0X3cuY2hhckNvZGVBdCgwKTwyNTYpIHtcbiAgICAgICAgICBmb3IgKGk9MCA7IGk8Y29udGV4dF9udW1CaXRzIDsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGZvciAoaT0wIDsgaTw4IDsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCAodmFsdWUmMSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgICAgZm9yIChpPTAgOyBpPGNvbnRleHRfbnVtQml0cyA7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgdmFsdWU7XG4gICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGZvciAoaT0wIDsgaTwxNiA7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgKHZhbHVlJjEpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dF9lbmxhcmdlSW4tLTtcbiAgICAgICAgaWYgKGNvbnRleHRfZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbiA9IE1hdGgucG93KDIsIGNvbnRleHRfbnVtQml0cyk7XG4gICAgICAgICAgY29udGV4dF9udW1CaXRzKys7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlW2NvbnRleHRfd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGNvbnRleHRfZGljdGlvbmFyeVtjb250ZXh0X3ddO1xuICAgICAgICBmb3IgKGk9MCA7IGk8Y29udGV4dF9udW1CaXRzIDsgaSsrKSB7XG4gICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgKHZhbHVlJjEpO1xuICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICB9XG5cblxuICAgICAgfVxuICAgICAgY29udGV4dF9lbmxhcmdlSW4tLTtcbiAgICAgIGlmIChjb250ZXh0X2VubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgIGNvbnRleHRfZW5sYXJnZUluID0gTWF0aC5wb3coMiwgY29udGV4dF9udW1CaXRzKTtcbiAgICAgICAgY29udGV4dF9udW1CaXRzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFyayB0aGUgZW5kIG9mIHRoZSBzdHJlYW1cbiAgICB2YWx1ZSA9IDI7XG4gICAgZm9yIChpPTAgOyBpPGNvbnRleHRfbnVtQml0cyA7IGkrKykge1xuICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgKHZhbHVlJjEpO1xuICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCB0aGUgbGFzdCBjaGFyXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKTtcbiAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRfZGF0YS5qb2luKCcnKTtcbiAgfSxcblxuICBkZWNvbXByZXNzOiBmdW5jdGlvbiAoY29tcHJlc3NlZCkge1xuICAgIGlmIChjb21wcmVzc2VkID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgIGlmIChjb21wcmVzc2VkID09IFwiXCIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBMWlN0cmluZy5fZGVjb21wcmVzcyhjb21wcmVzc2VkLmxlbmd0aCwgMzI3NjgsIGZ1bmN0aW9uKGluZGV4KSB7IHJldHVybiBjb21wcmVzc2VkLmNoYXJDb2RlQXQoaW5kZXgpOyB9KTtcbiAgfSxcblxuICBfZGVjb21wcmVzczogZnVuY3Rpb24gKGxlbmd0aCwgcmVzZXRWYWx1ZSwgZ2V0TmV4dFZhbHVlKSB7XG4gICAgdmFyIGRpY3Rpb25hcnkgPSBbXSxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgZW5sYXJnZUluID0gNCxcbiAgICAgICAgZGljdFNpemUgPSA0LFxuICAgICAgICBudW1CaXRzID0gMyxcbiAgICAgICAgZW50cnkgPSBcIlwiLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgdyxcbiAgICAgICAgYml0cywgcmVzYiwgbWF4cG93ZXIsIHBvd2VyLFxuICAgICAgICBjLFxuICAgICAgICBkYXRhID0ge3ZhbDpnZXROZXh0VmFsdWUoMCksIHBvc2l0aW9uOnJlc2V0VmFsdWUsIGluZGV4OjF9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgZGljdGlvbmFyeVtpXSA9IGk7XG4gICAgfVxuXG4gICAgYml0cyA9IDA7XG4gICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLDIpO1xuICAgIHBvd2VyPTE7XG4gICAgd2hpbGUgKHBvd2VyIT1tYXhwb3dlcikge1xuICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgfVxuICAgICAgYml0cyB8PSAocmVzYj4wID8gMSA6IDApICogcG93ZXI7XG4gICAgICBwb3dlciA8PD0gMTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5leHQgPSBiaXRzKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLDgpO1xuICAgICAgICAgIHBvd2VyPTE7XG4gICAgICAgICAgd2hpbGUgKHBvd2VyIT1tYXhwb3dlcikge1xuICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cyB8PSAocmVzYj4wID8gMSA6IDApICogcG93ZXI7XG4gICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIGMgPSBmKGJpdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsMTYpO1xuICAgICAgICAgIHBvd2VyPTE7XG4gICAgICAgICAgd2hpbGUgKHBvd2VyIT1tYXhwb3dlcikge1xuICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cyB8PSAocmVzYj4wID8gMSA6IDApICogcG93ZXI7XG4gICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIGMgPSBmKGJpdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGRpY3Rpb25hcnlbM10gPSBjO1xuICAgIHcgPSBjO1xuICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZGF0YS5pbmRleCA+IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cblxuICAgICAgYml0cyA9IDA7XG4gICAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsbnVtQml0cyk7XG4gICAgICBwb3dlcj0xO1xuICAgICAgd2hpbGUgKHBvd2VyIT1tYXhwb3dlcikge1xuICAgICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRzIHw9IChyZXNiPjAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgcG93ZXIgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYyA9IGJpdHMpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiw4KTtcbiAgICAgICAgICBwb3dlcj0xO1xuICAgICAgICAgIHdoaWxlIChwb3dlciE9bWF4cG93ZXIpIHtcbiAgICAgICAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gKHJlc2I+MCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgICAgICAgcG93ZXIgPDw9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGljdGlvbmFyeVtkaWN0U2l6ZSsrXSA9IGYoYml0cyk7XG4gICAgICAgICAgYyA9IGRpY3RTaXplLTE7XG4gICAgICAgICAgZW5sYXJnZUluLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsMTYpO1xuICAgICAgICAgIHBvd2VyPTE7XG4gICAgICAgICAgd2hpbGUgKHBvd2VyIT1tYXhwb3dlcikge1xuICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cyB8PSAocmVzYj4wID8gMSA6IDApICogcG93ZXI7XG4gICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGljdGlvbmFyeVtkaWN0U2l6ZSsrXSA9IGYoYml0cyk7XG4gICAgICAgICAgYyA9IGRpY3RTaXplLTE7XG4gICAgICAgICAgZW5sYXJnZUluLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgZW5sYXJnZUluID0gTWF0aC5wb3coMiwgbnVtQml0cyk7XG4gICAgICAgIG51bUJpdHMrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpY3Rpb25hcnlbY10pIHtcbiAgICAgICAgZW50cnkgPSBkaWN0aW9uYXJ5W2NdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGMgPT09IGRpY3RTaXplKSB7XG4gICAgICAgICAgZW50cnkgPSB3ICsgdy5jaGFyQXQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGVudHJ5KTtcblxuICAgICAgLy8gQWRkIHcrZW50cnlbMF0gdG8gdGhlIGRpY3Rpb25hcnkuXG4gICAgICBkaWN0aW9uYXJ5W2RpY3RTaXplKytdID0gdyArIGVudHJ5LmNoYXJBdCgwKTtcbiAgICAgIGVubGFyZ2VJbi0tO1xuXG4gICAgICB3ID0gZW50cnk7XG5cbiAgICAgIGlmIChlbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICBlbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBudW1CaXRzKTtcbiAgICAgICAgbnVtQml0cysrO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG59O1xuICByZXR1cm4gTFpTdHJpbmc7XG59KSgpO1xuXG5pZiAodHJ1ZSkge1xuICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIExaU3RyaW5nOyB9KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xufSBlbHNlIHt9XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY2Njpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICAgdHJ1ZSA/IG1vZHVsZS5leHBvcnRzIDogMFxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NjM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxOCk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiNTUwYjQ3YWJcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTI0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NzYpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjFiMzRiZmViXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDg4Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDQ5KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCI5ODk1ZDNhNlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MDc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiODEzOTAzNmFcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjAwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODgpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjFkYjAxYzBiXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDE2OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIzKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCI2OGYyNDNlYVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCIxMmQyMzA5ZFwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OCk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiNWI2MjA2MDVcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiMTQzZGZmYWJcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzUpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcImYzMmZkMzZlXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzc5KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCI2MDRiZjVlZlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCIyMWZkZTU3M1wiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODMpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcImZkODM2ODllXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwiWlwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBhZGRTdHlsZXNDbGllbnQpXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qc1xuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5cblxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5pZiAodHlwZW9mIERFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBERUJVRykge1xuICBpZiAoIWhhc0RvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuICcgK1xuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxuICApIH1cbn1cblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG52YXIgb3B0aW9ucyA9IG51bGxcbnZhciBzc3JJZEtleSA9ICdkYXRhLXZ1ZS1zc3ItaWQnXG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbmZ1bmN0aW9uIGFkZFN0eWxlc0NsaWVudCAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24sIF9vcHRpb25zKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICBvcHRpb25zID0gX29wdGlvbnMgfHwge31cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVsnICsgc3NySWRLZXkgKyAnfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cbiAgaWYgKG9wdGlvbnMuc3NySWQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKHNzcklkS2V5LCBvYmouaWQpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG4vKioqKioqLyBcdFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGUpO1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBkb2Vzbid0IHRlbGwgYWJvdXQgaXQncyB0b3AtbGV2ZWwgZGVjbGFyYXRpb25zIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1MSk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhZGluZy12dWUuanMubWFwIiwiLyohXG4gKiBUVkpTIE92ZXJsYXlzIC0gdjAuNS4wIC0gRnJpIEp1bCAwOSAyMDIxXG4gKiAgICAgaHR0cHM6Ly9naXRodWIuY29tL3R2anN4L3RyYWRpbmctdnVlLWpzXG4gKiAgICAgQ29weXJpZ2h0IChjKSAyMDIwIGM0NTEgQ29kZSdzIEFsbCBSaWdodDtcbiAqICAgICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAoIXJvb3RbJ3RyYWRpbmctdnVlLWpzJ10pIHtcbiAgICAgICAgcm9vdFsndHJhZGluZy12dWUtanMnXSA9IHJvb3RbJ1RyYWRpbmdWdWVKcyddXG4gICAgfVxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJ0cmFkaW5nLXZ1ZS1qc1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJ0cmFkaW5nLXZ1ZS1qc1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJUdmpzT3ZlcmxheXNcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJ0cmFkaW5nLXZ1ZS1qc1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiVHZqc092ZXJsYXlzXCJdID0gZmFjdG9yeShyb290W1widHJhZGluZy12dWUtanNcIl0pO1xufSkoc2VsZiwgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fOTU0X18pIHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDk1NDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fOTU0X187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpc29sYXRlZCBhZ2FpbnN0IG90aGVyIG1vZHVsZXMgaW4gdGhlIGNodW5rLlxuKCgpID0+IHtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcIkFMTUFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFMTUEpLFxuICBcIkFUUlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQVRSKSxcbiAgXCJBVFJwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBVFJwKSxcbiAgXCJBcmVhNTFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFyZWE1MSksXG4gIFwiQkJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJCKSxcbiAgXCJCQldcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJCVyksXG4gIFwiQ0NJXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDQ0kpLFxuICBcIkNNT1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ01PKSxcbiAgXCJDT0dcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENPRyksXG4gIFwiREhpc3RvZ3JhbVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gREhpc3RvZ3JhbSksXG4gIFwiRE1JXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBETUkpLFxuICBcIkVNQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRU1BKSxcbiAgXCJITUFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEhNQSksXG4gIFwiSGlzdG9ncmFtXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBIaXN0b2dyYW0pLFxuICBcIkljaGlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEljaGkpLFxuICBcIkljaGltb2t1XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJY2hpbW9rdSksXG4gIFwiS0NcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEtDKSxcbiAgXCJLQ1dcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEtDVyksXG4gIFwiTG9uZ1Nob3J0VHJhZGVzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBMb25nU2hvcnRUcmFkZXMpLFxuICBcIk1BQ0RcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1BQ0QpLFxuICBcIk1GSVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTUZJKSxcbiAgXCJNT01cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1PTSksXG4gIFwiTWFya2Vyc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWFya2VycyksXG4gIFwiUGxvdENyb3NzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQbG90Q3Jvc3MpLFxuICBcIlJPQ1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUk9DKSxcbiAgXCJSU0lcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJTSSksXG4gIFwiUmliYm9uXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSaWJib24pLFxuICBcIlNBUlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU0FSKSxcbiAgXCJTTUFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNNQSksXG4gIFwiU1dNQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU1dNQSksXG4gIFwiU3RvY2hcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFN0b2NoKSxcbiAgXCJUU0lcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRTSSksXG4gIFwiVHJhZGVzUGx1c1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVHJhZGVzUGx1cyksXG4gIFwiVldNQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVldNQSksXG4gIFwiV2lsbGlhbXNSXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBXaWxsaWFtc1IpLFxuICBcIlhPaGxjQmFyc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gWE9obGNCYXJzKSxcbiAgXCJkZWZhdWx0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGluZGV4X3Byb2QpXG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcInRyYWRpbmctdnVlLWpzXCJcbnZhciBleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0FMTUEvQUxNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQUxNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdBTE1BJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdBcm5hdWQgTGVnb3V4IE1vdmluZyBBdmVyYWdlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0FMTUEgJGxlbmd0aCAkb2Zmc2V0ICRzaWdtYScsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyM1NTlkZTAnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0FMTUEnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxMCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgIGRlZjogMC45LFxuICAgICAgICAgICAgdGV4dDogJ09mZnNldCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ21hOiB7XG4gICAgICAgICAgICBkZWY6IDUsXG4gICAgICAgICAgICB0ZXh0OiAnU2lnbWEnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbG1hKGNsb3NlLCBsZW5ndGgsIG9mZnNldCwgc2lnbWEpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQUxNQS9BTE1BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFMTUFfQUxNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChBTE1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgKG9wdGlvbnMuZnVuY3Rpb25hbCA/IHRoaXMucGFyZW50IDogdGhpcykuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdFxuICAgICAgICApXG4gICAgICB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQUxNQS9BTE1BLnZ1ZVxudmFyIHJlbmRlciwgc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBBTE1BX0FMTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBhcGk7IH1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0FMTUEvQUxNQS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBTE1BID0gKGNvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQVRSL0FUUi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQVRSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0FUUicsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnQXZlcmFnZSBUcnVlIFJhbmdlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0FUUiAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNlNTI0NjgnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0FUUiddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDE1LFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0cihsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQVRSL0FUUi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBVFJfQVRSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEFUUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0FUUi9BVFIudnVlXG52YXIgQVRSX3JlbmRlciwgQVRSX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEFUUl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEFUUl9BVFJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEFUUl9yZW5kZXIsXG4gIEFUUl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEFUUl9hcGk7IH1cbkFUUl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9BVFIvQVRSLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFUUiA9IChBVFJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9BVFJwL0FUUnAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFUUnB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQVRScCcsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnQXZlcmFnZSBUcnVlIFJhbmdlLCAlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0FUUiUgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjZjQ0MzM2J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydBVFJwJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTUsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTAwICogYXRyKGxlbmd0aClbMF0gLyBjbG9zZVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0FUUnAvQVRScC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBVFJwX0FUUnB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQVRScHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0FUUnAvQVRScC52dWVcbnZhciBBVFJwX3JlbmRlciwgQVRScF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBBVFJwX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQVRScF9BVFJwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBBVFJwX3JlbmRlcixcbiAgQVRScF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEFUUnBfYXBpOyB9XG5BVFJwX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0FUUnAvQVRScC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBVFJwID0gKEFUUnBfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9BcmVhNTEvQXJlYTUxLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBcmVhNTF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQXJlYTUxJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICfwn5G9JyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0dyYWRpZW50IGFyZWEgY2hhcnQnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuJHByb3BzLmRhdGE7XG4gICAgICB2YXIgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGxheW91dC5oZWlnaHQpO1xuICAgICAgZ3JkLmFkZENvbG9yU3RvcCgwLCB0aGlzLmJhY2sxKTtcbiAgICAgIGdyZC5hZGRDb2xvclN0b3AoMSwgdGhpcy5iYWNrMik7IC8vIExpbmVcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuICAgICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0pO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBBcmVhXG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBncmQ7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB2YXIgcDAgPSAoZGF0YVswXSB8fCBbXSlbMF07XG4gICAgICB2YXIgcE4gPSAoZGF0YVtkYXRhLmxlbmd0aCAtIDFdIHx8IFtdKVswXTtcbiAgICAgIGN0eC5saW5lVG8obGF5b3V0LnQyc2NyZWVuKHAwKSwgbGF5b3V0LmhlaWdodCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF94ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuXG4gICAgICAgICAgdmFyIF95ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0pO1xuXG4gICAgICAgICAgY3R4LmxpbmVUbyhfeCwgX3kpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmxpbmVUbyhsYXlvdXQudDJzY3JlZW4ocE4pLCBsYXlvdXQuaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQXJlYTUxJ107XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3JdO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMS4yNTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgJyMyZmQ2OGYnO1xuICAgIH0sXG4gICAgYmFjazE6IGZ1bmN0aW9uIGJhY2sxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYWNrMSB8fCB0aGlzLmNvbG9yICsgJzE1JztcbiAgICB9LFxuICAgIGJhY2syOiBmdW5jdGlvbiBiYWNrMigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFjazIgfHwgdGhpcy5jb2xvciArICcwMSc7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQXJlYTUxL0FyZWE1MS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBcmVhNTFfQXJlYTUxdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEFyZWE1MXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0FyZWE1MS9BcmVhNTEudnVlXG52YXIgQXJlYTUxX3JlbmRlciwgQXJlYTUxX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEFyZWE1MV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEFyZWE1MV9BcmVhNTF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEFyZWE1MV9yZW5kZXIsXG4gIEFyZWE1MV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEFyZWE1MV9hcGk7IH1cbkFyZWE1MV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9BcmVhNTEvQXJlYTUxLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFyZWE1MSA9IChBcmVhNTFfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9CQi9CQi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQkJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQkInLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0JvbGxpbmdlciBCYW5kcycsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdCQiAkbGVuZ3RoICRzdGRkZXYnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjMmNjNmM5YWInLFxuICAgICAgICAgICAgc2hvd01pZDogdHJ1ZSxcbiAgICAgICAgICAgIGJhY2tDb2xvcjogJyMyY2M2YzkwYSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQkInXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAyMSxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGRkZXY6IHtcbiAgICAgICAgICAgIGRlZjogMixcbiAgICAgICAgICAgIHRleHQ6ICdTdGREZXYnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdDaGFubmVsJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICBsZXQgW20sIGgsIGxdID0gYmIoY2xvc2UsIGxlbmd0aCwgc3RkZGV2KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtoWzBdLCBtWzBdLCBsWzBdXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0JCL0JCLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJCX0JCdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEJCdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQkIvQkIudnVlXG52YXIgQkJfcmVuZGVyLCBCQl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBCQl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEJCX0JCdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBCQl9yZW5kZXIsXG4gIEJCX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQkJfYXBpOyB9XG5CQl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9CQi9CQi52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCQiA9IChCQl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0JCVy9CQlcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJCV3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdCQlcnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0JvbGxpbmdlciBCYW5kcyBXaWR0aCcsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdCQlcgJGxlbmd0aCAkc3RkZGV2JyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyMyY2M2YzlhYidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQkJXJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMjEsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RkZGV2OiB7XG4gICAgICAgICAgICBkZWY6IDIsXG4gICAgICAgICAgICB0ZXh0OiAnU3RkRGV2J1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmJ3KGNsb3NlLCBsZW5ndGgsIHN0ZGRldilbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9CQlcvQkJXLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJCV19CQld2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQkJXdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQkJXL0JCVy52dWVcbnZhciBCQldfcmVuZGVyLCBCQldfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQkJXX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQkJXX0JCV3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQkJXX3JlbmRlcixcbiAgQkJXX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQkJXX2FwaTsgfVxuQkJXX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0JCVy9CQlcudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQkJXID0gKEJCV19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0NDSS9DQ0kudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENDSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDQ0knLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0NvbW1vZGl0eSBDaGFubmVsIEluZGV4JyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0NDSSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNlMjhhM2RlZScsXG4gICAgICAgICAgICBiYWNrQ29sb3I6ICcjZTI4YTNkMTEnLFxuICAgICAgICAgICAgYmFuZENvbG9yOiAnI2FhYWFhYScsXG4gICAgICAgICAgICB1cHBlcjogMTAwLFxuICAgICAgICAgICAgbG93ZXI6IC0xMDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQ0NJJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMjEsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnUmFuZ2UnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJyZXR1cm4gY2NpKGNsb3NlLCBsZW5ndGgpWzBdXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9DQ0kvQ0NJLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENDSV9DQ0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ0NJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQ0NJL0NDSS52dWVcbnZhciBDQ0lfcmVuZGVyLCBDQ0lfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQ0NJX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQ0NJX0NDSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQ0NJX3JlbmRlcixcbiAgQ0NJX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQ0NJX2FwaTsgfVxuQ0NJX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0NDSS9DQ0kudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ0NJID0gKENDSV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0NNTy9DTU8udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENNT3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDTU8nLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0NoYW5kZSBNb21lbnR1bSBPc2NpbGxhdG9yJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0NNTyAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyM1NTlkZTAnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0NNTyddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDEwLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcInJldHVybiBjbW8oY2xvc2UsIGxlbmd0aClbMF1cIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0NNTy9DTU8udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ01PX0NNT3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDTU92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9DTU8vQ01PLnZ1ZVxudmFyIENNT19yZW5kZXIsIENNT19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBDTU9fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBDTU9fQ01PdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDTU9fcmVuZGVyLFxuICBDTU9fc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBDTU9fYXBpOyB9XG5DTU9fY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQ01PL0NNTy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDTU8gPSAoQ01PX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQ09HL0NPRy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ09HdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0NPRycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnQ2VudGVyIG9mIEdyYXZpdHknLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnQ09HICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzU1OWRlMCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQ09HJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTAsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwicmV0dXJuIGNvZyhjbG9zZSwgbGVuZ3RoKVswXVwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQ09HL0NPRy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDT0dfQ09HdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKENPR3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0NPRy9DT0cudnVlXG52YXIgQ09HX3JlbmRlciwgQ09HX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIENPR19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIENPR19DT0d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIENPR19yZW5kZXIsXG4gIENPR19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIENPR19hcGk7IH1cbkNPR19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9DT0cvQ09HLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENPRyA9IChDT0dfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9ESGlzdG9ncmFtL0RIaXN0b2dyYW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiBcIkRIaXN0b2dyYW1cIixcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6IFwiQWNpZDNjcm9jb1wiLFxuICAgICAgICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gICAgICAgIGRlc2M6IFwiRG91YmxlIEhpc3RvZ3JhbSBQbG90XCIsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6IFwiREhpc3RvZ3JhbVwiLFxuICAgICAgICAgIHNpZGU6IFwib2ZmY2hhcnRcIixcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgaGlzdFdpZHRoOiA0LFxuICAgICAgICAgICAgdGhyZXNob2xkU2l6ZTogMCxcbiAgICAgICAgICAgIHBvc0NvbG9yOiBcIiMzNWE3NzZcIixcbiAgICAgICAgICAgIG5lZ0NvbG9yOiBcIiNlNTQxNTBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5oaXN0X3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgYmFzZSA9IGxheW91dC4kMnNjcmVlbigwKSArIDAuNTtcbiAgICAgIHZhciBvZmYgPSB0aGlzLmhpc3Rfd2lkdGggJSAyID8gMCA6IDAuNTsgLy8gQ29sb3IgY2hhbmdlZFxuXG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgcG9zX3ZhbHVlID0gcFsxXTtcbiAgICAgICAgICB2YXIgbmVnX3ZhbHVlID0gcFsyXTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKSAtIG9mZjtcbiAgICAgICAgICB2YXIgeTEgPSBsYXlvdXQuJDJzY3JlZW4ocG9zX3ZhbHVlKSAtIDAuNTtcbiAgICAgICAgICB2YXIgeTIgPSBsYXlvdXQuJDJzY3JlZW4obmVnX3ZhbHVlKSAtIDAuNTtcblxuICAgICAgICAgIGlmIChwb3NfdmFsdWUgPiB0aGlzLnRocmVzaG9sZF9zaXplKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnBvc19jb2xvcjtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgYmFzZSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkxKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVnX3ZhbHVlIDwgLXRoaXMudGhyZXNob2xkX3NpemUpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMubmVnX2NvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCBiYXNlKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeTIpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbXCJESGlzdG9ncmFtXCJdO1xuICAgIH0sXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQodmFsdWVzKSB7XG4gICAgICB2YXIgeHMgPSB2YWx1ZXMuc2xpY2UoMSwgMykubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvRml4ZWQoTWF0aC5hYnMoeCkgPiAwLjAwMSA/IDQgOiA4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZhbHVlOiB4c1swXSxcbiAgICAgICAgY29sb3I6IHRoaXMucG9zX2NvbG9yXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiB4c1sxXSxcbiAgICAgICAgY29sb3I6IHRoaXMubmVnX2NvbG9yXG4gICAgICB9XTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgaGlzdF93aWR0aDogZnVuY3Rpb24gaGlzdF93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuaGlzdFdpZHRoIHx8IDQ7XG4gICAgfSxcbiAgICB0aHJlc2hvbGRfc2l6ZTogZnVuY3Rpb24gdGhyZXNob2xkX3NpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnRocmVzaG9sZFNpemUgfHwgMDtcbiAgICB9LFxuICAgIHBvc19jb2xvcjogZnVuY3Rpb24gcG9zX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5wb3NDb2xvciB8fCBcIiMzNWE3NzZcIjtcbiAgICB9LFxuICAgIG5lZ19jb2xvcjogZnVuY3Rpb24gbmVnX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5uZWdDb2xvciB8fCBcIiNlNTQxNTBcIjtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9ESGlzdG9ncmFtL0RIaXN0b2dyYW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgREhpc3RvZ3JhbV9ESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9ESGlzdG9ncmFtL0RIaXN0b2dyYW0udnVlXG52YXIgREhpc3RvZ3JhbV9yZW5kZXIsIERIaXN0b2dyYW1fc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgREhpc3RvZ3JhbV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIERIaXN0b2dyYW1fREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgREhpc3RvZ3JhbV9yZW5kZXIsXG4gIERIaXN0b2dyYW1fc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBESGlzdG9ncmFtX2FwaTsgfVxuREhpc3RvZ3JhbV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9ESGlzdG9ncmFtL0RIaXN0b2dyYW0udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgREhpc3RvZ3JhbSA9IChESGlzdG9ncmFtX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvRE1JL0RNSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRE1JdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0RNSScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnRGlyZWN0aW9uYWwgTW92ZW1lbnQgSW5kZXgnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnRE1JICRsZW5ndGggJHNtb290aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3JzOiBbXCIjZWYxMzYwXCIsIFwiIzM3ODJmMlwiLCBcIiNmNDg3MDlcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnRE1JJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTUsXG4gICAgICAgICAgICB0ZXh0OiAnREkgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICBkZWY6IDE1LFxuICAgICAgICAgICAgdGV4dDogJ0FEWCBTbW90aGluZydcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZXMnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBbYWR4LCBkcCwgZG5dID0gZG1pKGxlbmd0aCwgc21vb3RoKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthZHhbMF0sIGRwWzBdLCBkblswXV1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9ETUkvRE1JLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERNSV9ETUl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoRE1JdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvRE1JL0RNSS52dWVcbnZhciBETUlfcmVuZGVyLCBETUlfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgRE1JX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgRE1JX0RNSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgRE1JX3JlbmRlcixcbiAgRE1JX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgRE1JX2FwaTsgfVxuRE1JX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0RNSS9ETUkudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRE1JID0gKERNSV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0VNQS9FTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEVNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdFTUEnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0V4cG9uZW50aWFsIE1vdmluZyBBdmVyYWdlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0VNQSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2Y3ODkwYydcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnRU1BJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTIsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1hKGNsb3NlLCBsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvRU1BL0VNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBFTUFfRU1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEVNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0VNQS9FTUEudnVlXG52YXIgRU1BX3JlbmRlciwgRU1BX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEVNQV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEVNQV9FTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEVNQV9yZW5kZXIsXG4gIEVNQV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEVNQV9hcGk7IH1cbkVNQV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9FTUEvRU1BLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEVNQSA9IChFTUFfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9ITUEvSE1BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBITUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnSE1BJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdIdWxsIE1vdmluZyBBdmVyYWdlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0hNQSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzNhZjQ3NSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnSE1BJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTAsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG1hKGNsb3NlLCBsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvSE1BL0hNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBITUFfSE1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEhNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0hNQS9ITUEudnVlXG52YXIgSE1BX3JlbmRlciwgSE1BX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEhNQV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEhNQV9ITUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEhNQV9yZW5kZXIsXG4gIEhNQV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEhNQV9hcGk7IH1cbkhNQV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9ITUEvSE1BLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEhNQSA9IChITUFfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9IaXN0b2dyYW0vSGlzdG9ncmFtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnSGlzdG9ncmFtJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdIaXN0b2dyYW0gcGxvdCdcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGJhc2UgPSBsYXlvdXQuJDJzY3JlZW4oMCkgKyAwLjU7XG4gICAgICB2YXIgb2ZmID0gdGhpcy5saW5lX3dpZHRoICUgMiA/IDAgOiAwLjU7IC8vIENvbG9yIGNoYW5nZWRcblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKSAtIG9mZjtcbiAgICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzFdKSAtIDAuNTtcbiAgICAgICAgICB2YXIgX2NoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChwWzJdKSB7XG4gICAgICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSBwWzJdKSB7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBwWzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSB0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfY2hhbmdlZCkgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgYmFzZSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnSGlzdG9ncmFtJ107XG4gICAgfSxcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCh2YWx1ZXMpIHtcbiAgICAgIHZhciB4ID0gdmFsdWVzWzFdO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCA9IHgudG9GaXhlZChNYXRoLmFicyh4KSA+IDAuMDAxID8gNCA6IDgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgIGNvbG9yOiB2YWx1ZXNbMl0gfHwgdGhpcy5jb2xvclxuICAgICAgfV07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAyO1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgdmFyIG4gPSB0aGlzLiRwcm9wcy5udW0gJSA1O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCB0aGlzLkNPTE9SU1tuXTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIENPTE9SUzogWycjODg4ODg4JywgJyM0MmIyOGEnLCAnIzU2OTFjZScsICcjNjEyZmY5JywgJyNkNTBiOTAnLCAnI2ZmMjMxNiddXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvSGlzdG9ncmFtL0hpc3RvZ3JhbS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBIaXN0b2dyYW1fSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0hpc3RvZ3JhbS9IaXN0b2dyYW0udnVlXG52YXIgSGlzdG9ncmFtX3JlbmRlciwgSGlzdG9ncmFtX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEhpc3RvZ3JhbV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEhpc3RvZ3JhbV9IaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEhpc3RvZ3JhbV9yZW5kZXIsXG4gIEhpc3RvZ3JhbV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEhpc3RvZ3JhbV9hcGk7IH1cbkhpc3RvZ3JhbV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9IaXN0b2dyYW0vSGlzdG9ncmFtLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEhpc3RvZ3JhbSA9IChIaXN0b2dyYW1fY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9JY2hpL0ljaGkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gQ2xvdWQgcmVuZGVyZXIuIChJY2hpbW9rdSlcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBJY2hpdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0ljaGknLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnSWNoaW1va3UgQ2xvdWQgYmFzZWQgb24gc2NyaXB0cydcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRwcm9wcy5kYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgcDEgPSB0aGlzLm1hcHAodGhpcy4kcHJvcHMuZGF0YVtpXSk7XG4gICAgICAgIHZhciBwMiA9IHRoaXMubWFwcCh0aGlzLiRwcm9wcy5kYXRhW2kgKyAxXSk7XG4gICAgICAgIGlmICghcDIpIGNvbnRpbnVlO1xuICAgICAgICBpZiAocDEueTEgIT09IHAxLnkxKSBjb250aW51ZTsgLy8gRml4IE5hTlxuICAgICAgICAvLyBCYWNrZ3JvdW5kXG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gcDEueTEgPCBwMS55MiA/IHRoaXMuYmFjazEgOiB0aGlzLmJhY2syO1xuICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkxKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwMi54ICsgMC4xLCBwMi55MSk7XG4gICAgICAgIGN0eC5saW5lVG8ocDIueCArIDAuMSwgcDIueTIpO1xuICAgICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkyKTtcbiAgICAgICAgY3R4LmZpbGwoKTsgLy8gTGluZXNcblxuICAgICAgICBpZiAoIXRoaXMuZHJhd19saW5lcykgY29udGludWU7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjE7XG4gICAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueTEpO1xuICAgICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkxKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3IyO1xuICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55Mik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hcHA6IGZ1bmN0aW9uIG1hcHAocCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHJldHVybiBwICYmIHtcbiAgICAgICAgeDogbGF5b3V0LnQyc2NyZWVuKHBbMF0pLFxuICAgICAgICB5MTogbGF5b3V0LiQyc2NyZWVuKHBbMV0pLFxuICAgICAgICB5MjogbGF5b3V0LiQyc2NyZWVuKHBbMl0pXG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0ljaGknXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvcjEsIHRoaXMuY29sb3IyXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIENQOiB7XG4gICAgICAgICAgICBkZWY6IDksXG4gICAgICAgICAgICB0ZXh0OiAnQ29udmVyc2lvbiBMaW5lIExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIEJQOiB7XG4gICAgICAgICAgICBkZWY6IDI2LFxuICAgICAgICAgICAgdGV4dDogJ0Jhc2UgTGluZSBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBMU1A6IHtcbiAgICAgICAgICAgIGRlZjogNTIsXG4gICAgICAgICAgICB0ZXh0OiAnTGFnZ2luZyBTcGFuIDIgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgRElaOiB7XG4gICAgICAgICAgICBkZWY6IDI2LFxuICAgICAgICAgICAgdGV4dDogJ0Rpc3BsYWNlbWVudCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJhc2VDb2xvcjoge1xuICAgICAgICAgICAgZGVmOiAnYnJvd24nLFxuICAgICAgICAgICAgdGV4dDogJ0Jhc2UgTGluZSBDb2xvcidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbnZlcnNpb25Db2xvcjoge1xuICAgICAgICAgICAgZGVmOiAnbGlnaHRibHVlJyxcbiAgICAgICAgICAgIHRleHQ6ICdDb252ZXJzaW9uIExpbmUgQ29sb3InXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsYWdnaW5nQ29sb3I6IHtcbiAgICAgICAgICAgIGRlZjogJyM2NkNDNjYnLFxuICAgICAgICAgICAgdGV4dDogJ0xhZ2dpbmcgU3BhbiBDb2xvcidcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBkb25jaGlhbiA9IChsZW4sIGlkKSA9PiB0cyhcXG4gICAgICAgICAgICAgICAgICAgICAgICBhdmcobG93ZXN0KGxvdywgbGVuKVswXSwgaGlnaGVzdChoaWdoLCBsZW4pWzBdKSwgaWRcXG4gICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb252ZXJzaW9uTGluZSA9IGRvbmNoaWFuKENQLCAxKVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhc2VMaW5lID0gZG9uY2hpYW4oQlAsIDIpXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGVhZExpbmUxID0gdHMoYXZnKGNvbnZlcnNpb25MaW5lWzBdLCBiYXNlTGluZVswXSkpXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGVhZExpbmUyID0gZG9uY2hpYW4oTFNQLCAzKVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhZ2dpbmcgPSB0cyhjbG9zZVswXSlcXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCh0aGlzLCBESVogLSAxKVxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0KGxhZ2dpbmcsIC1ESVogKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgb25jaGFydChbY29udmVyc2lvbkxpbmUsIGJhc2VMaW5lXSwgJ0Jhc2UgTGluZXMnLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzOiBbY29udmVyc2lvbkNvbG9yLCBiYXNlQ29sb3JdXFxuICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgb25jaGFydChsYWdnaW5nLCAnTGFnZ2luZyBTcGFuJywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBsYWdnaW5nQ29sb3JcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2xlYWRMaW5lMVswXSwgbGVhZExpbmUyWzBdXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuNzU7XG4gICAgfSxcbiAgICBjb2xvcjE6IGZ1bmN0aW9uIGNvbG9yMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IxIHx8ICdsaWdodGdyZWVuJztcbiAgICB9LFxuICAgIGNvbG9yMjogZnVuY3Rpb24gY29sb3IyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvcjIgfHwgJ29yYW5nZSc7XG4gICAgfSxcbiAgICBiYWNrMTogZnVuY3Rpb24gYmFjazEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhY2sxIHx8ICcjNzlmZjllMjInO1xuICAgIH0sXG4gICAgYmFjazI6IGZ1bmN0aW9uIGJhY2syKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYWNrMiB8fCAnI2VmNTM1MDIyJztcbiAgICB9LFxuICAgIGRyYXdfbGluZXM6IGZ1bmN0aW9uIGRyYXdfbGluZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmRyYXdMaW5lcztcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIENPTE9SUzogWycjNDJiMjhhJywgJyM1NjkxY2UnLCAnIzYxMmZmOScsICcjZDUwYjkwJywgJyNmZjIzMTYnXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0ljaGkvSWNoaS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBJY2hpX0ljaGl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoSWNoaXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0ljaGkvSWNoaS52dWVcbnZhciBJY2hpX3JlbmRlciwgSWNoaV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBJY2hpX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgSWNoaV9JY2hpdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBJY2hpX3JlbmRlcixcbiAgSWNoaV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEljaGlfYXBpOyB9XG5JY2hpX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0ljaGkvSWNoaS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBJY2hpID0gKEljaGlfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9JY2hpbW9rdS9JY2hpbW9rdS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vL0ljaGltb2t1IEluZGljYXRvciBPdmVybGF5LiBFeHBlY3RlZCBGb3JtYXQ6IFsgPHRpbWVzdGFtcD4sIDxDb252ZXJzaW9uTGluZT4sIDxCYXNlTGluZT4sIDxMZWFkMT4sIDxMZWFkMj4sIDxMYWdnaW5nPiBdXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiBcIkljaGltb2t1XCIsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3R4VGVua2FuOiB7fSxcbiAgICAgIGN0eEtpanVuOiB7fSxcbiAgICAgIGN0eFNlbmtvdVNwYW5BOiB7fSxcbiAgICAgIGN0eFNlbmtvdVNwYW5COiB7fSxcbiAgICAgIGN0eENoaW5rb3U6IHt9LFxuICAgICAgY3R4RmlsbEt1bW86IHt9LFxuICAgICAgdGVua2FuOiBbXSxcbiAgICAgIGtpanVuOiBbXSxcbiAgICAgIHNlbmtvdVNwYW5BOiBbXSxcbiAgICAgIHNlbmtvdVNwYW5COiBbXSxcbiAgICAgIGNoaW5rb3U6IFtdLFxuICAgICAgb2Zmc2V0OiAyNixcbiAgICAgIHRlbmthbkxpbmVXaWR0aDogMSxcbiAgICAgIGtpanVuTGluZVdpZHRoOiAxLFxuICAgICAgc2Vua291U3BhbkFMaW5lV2lkdGg6IDEsXG4gICAgICBzZW5rb3VTcGFuQkxpbmVXaWR0aDogMSxcbiAgICAgIGNoaW5rb3VMaW5lV2lkdGg6IDEsXG4gICAgICBjb2xvclRlbmthbjogXCIjNTJBNjM0XCIsXG4gICAgICBjb2xvcktpanVuOiBcIiM1MkE1OURcIixcbiAgICAgIGNvbG9yU2Vua291U3BhbkE6IFwiIzQzODYyNVwiLFxuICAgICAgY29sb3JTZW5rb3VTcGFuQjogXCIjYmQwMDNjXCIsXG4gICAgICBjb2xvckNoaW5rb3U6IFwiI0JGMkE2NFwiLFxuICAgICAgY29sb3JLdW1vVXA6IFwiIzA2M2YwZlwiLFxuICAgICAgY29sb3JLdW1vRG93bjogXCIjMzkxYzE5XCIsXG4gICAgICBzaG93VGVua2FuOiB0cnVlLFxuICAgICAgc2hvd0tpanVuOiB0cnVlLFxuICAgICAgc2hvd1NlbmtvdVNwYW5BOiB0cnVlLFxuICAgICAgc2hvd1NlbmtvdVNwYW5COiB0cnVlLFxuICAgICAgc2hvd0NoaW5rb3U6IHRydWUsXG4gICAgICBzaG93RmlsbEt1bW86IHRydWVcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICB0ZW5rYW5fY29sb3I6IGZ1bmN0aW9uIHRlbmthbl9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ3Rlbmthbi1jb2xvciddIHx8IHRoaXMuY29sb3JUZW5rYW47XG4gICAgfSxcbiAgICBraWp1bl9jb2xvcjogZnVuY3Rpb24ga2lqdW5fY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydraWp1bi1jb2xvciddIHx8IHRoaXMuY29sb3JLaWp1bjtcbiAgICB9LFxuICAgIHNlbmtvdV9zcGFuQV9jb2xvcjogZnVuY3Rpb24gc2Vua291X3NwYW5BX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsnc2Vua291X3NwYW5BX2NvbG9yJ10gfHwgdGhpcy5jb2xvclNlbmtvdVNwYW5BO1xuICAgIH0sXG4gICAgc2Vua291X3NwYW5CX2NvbG9yOiBmdW5jdGlvbiBzZW5rb3Vfc3BhbkJfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydzZW5rb3Vfc3BhbkJfY29sb3InXSB8fCB0aGlzLmNvbG9yU2Vua291U3BhbkI7XG4gICAgfSxcbiAgICBjaGlua291X2NvbG9yOiBmdW5jdGlvbiBjaGlua291X2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsnY2hpbmtvdV9jb2xvciddIHx8IHRoaXMuY29sb3JDaGlua291O1xuICAgIH0sXG4gICAga3Vtb191cF9jb2xvcjogZnVuY3Rpb24ga3Vtb191cF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ2t1bW9fdXBfY29sb3InXSB8fCB0aGlzLmNvbG9yS3Vtb1VwO1xuICAgIH0sXG4gICAga3Vtb19kb3duX2NvbG9yOiBmdW5jdGlvbiBrdW1vX2Rvd25fY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydrdW1vX2Rvd25fY29sb3InXSB8fCB0aGlzLmNvbG9yS3Vtb0Rvd247XG4gICAgfSxcbiAgICB0ZW5rYW5fbGluZV93aWR0aDogZnVuY3Rpb24gdGVua2FuX2xpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Wyd0ZW5rYW5fbGluZV93aWR0aCddIHx8IHRoaXMudGVua2FuTGluZVdpZHRoO1xuICAgIH0sXG4gICAga2lqdW5fbGluZV93aWR0aDogZnVuY3Rpb24ga2lqdW5fbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ2tpanVuX2xpbmVfd2lkdGgnXSB8fCB0aGlzLmtpanVuTGluZVdpZHRoO1xuICAgIH0sXG4gICAgc2Vua291X3NwYW5BX2xpbmVfd2lkdGg6IGZ1bmN0aW9uIHNlbmtvdV9zcGFuQV9saW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsnc2Vua291X3NwYW5BX2xpbmVfd2lkdGgnXSB8fCB0aGlzLnNlbmtvdVNwYW5BTGluZVdpZHRoO1xuICAgIH0sXG4gICAgc2Vua291X3NwYW5CX2xpbmVfd2lkdGg6IGZ1bmN0aW9uIHNlbmtvdV9zcGFuQl9saW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsnc2Vua291X3NwYW5CX2xpbmVfd2lkdGgnXSB8fCB0aGlzLnNlbmtvdVNwYW5CTGluZVdpZHRoO1xuICAgIH0sXG4gICAgY2hpbmtvdV9saW5lX3dpZHRoOiBmdW5jdGlvbiBjaGlua291X2xpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydjaGlua291X2xpbmVfd2lkdGgnXSB8fCB0aGlzLmNoaW5rb3VMaW5lV2lkdGg7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6IFwiU3VkZWVwIEJhdHJhXCIsXG4gICAgICAgIHZlcnNpb246IFwiMS4wLjBcIlxuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHByb3BzU3ViID0gdGhpcy4kcHJvcHMuc3ViO1xuICAgICAgdGhpcy5jdHhUZW5rYW4gPSBjdHg7XG4gICAgICB0aGlzLmN0eEtpanVuID0gY3R4O1xuICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQSA9IGN0eDtcbiAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIgPSBjdHg7XG4gICAgICB0aGlzLmN0eENoaW5rb3UgPSBjdHg7XG4gICAgICB0aGlzLmN0eEZpbGxLdW1vID0gY3R4O1xuICAgICAgdmFyIHN1YmRhdGEgPSB0aGlzLiRwcm9wcy5kYXRhLnNsaWNlKDAsIHByb3BzU3ViLmxlbmd0aCk7XG4gICAgICB2YXIgc3ViZGF0YVNlbmtvdVNwYW4gPSB0aGlzLiRwcm9wcy5kYXRhLnNsaWNlKDAsIHByb3BzU3ViLmxlbmd0aCArIHRoaXMub2Zmc2V0KTtcbiAgICAgIHZhciBzdWJkYXRhQ2hpbmtvdSA9IHRoaXMuJHByb3BzLmRhdGEuc2xpY2UoMCwgcHJvcHNTdWIubGVuZ3RoIC0gdGhpcy5vZmZzZXQpO1xuXG4gICAgICBpZiAodGhpcy5zaG93RmlsbEt1bW8pIHtcbiAgICAgICAgdGhpcy5jdHhGaWxsS3Vtby5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIGluZCA9IDA7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdWJkYXRhU2Vua291U3BhbiksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgY3Vyckl0ZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGluZCA+IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHAxID0gdGhpcy5tYXBfc2Vua291X3NwYW5fdmFsdWVzKHN1YmRhdGFTZW5rb3VTcGFuW2luZCAtIDFdKTtcbiAgICAgICAgICAgICAgdmFyIHAyID0gdGhpcy5tYXBfc2Vua291X3NwYW5fdmFsdWVzKGN1cnJJdGVtKTtcbiAgICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5tb3ZlVG8ocDEueCwgcDEuc2Vua291U3BhbkEpO1xuICAgICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmxpbmVUbyhwMi54ICsgMC4xLCBwMi5zZW5rb3VTcGFuQSk7XG4gICAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIubGluZVRvKHAyLnggKyAwLjEsIHAyLnNlbmtvdVNwYW5CKTtcbiAgICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5saW5lVG8ocDEueCwgcDEuc2Vua291U3BhbkIpO1xuXG4gICAgICAgICAgICAgIGlmIChwMS5zZW5rb3VTcGFuQSA+PSBwMS5zZW5rb3VTcGFuQikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIuZmlsbFN0eWxlID0gdGhpcy5rdW1vX2Rvd25fY29sb3I7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5maWxsU3R5bGUgPSB0aGlzLmt1bW9fdXBfY29sb3I7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmZpbGwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5kKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaG93VGVua2FuKSB7XG4gICAgICAgIHRoaXMuY3R4VGVua2FuLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN1YmRhdGEpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwVGVua2FuID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jdHhUZW5rYW4uc3Ryb2tlU3R5bGUgPSB0aGlzLnRlbmthbl9jb2xvcjtcbiAgICAgICAgICAgIHRoaXMuY3R4VGVua2FuLmxpbmVXaWR0aCA9IHRoaXMudGVua2FuX2xpbmVfd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmN0eFRlbmthbi5saW5lVG8obGF5b3V0LnQyc2NyZWVuKHBUZW5rYW5bMF0pLCBsYXlvdXQuJDJzY3JlZW4ocFRlbmthblsxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eFRlbmthbi5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd0tpanVuKSB7XG4gICAgICAgIHRoaXMuY3R4S2lqdW4uYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3ViZGF0YSksXG4gICAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHBLaWp1biA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3R4S2lqdW4uc3Ryb2tlU3R5bGUgPSB0aGlzLmtpanVuX2NvbG9yO1xuICAgICAgICAgICAgdGhpcy5jdHhLaWp1bi5saW5lV2lkdGggPSB0aGlzLmtpanVuX2xpbmVfd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmN0eEtpanVuLmxpbmVUbyhsYXlvdXQudDJzY3JlZW4ocEtpanVuWzBdKSwgbGF5b3V0LiQyc2NyZWVuKHBLaWp1blsyXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eEtpanVuLnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaG93U2Vua291U3BhbkEpIHtcbiAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQS5iZWdpblBhdGgoKTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdWJkYXRhU2Vua291U3BhbiksXG4gICAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHBTZW5rb3VTcGFuQSA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkEuc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbmtvdV9zcGFuQV9jb2xvcjtcbiAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkEubGluZVdpZHRoID0gdGhpcy5zZW5rb3Vfc3BhbkFfbGluZV93aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkEubGluZVRvKGxheW91dC50MnNjcmVlbihwU2Vua291U3BhbkFbMF0pLCBsYXlvdXQuJDJzY3JlZW4ocFNlbmtvdVNwYW5BWzNdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkEuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbG9yU2Vua291U3BhbkIpIHtcbiAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5iZWdpblBhdGgoKTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yNSA9IEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdWJkYXRhU2Vua291U3BhbiksXG4gICAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHBTZW5rb3VTcGFuQiA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIuc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbmtvdV9zcGFuQl9jb2xvcjtcbiAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIubGluZVdpZHRoID0gdGhpcy5zZW5rb3Vfc3BhbkJfbGluZV93aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIubGluZVRvKGxheW91dC50MnNjcmVlbihwU2Vua291U3BhbkJbMF0pLCBsYXlvdXQuJDJzY3JlZW4ocFNlbmtvdVNwYW5CWzRdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNob3dDaGlua291KSB7XG4gICAgICAgIHRoaXMuY3R4Q2hpbmtvdS5iZWdpblBhdGgoKTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdWJkYXRhQ2hpbmtvdSksXG4gICAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHBDaGlrb3UgPSBfc3RlcDYudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN0eENoaW5rb3Uuc3Ryb2tlU3R5bGUgPSB0aGlzLmNoaW5rb3VfY29sb3I7XG4gICAgICAgICAgICB0aGlzLmN0eENoaW5rb3UubGluZVdpZHRoID0gdGhpcy5jaGlua291X2xpbmVfd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmN0eENoaW5rb3UubGluZVRvKGxheW91dC50MnNjcmVlbihwQ2hpa291WzBdKSwgbGF5b3V0LiQyc2NyZWVuKHBDaGlrb3VbNV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHhDaGlua291LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWFwX3NlbmtvdV9zcGFuX3ZhbHVlczogZnVuY3Rpb24gbWFwX3NlbmtvdV9zcGFuX3ZhbHVlcyhwKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgcmV0dXJuIHAgJiYge1xuICAgICAgICB4OiBsYXlvdXQudDJzY3JlZW4ocFswXSksXG4gICAgICAgIHNlbmtvdVNwYW5BOiBsYXlvdXQuJDJzY3JlZW4ocFszXSksXG4gICAgICAgIHNlbmtvdVNwYW5COiBsYXlvdXQuJDJzY3JlZW4ocFs0XSlcbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFtcIkljaGltb2t1XCJdO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgICAgY29sb3JzLnB1c2godGhpcy50ZW5rYW5fY29sb3IpO1xuICAgICAgY29sb3JzLnB1c2godGhpcy5raWp1bl9jb2xvcik7XG4gICAgICBjb2xvcnMucHVzaCh0aGlzLnNlbmtvdV9zcGFuQV9jb2xvcik7XG4gICAgICBjb2xvcnMucHVzaCh0aGlzLnNlbmtvdV9zcGFuQl9jb2xvcik7XG4gICAgICBjb2xvcnMucHVzaCh0aGlzLmNoaW5rb3VfY29sb3IpO1xuICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0ljaGltb2t1L0ljaGltb2t1LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEljaGltb2t1X0ljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvSWNoaW1va3UvSWNoaW1va3UudnVlXG52YXIgSWNoaW1va3VfcmVuZGVyLCBJY2hpbW9rdV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBJY2hpbW9rdV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEljaGltb2t1X0ljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBJY2hpbW9rdV9yZW5kZXIsXG4gIEljaGltb2t1X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgSWNoaW1va3VfYXBpOyB9XG5JY2hpbW9rdV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9JY2hpbW9rdS9JY2hpbW9rdS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBJY2hpbW9rdSA9IChJY2hpbW9rdV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0tDL0tDLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLQ3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdLQycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnS2VsdG5lciBDaGFubmVscycsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdLQyAkbGVuZ3RoICRtdWx0JyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzRjOGRmZmFiJyxcbiAgICAgICAgICAgIHNob3dNaWQ6IHRydWUsXG4gICAgICAgICAgICBiYWNrQ29sb3I6ICcjNGM4ZGZmMGEnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0tDJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMjAsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdDoge1xuICAgICAgICAgICAgZGVmOiAxLFxuICAgICAgICAgICAgdGV4dDogJ011bHRpcGxpZXInXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VfdHI6IHtcbiAgICAgICAgICAgIGRlZjogdHJ1ZSxcbiAgICAgICAgICAgIHRleHQ6ICdVc2UgVHJ1ZSBSYW5nZSdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ0NoYW5uZWwnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBbbSwgaCwgbF0gPSBrYyhjbG9zZSwgbGVuZ3RoLCBtdWx0LCB1c2VfdHIpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2hbMF0sIG1bMF0sIGxbMF1dXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvS0MvS0MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS0NfS0N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoS0N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9LQy9LQy52dWVcbnZhciBLQ19yZW5kZXIsIEtDX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEtDX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgS0NfS0N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEtDX3JlbmRlcixcbiAgS0Nfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBLQ19hcGk7IH1cbktDX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0tDL0tDLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtDID0gKEtDX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvS0NXL0tDVy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS0NXdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0tDVycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnS2VsdG5lciBDaGFubmVscyBXaWR0aCcsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdLQ1cgJGxlbmd0aCAkbXVsdCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjNGM4ZGZmYWInXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0tDVyddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDIwLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHQ6IHtcbiAgICAgICAgICAgIGRlZjogMSxcbiAgICAgICAgICAgIHRleHQ6ICdNdWx0aXBsaWVyJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXNlX3RyOiB7XG4gICAgICAgICAgICBkZWY6IHRydWUsXG4gICAgICAgICAgICB0ZXh0OiAnVXNlIFRydWUgUmFuZ2UnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrY3coY2xvc2UsIGxlbmd0aCwgbXVsdCwgdXNlX3RyKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0tDVy9LQ1cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS0NXX0tDV3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChLQ1d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9LQ1cvS0NXLnZ1ZVxudmFyIEtDV19yZW5kZXIsIEtDV19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBLQ1dfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBLQ1dfS0NXdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBLQ1dfcmVuZGVyLFxuICBLQ1dfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBLQ1dfYXBpOyB9XG5LQ1dfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvS0NXL0tDVy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLQ1cgPSAoS0NXX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvTG9uZ1Nob3J0VHJhZGVzL0xvbmdTaG9ydFRyYWRlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vL0xvbmcgU2hvcnQgT3ZlcmxheS4gRXhwZWN0ZWQgRm9ybWF0OiBbIDx0aW1lc3RhbXA+LCA8U2hvcnQ6MCBMb25nOjEgU2hvcnRDb3ZlcjogMiBMb25nQ292ZXI6Mz4sIDxQcmljZSBDaGFuZ2U+LCA8UGVyY2VudCBQcmljZSBDaGFuZ2U+LCA8T3BlbiBQcmljZT4sIDxIaWdoIFByaWNlPiwgPExvdyBQcmljZT4sIDxDbG9zZSBQcmljZT4gXVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdMb25nU2hvcnRUcmFkZXMnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGRlZmF1bHRfZm9udDogZnVuY3Rpb24gZGVmYXVsdF9mb250KCkge1xuICAgICAgcmV0dXJuICcxMnB4ICcgKyB0aGlzLiRwcm9wcy5mb250LnNwbGl0KCdweCcpLnBvcCgpO1xuICAgIH0sXG4gICAgY3VycmVuY3lfc3ltYm9sOiBmdW5jdGlvbiBjdXJyZW5jeV9zeW1ib2woKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmN1cnJlbmN5IHx8ICfigrknO1xuICAgIH0sXG4gICAgbG9uZ19jb2xvcjogZnVuY3Rpb24gbG9uZ19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubG9uZ0NvbG9yIHx8ICcjNjNkZjg5JztcbiAgICB9LFxuICAgIHNob3J0X2NvbG9yOiBmdW5jdGlvbiBzaG9ydF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2hvcnRDb2xvciB8fCAnI2ZmZDU4MSc7XG4gICAgfSxcbiAgICBsb25nX2NvdmVyX2NvbG9yOiBmdW5jdGlvbiBsb25nX2NvdmVyX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5sb25nQ292ZXJDb2xvciB8fCAnI2ZjN2UyZic7XG4gICAgfSxcbiAgICBzaG9ydF9jb3Zlcl9jb2xvcjogZnVuY3Rpb24gc2hvcnRfY292ZXJfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNob3J0Q292ZXJDb2xvciB8fCAnI2ZmNmJkNic7XG4gICAgfSxcbiAgICBsYWJlbF9jb2xvcjogZnVuY3Rpb24gbGFiZWxfY29sb3IoKSB7XG4gICAgICByZXR1cm4gJyM0QkVDRjknO1xuICAgIH0sXG4gICAgbWFya2VyX3NpemU6IGZ1bmN0aW9uIG1hcmtlcl9zaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5tYXJrZXJTaXplIHx8IDU7XG4gICAgfSxcbiAgICBzaG93X2xhYmVsOiBmdW5jdGlvbiBzaG93X2xhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zaG93TGFiZWwgIT09IGZhbHNlO1xuICAgIH0sXG4gICAgbmV3X2ZvbnQ6IGZ1bmN0aW9uIG5ld19mb250KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5mb250IHx8IHRoaXMuZGVmYXVsdF9mb250O1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3VkZWVwIEJhdHJhJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4xJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEuNTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHRyYWRlVGltZSA9IHBbMF07XG4gICAgICAgICAgdmFyIGxvbmdTaG9ydEVudHJ5RXhpdCA9IHBbMV07XG4gICAgICAgICAgdmFyIHByaWNlQ2hhbmdlID0gcFsyXTtcbiAgICAgICAgICB2YXIgcGVyY2VudFByaWNlQ2hhbmdlID0gcFszXTtcbiAgICAgICAgICB2YXIgb3BlblByaWNlID0gcFs0XTtcbiAgICAgICAgICB2YXIgaGlnaFByaWNlID0gcFs1XTtcbiAgICAgICAgICB2YXIgbG93UHJpY2UgPSBwWzZdO1xuICAgICAgICAgIHZhciBjbG9zZVByaWNlID0gcFs3XTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbih0cmFkZVRpbWUpO1xuICAgICAgICAgIHZhciBsb3dQcmljZVkgPSBsYXlvdXQuJDJzY3JlZW4obG93UHJpY2UpO1xuICAgICAgICAgIHZhciBoaWdoUHJpY2VZID0gbGF5b3V0LiQyc2NyZWVuKGhpZ2hQcmljZSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGxvbmdTaG9ydEVudHJ5RXhpdCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLmZpbGxlZEFycm93RG93bkZpbGxlZEJvdHRvbShjdHgsIHgsIGhpZ2hQcmljZVkgLSAyNSwgNSwgNSwgMywgMjAsIHRoaXMuc2hvcnRfY29sb3IpO1xuICAgICAgICAgICAgICB0aGlzLmRyYXdfbGFiZWwoY3R4LCB4ICsgMzAsIGhpZ2hQcmljZVkgLSAzNSwgdGhpcy5jdXJyZW5jeV9zeW1ib2wgKyBjbG9zZVByaWNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgdGhpcy5maWxsZWRBcnJvd1VwRmlsbGVkQm90dG9tKGN0eCwgeCwgbG93UHJpY2VZICsgMjAsIDUsIDUsIDMsIDIwLCB0aGlzLmxvbmdfY29sb3IpO1xuICAgICAgICAgICAgICB0aGlzLmRyYXdfbGFiZWwoY3R4LCB4ICsgMzAsIGxvd1ByaWNlWSArIDQwLCB0aGlzLmN1cnJlbmN5X3N5bWJvbCArIGNsb3NlUHJpY2UpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB0aGlzLnVwVHJpYW5nbGUoY3R4LCB4LCBsb3dQcmljZVkgKyAyNSwgNSwgNywgdGhpcy5zaG9ydF9jb3Zlcl9jb2xvcik7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd19sYWJlbCAmJiBwcmljZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd19sYWJlbChjdHgsIHgsIGxvd1ByaWNlWSArIDUwLCBwcmljZUNoYW5nZSArIFwiIChcIiArIHBlcmNlbnRQcmljZUNoYW5nZSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHRoaXMuZG93blRyaWFuZ2xlKGN0eCwgeCwgaGlnaFByaWNlWSAtIDI1LCA1LCA3LCB0aGlzLmxvbmdfY292ZXJfY29sb3IpO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnNob3dfbGFiZWwgJiYgcHJpY2VDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdfbGFiZWwoY3R4LCB4LCBoaWdoUHJpY2VZIC0gNDUsIHByaWNlQ2hhbmdlICsgXCIgKFwiICsgcGVyY2VudFByaWNlQ2hhbmdlICsgXCIpXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnYmxhY2snO1xuICAgICAgICAgIH0gLy8gdGhpcy5zaW1wbGVBcnJvd1VwKGN0eCwgeCwgeiAtIDI1LCAnIzg0ZTViMScpXG4gICAgICAgICAgLy8gdGhpcy5zaW1wbGVBcnJvd0Rvd24oY3R4LCB4LCB6IC0gMjUsICcjODRlNWIxJylcbiAgICAgICAgICAvLyB0aGlzLmZpbGxlZEFycm93VXAoY3R4LCB4LCB6IC0gMjUsIDUsIDUsIDIwLCAnIzg0ZTViMScpXG4gICAgICAgICAgLy8gdGhpcy5maWxsZWREb3duQXJyb3coY3R4LCB4LCB6IC0gMjUsIDUsIDUsIDIwLCAnIzg0ZTViMScpXG4gICAgICAgICAgLy8gdGhpcy5maWxsZWRBcnJvd1VwRmlsbGVkQm90dG9tKGN0eCwgeCwgeiAtIDI1LCA1LCA1LCAzLCAyMCwgJyM4NGU1YjEnKVxuICAgICAgICAgIC8vIHRoaXMuZmlsbGVkQXJyb3dEb3duRmlsbGVkQm90dG9tKGN0eCwgeCwgeiAtIDI1LCA1LCA1LCAzLCAyMCwgJyM4NGU1YjEnKVxuICAgICAgICAgIC8vIHRoaXMudXBUcmlhbmdsZShjdHgsIHgsIHotNjAsIDUsIDcsICcjODRlNWIxJylcbiAgICAgICAgICAvLyB0aGlzLmRvd25UcmlhbmdsZShjdHgsIHgsIHogLSAyNSwgNSwgNywgJyM4NGU1YjEnKVxuXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYXdfbGFiZWw6IGZ1bmN0aW9uIGRyYXdfbGFiZWwoY3R4LCB4LCB5LCBsYWJlbFRleHQpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsX2NvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLm5ld19mb250O1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgY3R4LmZpbGxUZXh0KGxhYmVsVGV4dCwgeCwgeSk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnTG9uZ1Nob3J0VHJhZGVzJ107XG4gICAgfSxcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCh2YWx1ZXMpIHtcbiAgICAgIHN3aXRjaCAodmFsdWVzWzFdKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB2YXIgcG9zID0gJ1Nob3J0JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcG9zID0gJ0xvbmcnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBwb3MgPSAnU2hvcnQgQ292ZXInO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwb3MgPSAnTG9uZyBDb3Zlcic7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwb3MgPSAnVW5rbm93bic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2YWx1ZTogcG9zXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZXNbMl0udG9GaXhlZCg0KSxcbiAgICAgICAgY29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy5jb2xvclRleHRcbiAgICAgIH1dLmNvbmNhdCh2YWx1ZXNbM10gPyBbe1xuICAgICAgICB2YWx1ZTogdmFsdWVzWzNdXG4gICAgICB9XSA6IFtdKTtcbiAgICB9LFxuICAgIHNpbXBsZUFycm93VXA6IGZ1bmN0aW9uIHNpbXBsZUFycm93VXAoY3R4LCB4LCB5LCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubW92ZVRvKHggLSA1LCB5ICsgNSk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgNSwgeSArIDUpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSArIDE1KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIHNpbXBsZUFycm93RG93bjogZnVuY3Rpb24gc2ltcGxlQXJyb3dEb3duKGN0eCwgeCwgeSwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0gNSwgeSAtIDUpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIDUsIHkgLSA1KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHgsIHkgLSAxNSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcbiAgICBmaWxsZWRBcnJvd1VwOiBmdW5jdGlvbiBmaWxsZWRBcnJvd1VwKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGNvbG9yKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgZGVwdGgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIGZpbGxlZERvd25BcnJvdzogZnVuY3Rpb24gZmlsbGVkRG93bkFycm93KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGNvbG9yKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHdpZHRoLCB5IC0gaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSAtIGhlaWdodCk7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gZGVwdGgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIGZpbGxlZEFycm93VXBGaWxsZWRCb3R0b206IGZ1bmN0aW9uIGZpbGxlZEFycm93VXBGaWxsZWRCb3R0b20oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBib3R0b20sIGRlcHRoLCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubW92ZVRvKHggLSB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5yZWN0KHggLSBib3R0b20gLyAyLCB5ICsgaGVpZ2h0LCBib3R0b20sIGRlcHRoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcbiAgICBmaWxsZWRBcnJvd0Rvd25GaWxsZWRCb3R0b206IGZ1bmN0aW9uIGZpbGxlZEFycm93RG93bkZpbGxlZEJvdHRvbShjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJvdHRvbSwgZGVwdGgsIGNvbG9yKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHdpZHRoLCB5IC0gaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSAtIGhlaWdodCk7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LnJlY3QoeCAtIGJvdHRvbSAvIDIsIHkgLSBoZWlnaHQgLSBkZXB0aCwgYm90dG9tLCBkZXB0aCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgdXBUcmlhbmdsZTogZnVuY3Rpb24gdXBUcmlhbmdsZShjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgZG93blRyaWFuZ2xlOiBmdW5jdGlvbiBkb3duVHJpYW5nbGUoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubW92ZVRvKHggLSB3aWR0aCwgeSAtIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgLSBoZWlnaHQpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0xvbmdTaG9ydFRyYWRlcy9Mb25nU2hvcnRUcmFkZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTG9uZ1Nob3J0VHJhZGVzX0xvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9Mb25nU2hvcnRUcmFkZXMvTG9uZ1Nob3J0VHJhZGVzLnZ1ZVxudmFyIExvbmdTaG9ydFRyYWRlc19yZW5kZXIsIExvbmdTaG9ydFRyYWRlc19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBMb25nU2hvcnRUcmFkZXNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBMb25nU2hvcnRUcmFkZXNfTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBMb25nU2hvcnRUcmFkZXNfcmVuZGVyLFxuICBMb25nU2hvcnRUcmFkZXNfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBMb25nU2hvcnRUcmFkZXNfYXBpOyB9XG5Mb25nU2hvcnRUcmFkZXNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvTG9uZ1Nob3J0VHJhZGVzL0xvbmdTaG9ydFRyYWRlcy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMb25nU2hvcnRUcmFkZXMgPSAoTG9uZ1Nob3J0VHJhZGVzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvTUFDRC9NQUNELnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIFRPRE86IHBhc3MgY29sb3JzIGZyb20gc2V0dGluZ3MgdG8gdGhlIHNjcmlwdFxuLy8gVE9ETzogaGlzdCBsaW5lcyA9PiByZWNhbmdsZXMgKGxpa2UgaW4gdm9sYmFyLmpzKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnTUFDRCcsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjInLFxuICAgICAgICBkZXNjOiAnTW92aW5nIEF2ZXJhZ2UgQ29udmVyZ2VuY2UvRGl2ZXJnZW5jZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdNQUNEICRmYXN0ICRzbG93ICRzbW9vdGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGhpc3RXaWR0aDogNCxcbiAgICAgICAgICAgIG1hY2RXaWR0aDogMSxcbiAgICAgICAgICAgIHNpZ25hbFdpZHRoOiAxLFxuICAgICAgICAgICAgZGVmQ29sb3I6IFwiIzQyYjI4YVwiLFxuICAgICAgICAgICAgbWFjZENvbG9yOiBcIiMzNzgyZjJcIixcbiAgICAgICAgICAgIHNpZ25hbENvbG9yOiBcIiNmNDg3MDlcIixcbiAgICAgICAgICAgIGhpc3RDb2xvcnM6IFtcIiMzNWE3NzZcIiwgXCIjNzllMGIzXCIsIFwiI2U1NDE1MFwiLCBcIiNlYTk2OWVcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDsgLy8gSElTVE9HUkFNXG5cbiAgICAgIHZhciBiYXNlID0gbGF5b3V0LiQyc2NyZWVuKDApICsgMC41O1xuICAgICAgdmFyIG9mZiA9IHRoaXMuaGlzdF93aWR0aCAlIDIgPyAwIDogMC41O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuaGlzdF93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pIC0gb2ZmO1xuICAgICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0pIC0gMC41O1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2V0dC5oaXN0Q29sb3JzW3BbNF1dO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIGJhc2UpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9IC8vIE1BQ0QgTElORVxuXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLm1hY2Rfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLm1hY2RfY29sb3I7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF94ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuXG4gICAgICAgICAgdmFyIF95ID0gbGF5b3V0LiQyc2NyZWVuKHBbMl0pO1xuXG4gICAgICAgICAgY3R4LmxpbmVUbyhfeCwgX3kpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBTSUdOQUwgTElORVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zaWduYWxfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNpZ25hbF9jb2xvcjtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3gyID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuXG4gICAgICAgICAgdmFyIF95MiA9IGxheW91dC4kMnNjcmVlbihwWzNdKTtcblxuICAgICAgICAgIGN0eC5saW5lVG8oX3gyLCBfeTIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ01BQ0QnXTtcbiAgICB9LFxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKHZhbHVlcykge1xuICAgICAgdmFyIHhzID0gdmFsdWVzLnNsaWNlKDEsIDQpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50b0ZpeGVkKE1hdGguYWJzKHgpID4gMC4wMDEgPyA0IDogOCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2YWx1ZTogeHNbMF0sXG4gICAgICAgIGNvbG9yOiB0aGlzLmhpc3RfY29sb3JzW3ZhbHVlc1s0XV1cbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IHhzWzFdLFxuICAgICAgICBjb2xvcjogdGhpcy5tYWNkX2NvbG9yXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiB4c1syXSxcbiAgICAgICAgY29sb3I6IHRoaXMuc2lnbmFsX2NvbG9yXG4gICAgICB9XTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGZhc3Q6IHtcbiAgICAgICAgICAgIGRlZjogMTIsXG4gICAgICAgICAgICB0ZXh0OiAnRmFzdCBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbG93OiB7XG4gICAgICAgICAgICBkZWY6IDI2LFxuICAgICAgICAgICAgdGV4dDogJ1Nsb3cgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICBkZWY6IDksXG4gICAgICAgICAgICB0ZXh0OiAnU2lnbmFsIEVNQSdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBbbWFjZCwgc2lnbmFsLCBoaXN0XSA9XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFjZChjbG9zZSwgZmFzdCwgc2xvdywgc21vb3RoKVxcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpc3RbMF0gPj0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSAwXFxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXN0WzBdIDwgaGlzdFsxXSkgY29sb3IgPSAxXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gMlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXN0WzBdID4gaGlzdFsxXSkgY29sb3IgPSAzXFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2hpc3RbMF0sIG1hY2RbMF0sIHNpZ25hbFswXSwgY29sb3JdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBoaXN0X3dpZHRoOiBmdW5jdGlvbiBoaXN0X3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5oaXN0V2lkdGggfHwgNDtcbiAgICB9LFxuICAgIG1hY2Rfd2lkdGg6IGZ1bmN0aW9uIG1hY2Rfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lm1hY2RXaWR0aCB8fCAxO1xuICAgIH0sXG4gICAgc2lnbmFsX3dpZHRoOiBmdW5jdGlvbiBzaWduYWxfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNpZ25hbFdpZHRoIHx8IDE7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmRlZkNvbG9yIHx8IFwiIzQyYjI4YVwiO1xuICAgIH0sXG4gICAgbWFjZF9jb2xvcjogZnVuY3Rpb24gbWFjZF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubWFjZENvbG9yIHx8IFwiIzM3ODJmMlwiO1xuICAgIH0sXG4gICAgc2lnbmFsX2NvbG9yOiBmdW5jdGlvbiBzaWduYWxfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNpZ25hbENvbG9yIHx8IFwiI2Y0ODcwOVwiO1xuICAgIH0sXG4gICAgaGlzdF9jb2xvcnM6IGZ1bmN0aW9uIGhpc3RfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5oaXN0Q29sb3JzO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTUFDRC9NQUNELnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1BQ0RfTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTUFDRC9NQUNELnZ1ZVxudmFyIE1BQ0RfcmVuZGVyLCBNQUNEX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIE1BQ0RfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNQUNEX01BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIE1BQ0RfcmVuZGVyLFxuICBNQUNEX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgTUFDRF9hcGk7IH1cbk1BQ0RfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvTUFDRC9NQUNELnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1BQ0QgPSAoTUFDRF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL01GSS9NRkkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1GSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdNRkknLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ01vbmV5IEZsb3cgSW5kZXgnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnTUZJICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzg1YzQyN2VlJyxcbiAgICAgICAgICAgIGJhbmRDb2xvcjogJyNhYWFhYWEnLFxuICAgICAgICAgICAgYmFja0NvbG9yOiAnIzg1YzQyNzExJyxcbiAgICAgICAgICAgIHVwcGVyOiA4MCxcbiAgICAgICAgICAgIGxvd2VyOiAyMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydNRkknXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxNCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdSYW5nZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhsYzMgPSB0cygoaGlnaFswXSArIGxvd1swXSArIGNsb3NlWzBdKSAvIDMpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWZpKGhsYzMsIGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9NRkkvTUZJLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1GSV9NRkl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTUZJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTUZJL01GSS52dWVcbnZhciBNRklfcmVuZGVyLCBNRklfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgTUZJX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTUZJX01GSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgTUZJX3JlbmRlcixcbiAgTUZJX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgTUZJX2FwaTsgfVxuTUZJX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL01GSS9NRkkudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTUZJID0gKE1GSV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL01PTS9NT00udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1PTXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdNT00nLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ01vbWVudHVtJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ01PTSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNiY2M0MjdlZSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnTU9NJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTEsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tKGNsb3NlLCBsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTU9NL01PTS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNT01fTU9NdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKE1PTXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL01PTS9NT00udnVlXG52YXIgTU9NX3JlbmRlciwgTU9NX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIE1PTV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1PTV9NT012dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIE1PTV9yZW5kZXIsXG4gIE1PTV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIE1PTV9hcGk7IH1cbk1PTV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9NT00vTU9NLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1PTSA9IChNT01fY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9NYXJrZXJzL01hcmtlcnMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnTWFya2VycycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMScsXG4gICAgICAgIGRlc2M6ICdJbnRlcmFjdGl2ZSBtYXJrZXJzJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEuNTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdhdXRvJztcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB0aGlzLmRyYXdfcG9pbnQoY3R4LCBwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZiA9IHRoaXMuZGF0YS5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4WzFdLnNlbDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZikge1xuICAgICAgICB0aGlzLmRyYXdfcG9pbnQoY3R4LCBmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYXdfcG9pbnQ6IGZ1bmN0aW9uIGRyYXdfcG9pbnQoY3R4LCBwKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuY29sb3JzLmJhY2s7XG4gICAgICB2YXIgZmlsbCA9IHBbMV0uY29sb3IgfHwgJ29yYW5nZSc7XG4gICAgICB2YXIgcmFkaXVzID0gMjtcbiAgICAgIHZhciBoZWlnaHQgPSBwWzFdLnNlbCA/IDIwIDogMTQ7XG4gICAgICB2YXIgd2lkdGggPSBwWzFdLnNlbCA/IDE3IDogMTM7XG4gICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKSAtIHdpZHRoICogMC41O1xuICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXS4kKSAtIChwWzFdLnNlbCA/IDI3IDogMjApOyAvLyBDb2xsaXNpb25zXG5cbiAgICAgIGlmICh0aGlzLm1vdXNlLnggPiB4ICYmIHRoaXMubW91c2UueCA8IHggKyB3aWR0aCAmJiB0aGlzLm1vdXNlLnkgPiB5ICYmIHRoaXMubW91c2UueSA8IHkgKyBoZWlnaHQpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBwO1xuICAgICAgICBzdHJva2UgPSB0aGlzLmNvbG9ycy50ZXh0O1xuICAgICAgfVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggKiAxIC8gMiwgeSArIGhlaWdodCArIGhlaWdodCAvIDUpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjdHguZmlsbFN0eWxlID0gcFsxXS50ZXh0Q29sb3IgfHwgdGhpcy5jb2xvcnMuYmFjaztcbiAgICAgIGN0eC5mb250ID0gXCJcIi5jb25jYXQocFsxXS5zZWwgPyAxNSA6IDExLCBcInB4IEFyaWFsXCIpO1xuICAgICAgY3R4LmZpbGxUZXh0KHBbMV0udGV4dCB8fCAnJCcsIHggKyB3aWR0aCAvIDIsIHkgKyBoZWlnaHQgKiAwLjgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ01hcmtlcnMnXTtcbiAgICB9LFxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbiBtb3VzZWRvd24oKSB7XG4gICAgICB0aGlzLiRlbWl0KCdtYXJrZXItc2VsZWN0ZWQnLCB0aGlzLnNlbGVjdGVkKTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgZGVmYXVsdF9mb250OiBmdW5jdGlvbiBkZWZhdWx0X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gJzEycHggJyArIHRoaXMuJHByb3BzLmZvbnQuc3BsaXQoJ3B4JykucG9wKCk7XG4gICAgfSxcbiAgICBuZXdfZm9udDogZnVuY3Rpb24gbmV3X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmZvbnQgfHwgdGhpcy5kZWZhdWx0X2ZvbnQ7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RlZDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL01hcmtlcnMvTWFya2Vycy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNYXJrZXJzX01hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL01hcmtlcnMvTWFya2Vycy52dWVcbnZhciBNYXJrZXJzX3JlbmRlciwgTWFya2Vyc19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBNYXJrZXJzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWFya2Vyc19NYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBNYXJrZXJzX3JlbmRlcixcbiAgTWFya2Vyc19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIE1hcmtlcnNfYXBpOyB9XG5NYXJrZXJzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL01hcmtlcnMvTWFya2Vycy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNYXJrZXJzID0gKE1hcmtlcnNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9QbG90Q3Jvc3MvUGxvdENyb3NzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnUGxvdENyb3NzJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdQbG90IGxpbmUgd2l0aCBjcm9zc2VzJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgdyA9IGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBiYXNlID0gbGF5b3V0LiQyc2NyZWVuKDApICsgMC41O1xuICAgICAgdmFyIG9mZiA9IHRoaXMubGluZV93aWR0aCAlIDIgPyAwIDogMC41O1xuICAgICAgdmFyIG9mZjIgPSB0aGlzLmxpbmVfd2lkdGggJSAyID8gMC41IDogMTsgLy8gQ29sb3IgY2hhbmdlZFxuXG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pIC0gb2ZmO1xuICAgICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0pIC0gb2ZmO1xuICAgICAgICAgIHZhciBfY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHBbMl0pIHtcbiAgICAgICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT09IHBbMl0pIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICBfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBbMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT09IHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICBfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGFuZ2VkKSBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5IC0gdyAqIDIgKyBvZmYyKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyB3ICogMiAtIG9mZjIpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCAtIHcgKiAyICsgb2ZmMiwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyAqIDIgLSBvZmYyLCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnUGxvdENyb3NzJ107XG4gICAgfSxcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCh2YWx1ZXMpIHtcbiAgICAgIHZhciB4ID0gdmFsdWVzWzFdO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCA9IHgudG9GaXhlZChNYXRoLmFicyh4KSA+IDAuMDAxID8gNCA6IDgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgIGNvbG9yOiB2YWx1ZXNbMl0gfHwgdGhpcy5jb2xvclxuICAgICAgfV07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAyO1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgdmFyIG4gPSB0aGlzLiRwcm9wcy5udW0gJSA1O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCB0aGlzLkNPTE9SU1tuXTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIENPTE9SUzogWycjODg4ODg4JywgJyM0MmIyOGEnLCAnIzU2OTFjZScsICcjNjEyZmY5JywgJyNkNTBiOTAnLCAnI2ZmMjMxNiddXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvUGxvdENyb3NzL1Bsb3RDcm9zcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQbG90Q3Jvc3NfUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1Bsb3RDcm9zcy9QbG90Q3Jvc3MudnVlXG52YXIgUGxvdENyb3NzX3JlbmRlciwgUGxvdENyb3NzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFBsb3RDcm9zc19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFBsb3RDcm9zc19QbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFBsb3RDcm9zc19yZW5kZXIsXG4gIFBsb3RDcm9zc19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFBsb3RDcm9zc19hcGk7IH1cblBsb3RDcm9zc19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9QbG90Q3Jvc3MvUGxvdENyb3NzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFBsb3RDcm9zcyA9IChQbG90Q3Jvc3NfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9ST0MvUk9DLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBST0N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnUk9DJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdSYXRlIG9mIENoYW5nZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdST0MgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjMjc5ZmM0J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydST0MnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiA5LFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvYyhjbG9zZSwgbGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1JPQy9ST0MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUk9DX1JPQ3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChST0N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9ST0MvUk9DLnZ1ZVxudmFyIFJPQ19yZW5kZXIsIFJPQ19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBST0NfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBST0NfUk9DdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBST0NfcmVuZGVyLFxuICBST0Nfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBST0NfYXBpOyB9XG5ST0NfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvUk9DL1JPQy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBST0MgPSAoUk9DX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvUlNJL1JTSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUlNJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1JTSScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnUmVsYXRpdmUgU3RyZW5ndGggSW5kZXgnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnUlNJICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2VjMjA2ZScsXG4gICAgICAgICAgICBiYW5kQ29sb3I6ICcjYWFhJyxcbiAgICAgICAgICAgIGJhY2tDb2xvcjogJyM5YjliYTMxNidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnUlNJJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTQsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnUmFuZ2UnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJyZXR1cm4gcnNpKGNsb3NlLCBsZW5ndGgpWzBdXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9SU0kvUlNJLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJTSV9SU0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoUlNJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvUlNJL1JTSS52dWVcbnZhciBSU0lfcmVuZGVyLCBSU0lfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgUlNJX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgUlNJX1JTSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgUlNJX3JlbmRlcixcbiAgUlNJX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgUlNJX2FwaTsgfVxuUlNJX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1JTSS9SU0kudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUlNJID0gKFJTSV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1JpYmJvbi9SaWJib24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJpYmJvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdSaWJib24nLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ01vdmluZyBBdmVyYWdlIFJpYmJvbicsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdFTUEgeCAkbnVtYmVyJyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yczogW1wiIzNhYWFmNGVlXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1JpYmJvbiddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIGRlZjogMTAsXG4gICAgICAgICAgICB0ZXh0OiAnU3RhcnQgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBkZWY6IDUsXG4gICAgICAgICAgICB0ZXh0OiAnTnVtYmVyIG9mIExpbmVzJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RlcDoge1xuICAgICAgICAgICAgZGVmOiAxMCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGggU3RlcCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZXMnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbMF0gPSBbXVxcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXI7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsID0gc3RhcnQgKyBpICogc3RlcFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0ucHVzaChlbWEoY2xvc2UsIGwpWzBdKVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1JpYmJvbi9SaWJib24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUmliYm9uX1JpYmJvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChSaWJib252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9SaWJib24vUmliYm9uLnZ1ZVxudmFyIFJpYmJvbl9yZW5kZXIsIFJpYmJvbl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBSaWJib25fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBSaWJib25fUmliYm9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBSaWJib25fcmVuZGVyLFxuICBSaWJib25fc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBSaWJib25fYXBpOyB9XG5SaWJib25fY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvUmliYm9uL1JpYmJvbi52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSaWJib24gPSAoUmliYm9uX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvU0FSL1NBUi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU0FSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NBUicsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnUGFyYWJvbGljIFNBUicsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdTQVIgJHN0YXJ0ICRpbmMgJG1heCcsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBjb2xvcjogJyMzNWE5YzYnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1NBUiddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIGRlZjogMC4wMixcbiAgICAgICAgICAgIHRleHQ6ICdTdGFydCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluYzoge1xuICAgICAgICAgICAgZGVmOiAwLjAyLFxuICAgICAgICAgICAgdGV4dDogJ0luY3JlbWVudCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1heDoge1xuICAgICAgICAgICAgZGVmOiAwLjIsXG4gICAgICAgICAgICB0ZXh0OiAnTWF4aW11bSdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1Bsb3RDcm9zcydcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhcihzdGFydCwgaW5jLCBtYXgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvU0FSL1NBUi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTQVJfU0FSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNBUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1NBUi9TQVIudnVlXG52YXIgU0FSX3JlbmRlciwgU0FSX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFNBUl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFNBUl9TQVJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNBUl9yZW5kZXIsXG4gIFNBUl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNBUl9hcGk7IH1cblNBUl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9TQVIvU0FSLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNBUiA9IChTQVJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9TTUEvU01BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU01BJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdTaW1wbGUgTW92aW5nIEF2ZXJhZ2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnU01BICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjZDEzODVjJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydTTUEnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAyNSxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbWEoY2xvc2UsIGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9TTUEvU01BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNNQV9TTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvU01BL1NNQS52dWVcbnZhciBTTUFfcmVuZGVyLCBTTUFfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU01BX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgU01BX1NNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU01BX3JlbmRlcixcbiAgU01BX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU01BX2FwaTsgfVxuU01BX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1NNQS9TTUEudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU01BID0gKFNNQV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1NXTUEvU1dNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU1dNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTV01BJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdTeW1tZXRyaWNhbGx5IFdlaWdodGVkIE1vdmluZyBBdmVyYWdlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ1NXTUEnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjZTU3NDQwJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydTV01BJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzd21hKGNsb3NlKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1NXTUEvU1dNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTV01BX1NXTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU1dNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1NXTUEvU1dNQS52dWVcbnZhciBTV01BX3JlbmRlciwgU1dNQV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTV01BX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgU1dNQV9TV01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTV01BX3JlbmRlcixcbiAgU1dNQV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNXTUFfYXBpOyB9XG5TV01BX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1NXTUEvU1dNQS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTV01BID0gKFNXTUFfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9TdG9jaC9TdG9jaC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU3RvY2gnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1N0b2NoYXN0aWMnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnU3RvY2ggJHBhcmFtX2sgJHBhcmFtX2QgJHNtb290aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAga0NvbG9yOiAnIzM3ODJmMicsXG4gICAgICAgICAgICBkQ29sb3I6ICcjZjQ4NzA5JyxcbiAgICAgICAgICAgIGJhbmRDb2xvcjogJyNkZGQnLFxuICAgICAgICAgICAgYmFja0NvbG9yOiAnIzM4MWU5YzE2J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHVwcGVyID0gbGF5b3V0LiQyc2NyZWVuKHRoaXMuc2V0dC51cHBlciB8fCA4MCk7XG4gICAgICB2YXIgbG93ZXIgPSBsYXlvdXQuJDJzY3JlZW4odGhpcy5zZXR0Lmxvd2VyIHx8IDIwKTsgLy8gS1xuXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5rX2NvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG4gICAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7IC8vIERcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZF9jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF94ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuXG4gICAgICAgICAgdmFyIF95ID0gbGF5b3V0LiQyc2NyZWVuKHBbMl0pO1xuXG4gICAgICAgICAgY3R4LmxpbmVUbyhfeCwgX3kpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5iYW5kX2NvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFs1XSk7IC8vIFdpbGwgYmUgcmVtb3ZlZCBhZnRlciBkcmF3KClcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpOyAvLyBGaWxsIHRoZSBhcmVhIGJldHdlZW4gdGhlIGJhbmRzXG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tfY29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgdXBwZXIsIGxheW91dC53aWR0aCwgbG93ZXIgLSB1cHBlcik7IC8vIFVwcGVyIGJhbmRcblxuICAgICAgY3R4Lm1vdmVUbygwLCB1cHBlcik7XG4gICAgICBjdHgubGluZVRvKGxheW91dC53aWR0aCwgdXBwZXIpOyAvLyBMb3dlciBiYW5kXG5cbiAgICAgIGN0eC5tb3ZlVG8oMCwgbG93ZXIpO1xuICAgICAgY3R4LmxpbmVUbyhsYXlvdXQud2lkdGgsIGxvd2VyKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydTdG9jaCddO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yXTtcbiAgICB9LFxuICAgIHlfcmFuZ2U6IGZ1bmN0aW9uIHlfcmFuZ2UoaGksIGxvKSB7XG4gICAgICByZXR1cm4gW01hdGgubWF4KGhpLCB0aGlzLnNldHQudXBwZXIgfHwgODApLCBNYXRoLm1pbihsbywgdGhpcy5zZXR0Lmxvd2VyIHx8IDIwKV07XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBwYXJhbV9rOiB7XG4gICAgICAgICAgICBkZWY6IDE0LFxuICAgICAgICAgICAgdGV4dDogJ0snXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJhbV9kOiB7XG4gICAgICAgICAgICBkZWY6IDMsXG4gICAgICAgICAgICB0ZXh0OiAnRCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgZGVmOiAzLFxuICAgICAgICAgICAgdGV4dDogJ1Ntb290aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBrID0gc21hKHN0b2NoKGNsb3NlLCBoaWdoLCBsb3csIHBhcmFtX2spLCBzbW9vdGgpXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHNtYShrLCBwYXJhbV9kKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtrWzBdLCBkWzBdXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjc1O1xuICAgIH0sXG4gICAga19jb2xvcjogZnVuY3Rpb24ga19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQua0NvbG9yIHx8ICcjMzc4MmYyJztcbiAgICB9LFxuICAgIGRfY29sb3I6IGZ1bmN0aW9uIGRfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmRDb2xvciB8fCAnI2Y0ODcwOSc7XG4gICAgfSxcbiAgICBiYW5kX2NvbG9yOiBmdW5jdGlvbiBiYW5kX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYW5kQ29sb3IgfHwgJyNkZGQnO1xuICAgIH0sXG4gICAgYmFja19jb2xvcjogZnVuY3Rpb24gYmFja19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFja0NvbG9yIHx8ICcjMzgxZTljMTYnO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvU3RvY2gvU3RvY2gudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3RvY2hfU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9TdG9jaC9TdG9jaC52dWVcbnZhciBTdG9jaF9yZW5kZXIsIFN0b2NoX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFN0b2NoX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgU3RvY2hfU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFN0b2NoX3JlbmRlcixcbiAgU3RvY2hfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTdG9jaF9hcGk7IH1cblN0b2NoX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1N0b2NoL1N0b2NoLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFN0b2NoID0gKFN0b2NoX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvVFNJL1RTSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVFNJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1RTSScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnVHJ1ZSBTdHJlbmd0aCBJbmRleCcsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdUU0kgJGxvbmcgJHNob3J0ICRzaWduYWwnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yczogW1wiIzNiYjNlNFwiLCBcIiNmNzA0NmRcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnVFNJJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBcImxvbmdcIjoge1xuICAgICAgICAgICAgZGVmOiAyNSxcbiAgICAgICAgICAgIHRleHQ6ICdMb25nIExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2hvcnRcIjoge1xuICAgICAgICAgICAgZGVmOiAxMyxcbiAgICAgICAgICAgIHRleHQ6ICdTaG9ydCBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaWduYWw6IHtcbiAgICAgICAgICAgIGRlZjogMTMsXG4gICAgICAgICAgICB0ZXh0OiAnU2lnbmFsIExlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZXMnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSB0c2koY2xvc2UsIHNob3J0LCBsb25nKVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpZyA9IGVtYSh2YWwsIHNpZ25hbClcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdmFsWzBdICogMTAwLCBzaWdbMF0gKiAxMDBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvVFNJL1RTSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUU0lfVFNJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFRTSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1RTSS9UU0kudnVlXG52YXIgVFNJX3JlbmRlciwgVFNJX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFRTSV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFRTSV9UU0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFRTSV9yZW5kZXIsXG4gIFRTSV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFRTSV9hcGk7IH1cblRTSV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9UU0kvVFNJLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRTSSA9IChUU0lfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9UcmFkZXNQbHVzL1RyYWRlc1BsdXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG52YXIgQ1JPU1MgPSBcIm01MTIuMDAxIDg0Ljg1My04NC44NTMtODQuODUzLTE3MS4xNDcgMTcxLjE0Ny0xNzEuMTQ4LTE3MS4xNDctODQuODUzXFxuODQuODUzIDE3MS4xNDggMTcxLjE0Ny0xNzEuMTQ4IDE3MS4xNDggODQuODUzIDg0Ljg1MyAxNzEuMTQ4LTE3MS4xNDdcXG4xNzEuMTQ3IDE3MS4xNDcgODQuODUzLTg0Ljg1My0xNzEuMTQ4LTE3MS4xNDh6XCI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVHJhZGVzUGx1cycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMScsXG4gICAgICAgIGRlc2M6ICdUcmFkZXMgb3ZlcmxheSB3aXRoIHN0b3BzJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHBbMV0gPyB0aGlzLmJ1eV9jb2xvciA6IHRoaXMuc2VsbF9jb2xvcjtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTsgLy8geCAtIE1hcHBpbmdcblxuICAgICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMl0pOyAvLyB5IC0gTWFwcGluZ1xuXG4gICAgICAgICAgaWYgKHBbM10gPT09ICdTdG9wJykge1xuICAgICAgICAgICAgdGhpcy5kcmF3X2Nyb3NzKGN0eCwgeCwgeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd19jaXJjbGUoY3R4LCB4LCB5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zaG93X2xhYmVsICYmIHBbM10gJiYgcFszXSAhPT0gJ1N0b3AnKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdfbGFiZWwoY3R4LCB4LCB5LCBwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYXdfbGFiZWw6IGZ1bmN0aW9uIGRyYXdfbGFiZWwoY3R4LCB4LCB5LCBwKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbF9jb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGhpcy5uZXdfZm9udDtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGN0eC5maWxsVGV4dChwWzNdLCB4LCB5IC0gMjUpO1xuICAgIH0sXG4gICAgZHJhd19jaXJjbGU6IGZ1bmN0aW9uIGRyYXdfY2lyY2xlKGN0eCwgeCwgeSkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEuNTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMoeCwgeSwgdGhpcy5tYXJrZXJfc2l6ZSArIDAuNSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIGRyYXdfY3Jvc3M6IGZ1bmN0aW9uIGRyYXdfY3Jvc3MoY3R4LCB4LCB5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIHAgPSBuZXcgUGF0aDJEKENST1NTKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxNTA7XG4gICAgICBjdHgudHJhbnNsYXRlKHggLSA1LCB5IC0gNSk7XG4gICAgICBjdHguc2NhbGUoMC4wMTc1LCAwLjAxNzUpO1xuICAgICAgY3R4LnN0cm9rZShwKTtcbiAgICAgIGN0eC5maWxsKHApO1xuICAgICAgY3R4LnNjYWxlKDEsIDEpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydUcmFkZXNQbHVzJ107XG4gICAgfSxcbiAgICAvLyBEZWZpbmVzIGxlZ2VuZCBmb3JtYXQgKHZhbHVlcyAmIGNvbG9ycylcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCh2YWx1ZXMpIHtcbiAgICAgIHN3aXRjaCAodmFsdWVzWzFdKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB2YXIgcG9zID0gJ1NlbGwnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwb3MgPSAnQnV5JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHBvcyA9ICdVbmtub3duJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZhbHVlOiBwb3NcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlc1syXS50b0ZpeGVkKDQpLFxuICAgICAgICBjb2xvcjogdGhpcy4kcHJvcHMuY29sb3JzLmNvbG9yVGV4dFxuICAgICAgfV0uY29uY2F0KHZhbHVlc1szXSA/IFt7XG4gICAgICAgIHZhbHVlOiB2YWx1ZXNbM11cbiAgICAgIH1dIDogW10pO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBkZWZhdWx0X2ZvbnQ6IGZ1bmN0aW9uIGRlZmF1bHRfZm9udCgpIHtcbiAgICAgIHJldHVybiAnMTJweCAnICsgdGhpcy4kcHJvcHMuZm9udC5zcGxpdCgncHgnKS5wb3AoKTtcbiAgICB9LFxuICAgIGJ1eV9jb2xvcjogZnVuY3Rpb24gYnV5X2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5idXlDb2xvciB8fCAnIzYzZGY4OSc7XG4gICAgfSxcbiAgICBzZWxsX2NvbG9yOiBmdW5jdGlvbiBzZWxsX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zZWxsQ29sb3IgfHwgJyNlYzQ2NjInO1xuICAgIH0sXG4gICAgbGFiZWxfY29sb3I6IGZ1bmN0aW9uIGxhYmVsX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5sYWJlbENvbG9yIHx8IHRoaXMuY29sb3JzLnRleHQ7XG4gICAgfSxcbiAgICBtYXJrZXJfc2l6ZTogZnVuY3Rpb24gbWFya2VyX3NpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lm1hcmtlclNpemUgfHwgNTtcbiAgICB9LFxuICAgIHNob3dfbGFiZWw6IGZ1bmN0aW9uIHNob3dfbGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNob3dMYWJlbCAhPT0gZmFsc2U7XG4gICAgfSxcbiAgICBuZXdfZm9udDogZnVuY3Rpb24gbmV3X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmZvbnQgfHwgdGhpcy5kZWZhdWx0X2ZvbnQ7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9UcmFkZXNQbHVzL1RyYWRlc1BsdXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhZGVzUGx1c19UcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9UcmFkZXNQbHVzL1RyYWRlc1BsdXMudnVlXG52YXIgVHJhZGVzUGx1c19yZW5kZXIsIFRyYWRlc1BsdXNfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgVHJhZGVzUGx1c19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFRyYWRlc1BsdXNfVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVHJhZGVzUGx1c19yZW5kZXIsXG4gIFRyYWRlc1BsdXNfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBUcmFkZXNQbHVzX2FwaTsgfVxuVHJhZGVzUGx1c19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9UcmFkZXNQbHVzL1RyYWRlc1BsdXMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhZGVzUGx1cyA9IChUcmFkZXNQbHVzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvVldNQS9WV01BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBWV01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1ZXTUEnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1ZvbHVtZSBXZWlnaHRlZCBNb3ZpbmcgQXZlcmFnZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdWV01BICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjZGIwNjcwJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydWV01BJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMjAsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdndtYShjbG9zZSwgbGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1ZXTUEvVldNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBWV01BX1ZXTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVldNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1ZXTUEvVldNQS52dWVcbnZhciBWV01BX3JlbmRlciwgVldNQV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBWV01BX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgVldNQV9WV01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBWV01BX3JlbmRlcixcbiAgVldNQV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFZXTUFfYXBpOyB9XG5WV01BX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1ZXTUEvVldNQS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBWV01BID0gKFZXTUFfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9XaWxsaWFtc1IvV2lsbGlhbXNSLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBXaWxsaWFtc1J2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnV2lsbGlhbXNSJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdXaWxsaWFtcyAlUicsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICclUiAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyMwOTgwZTgnLFxuICAgICAgICAgICAgYmFuZENvbG9yOiAnI2FhYScsXG4gICAgICAgICAgICBiYWNrQ29sb3I6ICcjOWI5YmEzMTYnLFxuICAgICAgICAgICAgdXBwZXI6IC0yMCxcbiAgICAgICAgICAgIGxvd2VyOiAtODBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnV2lsbGlhbXNSJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTQsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnUmFuZ2UnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cHIobGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1dpbGxpYW1zUi9XaWxsaWFtc1IudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgV2lsbGlhbXNSX1dpbGxpYW1zUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChXaWxsaWFtc1J2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9XaWxsaWFtc1IvV2lsbGlhbXNSLnZ1ZVxudmFyIFdpbGxpYW1zUl9yZW5kZXIsIFdpbGxpYW1zUl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBXaWxsaWFtc1JfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBXaWxsaWFtc1JfV2lsbGlhbXNSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBXaWxsaWFtc1JfcmVuZGVyLFxuICBXaWxsaWFtc1Jfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBXaWxsaWFtc1JfYXBpOyB9XG5XaWxsaWFtc1JfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvV2lsbGlhbXNSL1dpbGxpYW1zUi52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBXaWxsaWFtc1IgPSAoV2lsbGlhbXNSX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzXG5mdW5jdGlvbiBhcnJheUxpa2VUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzXG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qc1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanNcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanNcblxuXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanNcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9YT2hsY0JhcnMvcHJpbWl0aXZlcy94b2hsY2Jhci5qc1xuXG5cblxuLy8gT2hsYyBvYmplY3QgZm9yIE9obGNzIG92ZXJsYXlcbnZhciBYT2hsY0JhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhPaGxjQmFyKG92ZXJsYXksIGN0eCwgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYT2hsY0Jhcik7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLnNlbGYgPSBvdmVybGF5O1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnJhd1s2XSB8fCB0aGlzLnNlbGY7XG5cbiAgICB0aGlzLl9kcmF3KGRhdGEpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFhPaGxjQmFyLCBbe1xuICAgIGtleTogXCJfZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhdyhkYXRhKSB7XG4gICAgICB2YXIgbGluZV93aWR0aCA9IHRoaXMuc3R5bGUubGluZVdpZHRoO1xuICAgICAgdmFyIGhsY19vbmx5ID0gdGhpcy5zdHlsZS5jaGFydFR5cGUgPT0gXCJITENcIjtcbiAgICAgIHZhciBsaW5lX3dpZHRoX2hhbGYgPSBsaW5lX3dpZHRoIC8gMjsgLy8gQmFyIGNvbG9yXG5cbiAgICAgIHZhciBiYXJfY29sb3IgPSBkYXRhLmMgPD0gZGF0YS5vID8gdGhpcy5zdHlsZS51cEJhckNvbG9yIDogdGhpcy5zdHlsZS5kb3duQmFyQ29sb3I7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLm1heChkYXRhLncsIDEpO1xuICAgICAgdmFyIGhhbGZ3aWR0aCA9IE1hdGgubWF4KE1hdGguZmxvb3Iod2lkdGggKiAwLjUpLCAxKTtcbiAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmFicyhkYXRhLm8gLSBkYXRhLmMpO1xuICAgICAgdmFyIG1heF9oID0gZGF0YS5jID09PSBkYXRhLm8gPyAxIDogMjtcbiAgICAgIHZhciBzID0gbGluZV93aWR0aCAlIDIgPT09IDAgPyAwIDogMC41OyAvLyBEcmF3IHRoZSBsaW5lIGZyb20gbG93IHRvIGhpZ2ggYW5kIG9wZW4gYW5kIGNsb3NlIGFsc29cblxuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBiYXJfY29sb3I7XG4gICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSBsaW5lX3dpZHRoO1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7IC8vIERyYXcgaGlnaCB0byBsb3dcblxuICAgICAgdGhpcy5jdHgubW92ZVRvKE1hdGguZmxvb3IoZGF0YS54IC0gbGluZV93aWR0aF9oYWxmKSArIHMsIE1hdGguZmxvb3IoZGF0YS5oKSk7XG4gICAgICB0aGlzLmN0eC5saW5lVG8oTWF0aC5mbG9vcihkYXRhLnggLSBsaW5lX3dpZHRoX2hhbGYpICsgcywgTWF0aC5mbG9vcihkYXRhLmwpKTtcblxuICAgICAgaWYgKHdpZHRoID4gMSkge1xuICAgICAgICAvLyBEcmF3IG9wZW4gbm90Y2hcbiAgICAgICAgaWYgKGhsY19vbmx5KSB7XG4gICAgICAgICAgLy8gTm8gb3BlbiBwcmljZSBpbiBjb25zaWRlcmF0aW9uXG4gICAgICAgICAgLy8gRHJhdyBvcGVuIG5vdGNoIHdpdGggY2xvc2UgcHJpY2VcbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oTWF0aC5mbG9vcihkYXRhLnggLSBoYWxmd2lkdGggLSBsaW5lX3dpZHRoX2hhbGYgLSAxKSwgTWF0aC5mbG9vcihkYXRhLmMpIC0gcyk7XG4gICAgICAgICAgdGhpcy5jdHgubGluZVRvKE1hdGguZmxvb3IoZGF0YS54IC0gbGluZV93aWR0aF9oYWxmKSwgTWF0aC5mbG9vcihkYXRhLmMpIC0gcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRHJhdyBvcGVuIG5vdGNoIHdpdGggb3BlbiBwcmljZVxuICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhNYXRoLmZsb29yKGRhdGEueCAtIGhhbGZ3aWR0aCAtIGxpbmVfd2lkdGhfaGFsZiAtIDEpLCBNYXRoLmZsb29yKGRhdGEubykgLSBzKTtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oTWF0aC5mbG9vcihkYXRhLnggLSBsaW5lX3dpZHRoX2hhbGYpLCBNYXRoLmZsb29yKGRhdGEubykgLSBzKTtcbiAgICAgICAgfSAvLyBEcmF3IGNsb3NlIG5vdGNoXG5cblxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oTWF0aC5mbG9vcihkYXRhLnggLSBsaW5lX3dpZHRoX2hhbGYpLCBNYXRoLmZsb29yKGRhdGEuYykgLSBzKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKE1hdGguZmxvb3IoZGF0YS54ICsgaGFsZndpZHRoIC0gbGluZV93aWR0aF9oYWxmICsgMSksIE1hdGguZmxvb3IoZGF0YS5jKSAtIHMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWE9obGNCYXI7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1hPaGxjQmFycy9wcmltaXRpdmVzL3h2b2xiYXIuanNcblxuXG5cbnZhciBYVm9sYmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWFZvbGJhcihvdmVybGF5LCBjdHgsIGRhdGEsIGJhckRhdGEsIHRoaW5Wb2x1bWVCYXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWFZvbGJhcik7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLiRwID0gb3ZlcmxheS4kcHJvcHM7XG4gICAgdGhpcy5zZWxmID0gb3ZlcmxheTtcbiAgICB0aGlzLnN0eWxlID0gZGF0YS5yYXdbNl0gfHwgdGhpcy5zZWxmO1xuXG4gICAgdGhpcy5fZHJhdyhkYXRhLCBiYXJEYXRhLCB0aGluVm9sdW1lQmFyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYVm9sYmFyLCBbe1xuICAgIGtleTogXCJfZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhdyhkYXRhLCBiYXJEYXRhLCB0aGluVm9sdW1lQmFyKSB7XG4gICAgICBpZiAodGhpblZvbHVtZUJhcikge1xuICAgICAgICAvLyBUaGluIFZvbHVtZSBCYXJcbiAgICAgICAgdmFyIGJhcl9jb2xvciA9IGRhdGEuZ3JlZW4gPyB0aGlzLnN0eWxlLnVwVm9sQmFyQ29sb3IgOiB0aGlzLnN0eWxlLmRvd25Wb2xCYXJDb2xvcjtcbiAgICAgICAgdmFyIGxpbmVfd2lkdGggPSB0aGlzLnN0eWxlLnZvbEJhcldpZHRoO1xuICAgICAgICB2YXIgbGluZV93aWR0aF9oYWxmID0gbGluZV93aWR0aCAvIDI7XG4gICAgICAgIHZhciB5MCA9IHRoaXMuJHAubGF5b3V0LmhlaWdodDtcbiAgICAgICAgdmFyIHcgPSBkYXRhLngyIC0gZGF0YS54MTtcbiAgICAgICAgdmFyIGggPSBNYXRoLmZsb29yKGRhdGEuaCk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gYmFyX2NvbG9yO1xuICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSBsaW5lX3dpZHRoO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTsgLy8gRHJhdyBoaWdoIHRvIGxvd1xuXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhNYXRoLmZsb29yKGJhckRhdGEueCAtIGxpbmVfd2lkdGhfaGFsZiksIE1hdGguZmxvb3IoeTAgLSBoIC0gMC41KSk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyhNYXRoLmZsb29yKGJhckRhdGEueCAtIGxpbmVfd2lkdGhfaGFsZiksIE1hdGguZmxvb3IoeTAgKyAwLjUpKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGljayBWb2x1bWUgQmFyXG4gICAgICAgIHZhciBfeSA9IHRoaXMuJHAubGF5b3V0LmhlaWdodDtcblxuICAgICAgICB2YXIgX3cgPSBkYXRhLngyIC0gZGF0YS54MTtcblxuICAgICAgICB2YXIgX2ggPSBNYXRoLmZsb29yKGRhdGEuaCk7XG5cbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gZGF0YS5ncmVlbiA/IHRoaXMuc3R5bGUudXBWb2xCYXJDb2xvciA6IHRoaXMuc3R5bGUuZG93blZvbEJhckNvbG9yO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdChNYXRoLmZsb29yKGRhdGEueDEpLCBNYXRoLmZsb29yKF95IC0gX2ggLSAwLjUpLCBNYXRoLmZsb29yKF93KSwgTWF0aC5mbG9vcihfaCArIDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWFZvbGJhcjtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1hPaGxjQmFycy9YT2hsY0JhcnMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cbmZ1bmN0aW9uIFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIFJlbmVkcmVyIGZvciBvaGxjYmFyICsgdm9sdW1lIChvcHRpb25hbClcbi8vIEl0IGNhbiBiZSB1c2VkIGFzIHRoZSBtYWluIGNoYXJ0IG9yIGFuIGluZGljYXRvclxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnWE9obGNCYXJzJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdYJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMy4wJyxcbiAgICAgICAgZGVzYzogJ0JhciBDaGFydCdcbiAgICAgIH07XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkgey8vdGhpcy5wcmljZSA9IG5ldyBQcmljZSh0aGlzKSAvLyBUT0RPOlxuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJYT2hsY0Jhci5kcmF3KCkgY2FsbGVkLiB0aGlzLiRwcm9wcy5kYXRhLmxlbmd0aCA9IFwiICsgdGhpcy4kcHJvcHMuZGF0YS5sZW5ndGgpXG4gICAgICAvLyByZW5kZXIgYXMgbWFpbiBjaGFydDpcbiAgICAgIGlmICh0aGlzLiRwcm9wcy5zdWIgPT09IHRoaXMuJHByb3BzLmRhdGEpIHtcbiAgICAgICAgdmFyIGNudiA9IHtcbiAgICAgICAgICBvaGxjYmFyczogdGhpcy4kcHJvcHMubGF5b3V0LmNhbmRsZXMsXG4gICAgICAgICAgdm9sdW1lOiB0aGlzLiRwcm9wcy5sYXlvdXQudm9sdW1lXG4gICAgICAgIH07IC8vIEVsc2UsIGFzIG9mZmNoYXJ0IC8gb25jaGFydCBpbmRpY2F0b3I6XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbnYgPSAoMCxleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18ubGF5b3V0X2NudikodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNob3dfdm9sdW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY252LnZvbHVtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2b2x1bWVEYXRhID0gY252LnZvbHVtZVtpXTtcbiAgICAgICAgICB2YXIgX2JhckRhdGEgPSBjbnYub2hsY2JhcnNbaV07XG4gICAgICAgICAgbmV3IFhWb2xiYXIodGhpcywgY3R4LCB2b2x1bWVEYXRhLCBfYmFyRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvciA9IFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY252Lm9obGNiYXJzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYmFyRGF0YSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIG5ldyBYT2hsY0Jhcih0aGlzLCBjdHgsIGJhckRhdGEpO1xuICAgICAgICB9IC8vaWYgKHRoaXMucHJpY2VfbGluZSkgdGhpcy5wcmljZS5kcmF3KGN0eCkgIC8vIFRPRE86XG5cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydYT2hsY0JhcnMnXTtcbiAgICB9LFxuICAgIC8vIFdoZW4gYWRkZWQgYXMgb2ZmY2hhcnQgb3ZlcmxheVxuICAgIHlfcmFuZ2U6IGZ1bmN0aW9uIHlfcmFuZ2UoKSB7XG4gICAgICByZXR1cm4gW01hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLiRwcm9wcy5zdWIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4WzJdO1xuICAgICAgfSkpKSwgTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuJHByb3BzLnN1Yi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhbM107XG4gICAgICB9KSkpXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgc2hvd192b2x1bWU6IGZ1bmN0aW9uIHNob3dfdm9sdW1lKCkge1xuICAgICAgcmV0dXJuICdzaG93Vm9sdW1lJyBpbiB0aGlzLnNldHQgPyB0aGlzLnNldHQuc2hvd1ZvbHVtZSA6IHRydWU7XG4gICAgfSxcbiAgICBwcmljZV9saW5lOiBmdW5jdGlvbiBwcmljZV9saW5lKCkge1xuICAgICAgcmV0dXJuICdwcmljZUxpbmUnIGluIHRoaXMuc2V0dCA/IHRoaXMuc2V0dC5wcmljZUxpbmUgOiB0cnVlO1xuICAgIH0sXG4gICAgdXBWb2xCYXJDb2xvcjogZnVuY3Rpb24gdXBWb2xCYXJDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQudXBCYXJDb2xvciB8fCBcIiMyM2E3NzY1NVwiO1xuICAgIH0sXG4gICAgZG93blZvbEJhckNvbG9yOiBmdW5jdGlvbiBkb3duVm9sQmFyQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmRvd25CYXJDb2xvciB8fCBcIiNlNTQxNTA1NVwiO1xuICAgIH0sXG4gICAgdm9sQmFyV2lkdGg6IGZ1bmN0aW9uIHZvbEJhcldpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYXJXaWR0aCB8fCAyO1xuICAgIH0sXG4gICAgdXBCYXJDb2xvcjogZnVuY3Rpb24gdXBCYXJDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQudXBCYXJDb2xvciB8fCBcIiMyM2E3NzZcIjtcbiAgICB9LFxuICAgIGRvd25CYXJDb2xvcjogZnVuY3Rpb24gZG93bkJhckNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5kb3duQmFyQ29sb3IgfHwgXCIjZTU0MTUwXCI7XG4gICAgfSxcbiAgICBiYXJXaWR0aDogZnVuY3Rpb24gYmFyV2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhcldpZHRoIHx8IDE7XG4gICAgfSxcbiAgICBobGNPbmx5OiBmdW5jdGlvbiBobGNPbmx5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5obGNPbmx5IHx8IGZhbHNlO1xuICAgIH0sXG4gICAgbGluZVdpZHRoOiBmdW5jdGlvbiBsaW5lV2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAxO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJpY2U6IHt9XG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvWE9obGNCYXJzL1hPaGxjQmFycy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBYT2hsY0JhcnNfWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1hPaGxjQmFycy9YT2hsY0JhcnMudnVlXG52YXIgWE9obGNCYXJzX3JlbmRlciwgWE9obGNCYXJzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFhPaGxjQmFyc19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFhPaGxjQmFyc19YT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFhPaGxjQmFyc19yZW5kZXIsXG4gIFhPaGxjQmFyc19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFhPaGxjQmFyc19hcGk7IH1cblhPaGxjQmFyc19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9YT2hsY0JhcnMvWE9obGNCYXJzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFhPaGxjQmFycyA9IChYT2hsY0JhcnNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2luZGV4X3Byb2QuanNcbi8vIC0tLS0tLS0tIFByb2R1Y3Rpb24gb3ZlcmxheSBpbmRleCAtLS0tLS0tLS1cbi8vICAgICAgISBUSElTIEZJTEUgV0FTIEFVVE8tR0VORVJBVEVEICFcbi8vXG4vLyBEbyBub3QgY29tbWl0IHRoaXMgZmlsZSwgdGhlIGZpbmFsIGluZGV4IGlzXG4vLyBjb21waWxlZCBieSB0aGUgcmVwbyBvd25lciwgdXNlIGluZGV4X2Rldi5qcyB0b1xuLy8gZXhwZXJpbWVudDogJ25wbSBydW4gY29tcGlsZSdcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBQYWNrID0ge1xuICBBTE1BOiBBTE1BLFxuICBBVFI6IEFUUixcbiAgQVRScDogQVRScCxcbiAgQXJlYTUxOiBBcmVhNTEsXG4gIEJCOiBCQixcbiAgQkJXOiBCQlcsXG4gIENDSTogQ0NJLFxuICBDTU86IENNTyxcbiAgQ09HOiBDT0csXG4gIERIaXN0b2dyYW06IERIaXN0b2dyYW0sXG4gIERNSTogRE1JLFxuICBFTUE6IEVNQSxcbiAgSE1BOiBITUEsXG4gIEhpc3RvZ3JhbTogSGlzdG9ncmFtLFxuICBJY2hpOiBJY2hpLFxuICBJY2hpbW9rdTogSWNoaW1va3UsXG4gIEtDOiBLQyxcbiAgS0NXOiBLQ1csXG4gIExvbmdTaG9ydFRyYWRlczogTG9uZ1Nob3J0VHJhZGVzLFxuICBNQUNEOiBNQUNELFxuICBNRkk6IE1GSSxcbiAgTU9NOiBNT00sXG4gIE1hcmtlcnM6IE1hcmtlcnMsXG4gIFBsb3RDcm9zczogUGxvdENyb3NzLFxuICBST0M6IFJPQyxcbiAgUlNJOiBSU0ksXG4gIFJpYmJvbjogUmliYm9uLFxuICBTQVI6IFNBUixcbiAgU01BOiBTTUEsXG4gIFNXTUE6IFNXTUEsXG4gIFN0b2NoOiBTdG9jaCxcbiAgVFNJOiBUU0ksXG4gIFRyYWRlc1BsdXM6IFRyYWRlc1BsdXMsXG4gIFZXTUE6IFZXTUEsXG4gIFdpbGxpYW1zUjogV2lsbGlhbXNSLFxuICBYT2hsY0JhcnM6IFhPaGxjQmFyc1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlR2anNPdmVybGF5cyA9IFBhY2s7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgaW5kZXhfcHJvZCA9IChQYWNrKTtcblxufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vTWFpbk0udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTdlMTNkOGVhJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL01haW5NLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vTWFpbk0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL01haW5NLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnN2UxM2Q4ZWEnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnN2UxM2Q4ZWEnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnN2UxM2Q4ZWEnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL01haW5NLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03ZTEzZDhlYSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc3ZTEzZDhlYScsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL01haW5NLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vU3RkSW5wdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVlMWYxYzE3JlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vU3RkSW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnNWUxZjFjMTcnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnNWUxZjFjMTcnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnNWUxZjFjMTcnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZTFmMWMxNyZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc1ZTFmMWMxNycsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9XaW5kb3cudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTViMDMwYTIwJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1dpbmRvdy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1dpbmRvdy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vV2luZG93LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnNWIwMzBhMjAnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnNWIwMzBhMjAnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnNWIwMzBhMjAnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1dpbmRvdy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWIwMzBhMjAmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNWIwMzBhMjAnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1dpbmRvdy52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1NwbGl0dGVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xODlmY2NhZCZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1NwbGl0dGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xODlmY2NhZCZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMTg5ZmNjYWRcIixcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMTg5ZmNjYWQnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMTg5ZmNjYWQnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMTg5ZmNjYWQnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1NwbGl0dGVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xODlmY2NhZCZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCcxODlmY2NhZCcsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTUzNDA4YWM3JnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FkZFdpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0FkZFdpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vQWRkV2luLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTUzNDA4YWM3JnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI1MzQwOGFjN1wiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIkM6XFxcXHhhbXBwXFxcXGh0ZG9jc1xcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCc1MzQwOGFjNycpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc1MzQwOGFjNycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc1MzQwOGFjNycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQWRkV2luLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01MzQwOGFjNyZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc1MzQwOGFjNycsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vU2V0dGluZ3NXaW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVkMjIzYjBlJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vU2V0dGluZ3NXaW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTVkMjIzYjBlJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI1ZDIyM2IwZVwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIkM6XFxcXHhhbXBwXFxcXGh0ZG9jc1xcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCc1ZDIyM2IwZScpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc1ZDIyM2IwZScsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc1ZDIyM2IwZScsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vU2V0dGluZ3NXaW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVkMjIzYjBlJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzVkMjIzYjBlJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL01haW5NLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL01haW5NLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vV2luZG93LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1dpbmRvdy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FkZFdpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgIFwiZmxleC1zdGFydCBjb2wtMTAgY29sLXhsbC0xMCBjb2wteGwtMTAgY29sLWxnLTEwIGNvbC1tZC05IGNvbC1zbS0xMlwiLFxuICAgIH0sXG4gICAgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJ0dmpzLWhlYWRlclwiIH0gfSwgW1xuICAgICAgICBfdm0uX20oMCksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiYVwiLCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWUtMSBiYWRnZSBiZy1saWdodC1zZWNvbmRhcnlcIixcbiAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5jYW5kbGVzIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJiaSBiaS1iYXItY2hhcnRcIiB9KSxcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkLW1kLWlubGluZSBkLW5vbmVcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiICBDYW5kbGVzXCIpLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLFxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJhXCIsIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXNlY29uZGFyeVwiLFxuICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnNwbGluZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktZ3JhcGgtdXBcIiB9KSxcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkLW1kLWlubGluZSBkLW5vbmVcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiICBTcGxpbmVcIiksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfdm0uX20oMSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF92bS5fbSgyKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX3ZtLl9tKDMpLFxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgIFwiY29sbGFwc2UgY29sLWxnLTQgY29sLW1kLTUgY29sLXNtLTYgcG9zaXRpb24tYWJzb2x1dGUgc3RpY2t5LXRvcCBjYXJkLTExMCBcIixcbiAgICAgICAgICBhdHRyczogeyBpZDogXCJjb2xsYXBzZUluZm9zXCIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiY2FyZFwiLFxuICAgICAgICAgICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiIzEzMTcyMmU2IWltcG9ydGFudFwiLFxuICAgICAgICAgICAgICAgIFwiYm94LXNoYWRvd1wiOiBcIjAgNHB4IDI0cHggMCByZ2IoMCAwIDAgLyAzMCUpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNhcmQtaGVhZGVyXCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29sLW1kLThcIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfYyhcImg0XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC10aXRsZVwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS5zeW1ib2wpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfdm0uX20oNCksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uX20oNSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9tKDYpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImFwcC1jb250YWluZXJcIiwgc3RhdGljU3R5bGU6IHsgXCJtYXJnaW4tdG9wXCI6IFwiNDBweFwiIH0gfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwidHJhZGluZy12dWVcIiwge1xuICAgICAgICAgICAga2V5OiBfdm0ucmVzZXRrZXksXG4gICAgICAgICAgICByZWY6IFwidHZqc1wiLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgZGF0YTogX3ZtLmRjLFxuICAgICAgICAgICAgICB3aWR0aDogX3ZtLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IF92bS5oZWlnaHQsXG4gICAgICAgICAgICAgIFwidGl0bGUtdHh0XCI6IF92bS50aXRsZSxcbiAgICAgICAgICAgICAgXCJjb2xvci10aXRsZVwiOiBcIiNmZjlmNDNcIixcbiAgICAgICAgICAgICAgXCJsZWdlbmQtYnV0dG9uc1wiOiBbXG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCIsXG4gICAgICAgICAgICAgICAgXCJzZXR0aW5nc1wiLFxuICAgICAgICAgICAgICAgIFwidXBcIixcbiAgICAgICAgICAgICAgICBcImRvd25cIixcbiAgICAgICAgICAgICAgICBcImFkZFwiLFxuICAgICAgICAgICAgICAgIFwicmVtb3ZlXCIsXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFwiY2hhcnQtY29uZmlnXCI6IHsgREVGQVVMVF9MRU46IDMwLCBNSU5fWk9PTTogMSB9LFxuICAgICAgICAgICAgICBcImNvbG9yLWJhY2tcIjogX3ZtLmNvbG9ycy5jb2xvckJhY2ssXG4gICAgICAgICAgICAgIFwiY29sb3ItZ3JpZFwiOiBfdm0uY29sb3JzLmNvbG9yR3JpZCxcbiAgICAgICAgICAgICAgXCJjb2xvci10ZXh0XCI6IF92bS5jb2xvcnMuY29sb3JUZXh0LFxuICAgICAgICAgICAgICBleHRlbnNpb25zOiBfdm0uZXh0LFxuICAgICAgICAgICAgICBvdmVybGF5czogX3ZtLm92cyxcbiAgICAgICAgICAgICAgbmlnaHQ6IF92bS5uaWdodCxcbiAgICAgICAgICAgICAgcmVzZXRrZXk6IF92bS5yZXNldGtleSxcbiAgICAgICAgICAgICAgXCJ4LXNldHRpbmdzXCI6IF92bS54c2V0dCxcbiAgICAgICAgICAgICAgdGltZXpvbmU6IF92bS50aW1lem9uZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgXVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJhXCIsIFtcbiAgICAgIF9jKFxuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1wiLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBpZDogXCJ0b2dnbGVDb250cmFjdHNcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10b2dnbGVcIjogXCJjb2xsYXBzZVwiLFxuICAgICAgICAgICAgXCJkYXRhLWJzLXRhcmdldFwiOiBcIiNjb2xsYXBzZUNvbnRyYWN0c1wiLFxuICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBcImNvbGxhcHNlQ29udHJhY3RzXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImJpIGJpLWJyaWVmY2FzZVwiIH0pLFxuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZC1tZC1pbmxpbmUgZC1ub25lXCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFwiIENvbnRyYWN0c1wiKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJhXCIsIFtcbiAgICAgIF9jKFxuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1wiLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBpZDogXCJ0b2dnbGVJbmZvXCIsXG4gICAgICAgICAgICBcImRhdGEtYnMtdG9nZ2xlXCI6IFwiY29sbGFwc2VcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10YXJnZXRcIjogXCIjY29sbGFwc2VJbmZvc1wiLFxuICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBcImNvbGxhcHNlSW5mb3NcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktaW5mby1jaXJjbGVcIiB9KSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtbWQtaW5saW5lIGQtbm9uZVwiIH0sIFtfdm0uX3YoXCIgIEluZm9cIildKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJhXCIsIFtcbiAgICAgIF9jKFxuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtcHJpbWFyeSBcIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaWQ6IFwidG9nZ2xlRGVwdGhcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10b2dnbGVcIjogXCJjb2xsYXBzZVwiLFxuICAgICAgICAgICAgXCJkYXRhLWJzLXRhcmdldFwiOiBcIiNjb2xsYXBzZURlcHRoXCIsXG4gICAgICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuICAgICAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IFwiY29sbGFwc2VEZXB0aFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJiaSBiaS1rYW5iYW5cIiB9KSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtbWQtaW5saW5lIGQtbm9uZVwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIiAgRGVwdGggVmlld1wiKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJhXCIsIFtcbiAgICAgIF9jKFxuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtd2FybmluZyBcIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaWQ6IFwidG9nZ2xlT3JkZXJzXCIsXG4gICAgICAgICAgICBcImRhdGEtYnMtdG9nZ2xlXCI6IFwiY29sbGFwc2VcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10YXJnZXRcIjogXCIjY29sbGFwc2VPcmRlcnNcIixcbiAgICAgICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBcImFyaWEtY29udHJvbHNcIjogXCJjb2xsYXBzZU9yZGVyc1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJiaSBiaS1maWxlLWJhci1ncmFwaFwiIH0pLFxuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZC1tZC1pbmxpbmUgZC1ub25lXCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFwiICBPcmRlciBCb29rXCIpLFxuICAgICAgICAgIF0pLFxuICAgICAgICBdXG4gICAgICApLFxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNhcmQtY29udGVudFwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC1ib2R5XCIgfSwgW1xuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInJvd1wiIH0sIFtcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbC04XCIgfSwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1zdGFydCBmcy0xXCIsIGF0dHJzOiB7IGlkOiBcInNob3dfYlwiIH0gfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wtNFwiIH0sIFtcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcImZvbnQtc2l6ZVwiOiBcIjE0cHhcIiB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfcFwiIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRleHQtZW5kXCIsXG4gICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgXCJmb250LXNpemVcIjogXCIxNHB4XCIgfSxcbiAgICAgICAgICAgICAgICBhdHRyczogeyBpZDogXCJzaG93X1BcIiB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInJvdyBtdC0xXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwicHJvZ3Jlc3NcIiwgYXR0cnM6IHsgaWQ6IFwibXlSYW5nZUNvbG9yXCIgfSB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICBcInByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItc3RyaXBlZCBwcm9ncmVzcy1iYXItYW5pbWF0ZWRcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyB3aWR0aDogXCI4MCVcIiB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICBpZDogXCJteVJhbmdlXCIsXG4gICAgICAgICAgICAgICAgICByb2xlOiBcInByb2dyZXNzYmFyXCIsXG4gICAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogXCI1MFwiLFxuICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbWluXCI6IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IFwiMTAwXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKSxcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgIFwicm93IGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXJcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiY29sIHRleHQtc3RhcnQgdGV4dC1kYW5nZXJcIixcbiAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgXCJmb250LXNpemVcIjogXCIxMHB4XCIgfSxcbiAgICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwic2hvd19sXCIgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiY29sIHRleHQtZGFyayB0ZXh0LWNlbnRlclwiLFxuICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IFwiZm9udC1zaXplXCI6IFwiMTBweFwiIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXkgUmFuZ2VcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJkaXZcIiwge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJjb2wgdGV4dC1lbmQgdGV4dC1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IFwiZm9udC1zaXplXCI6IFwiMTBweFwiIH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfaFwiIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicm93IG10LTFcIiB9LCBbXG4gICAgICAgICAgX2MoXCJzbWFsbFwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIlZvbHVtZSAyNEhcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfdlwiIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImhyXCIpLFxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJyb3dcIiB9LCBbXG4gICAgICAgICAgX2MoXCJzbWFsbFwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIk1hcmtldCBDYXBcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfbWNcIiB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJoclwiKSxcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicm93XCIgfSwgW1xuICAgICAgICAgIF9jKFwic21hbGxcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhcmsgY2xlYXJmaXhcIiB9LCBbXG4gICAgICAgICAgICBfdm0uX3YoXCJUb3RhbCBTdXBwbHlcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfdHNcIiB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJoclwiKSxcbiAgICAgICAgXSksXG4gICAgICBdKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICBcImNvbGxhcHNlIGNvbC1sZy02IGNvbC1tZC0xMCBjb2wtc20tMTIgY29sLTEyIHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTAgXCIsXG4gICAgICAgIGF0dHJzOiB7IGlkOiBcImNvbGxhcHNlRGVwdGhcIiB9LFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJjYXJkXCIsXG4gICAgICAgICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxMzE3MjJlNiFpbXBvcnRhbnRcIixcbiAgICAgICAgICAgICAgXCJib3gtc2hhZG93XCI6IFwiMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSlcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNhcmQtY29udGVudFwiIH0sIFtcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJjaGFydGRpdlwiIH0gfSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICBdXG4gICAgKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICBcImNvbGxhcHNlIGNvbC1sZy00IGNvbC1tZC00IGNvbC1zbS02IGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwXCIsXG4gICAgICAgIHN0YXRpY1N0eWxlOiB7IFwibWF4LXdpZHRoXCI6IFwiMjgwcHhcIiB9LFxuICAgICAgICBhdHRyczogeyBpZDogXCJjb2xsYXBzZU9yZGVyc1wiIH0sXG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNhcmRcIixcbiAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiIzEzMTcyMmU2IWltcG9ydGFudFwiLFxuICAgICAgICAgICAgICBcImJveC1zaGFkb3dcIjogXCIwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC1jb250ZW50IG15LTFcIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYm94XCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwidGFibGVcIiwgW1xuICAgICAgICAgICAgICAgICAgX2MoXCJ0aGVhZFwiLCBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwidHJcIiwgeyBzdGF0aWNDbGFzczogXCJtYi0xXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGhcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LXN0YXJ0IHBzLTEgdGV4dC1kYXJrXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByaWNlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGhcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LWNlbnRlciBwcy0xIHRleHQtZGFya1wiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFudGl0eVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInRoXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1lbmQgcGUtMSB0ZXh0LWRhcmtcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG90YWxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXCJ0YWJsZVwiLCB7IHN0YXRpY0NsYXNzOiBcImFza3NcIiB9KSxcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibmV3ZXN0XCIgfSksXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICBfYyhcInRhYmxlXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmlkc1wiIH0pLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgIF1cbiAgICAgICAgKSxcbiAgICAgIF1cbiAgICApXG4gIH0sXG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwic3BhblwiLCBbXG4gICAgX3ZtLnR5cGUgPT09IFwidGV4dFwiIHx8ICFfdm0udHlwZVxuICAgICAgPyBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXN0ZC1pbnB1dFwiLFxuICAgICAgICAgIHN0eWxlOiBfdm0uc3R5bGUsXG4gICAgICAgICAgYXR0cnM6IHsgcGxhY2Vob2xkZXI6IF92bS5uYW1lIH0sXG4gICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS52YWx1ZSB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF92bS4kZW1pdChcImNoYW5nZVwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdm0uJGVtaXQoXCJpbnB1dFwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgOiBfdm0udHlwZSA9PT0gXCJzZWxlY3RcIlxuICAgICAgPyBfYyhcbiAgICAgICAgICBcInNlbGVjdFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMtc3RkLWlucHV0XCIsXG4gICAgICAgICAgICBzdHlsZTogX3ZtLnN0eWxlLFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS52YWx1ZSB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLiRlbWl0KFwiaW5wdXRcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfdm0uX2woX3ZtLmxpc3QsIGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBfYyhcIm9wdGlvblwiLCBbX3ZtLl92KF92bS5fcyhvcHQpKV0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgMFxuICAgICAgICApXG4gICAgICA6IF92bS5fZSgpLFxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyByZWY6IFwid2luXCIsIHN0YXRpY0NsYXNzOiBcInR2anMteC13aW5kb3dcIiwgc3R5bGU6IF92bS5zdHlsZSB9LFxuICAgIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidHZqcy14LXdpbmRvdy1oZWFkXCIgfSwgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMteC13aW5kb3ctdGl0bGVcIixcbiAgICAgICAgICAgIG9uOiB7IG1vdXNlZG93bjogX3ZtLm9uTW91c2VEb3duIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgICAgIFwiICsgX3ZtLl9zKF92bS50aXRsZSkgKyBcIlxcbiAgICAgICAgICAgIFwiKV1cbiAgICAgICAgKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXgtd2luZG93LWNsb3NlXCIsXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdm0uJGVtaXQoXCJjbG9zZVwiKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtfdm0uX3YoXCJcXG4gICAgICAgICAgICAgICAg4pWzXFxuICAgICAgICAgICAgXCIpXVxuICAgICAgICApLFxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0dmpzLXgtd2luZG93LWJvZHlcIiB9LCBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sIDIpLFxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwic3BhblwiLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaC1zcGxpdHRlclwiLFxuICAgIHN0eWxlOiBfdm0uaHNfc3R5bGUsXG4gICAgb246IHsgbW91c2Vkb3duOiBfdm0uaHNfbW91c2Vkb3duIH0sXG4gIH0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJ3aW5kb3dcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJhZGQtd2luXCIsXG4gICAgICBhdHRyczogeyB0aXRsZTogXCJBZGQgSW5kaWNhdG9yXCIsIHR2OiBfdm0udHYgfSxcbiAgICAgIG9uOiB7IGNsb3NlOiBfdm0ub25fY2xvc2UgfSxcbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImFkZC13aW4tbGlzdFwiIH0sXG4gICAgICAgIF92bS5fbChfdm0ub3ZzLCBmdW5jdGlvbiAob3YpIHtcbiAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJhZGQtd2luLWl0ZW1cIixcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5vbl9jbGljayhvdi5uYW1lKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgW192bS5fdihfdm0uX3Mob3YubmFtZSkpXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImFkZC13aW4taXRlbS1kZXNjXCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKG92Lm1ldGhvZHMubWV0YV9pbmZvKCkuZGVzYykgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICB9KSxcbiAgICAgICAgMFxuICAgICAgKSxcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIndpbmRvd1wiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcInNldHQtd2luXCIsXG4gICAgICBhdHRyczogeyB0aXRsZTogX3ZtLmRhdGEub3YubmFtZSwgdHY6IF92bS50diB9LFxuICAgICAgb246IHsgY2xvc2U6IF92bS5vbl9jbG9zZSB9LFxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLl9sKF92bS5zZXR0bGlzdCwgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJzZXR0LXdpbi1pdGVtXCIgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcImxhYmVsXCIsIFtfdm0uX3YoX3ZtLl9zKF92bS5zMmQoaykpKV0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwic3RkLWlucHV0XCIsIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHsgdmFsdWU6IF92bS5zZXR0W2tdIH0sXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0udXBkYXRlX3NldHQoaywgJGV2ZW50KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgIV92bS5zZXR0bGlzdC5sZW5ndGhcbiAgICAgICAgPyBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJzZXR0LXdpbi1lbXB0eVwiIH0sIFtcbiAgICAgICAgICAgIF9jKFwiaVwiLCBbX3ZtLl92KFwiTm8gc2NyaXB0IHNldHRpbmdzXCIpXSksXG4gICAgICAgICAgXSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjE0XG4gKiAoYykgMjAxNC0yMDIxIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIChcbiAgICBpc0RlZih2YWwpICYmXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAqL1xudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xudmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG52YXIgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgIC8vIG9yZGVyXG4gICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmIChoYXNQcm90bykge1xuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICApIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHZhciByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qJFwiKSkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSwgdm0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhdmVFeHBlY3RlZFR5cGVzID0gZXhwZWN0ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9KTtcbiAgaWYgKCF2YWxpZCAmJiBoYXZlRXhwZWN0ZWRUeXBlcykge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sfEJpZ0ludCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUsIHZtKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybignSW52YWxpZCBwcm9wIHR5cGU6IFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBpcyBub3QgYSBjb25zdHJ1Y3RvcicsIHZtKTtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxudmFyIGZ1bmN0aW9uVHlwZUNoZWNrUkUgPSAvXlxccypmdW5jdGlvbiAoXFx3KykvO1xuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKGZ1bmN0aW9uVHlwZUNoZWNrUkUpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gIGlmIChcbiAgICBleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgaXNFeHBsaWNhYmxlKHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKVxuICApIHtcbiAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyAoc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKSk7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIChzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpKSArIFwiLlwiO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIChcIlwiICsgKE51bWJlcih2YWx1ZSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxuICB9XG59XG5cbnZhciBFWFBMSUNBQkxFX1RZUEVTID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgcmV0dXJuIEVYUExJQ0FCTEVfVFlQRVMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICBpZiAodm0pIHtcbiAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIHZhciBjb3VudGVyID0gMTtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cyQxLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgdmFyIHNsb3RzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzLFxuICBwcmV2U2xvdHNcbikge1xuICB2YXIgcmVzO1xuICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICBpZiAoIXNsb3RzKSB7XG4gICAgcmVzID0ge307XG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgfSBlbHNlIGlmIChcbiAgICBpc1N0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBrZXkgPT09IHByZXZTbG90cy4ka2V5ICYmXG4gICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5JDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5JDFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5JDEsIHNsb3RzW2tleSQxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkkMiBpbiByZXMpKSB7XG4gICAgICByZXNba2V5JDJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMik7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICB2YXIgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgdmFyIHZub2RlID0gcmVzICYmIHJlc1swXTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgICF2bm9kZSB8fFxuICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgdm5vZGUuaXNDb21tZW50ICYmICFpc0FzeW5jUGxhY2Vob2xkZXIodm5vZGUpKSAvLyAjOTY1OCwgIzEwMzkxXG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrUmVuZGVyLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7XG4gICAgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2Fybignc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9XG4gICAgICBzY29wZWRTbG90Rm4ocHJvcHMpIHx8XG4gICAgICAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9XG4gICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxuICAgICAgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxuICByZXR1cm4gZXZlbnRLZXlDb2RlID09PSB1bmRlZmluZWRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXMsXG4gIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICBoYXNEeW5hbWljS2V5cyxcbiAgY29udGVudEhhc2hLZXlcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlY2lhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgdm5vZGUsXG4gIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRcbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICkge1xuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLm5hdGl2ZU9uKSAmJiBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJUaGUgLm5hdGl2ZSBtb2RpZmllciBmb3Igdi1vbiBpcyBvbmx5IHZhbGlkIG9uIGNvbXBvbmVudHMgYnV0IGl0IHdhcyB1c2VkIG9uIDxcIiArIHRhZyArIFwiPi5cIiksXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbnZhciBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdm0uJHNsb3RzLFxuICAgICAgICB2bS4kc2NvcGVkU2xvdHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVzZSBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yXG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICB2YXIgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKG93bmVyICYmICFpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcbiAgICB2YXIgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICB2YXIgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICB2YXIgdGltZXJUaW1lb3V0ID0gbnVsbFxuXG4gICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aW1lckxvYWRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJMb2FkaW5nKTtcbiAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lclRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHRpbWVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGV2ZW50LCBmbikge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldDtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZtLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdm0uJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBpbmZvID0gXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XG4gICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XG4gIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSkgfHxcbiAgICAoIW5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5KVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG52YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wXG4gICkge1xuICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgIC8vIHdlbGwuXG4gICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcodGhpcy5jYiwgdGhpcy52bSwgW3ZhbHVlLCBvbGRWYWx1ZV0sIHRoaXMudm0sIGluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIGlmICghaXNSb290KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgfVxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLm1ldGhvZHMgJiYga2V5IGluIHZtLiRvcHRpb25zLm1ldGhvZHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIG1ldGhvZC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHZhciBpbmZvID0gXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgIHB1c2hUYXJnZXQoKTtcbiAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNiLCB2bSwgW3dhdGNoZXIudmFsdWVdLCB2bSwgaW5mbyk7XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBlbnRyeSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB2YXIgbmFtZSA9IGVudHJ5Lm5hbWU7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgaWYgKGVudHJ5ICYmICghY3VycmVudCB8fCBlbnRyeS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGVudHJ5LmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBjYWNoZVZOb2RlOiBmdW5jdGlvbiBjYWNoZVZOb2RlKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZi5rZXlzO1xuICAgICAgdmFyIHZub2RlVG9DYWNoZSA9IHJlZi52bm9kZVRvQ2FjaGU7XG4gICAgICB2YXIga2V5VG9DYWNoZSA9IHJlZi5rZXlUb0NhY2hlO1xuICAgICAgaWYgKHZub2RlVG9DYWNoZSkge1xuICAgICAgICB2YXIgdGFnID0gdm5vZGVUb0NhY2hlLnRhZztcbiAgICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlVG9DYWNoZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBjYWNoZVtrZXlUb0NhY2hlXSA9IHtcbiAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpLFxuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlOiBjb21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgfTtcbiAgICAgICAga2V5cy5wdXNoKGtleVRvQ2FjaGUpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5jYWNoZVZOb2RlKCk7XG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxheSBzZXR0aW5nIHRoZSBjYWNoZSB1bnRpbCB1cGRhdGVcbiAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSB2bm9kZTtcbiAgICAgICAgdGhpcy5rZXlUb0NhY2hlID0ga2V5O1xuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gIFZ1ZS5vYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIG9ic2VydmUob2JqKTtcbiAgICByZXR1cm4gb2JqXG4gIH07XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjE0JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxudmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZSdcbiAgICA/ICdmYWxzZSdcbiAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICA6IGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiAndHJ1ZSdcbn07XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25vYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIsIHZub2RlLmRhdGEucHJlKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSwgaXNJblByZSkge1xuICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydtb3VzZXVwJzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG52YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxudmFyIHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICkge1xuICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0J1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XSs/XFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBuY25hbWUgPSBcIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSpcIjtcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKSxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOnxeIy87XG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvWyBcXGZcXHRcXHJcXG5dKy9nO1xuXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIShcbiAgICBlbC5jb21wb25lbnQgfHxcbiAgICBlbC5hdHRyc01hcFsnOmlzJ10gfHxcbiAgICBlbC5hdHRyc01hcFsndi1iaW5kOmlzJ10gfHxcbiAgICAhKGVsLmF0dHJzTWFwLmlzID8gaXNSZXNlcnZlZFRhZyhlbC5hdHRyc01hcC5pcykgOiBpc1Jlc2VydmVkVGFnKGVsLnRhZykpXG4gICk7IH07XG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAodGFnLCBzdGFydCwgZW5kJDEpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwiRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBcIiArXG4gICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLFxuICAgICAgICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKSxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCIsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4vLyBlLmcuIDx0ZW1wbGF0ZSBzbG90PVwieHh4XCI+LCA8ZGl2IHNsb3Qtc2NvcGU9XCJ4eHhcIj5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgdmFyIHNsb3RTY29wZTtcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgfVxuXG4gIC8vIHNsb3Q9XCJ4eHhcIlxuICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xuICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSxcIiArXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgIFwiKVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHRoaXMucHJlID0gZmFsc2U7XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICAvLyBmaXggIzExNDgzLCBSb290IGxldmVsIDxzY3JpcHQ+IHRhZ3Mgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cbiAgdmFyIGNvZGUgPSBhc3QgPyAoYXN0LnRhZyA9PT0gJ3NjcmlwdCcgPyAnbnVsbCcgOiBnZW5FbGVtZW50KGFzdCwgc3RhdGUpKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczpcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCIsXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgLy8gIzk0MzgsICM5NTA2XG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICBwYXJlbnQuZm9yXG4gICAgICApIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAuam9pbignLCcpO1xuXG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gaGFzaCA+Pj4gMFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBcIlwiXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixmdW5jdGlvbigpe3JldHVybiBcIiArIGNoaWxkcmVuICsgXCJ9XCIpIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgfSk7IH0pKVxuICAgIDogbnVsbDtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcIixcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IFwie1wiICsgKHN0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICB9XG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG5cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0LCB3YXJuKSB7XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2LXNsb3QnIHx8IG5hbWVbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgY2hlY2tGdW5jdGlvblBhcmFtZXRlckV4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgd2Fybik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB2YXIgc3RyaXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdHJpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdHJpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgd2FybixcbiAgcmFuZ2Vcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKGV4cCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgd2FybihcbiAgICAgIFwiaW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXIgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0LFxuICBlbmRcbikge1xuICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDA7XG4gIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIHsgY29udGludWUgfVxuICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIiBcIiwgcGFkKSArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCQxID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQkMSAoc3RyLCBuKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKG4gPiAwKSB7XG4gICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgIG4gPj4+PSAxO1xuICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICBzdHIgKz0gc3RyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuXG4gICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB2YXIgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0geyBtc2c6IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZSA9IHJlZiQxLmNvbXBpbGU7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBBcHAgZnJvbSAnLi9NYWluTS52dWUnXG5cbm5ldyBWdWUoe1xuICAgIGVsOiAnI2FwcE0nLFxuICAgIHJlbmRlcjogaCA9PiBoKEFwcClcbn0pXG4iXSwibmFtZXMiOlsiTWFpbiIsIl9fbmFtZV9fIiwid2lkZ2V0cyIsImNvbXBvbmVudHMiLCJvdmVybGF5cyIsImNvbG9ycGFja3MiLCJza2lucyIsIlBhY2siLCJTZXR0aW5nc1dpbiIsIm1ldGhvZHMiLCJvbk1vdXNlRG93biIsImUiLCJ3aW5kb3ciLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiZHJhZyIsIm9mZnNldF94IiwiY2xpZW50WCIsIngiLCJvZmZzZXRfeSIsImNsaWVudFkiLCJ5IiwiZG9jdW1lbnQiLCJvbm1vdXNldXAiLCJzdG9wZHJhZyIsIm9ubW91c2Vtb3ZlIiwib25kcmFnIiwiZGF0YSIsIlNoYXJlZCIsIlV0aWxzIiwidHYiLCJkYyIsInNldHQiLCJ1c2Vfd2luZG93IiwieGNoYXJ0bGluayQiLCJzaGFyZWQiLCJ0YXJnZXRzIiwib25zZXR0aW5ncyIsImFsbCIsImNsZWFyVGltZW91dCIsInJlc2V0X2lkIiwicnVsZXMiLCJyZWZzIiwibWV0YSIsImVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJpZCIsImNvbWJpbmUiLCJzZXRUaW1lb3V0IiwicmVzZXQiLCJjb21iaW5lZCIsInIiLCJnZWJjbiIsImVscyIsInJhbmsiLCJkc3QiLCJwYWlyIiwiT2JqZWN0Iiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsImQiLCJhc3NpZ24iLCJvdXQiLCJzcGxpdHIiLCJtYXRjaGVzIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsInNyYyIsImluY2x1ZGVzIiwicnVsZSIsInRyaW0iLCJzcGxpdCIsIm1hcCIsInR1cCIsImxlbmd0aCIsImNvbXBpbGUiLCIkcmVmcyIsImNoYXJ0IiwiaG9va3MiLCIkd2F0Y2giLCJnZXQiLCJmaWx0ZXIiLCJzZXR0aW5ncyIsIiRzdGF0ZSIsIm9udG9vbHMiLCJiaW5kIiwiY3Vyc29yIiwiYXJncyIsIm1haW4iLCJfbGF5b3V0IiwiZ3JpZHMiLCJncmlkX2lkIiwibWMiLCJ0IiwiJCIsInkkIiwiZyIsInh4IiwiaXNYIiwieXkiLCJpc1kiLCJ1cGQiLCJ0MnNjcmVlbiIsIiQyc2NyZWVuIiwiY3Vyc29yX2NoYW5nZWQiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInBvc2l0aW9uIiwibG9jayIsInJhbmdlIiwibiIsInAiLCJyZW0iLCJyZW1vdmVkIiwiJHV1aWQiLCJ0b29scyIsImNvcHlfdG9vbHMiLCJmb3JFYWNoIiwiZGVsIiwidG9vbCIsInV1aWQiLCJleGkiLCJnZXRfb25lIiwiJHNldCIsImNvcHkiLCIkc2VsZWN0ZWQiLCJvdnMiLCJzZWMiLCJncmlkIiwiJGNoaWxkcmVuIiwib3YiLCJwaW5zIiwicmVfaW5pdCIsImFkZCIsIl9faWRfXyIsIk1hdGgiLCJyYW5kb20iLCJvYmoiLCJtb2QiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJpZHMiLCJwcmV2IiwibGlzdCIsIlZ1ZSIsIlNwbGl0dGVyIiwiJGVsIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ubW91c2VsZWF2ZSIsInBsYWNlX3NwbGl0dGVycyIsImNhbGNfaGVpZ2h0cyIsIm9uZ3JpZHMiLCJyZW1vdmVfd2lkZ2V0cyIsInMiLCJoc19tb3VzZW1vdmUiLCJoc19tb3VzZXVwIiwiaHNfbW91c2VsZWF2ZSIsImkiLCJnMSIsImcyIiwidXVpZDIiLCJzZXQiLCJjbHMiLCJncmlkMSIsImdyaWQyIiwiaHMiLCJoZWlnaHQiLCJzdW0iLCJyZWR1Y2UiLCJoIiwiZ3JpZF9vdnMiLCJvZmZjaGFydCIsInVuZGVmaW5lZCIsIiRkZWxldGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibW91c2V1cCIsIm1vdXNlbGVhdmUiLCJhZGRfc3R5bGUiLCJzdHlsZSIsInN0YnIiLCJzaGVldFBhcmVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInNoZWV0IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImlubmVySFRNTCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInJlbV9zdHlsZSIsIkFkZFdpbiIsIm9uYnV0dG9uIiwidHlwZSIsImRhdGFJbmRleCIsIm9uY2hhcnQiLCJidXR0b24iLCJkaXNwbGF5IiwiZmxhZyIsInNwbGljZSIsImkwIiwiaTEiLCJ1cGRhdGVfaWRzIiwiYXZnX2dyaWRfaCIsInVuc2hpZnQiLCJmIiwidmFsdWVzIiwiZmluZCIsImluZGV4IiwiY29uc29sZSIsImxvZyIsInByZXNldCIsImdldF9wcmVzZXQiLCJzaWRlIiwibmFtZSIsInByb3RvIiwibWV0YV9pbmZvIiwiZ2giLCJzZXR0MmRlc2MiLCJzZXRDaGFyQXQiLCJzdHIiLCJjaHIiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwidHVwbGUiLCJ0b1VwcGVyQ2FzZSIsImpvaW4iLCJDaGFydExpbmsiLCJHcmlkUmVzaXplIiwiTGVnZW5kQnV0dG9ucyIsIlN0cmVhbSIsInVybCIsIndzIiwiV2ViU29ja2V0IiwiY2IiLCJvbm9wZW4iLCJvbm1lc3NhZ2UiLCJvbnRyYWRlcyIsInZhbCIsIm9mZiIsImNsb3NlIiwiU0VDT05EIiwiTUlOVVRFIiwiTUlOVVRFMyIsIk1JTlVURTUiLCJNSU5VVEUxNSIsIk1JTlVURTMwIiwiSE9VUiIsIkhPVVI0IiwiSE9VUjEyIiwiREFZIiwiV0VFSyIsIk1PTlRIIiwiWUVBUiIsIk1PTlRITUFQIiwiVElNRVNDQUxFUyIsIiRTQ0FMRVMiLCJDaGFydENvbmZpZyIsIlNCTUlOIiwiU0JNQVgiLCJJbmZpbml0eSIsIlRPT0xCQVIiLCJUQl9JQ09OIiwiVEJfSVRFTV9NIiwiVEJfSUNPTl9CUkkiLCJUQl9JQ09OX0hPTEQiLCJUQl9CT1JERVIiLCJUQl9CX1NUWUxFIiwiVE9PTF9DT0xMIiwiRVhQQU5EIiwiQ0FORExFVyIsIkdSSURYIiwiR1JJRFkiLCJCT1RCQVIiLCJQQU5IRUlHSFQiLCJERUZBVUxUX0xFTiIsIk1JTklNVU1fTEVOIiwiTUlOX1pPT00iLCJNQVhfWk9PTSIsIlZPTFNDQUxFIiwiVVhfT1BBQ0lUWSIsIlpPT01fTU9ERSIsIkxfQlROX1NJWkUiLCJMX0JUTl9NQVJHSU4iLCJTQ1JPTExfV0hFRUwiLCJGT05UIiwiSUJfVEZfV0FSTiIsIk1BUF9VTklUIiwibWFwX3VuaXQiLCJJbmRleGVkQXJyYXkiLCJDb25zdCIsIm5hbWUyTmFtZSIsImNsYW1wIiwibnVtIiwibWluIiwibWF4IiwiYWRkX3plcm8iLCJkYXlfc3RhcnQiLCJzdGFydCIsInNldFVUQ0hvdXJzIiwibW9udGhfc3RhcnQiLCJkYXRlIiwiVVRDIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInllYXJfc3RhcnQiLCJnZXRfeWVhciIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0X21vbnRoIiwiZ2V0VVRDTW9udGgiLCJuZWFyZXN0X2EiLCJhcnJheSIsImRpc3QiLCJ4aSIsImFicyIsInJvdW5kIiwiZGVjaW1hbHMiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInN0cmlwIiwibnVtYmVyIiwidG9QcmVjaXNpb24iLCJnZXRfZGF5IiwiZ2V0RGF0ZSIsIm92ZXJ3cml0ZSIsImFyciIsIm5ld19hcnIiLCJjb3B5X2xheW91dCIsIm5ld19vYmoiLCJrIiwibSIsImRldGVjdF9pbnRlcnZhbCIsIm9obGN2IiwibGVuIiwic2xpY2UiLCJnZXRfbnVtX2lkIiwicGFyc2VJbnQiLCJwb3AiLCJmYXN0X2ZpbHRlciIsInQxIiwidDIiLCJpYSIsInJlcyIsImdldFJhbmdlIiwidmFscG9zIiwibmV4dCIsImZhc3RfZmlsdGVyX2kiLCJmbG9vciIsImkyIiwiZmFzdF9uZWFyZXN0IiwiZmV0Y2giLCJuZXh0bG93IiwibmV4dGhpZ2giLCJwYXVzZSIsImRlbGF5IiwiUHJvbWlzZSIsInJzIiwicmoiLCJzbWFydF93aGVlbCIsImRlbHRhIiwic2lnbiIsImdldF9kZWx0YVgiLCJvcmlnaW5hbEV2ZW50IiwiZGVsdGFYIiwiZ2V0X2RlbHRhWSIsImRlbHRhWSIsImFwcGx5X29wYWNpdHkiLCJjIiwib3AiLCJ0b1N0cmluZyIsInBhcnNlX3RmIiwic210aCIsImluZGV4X3NoaWZ0Iiwic3ViIiwiZmlyc3QiLCJzZWNvbmQiLCJqIiwibWVhc3VyZVRleHQiLCJjdHgiLCJ0ZXh0IiwidHZfaWQiLCJtZWFzdXJlVGV4dE9yZyIsIndpZHRoIiwiZG9jIiwiYmFzZSIsInRvcCIsImZvbnQiLCJpbm5lclRleHQiLCJvZmZzZXRXaWR0aCIsInRlbXAiLCJ2Iiwid2FybiIsImlzX3Njcl9wcm9wc191cGQiLCJwcm9wcyIsIiRwcm9wcyIsInNvbWUiLCJkZWxheWVkX2V4ZWMiLCJzY3JpcHQiLCJleGVjSW50ZXJ2YWwiLCJkdCIsIiRsYXN0X2V4ZWMiLCJmb3JtYXRfbmFtZSIsInJlZyIsIlJlZ0V4cCIsInhtb2RlIiwiaXNfbW9iaWxlIiwiZGVmYXVsdF9wcmV2ZW50ZWQiLCJvcmlnaW5hbCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ3IiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiRG9jdW1lbnRUb3VjaCIsIkFwcCIsInJlbmRlciJdLCJzb3VyY2VSb290IjoiIn0=