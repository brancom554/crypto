/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/arrayslicer/lib/compare/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/arrayslicer/lib/compare/index.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * Utility compare functions
 */

module.exports = {

    /**
     * Compare two numbers.
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    numcmp: function (a, b) {
        return a - b;
    },

    /**
     * Compare two strings.
     *
     * @param {Number|String} a
     * @param {Number|String} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    strcmp: function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

};


/***/ }),

/***/ "./node_modules/arrayslicer/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/arrayslicer/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Indexed Array Binary Search module
 */

/**
 * Dependencies
 */
var util = __webpack_require__(/*! ./util */ "./node_modules/arrayslicer/lib/util.js"),
    cmp = __webpack_require__(/*! ./compare */ "./node_modules/arrayslicer/lib/compare/index.js"),
    bin = __webpack_require__(/*! ./search/binary */ "./node_modules/arrayslicer/lib/search/binary.js");

/**
 * Module interface definition
 */
module.exports = IndexedArray;

/**
 * Indexed Array constructor
 *
 * It loads the array data, defines the index field and the comparison function
 * to be used.
 *
 * @param {Array} data is an array of objects
 * @param {String} index is the object's property used to search the array
 */
function IndexedArray(data, index) {

    // is data sortable array or array-like object?
    if (!util.isSortableArrayLike(data))
        throw new Error("Invalid data");

    // is index a valid property?
    if (!index || data.length > 0 && !(index in data[0]))
        throw new Error("Invalid index");

    // data array
    this.data = data;

    // name of the index property
    this.index = index;

    // set index boundary values
    this.setBoundaries();

    // default comparison function
    this.compare = typeof this.minv === "number" ? cmp.numcmp : cmp.strcmp;

    // default search function
    this.search = bin.search;

    // cache of index values to array positions
    // each value stores an object as { found: true|false, index: array-index }
    this.valpos = {};

    // cursor and adjacent positions
    this.cursor = null;
    this.nextlow = null;
    this.nexthigh = null;
}

/**
 * Set the comparison function
 *
 * @param {Function} fn to compare index values that returnes 1, 0, -1
 */
IndexedArray.prototype.setCompare = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.compare = fn;
    return this;
};

/**
 * Set the search function
 *
 * @param {Function} fn to search index values in the array of objects
 */
IndexedArray.prototype.setSearch = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.search = fn;
    return this;
};

/**
 * Sort the data array by its index property
 */
IndexedArray.prototype.sort = function () {
    var self = this,
        index = this.index;

    // sort the array
    this.data.sort(function (a, b) {
        return self.compare(a[index], b[index]);
    });

    // recalculate boundary values
    this.setBoundaries();

    return this;
};

/**
 * Inspect and set the boundaries of the internal data array
 */
IndexedArray.prototype.setBoundaries = function () {
    var data = this.data,
        index = this.index;

    this.minv = data.length && data[0][index];
    this.maxv = data.length && data[data.length - 1][index];

    return this;
};

/**
 * Get the position of the object corresponding to the given index
 *
 * @param {Number|String} index is the id of the requested object
 * @returns {Number} the position of the object in the array
 */
IndexedArray.prototype.fetch = function (value) {
    // check data has objects
    if (this.data.length === 0) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = null;
        return this;
    }

    // check the request is within range
    if (this.compare(value, this.minv) === -1) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = 0;
        return this;
    }
    if (this.compare(value, this.maxv) === 1) {
        this.cursor = null;
        this.nextlow = this.data.length - 1;
        this.nexthigh = null;
        return this;
    }

    var valpos = this.valpos,
        pos = valpos[value];

    // if the request is memorized, just give it back
    if (pos) {
        if (pos.found) {
            this.cursor = pos.index;
            this.nextlow = null;
            this.nexthigh = null;
        } else {
            this.cursor = null;
            this.nextlow = pos.prev;
            this.nexthigh = pos.next;
        }
        return this;
    }

    // if not, do the search
    var result = this.search.call(this, value);
    this.cursor = result.index;
    this.nextlow = result.prev;
    this.nexthigh = result.next;
    return this;
};

/**
 * Get the object corresponding to the given index
 *
 * When no value is given, the function will default to the last fetched item.
 *
 * @param {Number|String} [optional] index is the id of the requested object
 * @returns {Object} the found object or null
 */
IndexedArray.prototype.get = function (value) {
    if (value)
        this.fetch(value);

    var pos = this.cursor;
    return pos !== null ? this.data[pos] : null;
};

/**
 * Get an slice of the data array
 *
 * Boundaries have to be in order.
 *
 * @param {Number|String} begin index is the id of the requested object
 * @param {Number|String} end index is the id of the requested object
 * @returns {Object} the slice of data array or []
 */
IndexedArray.prototype.getRange = function (begin, end) {
    // check if boundaries are in order
    if (this.compare(begin, end) === 1) {
        return [];
    }

    // fetch start and default to the next index above
    this.fetch(begin);
    var start = this.cursor || this.nexthigh;

    // fetch finish and default to the next index below
    this.fetch(end);
    var finish = this.cursor || this.nextlow;

    // if any boundary is not set, return no range
    if (start === null || finish === null) {
        return [];
    }

    // return range
    return this.data.slice(start, finish + 1);
};


/***/ }),

/***/ "./node_modules/arrayslicer/lib/search/binary.js":
/*!*******************************************************!*\
  !*** ./node_modules/arrayslicer/lib/search/binary.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * Binary search implementation
 */

/**
 * Main search recursive function
 */
function loop(data, min, max, index, valpos) {

    // set current position as the middle point between min and max
    var curr = (max + min) >>> 1;

    // compare current index value with the one we are looking for
    var diff = this.compare(data[curr][this.index], index);

    // found?
    if (!diff) {
        return valpos[index] = {
            "found": true,
            "index": curr,
            "prev": null,
            "next": null
        };
    }

    // no more positions available?
    if (min >= max) {
        return valpos[index] = {
            "found": false,
            "index": null,
            "prev": (diff < 0) ? max : max - 1,
            "next": (diff < 0) ? max + 1 : max
        };
    }

    // continue looking for index in one of the remaining array halves
    // current position can be skept as index is not there...
    if (diff > 0)
        return loop.call(this, data, min, curr - 1, index, valpos);
    else
        return loop.call(this, data, curr + 1, max, index, valpos);
}

/**
 * Search bootstrap
 * The function has to be executed in the context of the IndexedArray object
 */
function search(index) {
    var data = this.data;
    return loop.call(this, data, 0, data.length - 1, index, this.valpos);
}

/**
 * Export search function
 */
module.exports.search = search;


/***/ }),

/***/ "./node_modules/arrayslicer/lib/util.js":
/*!**********************************************!*\
  !*** ./node_modules/arrayslicer/lib/util.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Utils module
 */

/**
 * Check if an object is an array-like object
 *
 * @credit Javascript: The Definitive Guide, O'Reilly, 2011
 */
function isArrayLike(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        isFinite(o.length) &&                // o.length is a finite number
        o.length >= 0 &&                     // o.length is non-negative
        o.length === Math.floor(o.length) && // o.length is an integer
        o.length < 4294967296)               // o.length < 2^32
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for the existence of the sort function in the object
 */
function isSortable(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        typeof o.sort === "function")        // o.sort is a function
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for sortable-array-like objects
 */
module.exports.isSortableArrayLike = function (o) {
    return isArrayLike(o) && isSortable(o);
};


/***/ }),

/***/ "./build/chart-link/chart-link-dev.js":
/*!********************************************!*\
  !*** ./build/chart-link/chart-link-dev.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "widgets": () => (/* binding */ widgets),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/chart-link/main.js */ "./src/extensions/chart-link/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'chart-link';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/grid-resize/grid-resize-dev.js":
/*!**********************************************!*\
  !*** ./build/grid-resize/grid-resize-dev.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "widgets": () => (/* binding */ widgets),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/grid-resize/main.js */ "./src/extensions/grid-resize/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'grid-resize';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/legend-buttons/legend-buttons-dev.js":
/*!****************************************************!*\
  !*** ./build/legend-buttons/legend-buttons-dev.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "widgets": () => (/* binding */ widgets),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/legend-buttons/main.js */ "./src/extensions/legend-buttons/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'legend-buttons';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/settings-win/settings-win-dev.js":
/*!************************************************!*\
  !*** ./build/settings-win/settings-win-dev.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "widgets": () => (/* binding */ widgets),
/* harmony export */   "SettingsWin": () => (/* reexport safe */ _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/settings-win/SettingsWin.vue */ "./src/extensions/settings-win/SettingsWin.vue");
/* harmony import */ var _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/extensions/settings-win/main.js */ "./src/extensions/settings-win/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'


_src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"].__name__ = 'settings-win';
var widgets = {
  SettingsWin: _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  SettingsWin: _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=script&lang=js&":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var tvjs_overlays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tvjs-overlays */ "./node_modules/tvjs-overlays/dist/tvjs-overlays.js");
/* harmony import */ var tvjs_overlays__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(tvjs_overlays__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _resources_data_data_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/data/data.json */ "./resources/data/data.json");
/* harmony import */ var _stuff_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stuff/utils.js */ "./src/stuff/utils.js");
/* harmony import */ var _stuff_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stuff/constants.js */ "./src/stuff/constants.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./stream.js */ "./src/stream.js");
/* harmony import */ var _index_dev__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./index_dev */ "./src/index_dev.js");


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






 // Gettin' data through webpeck proxy

var symbolsm = window.location.pathname.toLowerCase().split('/')[3];
var symbolbg = window.location.pathname.toUpperCase().split('/')[3];
var pairsm = window.location.pathname.toLowerCase().split('/')[4];
var pairbg = window.location.pathname.toUpperCase().split('/')[4];
var URL = "https://binance-watch-wrapper.herokuapp.com/https://api.binance.com/api/v1/klines?symbol=";
var WSS = "wss://stream.binance.com:9443/ws/".concat(symbolsm).concat(pairsm, "@aggTrade");
var datas = "datasets.binance-".concat(symbolsm).concat(pairsm); //const PORT = location.port
//const URL = `http://localhost:${PORT}/api/v1/klines?symbol=`
//const WSS = `ws://localhost:${PORT}/ws/${symbolsm}@aggTrade`

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'App',
  components: {
    TradingVue: trading_vue_js__WEBPACK_IMPORTED_MODULE_1__.TradingVue
  },
  data: function data() {
    return {
      dc: new trading_vue_js__WEBPACK_IMPORTED_MODULE_1__.DataCube(_resources_data_data_json__WEBPACK_IMPORTED_MODULE_3__),
      title: symbolbg + pairbg,
      width: 0,
      height: 0,
      log_scale: true,
      symbol: symbolbg + pairbg,
      index_based: true,
      timezone: this.timezoned(),
      xsett: {
        'grid-resize': {
          min_height: 30
        }
      },
      ovs: Object.values((tvjs_overlays__WEBPACK_IMPORTED_MODULE_2___default())),
      ext: Object.values(_index_dev__WEBPACK_IMPORTED_MODULE_7__["default"]),
      night: true,
      top: 50,
      resetkey: 0
    };
  },
  computed: {
    colors: function colors() {
      return this.night ? {} : {
        colorBack: '#fff',
        colorGrid: '#eee',
        colorText: '#333'
      };
    }
  },
  mounted: function mounted() {
    var _this = this;

    window.addEventListener('resize', this.onResize);
    var q = this.win_query();
    if (q.nm === 'false') this.night = false;
    if (q.ov) this.current = q.ov;
    if (q.header === 'false') this.top = 0;
    this.onResize(), window.dc = this.dc;
    window.tv = this.$refs.tvjs; // Load the last data chunk & init DataCube:

    var now = _stuff_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"].now();
    this.load_chunk([now - _stuff_constants_js__WEBPACK_IMPORTED_MODULE_5__["default"].HOUR4, now]).then(function (data) {
      dc.data.chart.data = data['chart.data']; // Register onrange callback & And a stream of trades

      _this.dc.onrange(_this.load_chunk);

      _this.stream = new _stream_js__WEBPACK_IMPORTED_MODULE_6__["default"](WSS);
      _this.stream.ontrades = _this.on_trades;
      window.dc = _this.chart; // Debug

      window.tv = _this.$refs.tvjs; // Debug
    });
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('resize', this.onResize);
    if (this.stream) this.stream.off();
  },
  methods: {
    onResize: function onResize() {
      if (window.innerWidth > '992') {
        this.width = window.innerWidth - window.innerWidth * 0.21;
      } else if (window.innerWidth > '768' && window.innerWidth <= '992') {
        this.width = window.innerWidth - window.innerWidth * 0.26;
      } else {
        this.width = window.innerWidth - 15;
      }

      this.height = window.innerHeight * 0.80;
    },
    spline: function spline() {
      this.dc.data.chart.type = "Spline";
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    candles: function candles() {
      this.dc.data.chart.type = "Candles";
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    xbars: function xbars() {
      this.data.ovs = 'XOhlcBars';
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    trade: function trade() {
      this.dc.data.chart.type = "Spline";
    },
    win_query: function win_query() {
      var qs = function (a) {
        if (a == "") return {};
        var b = {};

        for (var i = 0; i < a.length; ++i) {
          var p = a[i].split('=', 2);
          if (p.length == 1) b[p[0]] = "";else b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
        }

        return b;
      }(window.location.search.substr(1).split('&'));

      return qs;
    },
    reset: function reset(state) {
      var sub = Object.keys(state).filter(function (x) {
        return state[x];
      });
      this.extensions = sub.map(function (x) {
        return _index_dev__WEBPACK_IMPORTED_MODULE_7__["default"][x];
      });
      this.resetkey++;
    },
    onselect: function onselect(id) {
      this.current = id;
    },
    timezoned: function timezoned() {
      var offset = new Date().getTimezoneOffset();
      var minutes = Math.abs(offset);
      var hours = Math.floor(minutes / 60);
      var prefix = offset < 0 ? "" : "-";
      return parseInt(prefix + hours);
    },
    // New data handler. Should return Promise, or
    // use callback: load_chunk(range, tf, callback)
    load_chunk: function load_chunk(range) {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {
        var _range, t1, t2, x, y, q, r;

        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _range = _slicedToArray(range, 2), t1 = _range[0], t2 = _range[1];
                x = symbolbg;
                y = pairbg;
                q = "".concat(x).concat(y, "&interval=1m&startTime=").concat(t1, "&endTime=").concat(t2);
                _context.next = 6;
                return fetch(URL + q).then(function (r) {
                  return r.json();
                });

              case 6:
                r = _context.sent;
                return _context.abrupt("return", _this2.format(_this2.parse_binance(r)));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    // Parse a specific exchange format
    parse_binance: function parse_binance(data) {
      if (!Array.isArray(data)) return [];
      return data.map(function (x) {
        for (var i = 0; i < x.length; i++) {
          x[i] = parseFloat(x[i]);
        }

        return x.slice(0, 6);
      });
    },
    format: function format(data) {
      return {
        'chart.data': data
      };
    },
    on_trades: function on_trades(trade) {
      this.dc.update({
        t: trade.T,
        // Exchange time (optional)
        price: parseFloat(trade.p),
        // Trade price
        volume: parseFloat(trade.q),
        // Trade amount
        datas: [// Update dataset
        trade.T, trade.m ? 0 : 1, // Sell or Buy
        parseFloat(trade.q), parseFloat(trade.p)] // ... other onchart/offchart updates

      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'StdInput',
  props: ['value', 'name', 'type', 'list', 'colors'],
  data: function data() {
    return {};
  },
  computed: {
    style: function style() {
      return {//background: this.$props.colors.back,
        //color: this.$props.colors.text
      };
    }
  },
  methods: {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dragg.js */ "./src/components/dragg.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'Window',
  mixins: [_dragg_js__WEBPACK_IMPORTED_MODULE_0__["default"]],
  props: ['title', 'tv'],
  data: function data() {
    return {
      ww: 0,
      wh: 0,
      x: 0,
      y: 0
    };
  },
  computed: {
    style: function style() {
      return {
        top: "".concat(this.y, "px"),
        left: "".concat(this.x, "px")
      };
    },
    tvw: function tvw() {
      return this.$props.tv.width;
    },
    tvh: function tvh() {
      return this.$props.tv.height;
    }
  },
  mounted: function mounted() {
    this.ww = this.$refs.win.clientWidth;
    this.wh = this.$refs.win.clientHeight;
    this.x = this.tvw * 0.5 - this.ww * 0.5;
    this.y = this.tvh * 0.5 - this.wh * 0.5;
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/grid-resize/utils.js");
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'Splitter',
  props: ['id', 'main', 'dc', 'tv', 'data'],
  computed: {
    hs_style: function hs_style() {
      return {
        drag: null,
        top: this.data.grid2.offset + 'px' //backgroundColor: this.colors.splitter

      };
    }
  },
  mounted: function mounted() {
    this.MIN_HEIGHT = this.data.sett.min_height || 20;
  },
  methods: {
    hs_mousedown: function hs_mousedown(e) {
      this.drag = {
        type: 'hs',
        y: e.clientY,
        h1: this.data.grid1.height,
        h2: this.data.grid2.height
      };
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].add_style('disable-user-select', "body * {\n                user-select: none;\n            }\n            .trading-vue-chart {\n                pointer-events: none;\n            }");
    },
    hs_mouseup: function hs_mouseup(e) {
      this.drag = null;
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].rem_style('disable-user-select');
    },
    hs_mousemove: function hs_mousemove(e) {
      if (this.drag) {
        var off = e.clientY - this.drag.y;
        var new_h1 = this.drag.h1 + off;
        var new_h2 = this.drag.h2 - off;

        if (new_h1 > this.MIN_HEIGHT && new_h2 > this.MIN_HEIGHT) {
          this.data.grid1.height = new_h1;
          this.data.grid2.height = new_h2;
        }

        this.main.calc_heights();
      }
    },
    hs_mouseleave: function hs_mouseleave(e) {
      this.drag = null;
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].rem_style('disable-user-select');
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/Window.vue */ "./src/components/Window.vue");
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'AddWin',
  components: {
    Window: _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  props: ['id', 'main', 'dc', 'tv', 'data'],
  data: function data() {
    return {
      ovs: this.tv.overlays.filter(function (x) {
        return x.methods.calc;
      })
    };
  },
  computed: {
    sett: function sett() {
      return this.$props.data.ov.settings;
    }
  },
  mounted: function mounted() {},
  methods: {
    on_close: function on_close() {
      this.$props.main.remove_widget(this.$props.id);
    },
    on_click: function on_click(name) {
      this.on_close();
      this.main.add_overlay({
        side: this.data.type,
        index: this.data.index,
        type: name
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js& ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/Window.vue */ "./src/components/Window.vue");
/* harmony import */ var _components_StdInput_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/StdInput.vue */ "./src/components/StdInput.vue");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/settings-win/utils.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'SettingsWin',
  components: {
    Window: _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
    StdInput: _components_StdInput_vue__WEBPACK_IMPORTED_MODULE_1__["default"]
  },
  props: ['id', 'main', 'dc', 'tv', 'data'],
  computed: {
    sett: function sett() {
      return this.$props.data.ov.settings;
    },
    settlist: function settlist() {
      var _this = this;

      return Object.keys(this.sett).filter(function (x) {
        return x[0] !== '$' && _this.sett.$props && _this.sett.$props.includes(x);
      });
    }
  },
  mounted: function mounted() {},
  methods: {
    s2d: function s2d(str) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].sett2desc(str);
    },
    on_close: function on_close() {
      this.$props.main.remove_widget(this.$props.id);
    },
    update_sett: function update_sett(k, val) {
      var dcid = this.$props.data.ov.id;
      var valN = parseFloat(val);
      if (valN !== valN) valN = val;
      this.$props.dc.merge("".concat(dcid, ".settings"), _defineProperty({}, k, valN));
    }
  }
});

/***/ }),

/***/ "./src/components/dragg.js":
/*!*********************************!*\
  !*** ./src/components/dragg.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  methods: {
    onMouseDown: function onMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      this.drag.offset_x = e.clientX - this.x;
      this.drag.offset_y = e.clientY - this.y;
      document.onmouseup = this.stopdrag;
      document.onmousemove = this.ondrag;
    },
    ondrag: function ondrag(e) {
      e = e || window.event;
      e.preventDefault();
      this.x = e.clientX - this.drag.offset_x;
      this.y = e.clientY - this.drag.offset_y;
    },
    stopdrag: function stopdrag() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  },
  data: function data() {
    return {
      drag: {
        offset_x: 0,
        offset_y: 0
      }
    };
  }
});

/***/ }),

/***/ "./src/extensions/chart-link/main.js":
/*!*******************************************!*\
  !*** ./src/extensions/chart-link/main.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ "./src/extensions/chart-link/shared.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/chart-link/utils.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* Example:

rules: {
    '* -> *': {},     // From each to each
    '*': {            // The same as ^
        cursor: true, // bool, 'X', 'Y', 'XY'
        position: 'X', // bool, 'X', 'Y', 'XY'
        tools: true
    },
    'trading-vue-1 -> trading-vue-2': {
        data: [
            'onchart.SMA',
            'RSI4H',
            {
                from: 'chart.data',
                to: 'datasets',
                obj: {
                    id: 'small-tf-data',
                    type: 'SourceData'
                }
            }
        ]
    },
    'none': {
        range: 'X', // bool, 'X', 'Y', 'XY'
    }
}
*/



var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    _classCallCheck(this, Main);

    if (sett.use_window) {
      if (!window.xchartlink$) {
        window.xchartlink$ = {};
      }

      this.shared = window.xchartlink$;
    } else {
      this.shared = _shared_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    }

    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
    this.targets = {};
    this.onsettings({
      'chart-link': sett
    });
  }

  _createClass(Main, [{
    key: "onsettings",
    value: function onsettings(all) {
      var _this = this;

      clearTimeout(this.reset_id);
      this.sett = all['chart-link'];

      if (!this.shared.rules) {
        this.shared.rules = {};
        this.shared.refs = {};
        this.shared.meta = {};
      }

      var el = document.getElementById(this.tv.id);

      if (this.sett.rules && el) {
        this.shared.rules[this.tv.id] = this.sett.rules;
      }

      this.shared.refs[this.tv.id] = this.tv;
      this.combine();
      this.reset_id = setTimeout(function () {
        return _this.reset();
      });
    } //  Combine rules from different instances

  }, {
    key: "combine",
    value: function combine() {
      this.shared.combined = {};

      for (var id in this.shared.rules) {
        for (var r in this.shared.rules[id]) {
          this.shared.combined[r] = this.shared.rules[id][r];
        }
      }
    } // Compile rules for this instance

  }, {
    key: "compile",
    value: function compile() {
      var gebcn = 'getElementsByClassName';

      var els = _toConsumableArray(document[gebcn]('trading-vue'));

      this.targets = {};

      var _iterator = _createForOfIteratorHelper(els),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var el = _step.value;
          if (el.id === this.tv.id) continue;
          this.targets[el.id] = {};
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var rules = this.rank(this.shared.combined);

      var _iterator2 = _createForOfIteratorHelper(rules),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var r = _step2.value;
          var dst = r.pair[1];

          if (dst === '*') {
            dst = Object.keys(this.targets);
          }

          if (Array.isArray(dst)) {
            var _iterator3 = _createForOfIteratorHelper(dst),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var d = _step3.value;
                if (!(d in this.targets)) continue;
                Object.assign(this.targets[d], r.r);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } else {
            if (!(dst in this.targets)) continue;
            Object.assign(this.targets[dst], r.r);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } // Select, rank & sort the rules

  }, {
    key: "rank",
    value: function rank(rules) {
      var out = [];

      for (var r in rules) {
        var pair = this.splitr(r);
        if (!this.matches(pair[0])) continue;

        if (pair[0] === '*') {
          var rank = 20;
        } else if (Array.isArray(pair[0])) {
          rank = 10;
        } else {
          rank = 0;
        }

        if (pair[1] === '*') {
          rank += 2;
        } else if (Array.isArray(pair[1])) {
          rank += 1;
        } else {
          rank += 0;
        }

        out.push({
          pair: pair,
          rank: rank,
          r: rules[r]
        });
      }

      return out.sort(function (a, b) {
        return b.rank - a.rank;
      });
    } // Check if the source of a rule matches tv.id

  }, {
    key: "matches",
    value: function matches(src) {
      return src === '*' || src === this.tv.id || Array.isArray(src) && src.includes(this.tv.id);
    }
  }, {
    key: "splitr",
    value: function splitr(rule) {
      if (rule.trim() === '*') return ['*', '*'];
      return rule.split('->').map(function (x) {
        var tup = x.split(',');

        if (tup.length > 1) {
          return tup.map(function (y) {
            return y.trim();
          });
        }

        return x.trim();
      });
    } // Apply all rules for this instance

  }, {
    key: "reset",
    value: function reset() {
      var _this2 = this;

      this.compile(); // Enable some chart hook events

      this.tv.$refs.chart.hooks('xchanged');
      this.tv.$watch(function (x) {
        return _this2.dc.get('.').filter(function (x) {
          return x.settings.$state;
        });
      }, this.ontools.bind(this));
    } // Listening to the Chart.vue hooks &
    // other events

  }, {
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case '?x-changed':
          var cursor = e.args[0];
          if (cursor.preventDefault) return;
          var main = this.tv.$refs.chart._layout.grids[cursor.grid_id];
          var mc = this.tv.$refs.chart.cursor;
          cursor.t = mc.t;
          cursor.$ = mc.y$;

          for (var id in this.targets) {
            var r = this.targets[id].cursor;

            if (r) {
              var tv = this.shared.refs[id];
              var g = tv.$refs.chart._layout.grids[0];
              var xx = this.isX(r);
              var yy = g.id === main.id && this.isY(r);
              var upd = {
                preventDefault: true,
                x: xx ? g.t2screen(cursor.t) : -10,
                y: yy ? g.$2screen(cursor.$) : -10,
                grid_id: 0
              };
              tv.$refs.chart.cursor_changed(upd);
              tv.$refs.chart.cursor.t = xx ? cursor.t : -10;
              tv.$refs.chart.cursor.y$ = yy ? cursor.$ : -10;
            }
          }

          break;

        case 'range-changed':
          var now = new Date().getTime();
          var meta = this.shared.meta[this.tv.id];

          if (meta && meta.position) {
            if (meta.position.lock > now) return;
          }

          var range = e.args[0];

          for (var id in this.targets) {
            var _r = this.targets[id].position;
            var _tv = this.shared.refs[id];

            var _xx = this.isX(_r);

            var _yy = this.isY(_r);

            if (!this.shared.meta[id]) {
              this.shared.meta[id] = {};
            } // Prevents an infinite loop


            this.shared.meta[id].position = {
              lock: now + 100
            };
            if (_xx) _tv["goto"](range[1]);
          }

          break;
      }
    }
  }, {
    key: "ontools",
    value: function ontools(n, p) {
      var _this3 = this;

      var rem = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].removed(n.map(function (x) {
        return x.settings.$uuid;
      }), p.map(function (x) {
        return x.settings.$uuid;
      }));
      var now = new Date().getTime();
      var meta = this.shared.meta[this.tv.id];

      if (meta && meta.tools) {
        if (meta.tools.lock > now) return;
      }

      var _loop = function _loop() {
        var r = _this3.targets[id].tools;
        var tv = _this3.shared.refs[id];

        if (r) {
          if (!_this3.shared.meta[id]) {
            _this3.shared.meta[id] = {};
          } // Prevents an infinite loop


          _this3.shared.meta[id].tools = {
            lock: now + 100
          };

          _this3.copy_tools(n, tv);

          rem.forEach(function (r) {
            return tv.data.del("".concat(r));
          });
        }
      };

      for (var id in this.targets) {
        _loop();
      }
    }
  }, {
    key: "copy_tools",
    value: function copy_tools(n, tv) {
      var _iterator4 = _createForOfIteratorHelper(n),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var tool = _step4.value;
          if (tool.id.includes('offchart')) continue;
          var uuid = tool.settings.$uuid;
          var exi = tv.data.get_one("".concat(uuid));

          if (exi) {
            tv.$set(exi, 'settings', _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].copy(tool.settings, {
              $selected: false,
              $state: 'finished'
            })); // TODO: maybe add a proper method
            // of accessing overlays

            var ovs = tv.$refs.chart.$refs.sec[0].$refs.grid.$children.filter(function (x) {
              return x.tool;
            });

            var _iterator5 = _createForOfIteratorHelper(ovs),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var ov = _step5.value;
                ov.pins.forEach(function (x) {
                  return x.re_init();
                });
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          } else {
            var copy = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].copy(tool);
            copy.settings.$selected = false;
            copy.settings.$state = 'finished';
            tv.data.add('onchart', copy);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "isX",
    value: function isX(rule) {
      return rule === true || typeof rule === 'string' && rule.includes('X');
    }
  }, {
    key: "isY",
    value: function isY(rule) {
      return rule === true || typeof rule === 'string' && rule.includes('Y');
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/chart-link/shared.js":
/*!*********************************************!*\
  !*** ./src/extensions/chart-link/shared.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//  Object shared beetween tvjs instances
var Shared = /*#__PURE__*/_createClass(function Shared() {
  _classCallCheck(this, Shared);

  this.__id__ = Math.random();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Shared());

/***/ }),

/***/ "./src/extensions/chart-link/utils.js":
/*!********************************************!*\
  !*** ./src/extensions/chart-link/utils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  copy: function copy(obj, mod) {
    var copy = JSON.parse(JSON.stringify(obj));
    return Object.assign(copy, mod);
  },
  removed: function removed(ids, prev) {
    var list = [];

    var _iterator = _createForOfIteratorHelper(prev),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var id = _step.value;

        if (!ids.includes(id)) {
          list.push(id);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return list;
  }
});

/***/ }),

/***/ "./src/extensions/grid-resize/main.js":
/*!********************************************!*\
  !*** ./src/extensions/grid-resize/main.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _Splitter_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Splitter.vue */ "./src/extensions/grid-resize/Splitter.vue");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    var _this = this;

    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
    setTimeout(function () {
      _this.tv.$el.addEventListener('mousemove', _this.onmousemove.bind(_this));

      _this.tv.$el.addEventListener('mouseup', _this.onmouseup.bind(_this));

      _this.tv.$el.addEventListener('mouseleave', _this.onmouseleave.bind(_this));

      _this.place_splitters();

      _this.calc_heights(); // Track changes of grids count


      _this.tv.$watch(function (x) {
        return _this.dc.get('.').map(function (x) {
          return x.id;
        });
      }, _this.ongrids.bind(_this));
    });
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {}
    } // Extension settings has changed

  }, {
    key: "onsettings",
    value: function onsettings(sett) {}
  }, {
    key: "ongrids",
    value: function ongrids() {
      var _this2 = this;

      setTimeout(function () {
        _this2.remove_widgets();

        _this2.place_splitters();
      });
    }
  }, {
    key: "onmousemove",
    value: function onmousemove(e) {
      var _this3 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this3;
      });

      var _iterator = _createForOfIteratorHelper(list),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var s = _step.value;
          s.hs_mousemove(e);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "onmouseup",
    value: function onmouseup(e) {
      var _this4 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this4;
      });

      var _iterator2 = _createForOfIteratorHelper(list),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          s.hs_mouseup(e);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "onmouseleave",
    value: function onmouseleave(e) {
      var _this5 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this5;
      });

      var _iterator3 = _createForOfIteratorHelper(list),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var s = _step3.value;
          s.hs_mouseleave(e);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "place_splitters",
    value: function place_splitters() {
      var grids = this.tv.$refs.chart._layout.grids;

      for (var i = 1; i < grids.length; i++) {
        var g1 = grids[i - 1];
        var g2 = grids[i];
        var id = "Splitter-".concat(g1.id, "-").concat(g2.id, "-").concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
        vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(this.widgets, id, {
          id: id,
          cls: _Splitter_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
          data: {
            grid1: g1,
            grid2: g2,
            sett: this.sett
          }
        });
      }
    }
  }, {
    key: "calc_heights",
    value: function calc_heights() {
      var hs = [];

      var _iterator4 = _createForOfIteratorHelper(this.tv.$refs.chart._layout.grids),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var g = _step4.value;
          hs.push(g.height);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var sum = hs.reduce(function (a, b) {
        return a + b;
      }, 0);
      hs = hs.map(function (h) {
        return h / sum;
      });
      this.grid_ovs().forEach(function (ov, i) {
        if (!ov.grid) {
          vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(ov, 'grid', {});
        }

        vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(ov.grid, 'height', hs[i] || 1);
      });
    } // Grid defining overlays

  }, {
    key: "grid_ovs",
    value: function grid_ovs() {
      var list = [this.dc.data.chart];

      var _iterator5 = _createForOfIteratorHelper(this.dc.data.offchart),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ov = _step5.value;

          if (!ov.grid || ov.grid.id === undefined) {
            list.push(ov);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return list;
    }
  }, {
    key: "remove_widgets",
    value: function remove_widgets() {
      for (var id in this.widgets) {
        this.tv.$delete(this.widgets, id);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.tv.$el.removeEventListener('mousemove', this.onmousemove);
      this.tv.$el.removeEventListener('mouseup', this.mouseup);
      this.tv.$el.removeEventListener('mouseleave', this.mouseleave);
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/grid-resize/utils.js":
/*!*********************************************!*\
  !*** ./src/extensions/grid-resize/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  add_style: function add_style(id, style) {
    var stbr = document.getElementById(id);

    if (stbr) {
      var sheetParent = stbr.parentNode;
      sheetParent.removeChild(stbr);
    }

    var sheet = document.createElement('style');
    sheet.setAttribute("id", id);
    sheet.innerHTML = style;
    document.body.appendChild(sheet);
  },
  rem_style: function rem_style(id, style) {
    var stbr = document.getElementById(id);

    if (stbr) {
      var sheetParent = stbr.parentNode;
      sheetParent.removeChild(stbr);
    }
  }
});

/***/ }),

/***/ "./src/extensions/legend-buttons/main.js":
/*!***********************************************!*\
  !*** ./src/extensions/legend-buttons/main.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _AddWin_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddWin.vue */ "./src/extensions/legend-buttons/AddWin.vue");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case 'legend-button-click':
          this.onbutton(e.args[0]);
          break;
      }
    }
  }, {
    key: "onbutton",
    value: function onbutton(e) {
      var ov = this.dc.get(e.type)[e.dataIndex];
      var onchart = this.dc.data.onchart;
      var offchart = this.dc.data.offchart;
      if (!ov) return;

      switch (e.button) {
        case 'display':
          if (ov.settings.display === undefined) {
            var flag = false;
          } else {
            flag = !ov.settings.display;
          }

          this.tv.$set(ov.settings, 'display', flag);
          break;

        case 'up':
          if (e.type === 'offchart') {
            if (e.dataIndex === 0) {
              offchart.splice(e.dataIndex, 1);
              onchart.push(ov);
            } else {
              var data = offchart;
              var i0 = e.dataIndex;
              var i1 = e.dataIndex - 1;
              data[i0] = data.splice(i1, 1, data[i0])[0];
            }
          }

          this.dc.update_ids();
          break;

        case 'down':
          if (e.type === 'onchart') {
            var h = this.avg_grid_h(offchart);
            onchart.splice(e.dataIndex, 1);
            offchart.unshift(ov);
            this.tv.$set(ov, 'grid', {
              height: h
            });
          } else {
            var n = offchart.length;
            var _data = offchart;

            if (e.dataIndex < n - 1) {
              var _i = e.dataIndex;

              var _i2 = e.dataIndex + 1;

              _data[_i] = _data.splice(_i2, 1, _data[_i])[0];
            }
          }

          this.dc.update_ids();
          break;

        case 'add':
          try {
            var id = "AddWin-".concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
            var _ov = this.dc.data[e.type][e.dataIndex];
            var f = Object.values(this.widgets).find(function (x) {
              return x.data.ov === _ov;
            });

            if (f) {
              this.tv.$delete(this.widgets, f.id);
              break;
            }

            this.tv.$set(this.widgets, id, {
              id: id,
              cls: _AddWin_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
              data: {
                ov: _ov,
                type: e.type,
                index: e.dataIndex
              }
            });
          } catch (e) {
            console.log(e);
          }

          break;

        case 'remove':
          this.dc.data[e.type].splice(e.dataIndex, 1);
          this.dc.update_ids();
          break;
      }
    } // Called from AddWin.vue

  }, {
    key: "add_overlay",
    value: function add_overlay(e) {
      var preset = this.get_preset(e.type) || {};
      if (preset.side) e.side = preset.side;
      var onchart = this.dc.data.onchart;
      var offchart = this.dc.data.offchart;

      if (e.side === 'onchart') {
        onchart.splice(e.index + 1, 0, {
          name: preset.name,
          type: e.type,
          data: [],
          settings: preset.settings || {}
        });
      } else {
        var h = this.avg_grid_h(offchart);
        offchart.splice(e.index + 1, 0, {
          name: preset.name,
          type: e.type,
          data: [],
          settings: preset.settings || {},
          grid: {
            height: h
          }
        });
      }

      this.dc.update_ids();
    } // Get preset (default settings, colors) if defined

  }, {
    key: "get_preset",
    value: function get_preset(type) {
      var proto = this.tv.overlays.find(function (x) {
        return x.name === type;
      });

      if (proto && proto.methods.meta_info) {
        var meta = proto.methods.meta_info();
        return meta.preset;
      }
    } // Extension settings has changed

  }, {
    key: "onsettings",
    value: function onsettings(sett) {}
  }, {
    key: "avg_grid_h",
    value: function avg_grid_h(ovs) {
      if (!ovs.length) return 0.25;
      var gh = 0;

      var _iterator = _createForOfIteratorHelper(ovs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ov = _step.value;

          if (ov.grid && typeof ov.grid.height === 'number') {
            gh += ov.grid.height;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return gh / ovs.length;
    }
  }, {
    key: "remove_widget",
    value: function remove_widget(id) {
      this.tv.$delete(this.widgets, id);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/settings-win/main.js":
/*!*********************************************!*\
  !*** ./src/extensions/settings-win/main.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _SettingsWin_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingsWin.vue */ "./src/extensions/settings-win/SettingsWin.vue");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc) {
    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case 'legend-button-click':
          var id = "SettingsWin-".concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
          var args = e.args[0];
          if (args.button !== 'settings') break;

          try {
            var ov = this.dc.data[args.type][args.dataIndex];
            var f = Object.values(this.widgets).find(function (x) {
              return x.data.ov === ov;
            });

            if (f) {
              this.tv.$delete(this.widgets, f.id);
              break;
            }

            this.tv.$set(this.widgets, id, {
              id: id,
              cls: _SettingsWin_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
              data: {
                ov: ov
              }
            });
          } catch (e) {
            console.log(e);
          }

          break;
      }
    }
  }, {
    key: "remove_widget",
    value: function remove_widget(id) {
      this.tv.$delete(this.widgets, id);
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/settings-win/utils.js":
/*!**********************************************!*\
  !*** ./src/extensions/settings-win/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  sett2desc: function sett2desc(sett) {
    function setCharAt(str, index, chr) {
      if (index > str.length - 1) return str;
      return str.substring(0, index) + chr + str.substring(index + 1);
    }

    sett = sett.replace(/([^A-Z])([A-Z])/g, '$1 $2');
    sett = sett.replace(/-|_/g, ' ');
    var tuple = sett.split(' ');
    tuple = tuple.filter(function (x) {
      return x.length;
    }).map(function (x) {
      return setCharAt(x, 0, x[0].toUpperCase());
    });
    return tuple.join(' ');
  }
});

/***/ }),

/***/ "./src/index_dev.js":
/*!**************************!*\
  !*** ./src/index_dev.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _build_chart_link_chart_link_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../build/chart-link/chart-link-dev.js */ "./build/chart-link/chart-link-dev.js");
/* harmony import */ var _build_grid_resize_grid_resize_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../build/grid-resize/grid-resize-dev.js */ "./build/grid-resize/grid-resize-dev.js");
/* harmony import */ var _build_legend_buttons_legend_buttons_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../build/legend-buttons/legend-buttons-dev.js */ "./build/legend-buttons/legend-buttons-dev.js");
/* harmony import */ var _build_settings_win_settings_win_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../build/settings-win/settings-win-dev.js */ "./build/settings-win/settings-win-dev.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'




var Pack = {
  'chart-link': _build_chart_link_chart_link_dev_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'grid-resize': _build_grid_resize_grid_resize_dev_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  'legend-buttons': _build_legend_buttons_legend_buttons_dev_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  'settings-win': _build_settings_win_settings_win_dev_js__WEBPACK_IMPORTED_MODULE_3__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _Main_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Main.vue */ "./src/Main.vue");


new vue__WEBPACK_IMPORTED_MODULE_1__["default"]({
  el: '#app',
  render: function render(h) {
    return h(_Main_vue__WEBPACK_IMPORTED_MODULE_0__["default"]);
  }
});

/***/ }),

/***/ "./src/stream.js":
/*!***********************!*\
  !*** ./src/stream.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stream)
/* harmony export */ });
function Stream(url) {
  var ws = new WebSocket(url);

  var cb = function cb() {};

  ws.onopen = function () {
    console.log('Websocket is opened');
  };

  ws.onmessage = function (data) {
    try {
      data = JSON.parse(data.data);
      cb(data);
    } catch (e) {
      console.log(e);
    }
  };

  return {
    set ontrades(val) {
      cb = val;
    },

    off: function off() {
      ws.close(1000);
    }
  };
}

/***/ }),

/***/ "./src/stuff/constants.js":
/*!********************************!*\
  !*** ./src/stuff/constants.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var SECOND = 1000;
var MINUTE = SECOND * 60;
var MINUTE3 = MINUTE * 3;
var MINUTE5 = MINUTE * 5;
var MINUTE15 = MINUTE * 15;
var MINUTE30 = MINUTE * 30;
var HOUR = MINUTE * 60;
var HOUR4 = HOUR * 4;
var HOUR12 = HOUR * 12;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = WEEK * 4;
var YEAR = DAY * 365;
var MONTHMAP = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; // Grid time steps

var TIMESCALES = [YEAR * 10, YEAR * 5, YEAR * 3, YEAR * 2, YEAR, MONTH * 6, MONTH * 4, MONTH * 3, MONTH * 2, MONTH, DAY * 15, DAY * 10, DAY * 7, DAY * 5, DAY * 3, DAY * 2, DAY, HOUR * 12, HOUR * 6, HOUR * 3, HOUR * 1.5, HOUR, MINUTE30, MINUTE15, MINUTE * 10, MINUTE5, MINUTE * 2, MINUTE]; // Grid $ steps

var $SCALES = [0.05, 0.1, 0.2, 0.25, 0.5, 0.8, 1, 2, 5];
var ChartConfig = {
  SBMIN: 60,
  // Minimal sidebar px
  SBMAX: Infinity,
  // Max sidebar, px
  TOOLBAR: 57,
  // Toolbar width px
  TB_ICON: 25,
  // Toolbar icon size px
  TB_ITEM_M: 6,
  // Toolbar item margin px
  TB_ICON_BRI: 1,
  // Toolbar icon brightness
  TB_ICON_HOLD: 420,
  // ms, wait to expand
  TB_BORDER: 1,
  // Toolbar border px
  TB_B_STYLE: 'dotted',
  // Toolbar border style
  TOOL_COLL: 7,
  // Tool collision threshold
  EXPAND: 0.15,
  // %/100 of range
  CANDLEW: 0.6,
  // %/100 of step
  GRIDX: 100,
  // px
  GRIDY: 47,
  // px
  BOTBAR: 28,
  // px
  PANHEIGHT: 22,
  // px
  DEFAULT_LEN: 50,
  // candles
  MINIMUM_LEN: 5,
  // candles,
  MIN_ZOOM: 25,
  // candles
  MAX_ZOOM: 1000,
  // candles,
  VOLSCALE: 0.15,
  // %/100 of height
  UX_OPACITY: 0.9,
  // Ux background opacity
  ZOOM_MODE: 'tv',
  // 'tv' or 'tl'
  L_BTN_SIZE: 21,
  // Legend Button size, px
  L_BTN_MARGIN: '-6px 0 -6px 0',
  // css margin
  SCROLL_WHEEL: 'prevent' // 'pass', 'click'

};
ChartConfig.FONT = "11px -apple-system,BlinkMacSystemFont,\n    Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,\n    Fira Sans,Droid Sans,Helvetica Neue,\n    sans-serif";
var IB_TF_WARN = "When using IB mode you should specify " + "timeframe ('tf' filed in 'chart' object)," + "otherwise you can get an unexpected behaviour";
var MAP_UNIT = {
  "1s": SECOND,
  "5s": SECOND * 5,
  "10s": SECOND * 10,
  "20s": SECOND * 20,
  "30s": SECOND * 30,
  "1m": MINUTE,
  "3m": MINUTE3,
  "5m": MINUTE5,
  "15m": MINUTE15,
  "30m": MINUTE30,
  "1H": HOUR,
  "2H": HOUR * 2,
  "3H": HOUR * 3,
  "4H": HOUR4,
  "12H": HOUR12,
  "1D": DAY,
  "1W": WEEK,
  "1M": MONTH,
  "1Y": YEAR
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  SECOND: SECOND,
  MINUTE: MINUTE,
  MINUTE5: MINUTE5,
  MINUTE15: MINUTE15,
  MINUTE30: MINUTE30,
  HOUR: HOUR,
  HOUR4: HOUR4,
  DAY: DAY,
  WEEK: WEEK,
  MONTH: MONTH,
  YEAR: YEAR,
  MONTHMAP: MONTHMAP,
  TIMESCALES: TIMESCALES,
  $SCALES: $SCALES,
  ChartConfig: ChartConfig,
  map_unit: MAP_UNIT,
  IB_TF_WARN: IB_TF_WARN
});

/***/ }),

/***/ "./src/stuff/utils.js":
/*!****************************!*\
  !*** ./src/stuff/utils.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var arrayslicer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! arrayslicer */ "./node_modules/arrayslicer/lib/index.js");
/* harmony import */ var arrayslicer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(arrayslicer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./src/stuff/constants.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name2Name: function name2Name(sett) {
    function setCharAt(str, index, chr) {
      if (index > str.length - 1) return str;
      return str.substring(0, index) + chr + str.substring(index + 1);
    }

    sett = sett.replace(/([^A-Z])([A-Z])/g, '$1 $2');
    sett = sett.replace(/-|_/g, ' ');
    var tuple = sett.split(' ');
    tuple = tuple.filter(function (x) {
      return x.length;
    }).map(function (x) {
      return setCharAt(x, 0, x[0].toUpperCase());
    });
    return tuple.join('');
  },
  clamp: function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
  },
  add_zero: function add_zero(i) {
    if (i < 10) {
      i = "0" + i;
    }

    return i;
  },
  // Start of the day (zero millisecond)
  day_start: function day_start(t) {
    var start = new Date(t);
    return start.setUTCHours(0, 0, 0, 0);
  },
  // Start of the month
  month_start: function month_start(t) {
    var date = new Date(t);
    return Date.UTC(date.getFullYear(), date.getMonth(), 1);
  },
  // Start of the year
  year_start: function year_start(t) {
    return Date.UTC(new Date(t).getFullYear());
  },
  get_year: function get_year(t) {
    if (!t) return undefined;
    return new Date(t).getUTCFullYear();
  },
  get_month: function get_month(t) {
    if (!t) return undefined;
    return new Date(t).getUTCMonth();
  },
  // Nearest in array
  nearest_a: function nearest_a(x, array) {
    var dist = Infinity;
    var val = null;
    var index = -1;

    for (var i = 0; i < array.length; i++) {
      var xi = array[i];

      if (Math.abs(xi - x) < dist) {
        dist = Math.abs(xi - x);
        val = xi;
        index = i;
      }
    }

    return [index, val];
  },
  round: function round(num) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
    return parseFloat(num.toFixed(decimals));
  },
  // Strip? No, it's ugly floats in js
  strip: function strip(number) {
    return parseFloat(parseFloat(number).toPrecision(12));
  },
  get_day: function get_day(t) {
    return t ? new Date(t).getDate() : null;
  },
  // Update array keeping the same reference
  overwrite: function overwrite(arr, new_arr) {
    arr.splice.apply(arr, [0, arr.length].concat(_toConsumableArray(new_arr)));
  },
  // Copy layout in reactive way
  copy_layout: function copy_layout(obj, new_obj) {
    for (var k in obj) {
      if (Array.isArray(obj[k])) {
        // (some offchart indicators are added/removed)
        // we need to update layout in a reactive way
        if (obj[k].length !== new_obj[k].length) {
          this.overwrite(obj[k], new_obj[k]);
          continue;
        }

        for (var m in obj[k]) {
          Object.assign(obj[k][m], new_obj[k][m]);
        }
      } else {
        Object.assign(obj[k], new_obj[k]);
      }
    }
  },
  // Detects candles interval
  detect_interval: function detect_interval(ohlcv) {
    var len = Math.min(ohlcv.length - 1, 99);
    var min = Infinity;
    ohlcv.slice(0, len).forEach(function (x, i) {
      var d = ohlcv[i + 1][0] - x[0];
      if (d === d && d < min) min = d;
    }); // This saves monthly chart from being awkward

    if (min >= _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].MONTH && min <= _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].DAY * 30) {
      return _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].DAY * 31;
    }

    return min;
  },
  // Gets numberic part of overlay id (e.g 'EMA_1' = > 1)
  get_num_id: function get_num_id(id) {
    return parseInt(id.split('_').pop());
  },
  // Fast filter. Really fast, like 10X
  fast_filter: function fast_filter(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];

    try {
      var ia = new (arrayslicer__WEBPACK_IMPORTED_MODULE_0___default())(arr, "0");
      var res = ia.getRange(t1, t2);
      var i0 = ia.valpos[t1].next;
      return [res, i0];
    } catch (e) {
      // Something wrong with fancy slice lib
      // Fast fix: fallback to filter
      return [arr.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }), 0];
    }
  },
  // Fast filter (index-based)
  fast_filter_i: function fast_filter_i(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];
    var i1 = Math.floor(t1);
    if (i1 < 0) i1 = 0;
    var i2 = Math.floor(t2 + 1);
    var res = arr.slice(i1, i2);
    return [res, i1];
  },
  // Nearest indexes (left and right)
  fast_nearest: function fast_nearest(arr, t1) {
    var ia = new (arrayslicer__WEBPACK_IMPORTED_MODULE_0___default())(arr, "0");
    ia.fetch(t1);
    return [ia.nextlow, ia.nexthigh];
  },
  now: function now() {
    return new Date().getTime();
  },
  pause: function pause(delay) {
    return new Promise(function (rs, rj) {
      return setTimeout(rs, delay);
    });
  },
  // Limit crazy wheel delta values
  smart_wheel: function smart_wheel(delta) {
    var abs = Math.abs(delta);

    if (abs > 500) {
      return (200 + Math.log(abs)) * Math.sign(delta);
    }

    return delta;
  },
  // Parse the original mouse event to find deltaX
  get_deltaX: function get_deltaX(event) {
    return event.originalEvent.deltaX / 12;
  },
  // Parse the original mouse event to find deltaY
  get_deltaY: function get_deltaY(event) {
    return event.originalEvent.deltaY / 12;
  },
  // Apply opacity to a hex color
  apply_opacity: function apply_opacity(c, op) {
    if (c.length === 7) {
      var n = Math.floor(op * 255);
      n = this.clamp(n, 0, 255);
      c += n.toString(16);
    }

    return c;
  },
  // Parse timeframe or return value in ms
  parse_tf: function parse_tf(smth) {
    if (typeof smth === 'string') {
      return _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].map_unit[smth];
    } else {
      return smth;
    }
  },
  // Detect index shift between the main data sub
  // and the overlay's sub (for IB-mode)
  index_shift: function index_shift(sub, data) {
    // Find the second timestamp (by value)
    if (!data.length) return 0;
    var first = data[0][0];
    var second;

    for (var i = 1; i < data.length; i++) {
      if (data[i][0] !== first) {
        second = data[i][0];
        break;
      }
    }

    for (var j = 0; j < sub.length; j++) {
      if (sub[j][0] === second) {
        return j - i;
      }
    }

    return 0;
  },
  // Fallback fix for Brave browser
  // https://github.com/brave/brave-browser/issues/1738
  measureText: function measureText(ctx, text, tv_id) {
    var m = ctx.measureTextOrg(text);

    if (m.width === 0) {
      var doc = document;
      var id = 'tvjs-measure-text';
      var el = doc.getElementById(id);

      if (!el) {
        var base = doc.getElementById(tv_id);
        el = doc.createElement("div");
        el.id = id;
        el.style.position = 'absolute';
        el.style.top = '-1000px';
        base.appendChild(el);
      }

      if (ctx.font) el.style.font = ctx.font;
      el.innerText = text.replace(/ /g, '.');
      return {
        width: el.offsetWidth
      };
    } else {
      return m;
    }
  },
  uuid: function uuid() {
    var temp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    return temp.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  },
  uuid2: function uuid2() {
    return this.uuid('xxxxxxxxxxxx');
  },
  // Delayed warning, f = condition lambda fn
  warn: function warn(f, text) {
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    setTimeout(function () {
      if (f()) console.warn(text);
    }, delay);
  },
  // Checks if script props updated
  // (and not style settings or something else)
  is_scr_props_upd: function is_scr_props_upd(n, prev) {
    var p = prev.find(function (x) {
      return x.v.$uuid === n.v.$uuid;
    });
    if (!p) return false;
    var props = n.p.settings.$props;
    if (!props) return false;
    return props.some(function (x) {
      return n.v[x] !== p.v[x];
    });
  },
  // Checks if it's time to make a script update
  // (based on execInterval in ms)
  delayed_exec: function delayed_exec(v) {
    if (!v.script || !v.script.execInterval) return true;
    var t = this.now();
    var dt = v.script.execInterval;

    if (!v.settings.$last_exec || t > v.settings.$last_exec + dt) {
      v.settings.$last_exec = t;
      return true;
    }

    return false;
  },
  // Format names such 'RSI, $length', where
  // length - is one of the settings
  format_name: function format_name(ov) {
    if (!ov.name) return undefined;
    var name = ov.name;

    for (var k in ov.settings || {}) {
      var val = ov.settings[k];
      var reg = new RegExp("\\$".concat(k), 'g');
      name = name.replace(reg, val);
    }

    return name;
  },
  // Default cursor mode
  xmode: function xmode() {
    return this.is_mobile ? 'explore' : 'default';
  },
  default_prevented: function default_prevented(event) {
    if (event.original) {
      return event.original.defaultPrevented;
    }

    return event.defaultPrevented;
  },
  // WTF with modern web development
  is_mobile: function (w) {
    return 'onorientationchange' in w && (!!navigator.maxTouchPoints || !!navigator.msMaxTouchPoints || 'ontouchstart' in w || w.DocumentTouch && document instanceof w.DocumentTouch);
  }(typeof window !== 'undefined' ? window : {})
});

/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css&":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.app-content {\n    padding: calc(2rem + 2.45rem) 0 0 0rem !important;\n    overflow-x: hidden;\n}\n@media (max-width: 767.98px){\nhtml body.navbar-sticky .app-content {\n        padding: calc(1rem - 0.8rem + 4.45rem) 0 0 0 !important;\n}\n}\n.flexed {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    align-content: center;\n    flex-wrap: nowrap;\n}\n#app-conainer {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-content: space-between;\n    align-items: flex-start;\n    flex-wrap: nowrap;\n}\n\n/* @media (max-width: 767.98px){\n    #app-conainer {\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        align-content: space-between;\n        align-items: flex-start;\n        flex-wrap: nowrap;\n    }\n} */\n#tradebar {\n    color: #ddd;\n}\n#tvjs-header {\n    position: absolute;\n    display: flex;\n    align-content: center;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-items: center;\n    padding-left: 70px;\n    height: 40px;\n    color: #ddd;\n    width: 100%;\n    background-color: #121826;\n}\n.night-mode {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n}\n#trading-vue-js-grid-0-canvas,\n#trading-vue-js-sidebar-0-canvas,\n#trading-vue-js-grid-1-canvas,\n#trading-vue-js-sidebar-1-canvas,\n#trading-vue-js-botbar-canvas {\n    background-color: rgb(0 0 0 / 0%) !important;\n}\n#trading-vue-tbitem {\n    background-color: rgb(18, 24, 38);\n}\n@media only screen and (max-device-width: 480px) {\n.tf-selector {\n        top: 50px;\n        right: 140px;\n        max-width: 140px;\n        font: 12px -apple-system, BlinkMacSystemFont,\n            Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell,\n            Fira Sans, Droid Sans, Helvetica Neue,\n            sans-serif;\n}\n}\n.box {\n    width: 280px;\n    margin: 0 auto;\n    box-shadow: 0 1.5px 5px -2px rgba(0, 0, 0, 0.2);\n    border-radius: 3px;\n    padding: 0 15px 0 15px;\n}\ntable {\n    font-size: 13px;\n    font-weight: 500;\n    color: rgb(183, 189, 198);\n    overflow: hidden;\n    width: 100%;\n}\ntd {\n    position: relative;\n    height: 20px;\n    line-height: 20px;\n}\ntd.price {\n    width: 30%;\n}\ntd.price span {\n    padding-left: 5px;\n}\ntd.quantity {\n    width: 30%;\n    text-align: right;\n}\ntd.time {\n    width: 40%;\n    text-align: right;\n    color: #999;\n    padding-right: 5px;\n}\ntd.btc {\n    width: 40%;\n    text-align: right;\n    padding-right: 5px;\n}\ntd span {\n    position: relative;\n    z-index: 2;\n}\ntable.asks .percent {\n    background-color: rgba(246, 70, 94, 0.2);\n}\ntable.bids .percent {\n    background-color: rgba(14, 203, 129, 0.2);\n}\ntd .percent {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n}\n.newest {\n    border-bottom: 1px solid #eee;\n    margin: 15px -15px;\n}\n.card-110 {\n    top: 110px !important;\n    left: 70px;\n}\n/* Style page content - use this if you want to push the page content to the right when you open the side navigation */\n#main {\n    transition: margin-left .5s;\n    /* If you want a transition effect */\n}\n\n/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */\n@media screen and (max-height: 450px) {\n.sidebar1 {\n        padding-top: 15px;\n}\n.sidebar1 a {\n        font-size: 18px;\n}\n}\n.btn-circle {\n    width: 30px;\n    height: 30px;\n    padding: 6px 0px;\n    border-radius: 15px;\n    font-size: 8px;\n    text-align: center;\n}\n#chartdiv {\n    min-height: 300px;\n    max-height: 400px;\n    height: 70vh;\n}\n", "",{"version":3,"sources":["webpack://./src/Main.vue"],"names":[],"mappings":";AAmTA;IACA,iDAAA;IACA,kBAAA;AACA;AACA;AACA;QACA,uDAAA;AACA;AACA;AACA;IACA,aAAA;IACA,sBAAA;IACA,mBAAA;IACA,uBAAA;IACA,qBAAA;IACA,iBAAA;AACA;AAEA;IACA,aAAA;IACA,mBAAA;IACA,8BAAA;IACA,4BAAA;IACA,uBAAA;IACA,iBAAA;AACA;;AAEA;;;;;;;;;GASA;AACA;IACA,WAAA;AACA;AAEA;IACA,kBAAA;IACA,aAAA;IACA,qBAAA;IACA,mBAAA;IACA,iBAAA;IACA,2BAAA;IACA,mBAAA;IACA,kBAAA;IACA,YAAA;IACA,WAAA;IACA,WAAA;IACA,yBAAA;AACA;AAEA;IACA,kBAAA;IACA,SAAA;IACA,WAAA;AACA;AAEA;;;;;IAKA,4CAAA;AACA;AAEA;IACA,iCAAA;AACA;AAEA;AACA;QACA,SAAA;QACA,YAAA;QACA,gBAAA;QACA;;;sBAGA;AACA;AACA;AAEA;IACA,YAAA;IACA,cAAA;IACA,+CAAA;IACA,kBAAA;IACA,sBAAA;AACA;AAEA;IACA,eAAA;IACA,gBAAA;IACA,yBAAA;IACA,gBAAA;IACA,WAAA;AACA;AAEA;IACA,kBAAA;IACA,YAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;AACA;AAEA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;IACA,WAAA;IACA,kBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;IACA,kBAAA;AACA;AAEA;IACA,kBAAA;IACA,UAAA;AACA;AAEA;IACA,wCAAA;AACA;AAEA;IACA,yCAAA;AACA;AAEA;IACA,kBAAA;IACA,MAAA;IACA,SAAA;IACA,QAAA;AACA;AAEA;IACA,6BAAA;IACA,kBAAA;AACA;AAEA;IACA,qBAAA;IACA,UAAA;AACA;AACA,sHAAA;AACA;IACA,2BAAA;IACA,oCAAA;AACA;;AAEA,gIAAA;AACA;AACA;QACA,iBAAA;AACA;AAEA;QACA,eAAA;AACA;AACA;AAEA;IACA,WAAA;IACA,YAAA;IACA,gBAAA;IACA,mBAAA;IACA,cAAA;IACA,kBAAA;AACA;AAEA;IACA,iBAAA;IACA,iBAAA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <div class=\"flex-start col-10 col-xll-10 col-xl-10 col-lg-10 col-md-9 col-sm-12\">\n        <div id=\"tvjs-header\">\n            <a><span id=\"toggleContracts\" class=\"me-1 badge bg-light-info\" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#collapseContracts\" aria-expanded=\"false\" aria-controls=\"collapseContracts\"><i\n                        class=\"bi bi-briefcase\" /><div class=\"d-md-inline d-none\"> Contracts</div></span></a>\n            <a><span v-on:click=\"candles\" class=\"me-1 badge bg-light-secondary\"><i class=\"bi bi-bar-chart\" /><div class=\"d-md-inline d-none\">  Candles</div></span></a>\n            <a><span v-on:click=\"spline\" class=\"me-1 badge bg-light-secondary\"><i class=\"bi bi-graph-up\" /><div class=\"d-md-inline d-none\">  Spline</div></span></a>\n            <a><span id=\"toggleInfo\" class=\"me-1 badge bg-light-info\" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#collapseInfos\" aria-expanded=\"false\" aria-controls=\"collapseInfos\"><i\n                        class=\"bi bi-info-circle\" /><div class=\"d-md-inline d-none\">  Info</div></span></a>\n            <a><span id=\"toggleDepth\" class=\"me-1 badge bg-light-primary \" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#collapseDepth\" aria-expanded=\"false\" aria-controls=\"collapseDepth\"><i\n                        class=\"bi bi-kanban\" /><div class=\"d-md-inline d-none\">  Depth View</div></span></a>\n            <a><span id=\"toggleOrders\" class=\"me-1 badge bg-light-warning \" data-bs-toggle=\"collapse\"\n            data-bs-target=\"#collapseOrders\" aria-expanded=\"false\" aria-controls=\"collapseOrders\"><i\n                        class=\"bi bi-file-bar-graph\" /><div class=\"d-md-inline d-none\">  Order Book</div></span></a>\n        </div>\n        <div id=\"collapseInfos\"\n            class=\"collapse col-lg-4 col-md-5 col-sm-6 position-absolute sticky-top card-110 \">\n            <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                <div class=\"card-header\">\n                    <div class=\"col-md-8\">\n                        <h4 class=\"card-title\">\n                            {{ symbol }}\n                        </h4>\n                    </div>\n                </div>\n                <div class=\"card-content\">\n                    <div class=\"card-body\">\n                        <div class=\"row\">\n                            <div class=\"col-8\">\n                                <div id=\"show_b\" class=\"text-start fs-1\">\n                                    ...\n                                </div>\n                            </div>\n                            <div class=\"col-4\">\n                                <div id=\"show_p\" class=\"text-end\" style=\"font-size:14px;\">\n                                    ...\n                                </div>\n                                <div id=\"show_P\" class=\"text-end\" style=\"font-size:14px;\">\n                                    ...\n                                </div>\n                            </div>\n                        </div>\n                        <div class=\"row mt-1\">\n                            <div id=\"myRangeColor\" class=\"progress\">\n                                <div id=\"myRange\" class=\"progress-bar progress-bar-striped progress-bar-animated\"\n                                    role=\"progressbar\" aria-valuenow=\"50\" aria-valuemin=\"0\" aria-valuemax=\"100\"\n                                    style=\"width: 80%\" />\n                            </div>\n                        </div>\n                        <div class=\"row d-flex justify-content-between align-items-center\">\n                            <div id=\"show_l\" class=\"col text-start text-danger\" style=\"font-size:10px;\" />\n                            <div class=\"col text-dark text-center\" style=\"font-size:10px;\">\n                                Day Range\n                            </div>\n                            <div id=\"show_h\" class=\"col text-end text-success\" style=\"font-size:10px;\" />\n                        </div>\n                        <div class=\"row mt-1\">\n                            <small class=\"col text-start text-dark clearfix\">Volume 24H</small>\n                            <small id=\"show_v\" class=\"col text-end text-warning clearfix\" />\n                            <hr>\n                        </div>\n                        <div class=\"row\">\n                            <small class=\"col text-start text-dark clearfix\">Market Cap</small>\n                            <small id=\"show_mc\" class=\"col text-end text-warning clearfix\" />\n                            <hr>\n                        </div>\n\n                        <div class=\"row\">\n                            <small class=\"col text-start text-dark clearfix\">Total Supply</small>\n                            <small id=\"show_ts\" class=\"col text-end text-warning clearfix\" />\n                            <hr>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div id=\"collapseDepth\"\n            class=\"collapse col-lg-6 col-md-10 col-sm-12 col-12 position-absolute sticky-top card-110 \">\n            <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                <div class=\"card-content\">\n                    <div id=\"chartdiv\"></div>\n                </div>\n            </div>\n        </div>\n        <div id=\"collapseOrders\"\n            class=\"collapse col-lg-4 col-md-4 col-sm-6 col-12 position-absolute sticky-top card-110\" style=\"max-width:280px;\">\n            <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                <div class=\"card-content my-1\">\n                    <div class=\"box\">\n                        <table>\n                            <thead>\n                                <tr class=\"mb-1\">\n                                    <th class=\"text-start ps-1 text-dark\">\n                                        Price\n                                    </th>\n                                    <th class=\"text-center ps-1 text-dark\">\n                                        Quantity\n                                    </th>\n                                    <th class=\"text-end pe-1 text-dark\">\n                                        Total\n                                    </th>\n                                </tr>\n                            </thead>\n                        </table>\n                        <table class=\"asks\" />\n                        <div class=\"newest\" />\n                        <table class=\"bids\" />\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div class=\"app-container\" style=\"margin-top:40px;\">\n            <trading-vue :key=\"resetkey\" ref=\"tvjs\" :data=\"dc\" :width=\"width\" :height=\"height\" :title-txt=\"title\"\n                color-title=\"#ff9f43\" :legend-buttons=\"['display', 'settings', 'up', 'down', 'add', 'remove']\"\n                :chart-config=\"{DEFAULT_LEN:60,MIN_ZOOM:1}\" :toolbar=\"true\" :color-back=\"colors.colorBack\"\n                :color-grid=\"colors.colorGrid\" :color-text=\"colors.colorText\" :extensions=\"ext\" :overlays=\"ovs\"\n                :night=\"night\" :resetkey=\"resetkey\" :x-settings=\"xsett\" :timezone=\"timezone\" />\n        </div>\n    </div>\n</template>\n\n<script>\nimport { TradingVue, DataCube } from 'trading-vue-js'\nimport Overlays from 'tvjs-overlays'\nimport Data from '../resources/data/data.json'\nimport Utils from './stuff/utils.js'\nimport Const from './stuff/constants.js'\nimport Stream from './stream.js'\nimport Extensions from './index_dev'\n\n// Gettin' data through webpeck proxy\nconst symbolsm = window.location.pathname.toLowerCase().split('/')[3]\nconst symbolbg = window.location.pathname.toUpperCase().split('/')[3]\nconst pairsm = window.location.pathname.toLowerCase().split('/')[4]\nconst pairbg = window.location.pathname.toUpperCase().split('/')[4]\nconst URL = `https://binance-watch-wrapper.herokuapp.com/https://api.binance.com/api/v1/klines?symbol=`\nconst WSS = `wss://stream.binance.com:9443/ws/${symbolsm}${pairsm}@aggTrade`\nconst datas = `datasets.binance-${symbolsm}${pairsm}`\n//const PORT = location.port\n//const URL = `http://localhost:${PORT}/api/v1/klines?symbol=`\n//const WSS = `ws://localhost:${PORT}/ws/${symbolsm}@aggTrade`\n\nexport default {\n    name: 'App',\n    components: {\n        TradingVue\n    },\n    data() {\n        return {\n            dc: new DataCube(Data),\n            title: symbolbg + pairbg,\n            width: 0,\n            height: 0,\n            log_scale: true,\n            symbol: symbolbg + pairbg,\n            index_based: true,\n            timezone: this.timezoned(),\n            xsett: {\n                'grid-resize': { min_height: 30 }\n            },\n            ovs: Object.values(Overlays),\n            ext: Object.values(Extensions),\n            night: true,\n            top: 50,\n            resetkey: 0\n        }\n    },\n    computed: {\n        colors() {\n            return this.night ? {} : {\n                colorBack: '#fff',\n                colorGrid: '#eee',\n                colorText: '#333'\n            }\n        }\n    },\n    mounted() {\n        window.addEventListener('resize', this.onResize)\n        let q = this.win_query()\n        if (q.nm === 'false') this.night = false\n        if (q.ov) this.current = q.ov\n        if (q.header === 'false') this.top = 0\n        this.onResize(),\n        window.dc = this.dc\n        window.tv = this.$refs.tvjs\n        // Load the last data chunk & init DataCube:\n        let now = Utils.now()\n        this.load_chunk([now - Const.HOUR4, now]).then(data => {\n            dc.data.chart.data = data['chart.data']\n            // Register onrange callback & And a stream of trades\n            this.dc.onrange(this.load_chunk)\n            this.stream = new Stream(WSS)\n            this.stream.ontrades = this.on_trades\n            window.dc = this.chart      // Debug\n            window.tv = this.$refs.tvjs // Debug\n        })\n    },\n    beforeDestroy() {\n        window.removeEventListener('resize', this.onResize)\n        if (this.stream) this.stream.off()\n    },\n    methods: {\n        onResize() {\n            if (window.innerWidth > '992') {\n                this.width = (window.innerWidth - (window.innerWidth * 0.21))\n            } else if (window.innerWidth > '768'  && window.innerWidth <= '992') {\n                this.width = (window.innerWidth - (window.innerWidth * 0.26))\n            } else {\n                this.width = (window.innerWidth - 15)\n            }\n            this.height = window.innerHeight * 0.80\n        },\n        spline () {\n            this.dc.data.chart.type = \"Spline\"\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        candles () {\n            this.dc.data.chart.type = \"Candles\"\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        xbars () {\n            this.data.ovs = 'XOhlcBars'\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        trade () {\n            this.dc.data.chart.type = \"Spline\"\n        },\n        win_query() {\n            let qs = (function(a) {\n                if (a == \"\") return {};\n                var b = {};\n                for (var i = 0; i < a.length; ++i) {\n                    var p=a[i].split('=', 2);\n                    if (p.length == 1)\n                        b[p[0]] = \"\";\n                    else\n                        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n                }\n                return b;\n            })(window.location.search.substr(1).split('&'));\n            return qs\n        },\n        reset(state) {\n            let sub = Object.keys(state).filter(x => state[x])\n            this.extensions = sub.map(x => Extensions[x])\n            this.resetkey++\n        },\n        onselect(id) {\n            this.current = id\n        },\n        timezoned() {\n            var offset = new Date().getTimezoneOffset();\n            var minutes = Math.abs(offset);\n            var hours = Math.floor(minutes / 60);\n            var prefix = offset < 0 ? \"\" : \"-\";\n            return parseInt(prefix+hours);\n        },\n        // New data handler. Should return Promise, or\n        // use callback: load_chunk(range, tf, callback)\n        async load_chunk(range) {\n            let [t1, t2] = range\n            let x = symbolbg\n            let y = pairbg\n            let q = `${x}${y}&interval=1m&startTime=${t1}&endTime=${t2}`\n            let r = await fetch(URL + q).then(r => r.json())\n            return this.format(this.parse_binance(r))\n        },\n        // Parse a specific exchange format\n        parse_binance(data) {\n            if (!Array.isArray(data)) return []\n            return data.map(x => {\n                for (var i = 0; i < x.length; i++) {\n                    x[i] = parseFloat(x[i])\n                }\n                return x.slice(0,6)\n            })\n        },\n        format(data) {\n            return {\n                'chart.data': data,\n            }\n        },\n        on_trades(trade) {\n            this.dc.update({\n                t: trade.T,     // Exchange time (optional)\n                price: parseFloat(trade.p),   // Trade price\n                volume: parseFloat(trade.q),  // Trade amount\n                datas : [ // Update dataset\n                    trade.T,\n                    trade.m ? 0 : 1,          // Sell or Buy\n                    parseFloat(trade.q),\n                    parseFloat(trade.p)\n                ],\n                // ... other onchart/offchart updates\n            })\n        }\n    }\n}\n</script>\n\n<style>\n.app-content {\n    padding: calc(2rem + 2.45rem) 0 0 0rem !important;\n    overflow-x: hidden;\n}\n@media (max-width: 767.98px){\n    html body.navbar-sticky .app-content {\n        padding: calc(1rem - 0.8rem + 4.45rem) 0 0 0 !important;\n    }\n}\n.flexed {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    align-content: center;\n    flex-wrap: nowrap;\n}\n\n#app-conainer {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-content: space-between;\n    align-items: flex-start;\n    flex-wrap: nowrap;\n}\n\n/* @media (max-width: 767.98px){\n    #app-conainer {\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        align-content: space-between;\n        align-items: flex-start;\n        flex-wrap: nowrap;\n    }\n} */\n#tradebar {\n    color: #ddd;\n}\n\n#tvjs-header {\n    position: absolute;\n    display: flex;\n    align-content: center;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-items: center;\n    padding-left: 70px;\n    height: 40px;\n    color: #ddd;\n    width: 100%;\n    background-color: #121826;\n}\n\n.night-mode {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n}\n\n#trading-vue-js-grid-0-canvas,\n#trading-vue-js-sidebar-0-canvas,\n#trading-vue-js-grid-1-canvas,\n#trading-vue-js-sidebar-1-canvas,\n#trading-vue-js-botbar-canvas {\n    background-color: rgb(0 0 0 / 0%) !important;\n}\n\n#trading-vue-tbitem {\n    background-color: rgb(18, 24, 38);\n}\n\n@media only screen and (max-device-width: 480px) {\n    .tf-selector {\n        top: 50px;\n        right: 140px;\n        max-width: 140px;\n        font: 12px -apple-system, BlinkMacSystemFont,\n            Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell,\n            Fira Sans, Droid Sans, Helvetica Neue,\n            sans-serif;\n    }\n}\n\n.box {\n    width: 280px;\n    margin: 0 auto;\n    box-shadow: 0 1.5px 5px -2px rgba(0, 0, 0, 0.2);\n    border-radius: 3px;\n    padding: 0 15px 0 15px;\n}\n\ntable {\n    font-size: 13px;\n    font-weight: 500;\n    color: rgb(183, 189, 198);\n    overflow: hidden;\n    width: 100%;\n}\n\ntd {\n    position: relative;\n    height: 20px;\n    line-height: 20px;\n}\n\ntd.price {\n    width: 30%;\n}\n\ntd.price span {\n    padding-left: 5px;\n}\n\ntd.quantity {\n    width: 30%;\n    text-align: right;\n}\n\ntd.time {\n    width: 40%;\n    text-align: right;\n    color: #999;\n    padding-right: 5px;\n}\n\ntd.btc {\n    width: 40%;\n    text-align: right;\n    padding-right: 5px;\n}\n\ntd span {\n    position: relative;\n    z-index: 2;\n}\n\ntable.asks .percent {\n    background-color: rgba(246, 70, 94, 0.2);\n}\n\ntable.bids .percent {\n    background-color: rgba(14, 203, 129, 0.2);\n}\n\ntd .percent {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n}\n\n.newest {\n    border-bottom: 1px solid #eee;\n    margin: 15px -15px;\n}\n\n.card-110 {\n    top: 110px !important;\n    left: 70px;\n}\n/* Style page content - use this if you want to push the page content to the right when you open the side navigation */\n#main {\n    transition: margin-left .5s;\n    /* If you want a transition effect */\n}\n\n/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */\n@media screen and (max-height: 450px) {\n    .sidebar1 {\n        padding-top: 15px;\n    }\n\n    .sidebar1 a {\n        font-size: 18px;\n    }\n}\n\n.btn-circle {\n    width: 30px;\n    height: 30px;\n    padding: 6px 0px;\n    border-radius: 15px;\n    font-size: 8px;\n    text-align: center;\n}\n\n#chartdiv {\n    min-height: 300px;\n    max-height: 400px;\n    height: 70vh;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-std-input {\r\n    margin: 5px;\r\n    background-color: #161b27;\r\n    border: 1px dotted #353940;\r\n    height: 22px;\r\n    border-radius: 3px;\r\n    padding: 2px 0px 3px 10px;\r\n    color: whitesmoke;\r\n    font-size: 1.2em;\r\n    outline: none;\r\n    width: 100px;\n}\nselect.tvjs-std-input {\r\n    height: 29px;\r\n    -moz-appearance: none;\n}\nselect.tvjs-std-input  {\r\n    //display: none; /*hide original SELECT element: */\n}\n.tvjs-std-input::-moz-placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\n.tvjs-std-input:-ms-input-placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\n.tvjs-std-input::placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\r\n", "",{"version":3,"sources":["webpack://./src/components/StdInput.vue"],"names":[],"mappings":";AA4CA;IACA,WAAA;IACA,yBAAA;IACA,0BAAA;IACA,YAAA;IACA,kBAAA;IACA,yBAAA;IACA,iBAAA;IACA,gBAAA;IACA,aAAA;IACA,YAAA;AACA;AAEA;IACA,YAAA;IACA,qBAAA;AAEA;AAEA;IACA,eAAA,EAAA,iCAAA;AACA;AAGA;IACA,cAAA;IACA,aAAA;AACA;AAHA;IACA,cAAA;IACA,aAAA;AACA;AAHA;IACA,cAAA;IACA,aAAA;AACA","sourcesContent":["<template>\r\n    <span>\r\n        <input\nv-if=\"type==='text' || !type\"\r\n            :value=\"value\"\nclass=\"tvjs-std-input\"\n:style=\"style\"\r\n            :placeholder=\"name\"\r\n            @change=\"$emit('change', $event.target.value)\"\r\n            @input=\"$emit('input', $event.target.value)\"\n>\r\n        <select\nv-else-if=\"type==='select'\"\r\n            class=\"tvjs-std-input\"\n:style=\"style\"\r\n            :value=\"value\"\r\n            @input=\"$emit('input', $event.target.value)\"\n>\r\n            <option v-for=\"opt in list\">{{ opt }}</option>\r\n        </select>\r\n    </span>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name: 'StdInput',\r\n    props: ['value', 'name', 'type', 'list', 'colors'],\r\n    data() {\r\n        return {\r\n        }\r\n    },\r\n    computed: {\r\n        style() {\r\n            return {\r\n                //background: this.$props.colors.back,\r\n                //color: this.$props.colors.text\r\n            }\r\n        }\r\n    },\r\n    methods: {}\r\n}\r\n</script>\r\n\r\n<style>\r\n.tvjs-std-input {\r\n    margin: 5px;\r\n    background-color: #161b27;\r\n    border: 1px dotted #353940;\r\n    height: 22px;\r\n    border-radius: 3px;\r\n    padding: 2px 0px 3px 10px;\r\n    color: whitesmoke;\r\n    font-size: 1.2em;\r\n    outline: none;\r\n    width: 100px;\r\n}\r\n\r\nselect.tvjs-std-input {\r\n    height: 29px;\r\n    -moz-appearance: none;\r\n\r\n}\r\n\r\nselect.tvjs-std-input  {\r\n    //display: none; /*hide original SELECT element: */\r\n}\r\n\r\n\r\n.tvjs-std-input::placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window {\r\n    position: absolute;\r\n    background: #1b202def;\r\n    border-radius: 3px;\r\n    pointer-events: all;\r\n    padding-left: 7px;\r\n    z-index: 100;\r\n    color: #dedddd;\n}\n.tvjs-x-window-head {\r\n    font-size: 2em;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n        -ms-user-select: none;\r\n            user-select: none;\r\n    display: flex;\r\n    flex-direction: row;\r\n    flex-wrap: nowrap;\r\n    justify-content: flex-start;\r\n    align-content: center;\r\n    align-items: center;\r\n    height: 36px;\r\n    padding: 10px;\r\n    cursor: -webkit-grab;\r\n    cursor: grab;\n}\n.tvjs-x-window-body {\r\n    padding: 10px;\r\n    font-size: 1.1em;\n}\n.tvjs-x-window-title {\r\n    width: 300px;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n        -ms-user-select: none;\r\n            user-select: none;\n}\n.tvjs-x-window-close {\r\n    width: 26px;\r\n    cursor: pointer;\r\n    margin: -1em;\r\n    padding: 1em;\r\n    font-size: 0.75em;\n}\r\n", "",{"version":3,"sources":["webpack://./src/components/Window.vue"],"names":[],"mappings":";AAgEA;IACA,kBAAA;IACA,qBAAA;IACA,kBAAA;IACA,mBAAA;IACA,iBAAA;IACA,YAAA;IACA,cAAA;AACA;AACA;IACA,cAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;IACA,aAAA;IACA,mBAAA;IACA,iBAAA;IACA,2BAAA;IACA,qBAAA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,oBAAA;IAAA,YAAA;AACA;AAEA;IACA,aAAA;IACA,gBAAA;AACA;AACA;IACA,YAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;AACA;AACA;IACA,WAAA;IACA,eAAA;IACA,YAAA;IACA,YAAA;IACA,iBAAA;AACA","sourcesContent":["<template>\r\n    <div\nref=\"win\"\nclass=\"tvjs-x-window\"\n:style=\"style\"\n>\r\n        <div class=\"tvjs-x-window-head\">\r\n            <div\nclass=\"tvjs-x-window-title\"\r\n                @mousedown=\"onMouseDown\"\n>\r\n                {{ title }}\r\n            </div>\r\n            <div\nclass=\"tvjs-x-window-close\"\r\n                @click=\"$emit('close')\"\n>\r\n                \r\n            </div>\r\n        </div>\r\n        <div class=\"tvjs-x-window-body\">\r\n            <slot />\r\n        </div>\r\n    </div>\r\n</template>\r\n<script>\r\n\r\nimport Dragg from './dragg.js'\r\n\r\nexport default {\r\n    name: 'Window',\r\n    mixins: [Dragg],\r\n    props: ['title', 'tv'],\r\n    data() {\r\n        return {\r\n            ww: 0,\r\n            wh: 0,\r\n            x: 0,\r\n            y: 0\r\n        }\r\n    },\r\n    computed: {\r\n        style() {\r\n            return {\r\n                top: `${this.y}px`,\r\n                left: `${this.x}px`\r\n            }\r\n        },\r\n        tvw() {\r\n            return this.$props.tv.width\r\n        },\r\n        tvh() {\r\n            return this.$props.tv.height\r\n        }\r\n    },\r\n    mounted() {\r\n        this.ww = this.$refs.win.clientWidth\r\n        this.wh = this.$refs.win.clientHeight\r\n        this.x = this.tvw * 0.5 - this.ww * 0.5\r\n        this.y = this.tvh * 0.5 - this.wh * 0.5\r\n    }\r\n}\r\n</script>\r\n<style>\r\n.tvjs-x-window {\r\n    position: absolute;\r\n    background: #1b202def;\r\n    border-radius: 3px;\r\n    pointer-events: all;\r\n    padding-left: 7px;\r\n    z-index: 100;\r\n    color: #dedddd;\r\n}\r\n.tvjs-x-window-head {\r\n    font-size: 2em;\r\n    user-select: none;\r\n    display: flex;\r\n    flex-direction: row;\r\n    flex-wrap: nowrap;\r\n    justify-content: flex-start;\r\n    align-content: center;\r\n    align-items: center;\r\n    height: 36px;\r\n    padding: 10px;\r\n    cursor: grab;\r\n}\r\n\r\n.tvjs-x-window-body {\r\n    padding: 10px;\r\n    font-size: 1.1em;\r\n}\r\n.tvjs-x-window-title {\r\n    width: 300px;\r\n    user-select: none;\r\n}\r\n.tvjs-x-window-close {\r\n    width: 26px;\r\n    cursor: pointer;\r\n    margin: -1em;\r\n    padding: 1em;\r\n    font-size: 0.75em;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.h-splitter[data-v-189fccad] {\r\n    position: absolute;\r\n    left: 0;\r\n    height: 5px;\r\n    margin-top: -2px;\r\n    width: 100%;\r\n    z-index: 1;\r\n    background-color: #3ee4afb5;\r\n    opacity: 0;\r\n    pointer-events: all;\n}\n.h-splitter[data-v-189fccad]:hover {\r\n    cursor: row-resize;\r\n    opacity: 1;\n}\r\n", "",{"version":3,"sources":["webpack://./src/extensions/grid-resize/Splitter.vue"],"names":[],"mappings":";AAkEA;IACA,kBAAA;IACA,OAAA;IACA,WAAA;IACA,gBAAA;IACA,WAAA;IACA,UAAA;IACA,2BAAA;IACA,UAAA;IACA,mBAAA;AACA;AACA;IACA,kBAAA;IACA,UAAA;AACA","sourcesContent":["<template>\r\n    <span\nclass=\"h-splitter\"\r\n        :style=\"hs_style\"\n@mousedown=\"hs_mousedown\"\n/>\r\n</template>\r\n<script>\r\n\r\nimport Utils from './utils.js'\r\n\r\nexport default {\r\n    name: 'Splitter',\r\n    props: ['id', 'main', 'dc', 'tv', 'data'],\r\n    computed: {\r\n        hs_style() {\r\n            return {\r\n                drag: null,\r\n                top: this.data.grid2.offset + 'px',\r\n                //backgroundColor: this.colors.splitter\r\n            }\r\n        },\r\n    },\r\n    mounted() {\r\n        this.MIN_HEIGHT = this.data.sett.min_height || 20\r\n    },\r\n    methods: {\r\n        hs_mousedown(e) {\r\n            this.drag = {\r\n                type: 'hs',\r\n                y: e.clientY,\r\n                h1: this.data.grid1.height,\r\n                h2: this.data.grid2.height\r\n            }\r\n            Utils.add_style('disable-user-select', `body * {\r\n                user-select: none;\r\n            }\r\n            .trading-vue-chart {\r\n                pointer-events: none;\r\n            }`)\r\n        },\r\n        hs_mouseup(e) {\r\n            this.drag = null\r\n            Utils.rem_style('disable-user-select')\r\n        },\r\n        hs_mousemove(e) {\r\n            if (this.drag) {\r\n                let off = e.clientY - this.drag.y\r\n                let new_h1 = this.drag.h1 + off\r\n                let new_h2 = this.drag.h2 - off\r\n                if (new_h1 > this.MIN_HEIGHT &&\r\n                    new_h2 > this.MIN_HEIGHT) {\r\n                    this.data.grid1.height = new_h1\r\n                    this.data.grid2.height = new_h2\r\n                }\r\n                this.main.calc_heights()\r\n            }\r\n        },\r\n        hs_mouseleave(e) {\r\n            this.drag = null\r\n            Utils.rem_style('disable-user-select')\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style scoped>\r\n.h-splitter {\r\n    position: absolute;\r\n    left: 0;\r\n    height: 5px;\r\n    margin-top: -2px;\r\n    width: 100%;\r\n    z-index: 1;\r\n    background-color: #3ee4afb5;\r\n    opacity: 0;\r\n    pointer-events: all;\r\n}\r\n.h-splitter:hover {\r\n    cursor: row-resize;\r\n    opacity: 1;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window.add-win[data-v-53408ac7] {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.add-win-list[data-v-53408ac7] {\n    height: 300px;\n    overflow-x: hidden;\n    overflow-y: auto;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n/* Hide scrollbar for Chrome, Safari and Opera */\n.add-win-list[data-v-53408ac7]::-webkit-scrollbar {\n  display: none;\n}\n\n/* Hide scrollbar for IE, Edge and Firefox */\n.add-win-list[data-v-53408ac7] {\n  -ms-overflow-style: none;  /* IE and Edge */\n  scrollbar-width: none;  /* Firefox */\n}\n.add-win-item[data-v-53408ac7] {\n    color: #ffffff88;\n    width: 100%;\n    padding: 5px;\n    cursor: pointer;\n}\n.add-win-item[data-v-53408ac7]:hover {\n    background: #88888822;\n    color: #ffffffff;\n}\n.add-win-item-desc[data-v-53408ac7] {\n    color: #ffffff33;\n    margin-left: 3px;\n}\n.add-win-item:hover .add-win-item-desc[data-v-53408ac7] {\n    color: #ffffff44;\n}\n.add-win-empty[data-v-53408ac7] {\n    opacity: 0.5;\n}\n", "",{"version":3,"sources":["webpack://./src/extensions/legend-buttons/AddWin.vue"],"names":[],"mappings":";AAgDA;IACA,oBAAA;IACA,2BAAA;AACA;AACA;IACA,aAAA;IACA,kBAAA;IACA,gBAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;AACA;AACA,gDAAA;AACA;EACA,aAAA;AACA;;AAEA,4CAAA;AACA;EACA,wBAAA,GAAA,gBAAA;EACA,qBAAA,GAAA,YAAA;AACA;AACA;IACA,gBAAA;IACA,WAAA;IACA,YAAA;IACA,eAAA;AACA;AACA;IACA,qBAAA;IACA,gBAAA;AACA;AACA;IACA,gBAAA;IACA,gBAAA;AACA;AACA;IACA,gBAAA;AACA;AACA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <window title=\"Add Indicator\" class=\"add-win\" :tv=\"tv\" @close=\"on_close\">\n        <div class=\"add-win-list\">\n            <div v-for=\"ov of ovs\" class=\"add-win-item\" @click=\"on_click(ov.name)\">\n                <span>{{ ov.name }}</span>\n                <span class=\"add-win-item-desc\">\n                    {{ ov.methods.meta_info().desc }}\n                </span>\n            </div>\n        </div>\n    </window>\n</template>\n<script>\n\nimport Window from '../../components/Window.vue'\n\nexport default {\n    name: 'AddWin',\n    components: { Window },\n    props: ['id', 'main', 'dc', 'tv', 'data'],\n    data() {\n        return {\n            ovs: this.tv.overlays.filter(x => x.methods.calc)\n        }\n    },\n    computed: {\n        sett() {\n            return this.$props.data.ov.settings\n        }\n    },\n    mounted() {\n    },\n    methods: {\n        on_close() {\n            this.$props.main.remove_widget(this.$props.id)\n        },\n        on_click(name) {\n            this.on_close()\n            this.main.add_overlay({\n                side: this.data.type,\n                index: this.data.index,\n                type: name\n            })\n        }\n    }\n}\n</script>\n<style scoped>\n.tvjs-x-window.add-win {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.add-win-list {\n    height: 300px;\n    overflow-x: hidden;\n    overflow-y: auto;\n    user-select: none;\n}\n/* Hide scrollbar for Chrome, Safari and Opera */\n.add-win-list::-webkit-scrollbar {\n  display: none;\n}\n\n/* Hide scrollbar for IE, Edge and Firefox */\n.add-win-list {\n  -ms-overflow-style: none;  /* IE and Edge */\n  scrollbar-width: none;  /* Firefox */\n}\n.add-win-item {\n    color: #ffffff88;\n    width: 100%;\n    padding: 5px;\n    cursor: pointer;\n}\n.add-win-item:hover {\n    background: #88888822;\n    color: #ffffffff;\n}\n.add-win-item-desc {\n    color: #ffffff33;\n    margin-left: 3px;\n}\n.add-win-item:hover .add-win-item-desc {\n    color: #ffffff44;\n}\n.add-win-empty {\n    opacity: 0.5;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window.sett-win[data-v-5d223b0e] {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.sett-win-item[data-v-5d223b0e] {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-content: center;\n    align-items: center;\n}\n.sett-win-item label[data-v-5d223b0e] {\n    min-width: 80px;\n    color: #35a776;\n}\n.sett-win-empty[data-v-5d223b0e] {\n    opacity: 0.5;\n}\n", "",{"version":3,"sources":["webpack://./src/extensions/settings-win/SettingsWin.vue"],"names":[],"mappings":";AAsDA;IACA,oBAAA;IACA,2BAAA;AACA;AACA;IACA,aAAA;IACA,mBAAA;IACA,iBAAA;IACA,2BAAA;IACA,qBAAA;IACA,mBAAA;AACA;AACA;IACA,eAAA;IACA,cAAA;AACA;AACA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <window :title=\"data.ov.name\" class=\"sett-win\" :tv=\"tv\" @close=\"on_close\">\n        <div v-for=\"k in settlist\" class=\"sett-win-item\">\n            <label>{{ s2d(k) }}</label>\n            <std-input :value=\"sett[k]\" @input=\"update_sett(k, $event)\" />\n        </div>\n        <span v-if=\"!settlist.length\" class=\"sett-win-empty\">\n            <i>No script settings</i>\n        </span>\n    </window>\n</template>\n<script>\n\nimport Window from '../../components/Window.vue'\nimport StdInput from '../../components/StdInput.vue'\nimport Utils from './utils.js'\n\nexport default {\n    name: 'SettingsWin',\n    components: { Window, StdInput },\n    props: ['id', 'main', 'dc', 'tv', 'data'],\n    computed: {\n        sett() {\n            return this.$props.data.ov.settings\n        },\n        settlist() {\n            return Object.keys(this.sett).filter(x =>\n                x[0] !== '$' && this.sett.$props &&\n                this.sett.$props.includes(x))\n        }\n    },\n    mounted() {\n    },\n    methods: {\n        s2d(str) {\n            return Utils.sett2desc(str)\n        },\n        on_close() {\n            this.$props.main.remove_widget(this.$props.id)\n        },\n        update_sett(k, val) {\n            let dcid = this.$props.data.ov.id\n\n            let valN = parseFloat(val)\n            if (valN !== valN) valN = val\n\n            this.$props.dc.merge(`${dcid}.settings`,\n                { [k]: valN }\n            )\n        }\n    }\n}\n</script>\n<style scoped>\n.tvjs-x-window.sett-win {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.sett-win-item {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-content: center;\n    align-items: center;\n}\n.sett-win-item label {\n    min-width: 80px;\n    color: #35a776;\n}\n.sett-win-empty {\n    opacity: 0.5;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js":
/*!******************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-ratings.scss":
/*!***************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-ratings.scss ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-sliders.scss":
/*!***************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-sliders.scss ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-sweet-alerts.scss":
/*!********************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-sweet-alerts.scss ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-swiper.scss":
/*!**************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-swiper.scss ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-toastr.scss":
/*!**************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-toastr.scss ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-tour.scss":
/*!************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-tour.scss ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-tree.scss":
/*!************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-tree.scss ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-file-uploader.scss":
/*!*******************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-file-uploader.scss ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-number-input.scss":
/*!******************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-number-input.scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-quill-editor.scss":
/*!******************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-quill-editor.scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-validation.scss":
/*!****************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-validation.scss ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-wizard.scss":
/*!************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-wizard.scss ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/pickers/form-flat-pickr.scss":
/*!************************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/pickers/form-flat-pickr.scss ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/pickers/form-pickadate.scss":
/*!***********************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/pickers/form-pickadate.scss ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/maps/map-leaflet.scss":
/*!***********************************************************!*\
  !*** ./resources/scss/base/plugins/maps/map-leaflet.scss ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/ui/coming-soon.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/plugins/ui/coming-soon.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-calendar.scss":
/*!*****************************************************!*\
  !*** ./resources/scss/base/pages/app-calendar.scss ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-chat-list.scss":
/*!******************************************************!*\
  !*** ./resources/scss/base/pages/app-chat-list.scss ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-chat.scss":
/*!*************************************************!*\
  !*** ./resources/scss/base/pages/app-chat.scss ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-ecommerce-details.scss":
/*!**************************************************************!*\
  !*** ./resources/scss/base/pages/app-ecommerce-details.scss ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-ecommerce.scss":
/*!******************************************************!*\
  !*** ./resources/scss/base/pages/app-ecommerce.scss ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-email.scss":
/*!**************************************************!*\
  !*** ./resources/scss/base/pages/app-email.scss ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-file-manager.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/pages/app-file-manager.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-invoice-list.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/pages/app-invoice-list.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-invoice-print.scss":
/*!**********************************************************!*\
  !*** ./resources/scss/base/pages/app-invoice-print.scss ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-invoice.scss":
/*!****************************************************!*\
  !*** ./resources/scss/base/pages/app-invoice.scss ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-kanban.scss":
/*!***************************************************!*\
  !*** ./resources/scss/base/pages/app-kanban.scss ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-todo.scss":
/*!*************************************************!*\
  !*** ./resources/scss/base/pages/app-todo.scss ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/authentication.scss":
/*!*******************************************************!*\
  !*** ./resources/scss/base/pages/authentication.scss ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/dashboard-ecommerce.scss":
/*!************************************************************!*\
  !*** ./resources/scss/base/pages/dashboard-ecommerce.scss ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/modal-create-app.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/pages/modal-create-app.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-blog.scss":
/*!**************************************************!*\
  !*** ./resources/scss/base/pages/page-blog.scss ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-coming-soon.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/pages/page-coming-soon.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-faq.scss":
/*!*************************************************!*\
  !*** ./resources/scss/base/pages/page-faq.scss ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-knowledge-base.scss":
/*!************************************************************!*\
  !*** ./resources/scss/base/pages/page-knowledge-base.scss ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-misc.scss":
/*!**************************************************!*\
  !*** ./resources/scss/base/pages/page-misc.scss ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-pricing.scss":
/*!*****************************************************!*\
  !*** ./resources/scss/base/pages/page-pricing.scss ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-profile.scss":
/*!*****************************************************!*\
  !*** ./resources/scss/base/pages/page-profile.scss ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/ui-feather.scss":
/*!***************************************************!*\
  !*** ./resources/scss/base/pages/ui-feather.scss ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/colors/palette-gradient.scss":
/*!***************************************************************!*\
  !*** ./resources/scss/base/core/colors/palette-gradient.scss ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/colors/palette-noui.scss":
/*!***********************************************************!*\
  !*** ./resources/scss/base/core/colors/palette-noui.scss ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/colors/palette-variables.scss":
/*!****************************************************************!*\
  !*** ./resources/scss/base/core/colors/palette-variables.scss ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/menu/menu-types/horizontal-menu.scss":
/*!***********************************************************************!*\
  !*** ./resources/scss/base/core/menu/menu-types/horizontal-menu.scss ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/menu/menu-types/vertical-menu.scss":
/*!*********************************************************************!*\
  !*** ./resources/scss/base/core/menu/menu-types/vertical-menu.scss ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/menu/menu-types/vertical-overlay-menu.scss":
/*!*****************************************************************************!*\
  !*** ./resources/scss/base/core/menu/menu-types/vertical-overlay-menu.scss ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/mixins/alert.scss":
/*!****************************************************!*\
  !*** ./resources/scss/base/core/mixins/alert.scss ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/mixins/hex2rgb.scss":
/*!******************************************************!*\
  !*** ./resources/scss/base/core/mixins/hex2rgb.scss ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/mixins/main-menu-mixin.scss":
/*!**************************************************************!*\
  !*** ./resources/scss/base/core/mixins/main-menu-mixin.scss ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/mixins/transitions.scss":
/*!**********************************************************!*\
  !*** ./resources/scss/base/core/mixins/transitions.scss ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/themes/dark-layout.scss":
/*!*****************************************************!*\
  !*** ./resources/scss/base/themes/dark-layout.scss ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/themes/bordered-layout.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/themes/bordered-layout.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/themes/semi-dark-layout.scss":
/*!**********************************************************!*\
  !*** ./resources/scss/base/themes/semi-dark-layout.scss ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/core.scss":
/*!**********************************!*\
  !*** ./resources/scss/core.scss ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/overrides.scss":
/*!***************************************!*\
  !*** ./resources/scss/overrides.scss ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/custom-rtl.scss":
/*!*********************************************!*\
  !*** ./resources/scss/base/custom-rtl.scss ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/assets/scss/style-rtl.scss":
/*!**********************************************!*\
  !*** ./resources/assets/scss/style-rtl.scss ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/assets/scss/style.scss":
/*!******************************************!*\
  !*** ./resources/assets/scss/style.scss ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/charts/chart-apex.scss":
/*!************************************************************!*\
  !*** ./resources/scss/base/plugins/charts/chart-apex.scss ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-context-menu.scss":
/*!********************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-context-menu.scss ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-drag-drop.scss":
/*!*****************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-drag-drop.scss ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-media-player.scss":
/*!********************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-media-player.scss ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css&":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css& ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Main.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/trading-vue-js/dist/trading-vue.js":
/*!*********************************************************!*\
  !*** ./node_modules/trading-vue-js/dist/trading-vue.js ***!
  \*********************************************************/
/***/ ((module) => {

/*!
 * TradingVue.JS - v1.0.2 - Thu Mar 18 2021
 *     https://github.com/tvjsx/trading-vue-js
 *     Copyright (c) 2019 C451 Code's All Right;
 *     Licensed under the MIT license
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 757:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_694__) => {

module.exports = __nested_webpack_require_694__(666);


/***/ }),

/***/ 546:
/***/ ((module) => {

/**
 * Utility compare functions
 */

module.exports = {

    /**
     * Compare two numbers.
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    numcmp: function (a, b) {
        return a - b;
    },

    /**
     * Compare two strings.
     *
     * @param {Number|String} a
     * @param {Number|String} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    strcmp: function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

};


/***/ }),

/***/ 678:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1415__) => {

/**
 * Indexed Array Binary Search module
 */

/**
 * Dependencies
 */
var util = __nested_webpack_require_1415__(500),
    cmp = __nested_webpack_require_1415__(546),
    bin = __nested_webpack_require_1415__(101);

/**
 * Module interface definition
 */
module.exports = IndexedArray;

/**
 * Indexed Array constructor
 *
 * It loads the array data, defines the index field and the comparison function
 * to be used.
 *
 * @param {Array} data is an array of objects
 * @param {String} index is the object's property used to search the array
 */
function IndexedArray(data, index) {

    // is data sortable array or array-like object?
    if (!util.isSortableArrayLike(data))
        throw new Error("Invalid data");

    // is index a valid property?
    if (!index || data.length > 0 && !(index in data[0]))
        throw new Error("Invalid index");

    // data array
    this.data = data;

    // name of the index property
    this.index = index;

    // set index boundary values
    this.setBoundaries();

    // default comparison function
    this.compare = typeof this.minv === "number" ? cmp.numcmp : cmp.strcmp;

    // default search function
    this.search = bin.search;

    // cache of index values to array positions
    // each value stores an object as { found: true|false, index: array-index }
    this.valpos = {};

    // cursor and adjacent positions
    this.cursor = null;
    this.nextlow = null;
    this.nexthigh = null;
}

/**
 * Set the comparison function
 *
 * @param {Function} fn to compare index values that returnes 1, 0, -1
 */
IndexedArray.prototype.setCompare = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.compare = fn;
    return this;
};

/**
 * Set the search function
 *
 * @param {Function} fn to search index values in the array of objects
 */
IndexedArray.prototype.setSearch = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.search = fn;
    return this;
};

/**
 * Sort the data array by its index property
 */
IndexedArray.prototype.sort = function () {
    var self = this,
        index = this.index;

    // sort the array
    this.data.sort(function (a, b) {
        return self.compare(a[index], b[index]);
    });

    // recalculate boundary values
    this.setBoundaries();

    return this;
};

/**
 * Inspect and set the boundaries of the internal data array
 */
IndexedArray.prototype.setBoundaries = function () {
    var data = this.data,
        index = this.index;

    this.minv = data.length && data[0][index];
    this.maxv = data.length && data[data.length - 1][index];

    return this;
};

/**
 * Get the position of the object corresponding to the given index
 *
 * @param {Number|String} index is the id of the requested object
 * @returns {Number} the position of the object in the array
 */
IndexedArray.prototype.fetch = function (value) {
    // check data has objects
    if (this.data.length === 0) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = null;
        return this;
    }

    // check the request is within range
    if (this.compare(value, this.minv) === -1) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = 0;
        return this;
    }
    if (this.compare(value, this.maxv) === 1) {
        this.cursor = null;
        this.nextlow = this.data.length - 1;
        this.nexthigh = null;
        return this;
    }

    var valpos = this.valpos,
        pos = valpos[value];

    // if the request is memorized, just give it back
    if (pos) {
        if (pos.found) {
            this.cursor = pos.index;
            this.nextlow = null;
            this.nexthigh = null;
        } else {
            this.cursor = null;
            this.nextlow = pos.prev;
            this.nexthigh = pos.next;
        }
        return this;
    }

    // if not, do the search
    var result = this.search.call(this, value);
    this.cursor = result.index;
    this.nextlow = result.prev;
    this.nexthigh = result.next;
    return this;
};

/**
 * Get the object corresponding to the given index
 *
 * When no value is given, the function will default to the last fetched item.
 *
 * @param {Number|String} [optional] index is the id of the requested object
 * @returns {Object} the found object or null
 */
IndexedArray.prototype.get = function (value) {
    if (value)
        this.fetch(value);

    var pos = this.cursor;
    return pos !== null ? this.data[pos] : null;
};

/**
 * Get an slice of the data array
 *
 * Boundaries have to be in order.
 *
 * @param {Number|String} begin index is the id of the requested object
 * @param {Number|String} end index is the id of the requested object
 * @returns {Object} the slice of data array or []
 */
IndexedArray.prototype.getRange = function (begin, end) {
    // check if boundaries are in order
    if (this.compare(begin, end) === 1) {
        return [];
    }

    // fetch start and default to the next index above
    this.fetch(begin);
    var start = this.cursor || this.nexthigh;

    // fetch finish and default to the next index below
    this.fetch(end);
    var finish = this.cursor || this.nextlow;

    // if any boundary is not set, return no range
    if (start === null || finish === null) {
        return [];
    }

    // return range
    return this.data.slice(start, finish + 1);
};


/***/ }),

/***/ 101:
/***/ ((module) => {

/**
 * Binary search implementation
 */

/**
 * Main search recursive function
 */
function loop(data, min, max, index, valpos) {

    // set current position as the middle point between min and max
    var curr = (max + min) >>> 1;

    // compare current index value with the one we are looking for
    var diff = this.compare(data[curr][this.index], index);

    // found?
    if (!diff) {
        return valpos[index] = {
            "found": true,
            "index": curr,
            "prev": null,
            "next": null
        };
    }

    // no more positions available?
    if (min >= max) {
        return valpos[index] = {
            "found": false,
            "index": null,
            "prev": (diff < 0) ? max : max - 1,
            "next": (diff < 0) ? max + 1 : max
        };
    }

    // continue looking for index in one of the remaining array halves
    // current position can be skept as index is not there...
    if (diff > 0)
        return loop.call(this, data, min, curr - 1, index, valpos);
    else
        return loop.call(this, data, curr + 1, max, index, valpos);
}

/**
 * Search bootstrap
 * The function has to be executed in the context of the IndexedArray object
 */
function search(index) {
    var data = this.data;
    return loop.call(this, data, 0, data.length - 1, index, this.valpos);
}

/**
 * Export search function
 */
module.exports.search = search;


/***/ }),

/***/ 500:
/***/ ((module) => {

/**
 * Utils module
 */

/**
 * Check if an object is an array-like object
 *
 * @credit Javascript: The Definitive Guide, O'Reilly, 2011
 */
function isArrayLike(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        isFinite(o.length) &&                // o.length is a finite number
        o.length >= 0 &&                     // o.length is non-negative
        o.length === Math.floor(o.length) && // o.length is an integer
        o.length < 4294967296)               // o.length < 2^32
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for the existence of the sort function in the object
 */
function isSortable(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        typeof o.sort === "function")        // o.sort is a function
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for sortable-array-like objects
 */
module.exports.isSortableArrayLike = function (o) {
    return isArrayLike(o) && isSortable(o);
};


/***/ }),

/***/ 851:
/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_9759__) => {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_9759__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_9759__.d(__webpack_exports__, {
  "Candle": () => (/* reexport */ CandleExt),
  "Constants": () => (/* reexport */ constants),
  "DataCube": () => (/* reexport */ DataCube),
  "Interface": () => (/* reexport */ mixins_interface),
  "Overlay": () => (/* reexport */ overlay),
  "Tool": () => (/* reexport */ tool),
  "TradingVue": () => (/* reexport */ TradingVue),
  "Utils": () => (/* reexport */ utils),
  "Volbar": () => (/* reexport */ VolbarExt),
  "default": () => (/* binding */ src),
  "layout_cnv": () => (/* reexport */ layout_cnv),
  "layout_vol": () => (/* reexport */ layout_vol),
  "primitives": () => (/* binding */ primitives)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=template&id=235c0ade&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "trading-vue",
      style: {
        color: this.chart_props.colors.text,
        font: this.font_comp,
        width: this.width + "px",
        height: this.height + "px"
      },
      attrs: { id: _vm.id },
      on: { mousedown: _vm.mousedown, mouseleave: _vm.mouseleave }
    },
    [
      _vm.toolbar
        ? _c(
            "toolbar",
            _vm._b(
              {
                ref: "toolbar",
                attrs: { config: _vm.chart_config },
                on: { "custom-event": _vm.custom_event }
              },
              "toolbar",
              _vm.chart_props,
              false
            )
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.controllers.length
        ? _c("widgets", {
            ref: "widgets",
            attrs: {
              map: _vm.ws,
              width: _vm.width,
              height: _vm.height,
              tv: this,
              dc: _vm.data
            }
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "chart",
        _vm._b(
          {
            key: _vm.reset,
            ref: "chart",
            attrs: { tv_id: _vm.id, config: _vm.chart_config },
            on: {
              "custom-event": _vm.custom_event,
              "range-changed": _vm.range_changed,
              "legend-button-click": _vm.legend_button
            }
          },
          "chart",
          _vm.chart_props,
          false
        )
      ),
      _vm._v(" "),
      _c(
        "transition",
        { attrs: { name: "tvjs-drift" } },
        [
          _vm.tip
            ? _c("the-tip", {
                attrs: { data: _vm.tip },
                on: {
                  "remove-me": function($event) {
                    _vm.tip = null
                  }
                }
              })
            : _vm._e()
        ],
        1
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=template&id=235c0ade&

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./src/stuff/constants.js
var SECOND = 1000;
var MINUTE = SECOND * 60;
var MINUTE3 = MINUTE * 3;
var MINUTE5 = MINUTE * 5;
var MINUTE15 = MINUTE * 15;
var MINUTE30 = MINUTE * 30;
var HOUR = MINUTE * 60;
var HOUR4 = HOUR * 4;
var HOUR12 = HOUR * 12;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = WEEK * 4;
var YEAR = DAY * 365;
var MONTHMAP = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; // Grid time steps

var TIMESCALES = [YEAR * 10, YEAR * 5, YEAR * 3, YEAR * 2, YEAR, MONTH * 6, MONTH * 4, MONTH * 3, MONTH * 2, MONTH, DAY * 15, DAY * 10, DAY * 7, DAY * 5, DAY * 3, DAY * 2, DAY, HOUR * 12, HOUR * 6, HOUR * 3, HOUR * 1.5, HOUR, MINUTE30, MINUTE15, MINUTE * 10, MINUTE5, MINUTE * 2, MINUTE]; // Grid $ steps

var $SCALES = [0.05, 0.1, 0.2, 0.25, 0.5, 0.8, 1, 2, 5];
var ChartConfig = {
  SBMIN: 60,
  // Minimal sidebar px
  SBMAX: Infinity,
  // Max sidebar, px
  TOOLBAR: 57,
  // Toolbar width px
  TB_ICON: 25,
  // Toolbar icon size px
  TB_ITEM_M: 6,
  // Toolbar item margin px
  TB_ICON_BRI: 1,
  // Toolbar icon brightness
  TB_ICON_HOLD: 420,
  // ms, wait to expand
  TB_BORDER: 1,
  // Toolbar border px
  TB_B_STYLE: 'dotted',
  // Toolbar border style
  TOOL_COLL: 7,
  // Tool collision threshold
  EXPAND: 0.15,
  // %/100 of range
  CANDLEW: 0.6,
  // %/100 of step
  GRIDX: 100,
  // px
  GRIDY: 47,
  // px
  BOTBAR: 28,
  // px
  PANHEIGHT: 22,
  // px
  DEFAULT_LEN: 50,
  // candles
  MINIMUM_LEN: 5,
  // candles,
  MIN_ZOOM: 25,
  // candles
  MAX_ZOOM: 1000,
  // candles,
  VOLSCALE: 0.15,
  // %/100 of height
  UX_OPACITY: 0.9,
  // Ux background opacity
  ZOOM_MODE: 'tv',
  // 'tv' or 'tl'
  L_BTN_SIZE: 21,
  // Legend Button size, px
  L_BTN_MARGIN: '-6px 0 -6px 0',
  // css margin
  SCROLL_WHEEL: 'prevent' // 'pass', 'click'

};
ChartConfig.FONT = "11px -apple-system,BlinkMacSystemFont,\n    Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,\n    Fira Sans,Droid Sans,Helvetica Neue,\n    sans-serif";
var IB_TF_WARN = "When using IB mode you should specify " + "timeframe ('tf' filed in 'chart' object)," + "otherwise you can get an unexpected behaviour";
var MAP_UNIT = {
  "1s": SECOND,
  "5s": SECOND * 5,
  "10s": SECOND * 10,
  "20s": SECOND * 20,
  "30s": SECOND * 30,
  "1m": MINUTE,
  "3m": MINUTE3,
  "5m": MINUTE5,
  "15m": MINUTE15,
  "30m": MINUTE30,
  "1H": HOUR,
  "2H": HOUR * 2,
  "3H": HOUR * 3,
  "4H": HOUR4,
  "12H": HOUR12,
  "1D": DAY,
  "1W": WEEK,
  "1M": MONTH,
  "1Y": YEAR
};
/* harmony default export */ const constants = ({
  SECOND: SECOND,
  MINUTE: MINUTE,
  MINUTE5: MINUTE5,
  MINUTE15: MINUTE15,
  MINUTE30: MINUTE30,
  HOUR: HOUR,
  HOUR4: HOUR4,
  DAY: DAY,
  WEEK: WEEK,
  MONTH: MONTH,
  YEAR: YEAR,
  MONTHMAP: MONTHMAP,
  TIMESCALES: TIMESCALES,
  $SCALES: $SCALES,
  ChartConfig: ChartConfig,
  map_unit: MAP_UNIT,
  IB_TF_WARN: IB_TF_WARN
});
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Chart.vue?vue&type=template&id=4d06a4de&
var Chartvue_type_template_id_4d06a4de_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-chart", style: _vm.styles },
    [
      _c("keyboard", { ref: "keyboard" }),
      _vm._v(" "),
      _vm._l(this._layout.grids, function(grid, i) {
        return _c("grid-section", {
          key: grid.id,
          ref: "sec",
          refInFor: true,
          attrs: { common: _vm.section_props(i), grid_id: i },
          on: {
            "register-kb-listener": _vm.register_kb,
            "remove-kb-listener": _vm.remove_kb,
            "range-changed": _vm.range_changed,
            "cursor-changed": _vm.cursor_changed,
            "cursor-locked": _vm.cursor_locked,
            "sidebar-transform": _vm.set_ytransform,
            "layer-meta-props": _vm.layer_meta_props,
            "custom-event": _vm.emit_custom_event,
            "legend-button-click": _vm.legend_button_click
          }
        })
      }),
      _vm._v(" "),
      _c(
        "botbar",
        _vm._b(
          { attrs: { shaders: _vm.shaders, timezone: _vm.timezone } },
          "botbar",
          _vm.botbar_props,
          false
        )
      )
    ],
    2
  )
}
var Chartvue_type_template_id_4d06a4de_staticRenderFns = []
Chartvue_type_template_id_4d06a4de_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Chart.vue?vue&type=template&id=4d06a4de&

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
;// CONCATENATED MODULE: ./src/stuff/context.js
// Canvas context for text measurments
function Context($p) {
  var el = document.createElement('canvas');
  var ctx = el.getContext("2d");
  ctx.font = $p.font;
  return ctx;
}

/* harmony default export */ const context = (Context);
// EXTERNAL MODULE: ./node_modules/arrayslicer/lib/index.js
var lib = __nested_webpack_require_9759__(678);
var lib_default = /*#__PURE__*/__nested_webpack_require_9759__.n(lib);
;// CONCATENATED MODULE: ./src/stuff/utils.js



/* harmony default export */ const utils = ({
  clamp: function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
  },
  add_zero: function add_zero(i) {
    if (i < 10) {
      i = "0" + i;
    }

    return i;
  },
  // Start of the day (zero millisecond)
  day_start: function day_start(t) {
    var start = new Date(t);
    return start.setUTCHours(0, 0, 0, 0);
  },
  // Start of the month
  month_start: function month_start(t) {
    var date = new Date(t);
    return Date.UTC(date.getFullYear(), date.getMonth(), 1);
  },
  // Start of the year
  year_start: function year_start(t) {
    return Date.UTC(new Date(t).getFullYear());
  },
  get_year: function get_year(t) {
    if (!t) return undefined;
    return new Date(t).getUTCFullYear();
  },
  get_month: function get_month(t) {
    if (!t) return undefined;
    return new Date(t).getUTCMonth();
  },
  // Nearest in array
  nearest_a: function nearest_a(x, array) {
    var dist = Infinity;
    var val = null;
    var index = -1;

    for (var i = 0; i < array.length; i++) {
      var xi = array[i];

      if (Math.abs(xi - x) < dist) {
        dist = Math.abs(xi - x);
        val = xi;
        index = i;
      }
    }

    return [index, val];
  },
  round: function round(num, decimals) {
    if (decimals === void 0) {
      decimals = 8;
    }

    return parseFloat(num.toFixed(decimals));
  },
  // Strip? No, it's ugly floats in js
  strip: function strip(number) {
    return parseFloat(parseFloat(number).toPrecision(12));
  },
  get_day: function get_day(t) {
    return t ? new Date(t).getDate() : null;
  },
  // Update array keeping the same reference
  overwrite: function overwrite(arr, new_arr) {
    arr.splice.apply(arr, [0, arr.length].concat(_toConsumableArray(new_arr)));
  },
  // Copy layout in reactive way
  copy_layout: function copy_layout(obj, new_obj) {
    for (var k in obj) {
      if (Array.isArray(obj[k])) {
        // (some offchart indicators are added/removed)
        // we need to update layout in a reactive way
        if (obj[k].length !== new_obj[k].length) {
          this.overwrite(obj[k], new_obj[k]);
          continue;
        }

        for (var m in obj[k]) {
          Object.assign(obj[k][m], new_obj[k][m]);
        }
      } else {
        Object.assign(obj[k], new_obj[k]);
      }
    }
  },
  // Detects candles interval
  detect_interval: function detect_interval(ohlcv) {
    var len = Math.min(ohlcv.length - 1, 99);
    var min = Infinity;
    ohlcv.slice(0, len).forEach(function (x, i) {
      var d = ohlcv[i + 1][0] - x[0];
      if (d === d && d < min) min = d;
    }); // This saves monthly chart from being awkward

    if (min >= constants.MONTH && min <= constants.DAY * 30) {
      return constants.DAY * 31;
    }

    return min;
  },
  // Gets numberic part of overlay id (e.g 'EMA_1' = > 1)
  get_num_id: function get_num_id(id) {
    return parseInt(id.split('_').pop());
  },
  // Fast filter. Really fast, like 10X
  fast_filter: function fast_filter(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];

    try {
      var ia = new (lib_default())(arr, "0");
      var res = ia.getRange(t1, t2);
      var i0 = ia.valpos[t1].next;
      return [res, i0];
    } catch (e) {
      // Something wrong with fancy slice lib
      // Fast fix: fallback to filter
      return [arr.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }), 0];
    }
  },
  // Fast filter (index-based)
  fast_filter_i: function fast_filter_i(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];
    var i1 = Math.floor(t1);
    if (i1 < 0) i1 = 0;
    var i2 = Math.floor(t2 + 1);
    var res = arr.slice(i1, i2);
    return [res, i1];
  },
  // Nearest indexes (left and right)
  fast_nearest: function fast_nearest(arr, t1) {
    var ia = new (lib_default())(arr, "0");
    ia.fetch(t1);
    return [ia.nextlow, ia.nexthigh];
  },
  now: function now() {
    return new Date().getTime();
  },
  pause: function pause(delay) {
    return new Promise(function (rs, rj) {
      return setTimeout(rs, delay);
    });
  },
  // Limit crazy wheel delta values
  smart_wheel: function smart_wheel(delta) {
    var abs = Math.abs(delta);

    if (abs > 500) {
      return (200 + Math.log(abs)) * Math.sign(delta);
    }

    return delta;
  },
  // Parse the original mouse event to find deltaX
  get_deltaX: function get_deltaX(event) {
    return event.originalEvent.deltaX / 12;
  },
  // Parse the original mouse event to find deltaY
  get_deltaY: function get_deltaY(event) {
    return event.originalEvent.deltaY / 12;
  },
  // Apply opacity to a hex color
  apply_opacity: function apply_opacity(c, op) {
    if (c.length === 7) {
      var n = Math.floor(op * 255);
      n = this.clamp(n, 0, 255);
      c += n.toString(16);
    }

    return c;
  },
  // Parse timeframe or return value in ms
  parse_tf: function parse_tf(smth) {
    if (typeof smth === 'string') {
      return constants.map_unit[smth];
    } else {
      return smth;
    }
  },
  // Detect index shift between the main data sub
  // and the overlay's sub (for IB-mode)
  index_shift: function index_shift(sub, data) {
    // Find the second timestamp (by value)
    if (!data.length) return 0;
    var first = data[0][0];
    var second;

    for (var i = 1; i < data.length; i++) {
      if (data[i][0] !== first) {
        second = data[i][0];
        break;
      }
    }

    for (var j = 0; j < sub.length; j++) {
      if (sub[j][0] === second) {
        return j - i;
      }
    }

    return 0;
  },
  // Fallback fix for Brave browser
  // https://github.com/brave/brave-browser/issues/1738
  measureText: function measureText(ctx, text, tv_id) {
    var m = ctx.measureTextOrg(text);

    if (m.width === 0) {
      var doc = document;
      var id = 'tvjs-measure-text';
      var el = doc.getElementById(id);

      if (!el) {
        var base = doc.getElementById(tv_id);
        el = doc.createElement("div");
        el.id = id;
        el.style.position = 'absolute';
        el.style.top = '-1000px';
        base.appendChild(el);
      }

      if (ctx.font) el.style.font = ctx.font;
      el.innerText = text.replace(/ /g, '.');
      return {
        width: el.offsetWidth
      };
    } else {
      return m;
    }
  },
  uuid: function uuid(temp) {
    if (temp === void 0) {
      temp = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    }

    return temp.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  },
  uuid2: function uuid2() {
    return this.uuid('xxxxxxxxxxxx');
  },
  // Delayed warning, f = condition lambda fn
  warn: function warn(f, text, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    setTimeout(function () {
      if (f()) console.warn(text);
    }, delay);
  },
  // Checks if script props updated
  // (and not style settings or something else)
  is_scr_props_upd: function is_scr_props_upd(n, prev) {
    var p = prev.find(function (x) {
      return x.v.$uuid === n.v.$uuid;
    });
    if (!p) return false;
    var props = n.p.settings.$props;
    if (!props) return false;
    return props.some(function (x) {
      return n.v[x] !== p.v[x];
    });
  },
  // Checks if it's time to make a script update
  // (based on execInterval in ms)
  delayed_exec: function delayed_exec(v) {
    if (!v.script || !v.script.execInterval) return true;
    var t = this.now();
    var dt = v.script.execInterval;

    if (!v.settings.$last_exec || t > v.settings.$last_exec + dt) {
      v.settings.$last_exec = t;
      return true;
    }

    return false;
  },
  // Format names such 'RSI, $length', where
  // length - is one of the settings
  format_name: function format_name(ov) {
    if (!ov.name) return undefined;
    var name = ov.name;

    for (var k in ov.settings || {}) {
      var val = ov.settings[k];
      var reg = new RegExp("\\$".concat(k), 'g');
      name = name.replace(reg, val);
    }

    return name;
  },
  // Default cursor mode
  xmode: function xmode() {
    return this.is_mobile ? 'explore' : 'default';
  },
  default_prevented: function default_prevented(event) {
    if (event.original) {
      return event.original.defaultPrevented;
    }

    return event.defaultPrevented;
  },
  // WTF with modern web development
  is_mobile: function (w) {
    return 'onorientationchange' in w && (!!navigator.maxTouchPoints || !!navigator.msMaxTouchPoints || 'ontouchstart' in w || w.DocumentTouch && document instanceof w.DocumentTouch);
  }(typeof window !== 'undefined' ? window : {})
});
;// CONCATENATED MODULE: ./src/stuff/math.js
// Math/Geometry
/* harmony default export */ const math = ({
  // Distance from point to line
  // p1 = point, (p2, p3) = line
  point2line: function point2line(p1, p2, p3) {
    var _this$tri = this.tri(p1, p2, p3),
        area = _this$tri.area,
        base = _this$tri.base;

    return Math.abs(this.tri_h(area, base));
  },
  // Distance from point to segment
  // p1 = point, (p2, p3) = segment
  point2seg: function point2seg(p1, p2, p3) {
    var _this$tri2 = this.tri(p1, p2, p3),
        area = _this$tri2.area,
        base = _this$tri2.base; // Vector projection


    var proj = this.dot_prod(p1, p2, p3) / base; // Distance from left pin

    var l1 = Math.max(-proj, 0); // Distance from right pin

    var l2 = Math.max(proj - base, 0); // Normal

    var h = Math.abs(this.tri_h(area, base));
    return Math.max(h, l1, l2);
  },
  // Distance from point to ray
  // p1 = point, (p2, p3) = ray
  point2ray: function point2ray(p1, p2, p3) {
    var _this$tri3 = this.tri(p1, p2, p3),
        area = _this$tri3.area,
        base = _this$tri3.base; // Vector projection


    var proj = this.dot_prod(p1, p2, p3) / base; // Distance from left pin

    var l1 = Math.max(-proj, 0); // Normal

    var h = Math.abs(this.tri_h(area, base));
    return Math.max(h, l1);
  },
  tri: function tri(p1, p2, p3) {
    var area = this.area(p1, p2, p3);
    var dx = p3[0] - p2[0];
    var dy = p3[1] - p2[1];
    var base = Math.sqrt(dx * dx + dy * dy);
    return {
      area: area,
      base: base
    };
  },

  /* Area of triangle:
          p1
        /    \
      p2  _  p3
  */
  area: function area(p1, p2, p3) {
    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]);
  },
  // Triangle height
  tri_h: function tri_h(area, base) {
    return area / base;
  },
  // Dot product of (p2, p3) and (p2, p1)
  dot_prod: function dot_prod(p1, p2, p3) {
    var v1 = [p3[0] - p2[0], p3[1] - p2[1]];
    var v2 = [p1[0] - p2[0], p1[1] - p2[1]];
    return v1[0] * v2[0] + v1[1] * v2[1];
  },
  // Symmetrical log
  log: function log(x) {
    // TODO: log for small values
    return Math.sign(x) * Math.log(Math.abs(x) + 1);
  },
  // Symmetrical exp
  exp: function exp(x) {
    return Math.sign(x) * (Math.exp(Math.abs(x)) - 1);
  },
  // Middle line on log scale based on range & px height
  log_mid: function log_mid(r, h) {
    var log_hi = this.log(r[0]);
    var log_lo = this.log(r[1]);
    var px = h / 2;
    var gx = log_hi - px * (log_hi - log_lo) / h;
    return this.exp(gx);
  },
  // Return new adjusted range, based on the previous
  // range, new $_hi, target middle line
  re_range: function re_range(r1, hi2, mid) {
    var log_hi1 = this.log(r1[0]);
    var log_lo1 = this.log(r1[1]);
    var log_hi2 = this.log(hi2);
    var log_$ = this.log(mid);
    var W = (log_hi2 - log_$) * (log_hi1 - log_lo1) / (log_hi1 - log_$);
    return this.exp(log_hi2 - W);
  } // Return new adjusted range, based on the previous
  // range, new $_hi, target middle line + dy (shift)
  // WASTE

  /*range_shift(r1, hi2, mid, dy, h) {
      let log_hi1 = this.log(r1[0])
      let log_lo1 = this.log(r1[1])
      let log_hi2 = this.log(hi2)
      let log_$ = this.log(mid)
       let W = h * (log_hi2 - log_$) /
              (h * (log_hi1 - log_$) / (log_hi1 - log_lo1) + dy)
       return this.exp(log_hi2 - W)
   }*/

});
;// CONCATENATED MODULE: ./src/components/js/layout_fn.js
// Layout functional interface


/* harmony default export */ function layout_fn(self, range) {
  var ib = self.ti_map.ib;
  var dt = range[1] - range[0];
  var r = self.spacex / dt;
  var ls = self.grid.logScale || false;
  Object.assign(self, {
    // Time to screen coordinates
    t2screen: function t2screen(t) {
      if (ib) t = self.ti_map.smth2i(t);
      return Math.floor((t - range[0]) * r) - 0.5;
    },
    // $ to screen coordinates
    $2screen: function $2screen(y) {
      if (ls) y = math.log(y);
      return Math.floor(y * self.A + self.B) - 0.5;
    },
    // Time-axis nearest step
    t_magnet: function t_magnet(t) {
      if (ib) t = self.ti_map.smth2i(t);
      var cn = self.candles || self.master_grid.candles;
      var arr = cn.map(function (x) {
        return x.raw[0];
      });
      var i = utils.nearest_a(t, arr)[0];
      if (!cn[i]) return;
      return Math.floor(cn[i].x) - 0.5;
    },
    // Screen-Y to dollar value (or whatever)
    screen2$: function screen2$(y) {
      if (ls) return math.exp((y - self.B) / self.A);
      return (y - self.B) / self.A;
    },
    // Screen-X to timestamp
    screen2t: function screen2t(x) {
      // TODO: most likely Math.floor not needed
      // return Math.floor(range[0] + x / r)
      return range[0] + x / r;
    },
    // $-axis nearest step
    $_magnet: function $_magnet(price) {},
    // Nearest candlestick
    c_magnet: function c_magnet(t) {
      var cn = self.candles || self.master_grid.candles;
      var arr = cn.map(function (x) {
        return x.raw[0];
      });
      var i = utils.nearest_a(t, arr)[0];
      return cn[i];
    },
    // Nearest data points
    data_magnet: function data_magnet(t) {
      /* TODO: implement */
    }
  });
  return self;
}
;// CONCATENATED MODULE: ./src/components/js/log_scale.js
// Log-scale mode helpers
// TODO: all-negative numbers (sometimes wrong scaling)

/* harmony default export */ const log_scale = ({
  candle: function candle(self, mid, p, $p) {
    return {
      x: mid,
      w: self.px_step * $p.config.CANDLEW,
      o: Math.floor(math.log(p[1]) * self.A + self.B),
      h: Math.floor(math.log(p[2]) * self.A + self.B),
      l: Math.floor(math.log(p[3]) * self.A + self.B),
      c: Math.floor(math.log(p[4]) * self.A + self.B),
      raw: p
    };
  },
  expand: function expand(self, height) {
    // expand log scale
    var A = -height / (math.log(self.$_hi) - math.log(self.$_lo));
    var B = -math.log(self.$_hi) * A;
    var top = -height * 0.1;
    var bot = height * 1.1;
    self.$_hi = math.exp((top - B) / A);
    self.$_lo = math.exp((bot - B) / A);
  }
});
;// CONCATENATED MODULE: ./src/components/js/grid_maker.js






var grid_maker_TIMESCALES = constants.TIMESCALES,
    grid_maker_$SCALES = constants.$SCALES,
    grid_maker_WEEK = constants.WEEK,
    grid_maker_MONTH = constants.MONTH,
    grid_maker_YEAR = constants.YEAR,
    grid_maker_HOUR = constants.HOUR,
    grid_maker_DAY = constants.DAY;
var MAX_INT = Number.MAX_SAFE_INTEGER; // master_grid - ref to the master grid

function GridMaker(id, params, master_grid) {
  if (master_grid === void 0) {
    master_grid = null;
  }

  var sub = params.sub,
      interval = params.interval,
      range = params.range,
      ctx = params.ctx,
      $p = params.$p,
      layers_meta = params.layers_meta,
      height = params.height,
      y_t = params.y_t,
      ti_map = params.ti_map,
      grid = params.grid,
      timezone = params.timezone;
  var self = {
    ti_map: ti_map
  };
  var lm = layers_meta[id];
  var y_range_fn = null;
  var ls = grid.logScale;

  if (lm && Object.keys(lm).length) {
    // Gets last y_range fn()
    var yrs = Object.values(lm).filter(function (x) {
      return x.y_range;
    }); // The first y_range() determines the range

    if (yrs.length) y_range_fn = yrs[0].y_range;
  } // Calc vertical ($/) range


  function calc_$range() {
    if (!master_grid) {
      // $ candlestick range
      if (y_range_fn) {
        var _y_range_fn = y_range_fn(hi, lo),
            _y_range_fn2 = _slicedToArray(_y_range_fn, 2),
            hi = _y_range_fn2[0],
            lo = _y_range_fn2[1];
      } else {
        hi = -Infinity, lo = Infinity;

        for (var i = 0, n = sub.length; i < n; i++) {
          var x = sub[i];
          if (x[2] > hi) hi = x[2];
          if (x[3] < lo) lo = x[3];
        }
      }
    } else {
      // Offchart indicator range
      hi = -Infinity, lo = Infinity;

      for (var i = 0; i < sub.length; i++) {
        for (var j = 1; j < sub[i].length; j++) {
          var v = sub[i][j];
          if (v > hi) hi = v;
          if (v < lo) lo = v;
        }
      }

      if (y_range_fn) {
        var _y_range_fn3 = y_range_fn(hi, lo),
            _y_range_fn4 = _slicedToArray(_y_range_fn3, 3),
            hi = _y_range_fn4[0],
            lo = _y_range_fn4[1],
            exp = _y_range_fn4[2];
      }
    } // Fixed y-range in non-auto mode


    if (y_t && !y_t.auto && y_t.range) {
      self.$_hi = y_t.range[0];
      self.$_lo = y_t.range[1];
    } else {
      if (!ls) {
        exp = exp === false ? 0 : 1;
        self.$_hi = hi + (hi - lo) * $p.config.EXPAND * exp;
        self.$_lo = lo - (hi - lo) * $p.config.EXPAND * exp;
      } else {
        self.$_hi = hi;
        self.$_lo = lo;
        log_scale.expand(self, height);
      }

      if (self.$_hi === self.$_lo) {
        if (!ls) {
          self.$_hi *= 1.05; // Expand if height range === 0

          self.$_lo *= 0.95;
        } else {
          log_scale.expand(self, height);
        }
      }
    }
  }

  function calc_sidebar() {
    if (sub.length < 2) {
      self.prec = 0;
      self.sb = $p.config.SBMIN;
      return;
    } // TODO: improve sidebar width calculation
    // at transition point, when one precision is
    // replaced with another
    // Gets formated levels (their lengths),
    // calculates max and measures the sidebar length
    // from it:
    // TODO: add custom formatter f()


    self.prec = calc_precision(sub);
    var lens = [];
    lens.push(self.$_hi.toFixed(self.prec).length);
    lens.push(self.$_lo.toFixed(self.prec).length);
    var str = '0'.repeat(Math.max.apply(Math, lens)) + '    ';
    self.sb = ctx.measureText(str).width;
    self.sb = Math.max(Math.floor(self.sb), $p.config.SBMIN);
    self.sb = Math.min(self.sb, $p.config.SBMAX);
  } // Calculate $ precision for the Y-axis


  function calc_precision(data) {
    var max_r = 0,
        max_l = 0;
    var min = Infinity;
    var max = -Infinity; // Speed UP

    for (var i = 0, n = data.length; i < n; i++) {
      var x = data[i];
      if (x[1] > max) max = x[1];else if (x[1] < min) min = x[1];
    } // Get max lengths of integer and fractional parts


    [min, max].forEach(function (x) {
      // Fix undefined bug
      var str = x != null ? x.toString() : '';

      if (x < 0.000001) {
        // Parsing the exponential form. Gosh this
        // smells trickily
        var _str$split = str.split('e-'),
            _str$split2 = _slicedToArray(_str$split, 2),
            ls = _str$split2[0],
            rs = _str$split2[1];

        var _ls$split = ls.split('.'),
            _ls$split2 = _slicedToArray(_ls$split, 2),
            l = _ls$split2[0],
            r = _ls$split2[1];

        if (!r) r = '';
        r = {
          length: r.length + parseInt(rs) || 0
        };
      } else {
        var _str$split3 = str.split('.'),
            _str$split4 = _slicedToArray(_str$split3, 2),
            l = _str$split4[0],
            r = _str$split4[1];
      }

      if (r && r.length > max_r) {
        max_r = r.length;
      }

      if (l && l.length > max_l) {
        max_l = l.length;
      }
    }); // Select precision scheme depending
    // on the left and right part lengths
    //

    var even = max_r - max_r % 2 + 2;

    if (max_l === 1) {
      return Math.min(8, Math.max(2, even));
    }

    if (max_l <= 2) {
      return Math.min(4, Math.max(2, even));
    }

    return 2;
  }

  function calc_positions() {
    if (sub.length < 2) return;
    var dt = range[1] - range[0]; // A pixel space available to draw on (x-axis)

    self.spacex = $p.width - self.sb; // Candle capacity

    var capacity = dt / interval;
    self.px_step = self.spacex / capacity; // px / time ratio

    var r = self.spacex / dt;
    self.startx = (sub[0][0] - range[0]) * r; // Candle Y-transform: (A = scale, B = shift)

    if (!grid.logScale) {
      self.A = -height / (self.$_hi - self.$_lo);
      self.B = -self.$_hi * self.A;
    } else {
      self.A = -height / (math.log(self.$_hi) - math.log(self.$_lo));
      self.B = -math.log(self.$_hi) * self.A;
    }
  } // Select nearest good-loking t step (m is target scale)


  function time_step() {
    var k = ti_map.ib ? 60000 : 1;
    var xrange = (range[1] - range[0]) * k;
    var m = xrange * ($p.config.GRIDX / $p.width);
    var s = grid_maker_TIMESCALES;
    return utils.nearest_a(m, s)[1] / k;
  } // Select nearest good-loking $ step (m is target scale)


  function dollar_step() {
    var yrange = self.$_hi - self.$_lo;
    var m = yrange * ($p.config.GRIDY / height);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    var d = Math.pow(10, p);
    var s = grid_maker_$SCALES.map(function (x) {
      return x * d;
    }); // TODO: center the range (look at RSI for example,
    // it looks ugly when "80" is near the top)

    return utils.strip(utils.nearest_a(m, s)[1]);
  }

  function dollar_mult() {
    var mult_hi = dollar_mult_hi();
    var mult_lo = dollar_mult_lo();
    return Math.max(mult_hi, mult_lo);
  } // Price step multiplier (for the log-scale mode)


  function dollar_mult_hi() {
    var h = Math.min(self.B, height);
    if (h < $p.config.GRIDY) return 1;
    var n = h / $p.config.GRIDY; // target grid N

    var yrange = self.$_hi;

    if (self.$_lo > 0) {
      var yratio = self.$_hi / self.$_lo;
    } else {
      yratio = self.$_hi / 1; // TODO: small values
    }

    var m = yrange * ($p.config.GRIDY / h);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    return Math.pow(yratio, 1 / n);
  }

  function dollar_mult_lo() {
    var h = Math.min(height - self.B, height);
    if (h < $p.config.GRIDY) return 1;
    var n = h / $p.config.GRIDY; // target grid N

    var yrange = Math.abs(self.$_lo);

    if (self.$_hi < 0 && self.$_lo < 0) {
      var yratio = Math.abs(self.$_lo / self.$_hi);
    } else {
      yratio = Math.abs(self.$_lo) / 1;
    }

    var m = yrange * ($p.config.GRIDY / h);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    return Math.pow(yratio, 1 / n);
  }

  function grid_x() {
    // If this is a subgrid, no need to calc a timeline,
    // we just borrow it from the master_grid
    if (!master_grid) {
      self.t_step = time_step();
      self.xs = [];
      var dt = range[1] - range[0];
      var r = self.spacex / dt;
      /* TODO: remove the left-side glitch
       let year_0 = Utils.get_year(sub[0][0])
      for (var t0 = year_0; t0 < range[0]; t0 += self.t_step) {}
       let m0 = Utils.get_month(t0)*/

      for (var i = 0; i < sub.length; i++) {
        var p = sub[i];
        var prev = sub[i - 1] || [];
        var prev_xs = self.xs[self.xs.length - 1] || [0, []];
        var x = Math.floor((p[0] - range[0]) * r);
        insert_line(prev, p, x); // Filtering lines that are too near

        var xs = self.xs[self.xs.length - 1] || [0, []];
        if (prev_xs === xs) continue;

        if (xs[1][0] - prev_xs[1][0] < self.t_step * 0.8) {
          // prev_xs is a higher "rank" label
          if (xs[2] <= prev_xs[2]) {
            self.xs.pop();
          } else {
            // Otherwise
            self.xs.splice(self.xs.length - 2, 1);
          }
        }
      } // TODO: fix grid extension for bigger timeframes


      if (interval < grid_maker_WEEK && r > 0) {
        extend_left(dt, r);
        extend_right(dt, r);
      }
    } else {
      self.t_step = master_grid.t_step;
      self.px_step = master_grid.px_step;
      self.startx = master_grid.startx;
      self.xs = master_grid.xs;
    }
  }

  function insert_line(prev, p, x, m0) {
    var prev_t = ti_map.ib ? ti_map.i2t(prev[0]) : prev[0];
    var p_t = ti_map.ib ? ti_map.i2t(p[0]) : p[0];

    if (ti_map.tf < grid_maker_DAY) {
      prev_t += timezone * grid_maker_HOUR;
      p_t += timezone * grid_maker_HOUR;
    }

    var d = timezone * grid_maker_HOUR; // TODO: take this block =========> (see below)

    if ((prev[0] || interval === grid_maker_YEAR) && utils.get_year(p_t) !== utils.get_year(prev_t)) {
      self.xs.push([x, p, grid_maker_YEAR]); // [px, [...], rank]
    } else if (prev[0] && utils.get_month(p_t) !== utils.get_month(prev_t)) {
      self.xs.push([x, p, grid_maker_MONTH]);
    } // TODO: should be added if this day !== prev day
    // And the same for 'botbar.js', TODO(*)
    else if (utils.day_start(p_t) === p_t) {
        self.xs.push([x, p, grid_maker_DAY]);
      } else if (p[0] % self.t_step === 0) {
        self.xs.push([x, p, interval]);
      }
  }

  function extend_left(dt, r) {
    if (!self.xs.length || !isFinite(r)) return;
    var t = self.xs[0][1][0];

    while (true) {
      t -= self.t_step;
      var x = Math.floor((t - range[0]) * r);
      if (x < 0) break; // TODO: ==========> And insert it here somehow

      if (t % interval === 0) {
        self.xs.unshift([x, [t], interval]);
      }
    }
  }

  function extend_right(dt, r) {
    if (!self.xs.length || !isFinite(r)) return;
    var t = self.xs[self.xs.length - 1][1][0];

    while (true) {
      t += self.t_step;
      var x = Math.floor((t - range[0]) * r);
      if (x > self.spacex) break;

      if (t % interval === 0) {
        self.xs.push([x, [t], interval]);
      }
    }
  }

  function grid_y() {
    // Prevent duplicate levels
    var m = Math.pow(10, -self.prec);
    self.$_step = Math.max(m, dollar_step());
    self.ys = [];
    var y1 = self.$_lo - self.$_lo % self.$_step;

    for (var y$ = y1; y$ <= self.$_hi; y$ += self.$_step) {
      var y = Math.floor(y$ * self.A + self.B);
      if (y > height) continue;
      self.ys.push([y, utils.strip(y$)]);
    }
  }

  function grid_y_log() {
    // TODO: Prevent duplicate levels, is this even
    // a problem here ?
    self.$_mult = dollar_mult();
    self.ys = [];
    if (!sub.length) return;
    var v = Math.abs(sub[sub.length - 1][1] || 1);
    var y1 = search_start_pos(v);
    var y2 = search_start_neg(-v);
    var yp = -Infinity; // Previous y value

    var n = height / $p.config.GRIDY; // target grid N

    var q = 1 + (self.$_mult - 1) / 2; // Over 0

    for (var y$ = y1; y$ > 0; y$ /= self.$_mult) {
      y$ = log_rounder(y$, q);
      var y = Math.floor(math.log(y$) * self.A + self.B);
      self.ys.push([y, utils.strip(y$)]);
      if (y > height) break;
      if (y - yp < $p.config.GRIDY * 0.7) break;
      if (self.ys.length > n + 1) break;
      yp = y;
    } // Under 0


    yp = Infinity;

    for (var y$ = y2; y$ < 0; y$ /= self.$_mult) {
      y$ = log_rounder(y$, q);

      var _y = Math.floor(math.log(y$) * self.A + self.B);

      if (yp - _y < $p.config.GRIDY * 0.7) break;
      self.ys.push([_y, utils.strip(y$)]);
      if (_y < 0) break;
      if (self.ys.length > n * 3 + 1) break;
      yp = _y;
    } // TODO: remove lines near to 0

  } // Search a start for the top grid so that
  // the fixed value always included


  function search_start_pos(value) {
    var N = height / $p.config.GRIDY; // target grid N

    var y = Infinity,
        y$ = value,
        count = 0;

    while (y > 0) {
      y = Math.floor(math.log(y$) * self.A + self.B);
      y$ *= self.$_mult;
      if (count++ > N * 3) return 0; // Prevents deadloops
    }

    return y$;
  }

  function search_start_neg(value) {
    var N = height / $p.config.GRIDY; // target grid N

    var y = -Infinity,
        y$ = value,
        count = 0;

    while (y < height) {
      y = Math.floor(math.log(y$) * self.A + self.B);
      y$ *= self.$_mult;
      if (count++ > N * 3) break; // Prevents deadloops
    }

    return y$;
  } // Make log scale levels look great again


  function log_rounder(x, quality) {
    var s = Math.sign(x);
    x = Math.abs(x);

    if (x > 10) {
      for (var div = 10; div < MAX_INT; div *= 10) {
        var nice = Math.floor(x / div) * div;

        if (x / nice > quality) {
          // More than 10% off
          break;
        }
      }

      div /= 10;
      return s * Math.floor(x / div) * div;
    } else if (x < 1) {
      for (var ro = 10; ro >= 1; ro--) {
        var _nice = utils.round(x, ro);

        if (x / _nice > quality) {
          // More than 10% off
          break;
        }
      }

      return s * utils.round(x, ro + 1);
    } else {
      return s * Math.floor(x);
    }
  }

  function apply_sizes() {
    self.width = $p.width - self.sb;
    self.height = height;
  }

  calc_$range();
  calc_sidebar();
  return {
    // First we need to calculate max sidebar width
    // (among all grids). Then we can actually make
    // them
    create: function create() {
      calc_positions();
      grid_x();

      if (grid.logScale) {
        grid_y_log();
      } else {
        grid_y();
      }

      apply_sizes(); // Link to the master grid (candlesticks)

      if (master_grid) {
        self.master_grid = master_grid;
      }

      self.grid = grid; // Grid params
      // Here we add some helpful functions for
      // plugin creators

      return layout_fn(self, range);
    },
    get_layout: function get_layout() {
      return self;
    },
    set_sidebar: function set_sidebar(v) {
      return self.sb = v;
    },
    get_sidebar: function get_sidebar() {
      return self.sb;
    }
  };
}

/* harmony default export */ const grid_maker = (GridMaker);
;// CONCATENATED MODULE: ./src/components/js/layout.js



function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = layout_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function layout_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return layout_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return layout_arrayLikeToArray(o, minLen); }

function layout_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Calculates all necessary s*it to build the chart
// Heights, widths, transforms, ... = everything
// Why such a mess you ask? Well, that's because
// one components size can depend on other component
// data formatting (e.g. grid width depends on sidebar precision)
// So it's better to calc all in one place.





function Layout(params) {
  var chart = params.chart,
      sub = params.sub,
      offsub = params.offsub,
      interval = params.interval,
      range = params.range,
      ctx = params.ctx,
      layers_meta = params.layers_meta,
      ti_map = params.ti_map,
      $p = params.$props,
      y_ts = params.y_transforms;
  var mgrid = chart.grid || {};
  offsub = offsub.filter(function (x, i) {
    // Skip offchart overlays with custom grid id,
    // because they will be mergred with the existing grids
    return !(x.grid && x.grid.id);
  }); // Splits space between main chart
  // and offchart indicator grids

  function grid_hs() {
    var height = $p.height - $p.config.BOTBAR; // When at least one height defined (default = 1),
    // Pxs calculated as: (sum of weights) / number

    if (mgrid.height || offsub.find(function (x) {
      return x.grid.height;
    })) {
      return weighted_hs(mgrid, height);
    }

    var n = offsub.length;
    var off_h = 2 * Math.sqrt(n) / 7 / (n || 1); // Offchart grid height

    var px = Math.floor(height * off_h); // Main grid height

    var m = height - px * n;
    return [m].concat(Array(n).fill(px));
  }

  function weighted_hs(grid, height) {
    var hs = [{
      grid: grid
    }].concat(_toConsumableArray(offsub)).map(function (x) {
      return x.grid.height || 1;
    });
    var sum = hs.reduce(function (a, b) {
      return a + b;
    }, 0);
    hs = hs.map(function (x) {
      return Math.floor(x / sum * height);
    }); // Refine the height if Math.floor decreased px sum

    sum = hs.reduce(function (a, b) {
      return a + b;
    }, 0);

    for (var i = 0; i < height - sum; i++) {
      hs[i % hs.length]++;
    }

    return hs;
  }

  function candles_n_vol() {
    self.candles = [];
    self.volume = [];
    var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
      return x[5];
    })));
    var vs = $p.config.VOLSCALE * $p.height / maxv;
    var x1,
        x2,
        mid,
        prev = undefined;
    var splitter = self.px_step > 5 ? 1 : 0;
    var hf_px_step = self.px_step * 0.5;

    for (var i = 0; i < sub.length; i++) {
      var p = sub[i];
      mid = self.t2screen(p[0]) + 0.5;
      self.candles.push(mgrid.logScale ? log_scale.candle(self, mid, p, $p) : {
        x: mid,
        w: self.px_step * $p.config.CANDLEW,
        o: Math.floor(p[1] * self.A + self.B),
        h: Math.floor(p[2] * self.A + self.B),
        l: Math.floor(p[3] * self.A + self.B),
        c: Math.floor(p[4] * self.A + self.B),
        raw: p
      }); // Clear volume bar if there is a time gap

      if (sub[i - 1] && p[0] - sub[i - 1][0] > interval) {
        prev = null;
      }

      x1 = prev || Math.floor(mid - hf_px_step);
      x2 = Math.floor(mid + hf_px_step) - 0.5;
      self.volume.push({
        x1: x1,
        x2: x2,
        h: p[5] * vs,
        green: p[4] >= p[1],
        raw: p
      });
      prev = x2 + splitter;
    }
  } // Main grid


  var hs = grid_hs();
  var specs = {
    sub: sub,
    interval: interval,
    range: range,
    ctx: ctx,
    $p: $p,
    layers_meta: layers_meta,
    ti_map: ti_map,
    height: hs[0],
    y_t: y_ts[0],
    grid: mgrid,
    timezone: $p.timezone
  };
  var gms = [new grid_maker(0, specs)]; // Sub grids

  var _iterator = _createForOfIteratorHelper(offsub.entries()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          i = _step$value[0],
          _step$value$ = _step$value[1],
          data = _step$value$.data,
          grid = _step$value$.grid;

      specs.sub = data;
      specs.height = hs[i + 1];
      specs.y_t = y_ts[i + 1];
      specs.grid = grid || {};
      gms.push(new grid_maker(i + 1, specs, gms[0].get_layout()));
    } // Max sidebar among all grinds

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var sb = Math.max.apply(Math, _toConsumableArray(gms.map(function (x) {
    return x.get_sidebar();
  })));
  var grids = [],
      offset = 0;

  for (i = 0; i < gms.length; i++) {
    gms[i].set_sidebar(sb);
    grids.push(gms[i].create());
    grids[i].id = i;
    grids[i].offset = offset;
    offset += grids[i].height;
  }

  var self = grids[0];
  candles_n_vol();
  return {
    grids: grids,
    botbar: {
      width: $p.width,
      height: $p.config.BOTBAR,
      offset: offset,
      xs: grids[0] ? grids[0].xs : []
    }
  };
}

/* harmony default export */ const layout = (Layout);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function classCallCheck_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function createClass_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
;// CONCATENATED MODULE: ./src/components/js/updater.js




function updater_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = updater_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function updater_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return updater_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return updater_arrayLikeToArray(o, minLen); }

function updater_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Cursor updater: calculates current values for
// OHLCV and all other indicators


var CursorUpdater = /*#__PURE__*/function () {
  function CursorUpdater(comp) {
    classCallCheck_classCallCheck(this, CursorUpdater);

    this.comp = comp, this.grids = comp._layout.grids, this.cursor = comp.cursor;
  }

  createClass_createClass(CursorUpdater, [{
    key: "sync",
    value: function sync(e) {
      // TODO: values not displaying if a custom grid id is set:
      // grid: { id: N }
      this.cursor.grid_id = e.grid_id;
      var once = true;

      var _iterator = updater_createForOfIteratorHelper(this.grids),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var grid = _step.value;
          var c = this.cursor_data(grid, e);

          if (!this.cursor.locked) {
            // TODO: find a better fix to invisible cursor prob
            if (once) {
              this.cursor.t = this.cursor_time(grid, e, c);
              if (this.cursor.t) once = false;
            }

            if (c.values) {
              this.comp.$set(this.cursor.values, grid.id, c.values);
            }
          }

          if (grid.id !== e.grid_id) continue;
          this.cursor.x = grid.t2screen(this.cursor.t);
          this.cursor.y = c.y;
          this.cursor.y$ = c.y$;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "overlay_data",
    value: function overlay_data(grid, e) {
      var s = grid.id === 0 ? 'main_section' : 'sub_section';
      var data = this.comp[s].data; // Split offchart data between offchart grids

      if (grid.id > 0) {
        // Sequential grids
        var _d = data.filter(function (x) {
          return x.grid.id === undefined;
        }); // grids with custom ids (for merging)


        var m = data.filter(function (x) {
          return x.grid.id === grid.id;
        });
        data = [_d[grid.id - 1]].concat(_toConsumableArray(m));
      }

      var t = grid.screen2t(e.x);
      var ids = {},
          res = {};

      var _iterator2 = updater_createForOfIteratorHelper(data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var d = _step2.value;
          var ts = d.data.map(function (x) {
            return x[0];
          });
          var i = utils.nearest_a(t, ts)[0];
          d.type in ids ? ids[d.type]++ : ids[d.type] = 0;
          res["".concat(d.type, "_").concat(ids[d.type])] = d.data[i];
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return res;
    } // Nearest datapoints

  }, {
    key: "cursor_data",
    value: function cursor_data(grid, e) {
      var data = this.comp.main_section.sub;
      var xs = data.map(function (x) {
        return grid.t2screen(x[0]) + 0.5;
      });
      var i = utils.nearest_a(e.x, xs)[0];
      if (!xs[i]) return {};
      return {
        x: Math.floor(xs[i]) - 0.5,
        y: Math.floor(e.y - 2) - 0.5 - grid.offset,
        y$: grid.screen2$(e.y - 2 - grid.offset),
        t: (data[i] || [])[0],
        values: Object.assign({
          ohlcv: grid.id === 0 ? data[i] : undefined
        }, this.overlay_data(grid, e))
      };
    } // Get cursor t-position (extended)

  }, {
    key: "cursor_time",
    value: function cursor_time(grid, mouse, candle) {
      var t = grid.screen2t(mouse.x);
      var r = Math.abs((t - candle.t) / this.comp.interval);
      var sign = Math.sign(t - candle.t);

      if (r >= 0.5) {
        // Outside the data range
        var n = Math.round(r);
        return candle.t + n * this.comp.interval * sign;
      } // Inside the data range


      return candle.t;
    }
  }]);

  return CursorUpdater;
}();

/* harmony default export */ const updater = (CursorUpdater);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=template&id=8fbe9336&
var Sectionvue_type_template_id_8fbe9336_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-section" },
    [
      _c("chart-legend", {
        ref: "legend",
        attrs: {
          values: _vm.section_values,
          grid_id: _vm.grid_id,
          common: _vm.legend_props,
          meta_props: _vm.get_meta_props
        },
        on: { "legend-button-click": _vm.button_click }
      }),
      _vm._v(" "),
      _c(
        "grid",
        _vm._b(
          {
            ref: "grid",
            attrs: { grid_id: _vm.grid_id },
            on: {
              "register-kb-listener": _vm.register_kb,
              "remove-kb-listener": _vm.remove_kb,
              "range-changed": _vm.range_changed,
              "cursor-changed": _vm.cursor_changed,
              "cursor-locked": _vm.cursor_locked,
              "layer-meta-props": _vm.emit_meta_props,
              "custom-event": _vm.emit_custom_event,
              "sidebar-transform": _vm.sidebar_transform,
              "rezoom-range": _vm.rezoom_range
            }
          },
          "grid",
          _vm.grid_props,
          false
        )
      ),
      _vm._v(" "),
      _c(
        "sidebar",
        _vm._b(
          {
            ref: "sb-" + _vm.grid_id,
            attrs: { grid_id: _vm.grid_id, rerender: _vm.rerender },
            on: { "sidebar-transform": _vm.sidebar_transform }
          },
          "sidebar",
          _vm.sidebar_props,
          false
        )
      )
    ],
    1
  )
}
var Sectionvue_type_template_id_8fbe9336_staticRenderFns = []
Sectionvue_type_template_id_8fbe9336_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=template&id=8fbe9336&

;// CONCATENATED MODULE: ./src/stuff/frame.js


// Annimation frame with a fallback for
// slower devices


var FrameAnimation = /*#__PURE__*/function () {
  function FrameAnimation(cb) {
    var _this = this;

    classCallCheck_classCallCheck(this, FrameAnimation);

    this.t0 = this.t = utils.now();
    this.id = setInterval(function () {
      // The prev frame took too long
      if (utils.now() - _this.t > 100) return;

      if (utils.now() - _this.t0 > 1200) {
        _this.stop();
      }

      if (_this.id) cb(_this);
      _this.t = utils.now();
    }, 16);
  }

  createClass_createClass(FrameAnimation, [{
    key: "stop",
    value: function stop() {
      clearInterval(this.id);
      this.id = null;
    }
  }]);

  return FrameAnimation;
}();


// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js
var hammer = __nested_webpack_require_9759__(840);
// EXTERNAL MODULE: ./node_modules/hamsterjs/hamster.js
var hamster = __nested_webpack_require_9759__(981);
var hamster_default = /*#__PURE__*/__nested_webpack_require_9759__.n(hamster);
;// CONCATENATED MODULE: ./src/components/js/grid.js





function grid_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = grid_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function grid_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return grid_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return grid_arrayLikeToArray(o, minLen); }

function grid_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Grid.js listens to various user-generated events,
// emits Vue-events if something has changed (e.g. range)
// Think of it as an I/O system for Grid.vue




 // Grid is good.

var Grid = /*#__PURE__*/function () {
  function Grid(canvas, comp) {
    classCallCheck_classCallCheck(this, Grid);

    this.MIN_ZOOM = comp.config.MIN_ZOOM;
    this.MAX_ZOOM = comp.config.MAX_ZOOM;
    if (utils.is_mobile) this.MIN_ZOOM *= 0.5;
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.id = this.$p.grid_id;
    this.layout = this.$p.layout.grids[this.id];
    this.interval = this.$p.interval;
    this.cursor = comp.$props.cursor;
    this.offset_x = 0;
    this.offset_y = 0;
    this.deltas = 0; // Wheel delta events

    this.wmode = this.$p.config.SCROLL_WHEEL;
    this.listeners();
    this.overlays = [];
  }

  createClass_createClass(Grid, [{
    key: "listeners",
    value: function listeners() {
      var _this = this;

      this.hm = hamster_default()(this.canvas);
      this.hm.wheel(function (event, delta) {
        return _this.mousezoom(-delta * 50, event);
      });
      var mc = this.mc = new hammer.Manager(this.canvas);
      var T = utils.is_mobile ? 10 : 0;
      mc.add(new hammer.Pan({
        threshold: T
      }));
      mc.add(new hammer.Tap());
      mc.add(new hammer.Pinch({
        threshold: 0
      }));
      mc.get('pinch').set({
        enable: true
      });
      if (utils.is_mobile) mc.add(new hammer.Press());
      mc.on('panstart', function (event) {
        if (_this.cursor.scroll_lock) return;

        if (_this.cursor.mode === 'aim') {
          return _this.emit_cursor_coord(event);
        }

        var tfrm = _this.$p.y_transform;
        _this.drug = {
          x: event.center.x + _this.offset_x,
          y: event.center.y + _this.offset_y,
          r: _this.range.slice(),
          t: _this.range[1] - _this.range[0],
          o: tfrm ? tfrm.offset || 0 : 0,
          y_r: tfrm && tfrm.range ? tfrm.range.slice() : undefined,
          B: _this.layout.B,
          t0: utils.now()
        };

        _this.comp.$emit('cursor-changed', {
          grid_id: _this.id,
          x: event.center.x + _this.offset_x,
          y: event.center.y + _this.offset_y
        });

        _this.comp.$emit('cursor-locked', true);
      });
      mc.on('panmove', function (event) {
        if (utils.is_mobile) {
          _this.calc_offset();

          _this.propagate('mousemove', _this.touch2mouse(event));
        }

        if (_this.drug) {
          _this.mousedrag(_this.drug.x + event.deltaX, _this.drug.y + event.deltaY);

          _this.comp.$emit('cursor-changed', {
            grid_id: _this.id,
            x: event.center.x + _this.offset_x,
            y: event.center.y + _this.offset_y
          });
        } else if (_this.cursor.mode === 'aim') {
          _this.emit_cursor_coord(event);
        }
      });
      mc.on('panend', function (event) {
        if (utils.is_mobile && _this.drug) {
          _this.pan_fade(event);
        }

        _this.drug = null;

        _this.comp.$emit('cursor-locked', false);
      });
      mc.on('tap', function (event) {
        if (!utils.is_mobile) return;

        _this.sim_mousedown(event);

        if (_this.fade) _this.fade.stop();

        _this.comp.$emit('cursor-changed', {});

        _this.comp.$emit('cursor-changed', {
          /*grid_id: this.id,
          x: undefined,//event.center.x + this.offset_x,
          y: undefined,//event.center.y + this.offset_y,*/
          mode: 'explore'
        });

        _this.update();
      });
      mc.on('pinchstart', function () {
        _this.drug = null;
        _this.pinch = {
          t: _this.range[1] - _this.range[0],
          r: _this.range.slice()
        };
      });
      mc.on('pinchend', function () {
        _this.pinch = null;
      });
      mc.on('pinch', function (event) {
        if (_this.pinch) _this.pinchzoom(event.scale);
      });
      mc.on('press', function (event) {
        if (!utils.is_mobile) return;
        if (_this.fade) _this.fade.stop();

        _this.calc_offset();

        _this.emit_cursor_coord(event, {
          mode: 'aim'
        });

        setTimeout(function () {
          return _this.update();
        });

        _this.sim_mousedown(event);
      });
      var add = addEventListener;
      add("gesturestart", this.gesturestart);
      add("gesturechange", this.gesturechange);
      add("gestureend", this.gestureend);
    }
  }, {
    key: "gesturestart",
    value: function gesturestart(event) {
      event.preventDefault();
    }
  }, {
    key: "gesturechange",
    value: function gesturechange(event) {
      event.preventDefault();
    }
  }, {
    key: "gestureend",
    value: function gestureend(event) {
      event.preventDefault();
    }
  }, {
    key: "mousemove",
    value: function mousemove(event) {
      if (utils.is_mobile) return;
      this.comp.$emit('cursor-changed', {
        grid_id: this.id,
        x: event.layerX,
        y: event.layerY + this.layout.offset
      });
      this.calc_offset();
      this.propagate('mousemove', event);
    }
  }, {
    key: "mouseout",
    value: function mouseout(event) {
      if (utils.is_mobile) return;
      this.comp.$emit('cursor-changed', {});
      this.propagate('mouseout', event);
    }
  }, {
    key: "mouseup",
    value: function mouseup(event) {
      this.drug = null;
      this.comp.$emit('cursor-locked', false);
      this.propagate('mouseup', event);
    }
  }, {
    key: "mousedown",
    value: function mousedown(event) {
      if (utils.is_mobile) return;
      this.propagate('mousedown', event);
      this.comp.$emit('cursor-locked', true);
      if (event.defaultPrevented) return;
      this.comp.$emit('custom-event', {
        event: 'grid-mousedown',
        args: [this.id, event]
      });
    } // Simulated mousedown (for mobile)

  }, {
    key: "sim_mousedown",
    value: function sim_mousedown(event) {
      var _this2 = this;

      if (event.srcEvent.defaultPrevented) return;
      this.comp.$emit('custom-event', {
        event: 'grid-mousedown',
        args: [this.id, event]
      });
      this.propagate('mousemove', this.touch2mouse(event));
      this.update();
      this.propagate('mousedown', this.touch2mouse(event));
      setTimeout(function () {
        _this2.propagate('click', _this2.touch2mouse(event));
      });
    } // Convert touch to "mouse" event

  }, {
    key: "touch2mouse",
    value: function touch2mouse(e) {
      this.calc_offset();
      return {
        original: e.srcEvent,
        layerX: e.center.x + this.offset_x,
        layerY: e.center.y + this.offset_y,
        preventDefault: function preventDefault() {
          this.original.preventDefault();
        }
      };
    }
  }, {
    key: "click",
    value: function click(event) {
      this.propagate('click', event);
    }
  }, {
    key: "emit_cursor_coord",
    value: function emit_cursor_coord(event, add) {
      if (add === void 0) {
        add = {};
      }

      this.comp.$emit('cursor-changed', Object.assign({
        grid_id: this.id,
        x: event.center.x + this.offset_x,
        y: event.center.y + this.offset_y + this.layout.offset
      }, add));
    }
  }, {
    key: "pan_fade",
    value: function pan_fade(event) {
      var _this3 = this;

      var dt = utils.now() - this.drug.t0;
      var dx = this.range[1] - this.drug.r[1];
      var v = 42 * dx / dt;
      var v0 = Math.abs(v * 0.01);
      if (dt > 500) return;
      if (this.fade) this.fade.stop();
      this.fade = new FrameAnimation(function (self) {
        v *= 0.85;

        if (Math.abs(v) < v0) {
          self.stop();
        }

        _this3.range[0] += v;
        _this3.range[1] += v;

        _this3.change_range();
      });
    }
  }, {
    key: "calc_offset",
    value: function calc_offset() {
      var rect = this.canvas.getBoundingClientRect();
      this.offset_x = -rect.x;
      this.offset_y = -rect.y;
    }
  }, {
    key: "new_layer",
    value: function new_layer(layer) {
      if (layer.name === 'crosshair') {
        this.crosshair = layer;
      } else {
        this.overlays.push(layer);
      }

      this.update();
    }
  }, {
    key: "del_layer",
    value: function del_layer(id) {
      this.overlays = this.overlays.filter(function (x) {
        return x.id !== id;
      });
      this.update();
    }
  }, {
    key: "show_hide_layer",
    value: function show_hide_layer(event) {
      var l = this.overlays.filter(function (x) {
        return x.id === event.id;
      });
      if (l.length) l[0].display = event.display;
    }
  }, {
    key: "update",
    value: function update() {
      var _this4 = this;

      // Update reference to the grid
      // TODO: check what happens if data changes interval
      this.layout = this.$p.layout.grids[this.id];
      this.interval = this.$p.interval;
      if (!this.layout) return;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (this.$p.shaders.length) this.apply_shaders();
      this.grid();
      var overlays = [];
      overlays.push.apply(overlays, _toConsumableArray(this.overlays)); // z-index sorting

      overlays.sort(function (l1, l2) {
        return l1.z - l2.z;
      });
      overlays.forEach(function (l) {
        if (!l.display) return;

        _this4.ctx.save();

        var r = l.renderer;
        if (r.pre_draw) r.pre_draw(_this4.ctx);
        r.draw(_this4.ctx);
        if (r.post_draw) r.post_draw(_this4.ctx);

        _this4.ctx.restore();
      });

      if (this.crosshair) {
        this.crosshair.renderer.draw(this.ctx);
      }
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.$p.layout.grids[this.id];
      var props = {
        layout: layout,
        range: this.range,
        interval: this.interval,
        tf: layout.ti_map.tf,
        cursor: this.cursor,
        colors: this.$p.colors,
        sub: this.data,
        font: this.$p.font,
        config: this.$p.config,
        meta: this.$p.meta
      };

      var _iterator = grid_createForOfIteratorHelper(this.$p.shaders),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var s = _step.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } // Actually draws the grid (for real)

  }, {
    key: "grid",
    value: function grid() {
      this.ctx.strokeStyle = this.$p.colors.grid;
      this.ctx.beginPath();
      var ymax = this.layout.height;

      var _iterator2 = grid_createForOfIteratorHelper(this.layout.xs),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              x = _step2$value[0],
              p = _step2$value[1];

          this.ctx.moveTo(x - 0.5, 0);
          this.ctx.lineTo(x - 0.5, ymax);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = grid_createForOfIteratorHelper(this.layout.ys),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              y = _step3$value[0],
              y$ = _step3$value[1];

          this.ctx.moveTo(0, y - 0.5);
          this.ctx.lineTo(this.layout.width, y - 0.5);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.ctx.stroke();
      if (this.$p.grid_id) this.upper_border();
    }
  }, {
    key: "upper_border",
    value: function upper_border() {
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(this.layout.width, 0.5);
      this.ctx.stroke();
    }
  }, {
    key: "mousezoom",
    value: function mousezoom(delta, event) {
      // TODO: for mobile
      if (this.wmode !== 'pass') {
        if (this.wmode === 'click' && !this.$p.meta.activated) {
          return;
        }

        event.originalEvent.preventDefault();
        event.preventDefault();
      }

      event.deltaX = event.deltaX || utils.get_deltaX(event);
      event.deltaY = event.deltaY || utils.get_deltaY(event);

      if (Math.abs(event.deltaX) > 0) {
        this.trackpad = true;

        if (Math.abs(event.deltaX) >= Math.abs(event.deltaY)) {
          delta *= 0.1;
        }

        this.trackpad_scroll(event);
      }

      if (this.trackpad) delta *= 0.032;
      delta = utils.smart_wheel(delta); // TODO: mouse zooming is a little jerky,
      // needs to follow f(mouse_wheel_speed) and
      // if speed is low, scroll shoud be slower

      if (delta < 0 && this.data.length <= this.MIN_ZOOM) return;
      if (delta > 0 && this.data.length > this.MAX_ZOOM) return;
      var k = this.interval / 1000;
      var diff = delta * k * this.data.length;
      var tl = this.comp.config.ZOOM_MODE === 'tl';

      if (event.originalEvent.ctrlKey || tl) {
        var offset = event.originalEvent.offsetX;
        var diff1 = offset / (this.canvas.width - 1) * diff;
        var diff2 = diff - diff1;
        this.range[0] -= diff1;
        this.range[1] += diff2;
      } else {
        this.range[0] -= diff;
      }

      if (tl) {
        var _offset = event.originalEvent.offsetY;

        var _diff = _offset / (this.canvas.height - 1) * 2;

        var _diff2 = 2 - _diff;

        var z = diff / (this.range[1] - this.range[0]); //rezoom_range(z, diff_x, diff_y)

        this.comp.$emit('rezoom-range', {
          grid_id: this.id,
          z: z,
          diff1: _diff,
          diff2: _diff2
        });
      }

      this.change_range();
    }
  }, {
    key: "mousedrag",
    value: function mousedrag(x, y) {
      var dt = this.drug.t * (this.drug.x - x) / this.layout.width;
      var d$ = this.layout.$_hi - this.layout.$_lo;
      d$ *= (this.drug.y - y) / this.layout.height;
      var offset = this.drug.o + d$;
      var ls = this.layout.grid.logScale;

      if (ls && this.drug.y_r) {
        var dy = this.drug.y - y;
        var range = this.drug.y_r.slice();
        range[0] = math.exp((0 - this.drug.B + dy) / this.layout.A);
        range[1] = math.exp((this.layout.height - this.drug.B + dy) / this.layout.A);
      }

      if (this.drug.y_r && this.$p.y_transform && !this.$p.y_transform.auto) {
        this.comp.$emit('sidebar-transform', {
          grid_id: this.id,
          range: ls ? range || this.drug.y_r : [this.drug.y_r[0] - offset, this.drug.y_r[1] - offset]
        });
      }

      this.range[0] = this.drug.r[0] + dt;
      this.range[1] = this.drug.r[1] + dt;
      this.change_range();
    }
  }, {
    key: "pinchzoom",
    value: function pinchzoom(scale) {
      if (scale > 1 && this.data.length <= this.MIN_ZOOM) return;
      if (scale < 1 && this.data.length > this.MAX_ZOOM) return;
      var t = this.pinch.t;
      var nt = t * 1 / scale;
      this.range[0] = this.pinch.r[0] - (nt - t) * 0.5;
      this.range[1] = this.pinch.r[1] + (nt - t) * 0.5;
      this.change_range();
    }
  }, {
    key: "trackpad_scroll",
    value: function trackpad_scroll(event) {
      var dt = this.range[1] - this.range[0];
      this.range[0] += event.deltaX * dt * 0.011;
      this.range[1] += event.deltaX * dt * 0.011;
      this.change_range();
    }
  }, {
    key: "change_range",
    value: function change_range() {
      // TODO: better way to limit the view. Problem:
      // when you are at the dead end of the data,
      // and keep scrolling,
      // the chart continues to scale down a little.
      // Solution: I don't know yet
      if (!this.range.length || this.data.length < 2) return;
      var l = this.data.length - 1;
      var data = this.data;
      var range = this.range;
      range[0] = utils.clamp(range[0], -Infinity, data[l][0] - this.interval * 5.5);
      range[1] = utils.clamp(range[1], data[0][0] + this.interval * 5.5, Infinity); // TODO: IMPORTANT scrolling is jerky The Problem caused
      // by the long round trip of 'range-changed' event.
      // First it propagates up to update layout in Chart.vue,
      // then it moves back as watch() update. It takes 1-5 ms.
      // And because the delay is different each time we see
      // the lag. No smooth movement and it's annoying.
      // Solution: we could try to calc the layout immediatly
      // somewhere here. Still will hurt the sidebar & bottombar

      this.comp.$emit('range-changed', range);
    } // Propagate mouse event to overlays

  }, {
    key: "propagate",
    value: function propagate(name, event) {
      var _iterator4 = grid_createForOfIteratorHelper(this.overlays),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var layer = _step4.value;

          if (layer.renderer[name]) {
            layer.renderer[name](event);
          }

          var mouse = layer.renderer.mouse;
          var keys = layer.renderer.keys;

          if (mouse.listeners) {
            mouse.emit(name, event);
          }

          if (keys && keys.listeners) {
            keys.emit(name, event);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var rm = removeEventListener;
      rm("gesturestart", this.gesturestart);
      rm("gesturechange", this.gesturechange);
      rm("gestureend", this.gestureend);
      if (this.mc) this.mc.destroy();
      if (this.hm) this.hm.unwheel();
    }
  }]);

  return Grid;
}();


;// CONCATENATED MODULE: ./src/mixins/canvas.js
// Interactive canvas-based component
// Should implement: mousemove, mouseout, mouseup, mousedown, click

/* harmony default export */ const canvas = ({
  methods: {
    setup: function setup() {
      var _this = this;

      var id = "".concat(this.$props.tv_id, "-").concat(this._id, "-canvas");
      var canvas = document.getElementById(id);
      var dpr = window.devicePixelRatio || 1;
      canvas.style.width = "".concat(this._attrs.width, "px");
      canvas.style.height = "".concat(this._attrs.height, "px");
      if (dpr < 1) dpr = 1; // Realy ? That's it? Issue #63

      this.$nextTick(function () {
        var rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        var ctx = canvas.getContext('2d', {// TODO: test the boost:
          //alpha: false,
          //desynchronized: true,
          //preserveDrawingBuffer: false
        });
        ctx.scale(dpr, dpr);

        _this.redraw(); // Fallback fix for Brave browser
        // https://github.com/brave/brave-browser/issues/1738


        if (!ctx.measureTextOrg) {
          ctx.measureTextOrg = ctx.measureText;
        }

        ctx.measureText = function (text) {
          return utils.measureText(ctx, text, _this.$props.tv_id);
        };
      });
    },
    create_canvas: function create_canvas(h, id, props) {
      var _this2 = this;

      this._id = id;
      this._attrs = props.attrs;
      return h('div', {
        "class": "trading-vue-".concat(id),
        style: {
          left: props.position.x + 'px',
          top: props.position.y + 'px',
          position: 'absolute'
        }
      }, [h('canvas', {
        on: {
          mousemove: function mousemove(e) {
            return _this2.renderer.mousemove(e);
          },
          mouseout: function mouseout(e) {
            return _this2.renderer.mouseout(e);
          },
          mouseup: function mouseup(e) {
            return _this2.renderer.mouseup(e);
          },
          mousedown: function mousedown(e) {
            return _this2.renderer.mousedown(e);
          }
        },
        attrs: Object.assign({
          id: "".concat(this.$props.tv_id, "-").concat(id, "-canvas")
        }, props.attrs),
        ref: 'canvas',
        style: props.style
      })].concat(props.hs || []));
    },
    redraw: function redraw() {
      if (!this.renderer) return;
      this.renderer.update();
    }
  },
  watch: {
    width: function width(val) {
      this._attrs.width = val;
      this.setup();
    },
    height: function height(val) {
      this._attrs.height = val;
      this.setup();
    }
  }
});
;// CONCATENATED MODULE: ./src/mixins/uxlist.js
// Manager for Inteerface objects
/* harmony default export */ const uxlist = ({
  methods: {
    on_ux_event: function on_ux_event(d, target) {
      if (d.event === 'new-interface') {
        if (d.args[0].target === target) {
          d.args[0].vars = d.args[0].vars || {};
          d.args[0].grid_id = d.args[1];
          d.args[0].overlay_id = d.args[2];
          this.uxs.push(d.args[0]); // this.rerender++
        }
      } else if (d.event === 'close-interface') {
        this.uxs = this.uxs.filter(function (x) {
          return x.uuid !== d.args[0];
        });
      } else if (d.event === 'modify-interface') {
        var ux = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (ux.length) {
          this.modify(ux[0], d.args[1]);
        }
      } else if (d.event === 'hide-interface') {
        var _ux = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (_ux.length) {
          _ux[0].hidden = true;
          this.modify(_ux[0], {
            hidden: true
          });
        }
      } else if (d.event === 'show-interface') {
        var _ux2 = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (_ux2.length) {
          this.modify(_ux2[0], {
            hidden: false
          });
        }
      } else {
        return d;
      }
    },
    modify: function modify(ux, obj) {
      if (obj === void 0) {
        obj = {};
      }

      for (var k in obj) {
        if (k in ux) {
          this.$set(ux, k, obj[k]);
        }
      }
    },
    // Remove all UXs for a given overlay id
    remove_all_ux: function remove_all_ux(id) {
      this.uxs = this.uxs.filter(function (x) {
        return x.overlay.id !== id;
      });
    }
  },
  data: function data() {
    return {
      uxs: []
    };
  }
});
;// CONCATENATED MODULE: ./src/components/js/crosshair.js



var Crosshair = /*#__PURE__*/function () {
  function Crosshair(comp) {
    classCallCheck_classCallCheck(this, Crosshair);

    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this._visible = false;
    this.locked = false;
    this.layout = this.$p.layout;
  }

  createClass_createClass(Crosshair, [{
    key: "draw",
    value: function draw(ctx) {
      // Update reference to the grid
      this.layout = this.$p.layout;
      var cursor = this.comp.$props.cursor;
      if (!this.visible && cursor.mode === 'explore') return;
      this.x = this.$p.cursor.x;
      this.y = this.$p.cursor.y;
      ctx.save();
      ctx.strokeStyle = this.$p.colors.cross;
      ctx.beginPath();
      ctx.setLineDash([5]); // H

      if (this.$p.cursor.grid_id === this.layout.id) {
        ctx.moveTo(0, this.y);
        ctx.lineTo(this.layout.width - 0.5, this.y);
      } // V


      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x, this.layout.height);
      ctx.stroke();
      ctx.restore();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.visible = false;
      this.x = undefined;
      this.y = undefined;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(val) {
      this._visible = val;
    }
  }]);

  return Crosshair;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Crosshair.vue?vue&type=script&lang=js&


/* harmony default export */ const Crosshairvue_type_script_lang_js_ = ({
  name: 'Crosshair',
  props: ['cursor', 'colors', 'layout', 'sub'],
  methods: {
    create: function create() {
      this.ch = new Crosshair(this); // New grid overlay-renderer descriptor.
      // Should implement draw() (see Spline.vue)

      this.$emit('new-grid-layer', {
        name: 'crosshair',
        renderer: this.ch
      });
    }
  },
  watch: {
    cursor: {
      handler: function handler() {
        if (!this.ch) this.create(); // Explore = default mode on mobile

        var cursor = this.$props.cursor;
        var explore = cursor.mode === 'explore';

        if (!cursor.x || !cursor.y) {
          this.ch.hide();
          this.$emit('redraw-grid');
          return;
        }

        this.ch.visible = !explore;
      },
      deep: true
    }
  },
  render: function render(h) {
    return h();
  }
});
;// CONCATENATED MODULE: ./src/components/Crosshair.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Crosshairvue_type_script_lang_js_ = (Crosshairvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

;// CONCATENATED MODULE: ./src/components/Crosshair.vue
var Crosshair_render, Crosshair_staticRenderFns
;



/* normalize component */
;
var component = normalizeComponent(
  components_Crosshairvue_type_script_lang_js_,
  Crosshair_render,
  Crosshair_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/Crosshair.vue"
/* harmony default export */ const components_Crosshair = (component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/KeyboardListener.vue?vue&type=script&lang=js&
//
//
//
//
/* harmony default export */ const KeyboardListenervue_type_script_lang_js_ = ({
  name: 'KeyboardListener',
  render: function render(h) {
    return h();
  },
  created: function created() {
    this.$emit('register-kb-listener', {
      id: this._uid,
      keydown: this.keydown,
      keyup: this.keyup,
      keypress: this.keypress
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.$emit('remove-kb-listener', {
      id: this._uid
    });
  },
  methods: {
    keydown: function keydown(event) {
      this.$emit('keydown', event);
    },
    keyup: function keyup(event) {
      this.$emit('keyup', event);
    },
    keypress: function keypress(event) {
      this.$emit('keypress', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/KeyboardListener.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_KeyboardListenervue_type_script_lang_js_ = (KeyboardListenervue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/KeyboardListener.vue
var KeyboardListener_render, KeyboardListener_staticRenderFns
;



/* normalize component */
;
var KeyboardListener_component = normalizeComponent(
  components_KeyboardListenervue_type_script_lang_js_,
  KeyboardListener_render,
  KeyboardListener_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KeyboardListener_api; }
KeyboardListener_component.options.__file = "src/components/KeyboardListener.vue"
/* harmony default export */ const KeyboardListener = (KeyboardListener_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxLayer.vue?vue&type=template&id=390ccf6e&
var UxLayervue_type_template_id_390ccf6e_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "span",
    { class: "trading-vue-grid-ux-" + _vm.id, style: _vm.style },
    _vm._l(_vm.uxs, function(ux) {
      return _c("ux-wrapper", {
        key: ux.uuid,
        attrs: {
          ux: ux,
          updater: _vm.updater,
          colors: _vm.colors,
          config: _vm.config
        },
        on: { "custom-event": _vm.on_custom_event }
      })
    }),
    1
  )
}
var UxLayervue_type_template_id_390ccf6e_staticRenderFns = []
UxLayervue_type_template_id_390ccf6e_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/UxLayer.vue?vue&type=template&id=390ccf6e&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=template&id=4bc32070&
var UxWrappervue_type_template_id_4bc32070_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.visible
    ? _c(
        "div",
        {
          staticClass: "trading-vue-ux-wrapper",
          style: _vm.style,
          attrs: { id: "tvjs-ux-wrapper-" + _vm.ux.uuid }
        },
        [
          _c(_vm.ux.component, {
            tag: "component",
            attrs: {
              ux: _vm.ux,
              updater: _vm.updater,
              wrapper: _vm.wrapper,
              colors: _vm.colors
            },
            on: { "custom-event": _vm.on_custom_event }
          }),
          _vm._v(" "),
          _vm.ux.show_pin
            ? _c("div", {
                staticClass: "tvjs-ux-wrapper-pin",
                style: _vm.pin_style
              })
            : _vm._e(),
          _vm._v(" "),
          _vm.ux.win_header !== false
            ? _c("div", { staticClass: "tvjs-ux-wrapper-head" }, [
                _c(
                  "div",
                  {
                    staticClass: "tvjs-ux-wrapper-close",
                    style: _vm.btn_style,
                    on: { click: _vm.close }
                  },
                  [_vm._v("")]
                )
              ])
            : _vm._e()
        ],
        1
      )
    : _vm._e()
}
var UxWrappervue_type_template_id_4bc32070_staticRenderFns = []
UxWrappervue_type_template_id_4bc32070_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=template&id=4bc32070&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const UxWrappervue_type_script_lang_js_ = ({
  name: 'UxWrapper',
  props: ['ux', 'updater', 'colors', 'config'],
  mounted: function mounted() {
    this.self = document.getElementById(this.uuid);
    this.w = this.self.offsetWidth; // TODO: => width: "content"

    this.h = this.self.offsetHeight; // TODO: => height: "content"

    this.update_position();
  },
  created: function created() {
    this.mouse.on('mousemove', this.mousemove);
    this.mouse.on('mouseout', this.mouseout);
  },
  beforeDestroy: function beforeDestroy() {
    this.mouse.off('mousemove', this.mousemove);
    this.mouse.off('mouseout', this.mouseout);
  },
  methods: {
    update_position: function update_position() {
      if (this.uxr.hidden) return;
      var lw = this.layout.width;
      var lh = this.layout.height;
      var pin = this.uxr.pin;

      switch (pin[0]) {
        case 'cursor':
          var x = this.uxr.overlay.cursor.x;
          break;

        case 'mouse':
          x = this.mouse.x;
          break;

        default:
          if (typeof pin[0] === 'string') {
            x = this.parse_coord(pin[0], lw);
          } else {
            x = this.layout.t2screen(pin[0]);
          }

      }

      switch (pin[1]) {
        case 'cursor':
          var y = this.uxr.overlay.cursor.y;
          break;

        case 'mouse':
          y = this.mouse.y;
          break;

        default:
          if (typeof pin[1] === 'string') {
            y = this.parse_coord(pin[1], lh);
          } else {
            y = this.layout.$2screen(pin[1]);
          }

      }

      this.x = x + this.ox;
      this.y = y + this.oy;
    },
    parse_coord: function parse_coord(str, scale) {
      str = str.trim();
      if (str === '0' || str === '') return 0;
      var plus = str.split('+');

      if (plus.length === 2) {
        return this.parse_coord(plus[0], scale) + this.parse_coord(plus[1], scale);
      }

      var minus = str.split('-');

      if (minus.length === 2) {
        return this.parse_coord(minus[0], scale) - this.parse_coord(minus[1], scale);
      }

      var per = str.split('%');

      if (per.length === 2) {
        return scale * parseInt(per[0]) / 100;
      }

      var px = str.split('px');

      if (px.length === 2) {
        return parseInt(px[0]);
      }

      return undefined;
    },
    mousemove: function mousemove() {
      this.update_position();
      this.visible = true;
    },
    mouseout: function mouseout() {
      if (this.uxr.pin.includes('cursor') || this.uxr.pin.includes('mouse')) this.visible = false;
    },
    on_custom_event: function on_custom_event(event) {
      this.$emit('custom-event', event);

      if (event.event === 'modify-interface') {
        if (this.self) {
          this.w = this.self.offsetWidth;
          this.h = this.self.offsetHeight;
        }

        this.update_position();
      }
    },
    close: function close() {
      this.$emit('custom-event', {
        event: 'close-interface',
        args: [this.$props.ux.uuid]
      });
    }
  },
  computed: {
    uxr: function uxr() {
      return this.$props.ux; // just a ref
    },
    layout: function layout() {
      return this.$props.ux.overlay.layout;
    },
    settings: function settings() {
      return this.$props.ux.overlay.settings;
    },
    uuid: function uuid() {
      return "tvjs-ux-wrapper-".concat(this.uxr.uuid);
    },
    mouse: function mouse() {
      return this.uxr.overlay.mouse;
    },
    style: function style() {
      var st = {
        'display': this.uxr.hidden ? 'none' : undefined,
        'left': "".concat(this.x, "px"),
        'top': "".concat(this.y, "px"),
        'pointer-events': this.uxr.pointer_events || 'all',
        'z-index': this.z_index
      };
      if (this.uxr.win_styling !== false) st = Object.assign(st, {
        'border': "1px solid ".concat(this.$props.colors.grid),
        'border-radius': '3px',
        'background': "".concat(this.background)
      });
      return st;
    },
    pin_style: function pin_style() {
      return {
        'left': "".concat(-this.ox, "px"),
        'top': "".concat(-this.oy, "px"),
        'background-color': this.uxr.pin_color
      };
    },
    btn_style: function btn_style() {
      return {
        'background': "".concat(this.inactive_btn_color),
        'color': "".concat(this.inactive_btn_color)
      };
    },
    pin_pos: function pin_pos() {
      return this.uxr.pin_position ? this.uxr.pin_position.split(',') : ['0', '0'];
    },
    // Offset x
    ox: function ox() {
      if (this.pin_pos.length !== 2) return undefined;
      var x = this.parse_coord(this.pin_pos[0], this.w);
      return -x;
    },
    // Offset y
    oy: function oy() {
      if (this.pin_pos.length !== 2) return undefined;
      var y = this.parse_coord(this.pin_pos[1], this.h);
      return -y;
    },
    z_index: function z_index() {
      var base_index = this.settings['z-index'] || this.settings['zIndex'] || 0;
      var ux_index = this.uxr['z_index'] || 0;
      return base_index + ux_index;
    },
    background: function background() {
      var c = this.uxr.background || this.$props.colors.back;
      return utils.apply_opacity(c, this.uxr.background_opacity || this.$props.config.UX_OPACITY);
    },
    inactive_btn_color: function inactive_btn_color() {
      return this.uxr.inactive_btn_color || this.$props.colors.grid;
    },
    wrapper: function wrapper() {
      return {
        x: this.x,
        y: this.y,
        pin_x: this.x - this.ox,
        pin_y: this.y - this.oy
      };
    }
  },
  watch: {
    updater: function updater() {
      this.update_position();
    }
  },
  data: function data() {
    return {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      visible: true
    };
  }
});
;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_UxWrappervue_type_script_lang_js_ = (UxWrappervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=style&index=0&lang=css&
var UxWrappervue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(565);
;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/UxWrapper.vue



;


/* normalize component */

var UxWrapper_component = normalizeComponent(
  components_UxWrappervue_type_script_lang_js_,
  UxWrappervue_type_template_id_4bc32070_render,
  UxWrappervue_type_template_id_4bc32070_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var UxWrapper_api; }
UxWrapper_component.options.__file = "src/components/UxWrapper.vue"
/* harmony default export */ const UxWrapper = (UxWrapper_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxLayer.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const UxLayervue_type_script_lang_js_ = ({
  name: 'UxLayer',
  props: ['tv_id', 'id', 'uxs', 'updater', 'colors', 'config'],
  components: {
    UxWrapper: UxWrapper
  },
  created: function created() {},
  mounted: function mounted() {},
  beforeDestroy: function beforeDestroy() {},
  methods: {
    on_custom_event: function on_custom_event(event) {
      this.$emit('custom-event', event);
    }
  },
  computed: {
    style: function style() {
      return {
        'top': this.$props.id !== 0 ? '1px' : 0,
        'left': 0,
        'width': '100%',
        'height': 'calc(100% - 2px)',
        'position': 'absolute',
        'z-index': '1',
        'pointer-events': 'none',
        'overflow': 'hidden'
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/components/UxLayer.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_UxLayervue_type_script_lang_js_ = (UxLayervue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/UxLayer.vue





/* normalize component */
;
var UxLayer_component = normalizeComponent(
  components_UxLayervue_type_script_lang_js_,
  UxLayervue_type_template_id_390ccf6e_render,
  UxLayervue_type_template_id_390ccf6e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var UxLayer_api; }
UxLayer_component.options.__file = "src/components/UxLayer.vue"
/* harmony default export */ const UxLayer = (UxLayer_component.exports);
;// CONCATENATED MODULE: ./src/stuff/mouse.js



function mouse_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = mouse_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function mouse_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return mouse_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mouse_arrayLikeToArray(o, minLen); }

function mouse_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Mouse event handler for overlay
var Mouse = /*#__PURE__*/function () {
  function Mouse(comp) {
    classCallCheck_classCallCheck(this, Mouse);

    this.comp = comp;
    this.map = {};
    this.listeners = 0;
    this.pressed = false;
    this.x = comp.$props.cursor.x;
    this.y = comp.$props.cursor.y;
    this.t = comp.$props.cursor.t;
    this.y$ = comp.$props.cursor.y$;
  } // You can choose where to place the handler
  // (beginning or end of the queue)


  createClass_createClass(Mouse, [{
    key: "on",
    value: function on(name, handler, dir) {
      if (dir === void 0) {
        dir = "unshift";
      }

      if (!handler) return;
      this.map[name] = this.map[name] || [];
      this.map[name][dir](handler);
      this.listeners++;
    }
  }, {
    key: "off",
    value: function off(name, handler) {
      if (!this.map[name]) return;
      var i = this.map[name].indexOf(handler);
      if (i < 0) return;
      this.map[name].splice(i, 1);
      this.listeners--;
    } // Called by grid.js

  }, {
    key: "emit",
    value: function emit(name, event) {
      var l = this.comp.layout;

      if (name in this.map) {
        var _iterator = mouse_createForOfIteratorHelper(this.map[name]),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var f = _step.value;
            f(event);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (name === 'mousemove') {
        this.x = event.layerX;
        this.y = event.layerY;
        this.t = l.screen2t(this.x);
        this.y$ = l.screen2$(this.y);
      }

      if (name === 'mousedown') {
        this.pressed = true;
      }

      if (name === 'mouseup') {
        this.pressed = false;
      }
    }
  }]);

  return Mouse;
}();


;// CONCATENATED MODULE: ./src/mixins/overlay.js
// Usuful stuff for creating overlays. Include as mixin

/* harmony default export */ const overlay = ({
  props: ['id', 'num', 'interval', 'cursor', 'colors', 'layout', 'sub', 'data', 'settings', 'grid_id', 'font', 'config', 'meta', 'tf', 'i0', 'last'],
  mounted: function mounted() {
    // TODO(1): when hot reloading, dynamicaly changed mixins
    // dissapear (cuz it's a hack), the only way for now
    // is to reload the browser
    if (!this.draw) {
      this.draw = function (ctx) {
        var text = 'EARLY ADOPTER BUG: reload the browser & enjoy';
        console.warn(text);
      };
    } // Main chart?


    var main = this.$props.sub === this.$props.data;
    this.meta_info(); // TODO(1): quick fix for vue2, in vue3 we use 3rd party emit

    try {
      new Function('return ' + this.$emit)();
      this._$emit = this.$emit;
      this.$emit = this.custom_event;
    } catch (e) {
      return;
    }

    this._$emit('new-grid-layer', {
      name: this.$options.name,
      id: this.$props.id,
      renderer: this,
      display: 'display' in this.$props.settings ? this.$props.settings['display'] : true,
      z: this.$props.settings['z-index'] || this.$props.settings['zIndex'] || (main ? 0 : -1)
    }); // Overlay meta-props (adjusting behaviour)


    this._$emit('layer-meta-props', {
      grid_id: this.$props.grid_id,
      layer_id: this.$props.id,
      legend: this.legend,
      data_colors: this.data_colors,
      y_range: this.y_range
    });

    this.exec_script();
    this.mouse = new Mouse(this);
    if (this.init_tool) this.init_tool();
    if (this.init) this.init();
  },
  beforeDestroy: function beforeDestroy() {
    if (this.destroy) this.destroy();

    this._$emit('delete-grid-layer', this.$props.id);
  },
  methods: {
    use_for: function use_for() {
      /* override it (mandatory) */
      console.warn('use_for() should be implemented');
      console.warn("Format: use_for() {\n                  return ['type1', 'type2', ...]\n            }");
    },
    meta_info: function meta_info() {
      /* override it (optional) */
      var id = this.$props.id;
      console.warn("".concat(id, " meta_info() is req. for publishing"));
      console.warn("Format: meta_info() {\n                author: 'Satoshi Smith',\n                version: '1.0.0',\n                contact (opt) '<email>'\n                github: (opt) '<GitHub Page>',\n            }");
    },
    custom_event: function custom_event(event) {
      if (event.split(':')[0] === 'hook') return;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (event === 'change-settings' || event === 'object-selected' || event === 'new-shader' || event === 'new-interface' || event === 'remove-tool') {
        args.push(this.grid_id, this.id);

        if (this.$props.settings.$uuid) {
          args.push(this.$props.settings.$uuid);
        }
      }

      if (event === 'new-interface') {
        args[0].overlay = this;
        args[0].uuid = this.last_ux_id = "".concat(this.grid_id, "-").concat(this.id, "-").concat(this.uxs_count++);
      } // TODO: add a namespace to the event name
      // TODO(2): this prevents call overflow, but
      // the root of evil is in (1)


      if (event === 'custom-event') return;

      this._$emit('custom-event', {
        event: event,
        args: args
      });
    },
    // TODO: the event is not firing when the same
    // overlay type is added to the offchart[]
    exec_script: function exec_script() {
      if (this.calc) this.$emit('exec-script', {
        grid_id: this.$props.grid_id,
        layer_id: this.$props.id,
        src: this.calc(),
        use_for: this.use_for()
      });
    }
  },
  watch: {
    settings: {
      handler: function handler(n, p) {
        if (this.watch_uuid) this.watch_uuid(n, p);

        this._$emit('show-grid-layer', {
          id: this.$props.id,
          display: 'display' in this.$props.settings ? this.$props.settings['display'] : true
        });
      },
      deep: true
    }
  },
  data: function data() {
    return {
      uxs_count: 0,
      last_ux_id: null
    };
  },
  render: function render(h) {
    return h();
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Spline.vue?vue&type=script&lang=js&
// Spline renderer. (SMAs, EMAs, TEMAs...
// you know what I mean)
// TODO: make a real spline, not a bunch of lines...
// Adds all necessary stuff for you.

/* harmony default export */ const Splinevue_type_script_lang_js_ = ({
  name: 'Spline',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.2'
      };
    },
    // Here goes your code. You are provided with:
    // { All stuff is reactive }
    // $props.layout -> positions of all chart elements +
    //  some helper functions (see layout_fn.js)
    // $props.interval -> candlestick time interval
    // $props.sub -> current subset of candlestick data
    // $props.data -> your indicator's data subset.
    //  Comes "as is", should have the following format:
    //  [[<timestamp>, ... ], ... ]
    // $props.colors -> colors (see TradingVue.vue)
    // $props.cursor -> current position of crosshair
    // $props.settings -> indicator's custom settings
    //  E.g. colors, line thickness, etc. You define it.
    // $props.num -> indicator's layer number (of All
    // layers in the current grid)
    // $props.id -> indicator's id (e.g. EMA_0)
    // ~
    // Finally, let's make the canvas dirty!
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var i = this.data_index;
      var data = this.$props.data;

      if (!this.skip_nan) {
        for (var k = 0, n = data.length; k < n; k++) {
          var p = data[k];
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[i]);
          ctx.lineTo(x, y);
        }
      } else {
        var skip = false;

        for (var k = 0, n = data.length; k < n; k++) {
          var _p = data[k];

          var _x = layout.t2screen(_p[0]);

          var _y = layout.$2screen(_p[i]);

          if (_p[i] == null || _y !== _y) {
            skip = true;
          } else {
            if (skip) ctx.moveTo(_x, _y);
            ctx.lineTo(_x, _y);
            skip = false;
          }
        }
      }

      ctx.stroke();
    },
    // For all data with these types overlay will be
    // added to the renderer list. And '$props.data'
    // will have the corresponding values. If you want to
    // redefine the default behviour for a prticular
    // indicator (let's say EMA),
    // just create a new overlay with the same type:
    // e.g. use_for() { return ['EMA'] }.
    use_for: function use_for() {
      return ['Spline', 'EMA', 'SMA'];
    },
    // Colors for the legend, should have the
    // same dimention as a data point (excl. timestamp)
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    },
    data_index: function data_index() {
      return this.sett.dataIndex || 1;
    },
    // Don't connect separate parts if true
    skip_nan: function skip_nan() {
      return this.sett.skipNaN;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Spline.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splinevue_type_script_lang_js_ = (Splinevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Spline.vue
var Spline_render, Spline_staticRenderFns
;



/* normalize component */
;
var Spline_component = normalizeComponent(
  overlays_Splinevue_type_script_lang_js_,
  Spline_render,
  Spline_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Spline_api; }
Spline_component.options.__file = "src/components/overlays/Spline.vue"
/* harmony default export */ const Spline = (Spline_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Splines.vue?vue&type=script&lang=js&
// Channel renderer. (Keltner, Bollinger)

/* harmony default export */ const Splinesvue_type_script_lang_js_ = ({
  name: 'Splines',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    draw: function draw(ctx) {
      for (var i = 0; i < this.lines_num; i++) {
        var _i = i % this.clrx.length;

        ctx.strokeStyle = this.clrx[_i];
        ctx.lineWidth = this.widths[i] || this.line_width;
        ctx.beginPath();
        this.draw_spline(ctx, i);
        ctx.stroke();
      }
    },
    draw_spline: function draw_spline(ctx, i) {
      var layout = this.$props.layout;
      var data = this.$props.data;

      if (!this.skip_nan) {
        for (var k = 0, n = data.length; k < n; k++) {
          var p = data[k];
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[i + 1]);
          ctx.lineTo(x, y);
        }
      } else {
        var skip = false;

        for (var k = 0, n = data.length; k < n; k++) {
          var _p = data[k];

          var _x = layout.t2screen(_p[0]);

          var _y = layout.$2screen(_p[i + 1]);

          if (_p[i + 1] == null || _y !== _y) {
            skip = true;
          } else {
            if (skip) ctx.moveTo(_x, _y);
            ctx.lineTo(_x, _y);
            skip = false;
          }
        }
      }
    },
    use_for: function use_for() {
      return ['Splines', 'DMI'];
    },
    data_colors: function data_colors() {
      return this.clrx;
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    widths: function widths() {
      return this.sett.lineWidths || [];
    },
    clrx: function clrx() {
      var colors = this.sett.colors || [];
      var n = this.$props.num;

      if (!colors.length) {
        for (var i = 0; i < this.lines_num; i++) {
          colors.push(this.COLORS[(n + i) % 5]);
        }
      }

      return colors;
    },
    lines_num: function lines_num() {
      if (!this.$props.data[0]) return 0;
      return this.$props.data[0].length - 1;
    },
    // Don't connect separate parts if true
    skip_nan: function skip_nan() {
      return this.sett.skipNaN;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Splines.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splinesvue_type_script_lang_js_ = (Splinesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Splines.vue
var Splines_render, Splines_staticRenderFns
;



/* normalize component */
;
var Splines_component = normalizeComponent(
  overlays_Splinesvue_type_script_lang_js_,
  Splines_render,
  Splines_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Splines_api; }
Splines_component.options.__file = "src/components/overlays/Splines.vue"
/* harmony default export */ const Splines = (Splines_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Range.vue?vue&type=script&lang=js&
// R S I . Because we love it
// Adds all necessary stuff for you.

/* harmony default export */ const Rangevue_type_script_lang_js_ = ({
  name: 'Range',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },
    // Here goes your code. You are provided with:
    // { All stuff is reactive }
    // $props.layout -> positions of all chart elements +
    //  some helper functions (see layout_fn.js)
    // $props.interval -> candlestick time interval
    // $props.sub -> current subset of candlestick data
    // $props.data -> your indicator's data subset.
    //  Comes "as is", should have the following format:
    //  [[<timestamp>, ... ], ... ]
    // $props.colors -> colors (see TradingVue.vue)
    // $props.cursor -> current position of crosshair
    // $props.settings -> indicator's custom settings
    //  E.g. colors, line thickness, etc. You define it.
    // $props.num -> indicator's layer number (of All
    // layers in the current grid)
    // $props.id -> indicator's id (e.g. EMA_0)
    // ~
    // Finally, let's make the canvas dirty!
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var upper = layout.$2screen(this.sett.upper || 70);
      var lower = layout.$2screen(this.sett.lower || 30);
      var data = this.$props.data; // RSI values

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      for (var k = 0, n = data.length; k < n; k++) {
        var p = data[k];
        var x = layout.t2screen(p[0]);
        var y = layout.$2screen(p[1]);
        ctx.lineTo(x, y);
      }

      ctx.stroke();
      ctx.strokeStyle = this.band_color;
      ctx.setLineDash([5]); // Will be removed after draw()

      ctx.beginPath(); // Fill the area between the bands

      ctx.fillStyle = this.back_color;
      ctx.fillRect(0, upper, layout.width, lower - upper); // Upper band

      ctx.moveTo(0, upper);
      ctx.lineTo(layout.width, upper); // Lower band

      ctx.moveTo(0, lower);
      ctx.lineTo(layout.width, lower);
      ctx.stroke();
    },
    // For all data with these types overlay will be
    // added to the renderer list. And '$props.data'
    // will have the corresponding values. If you want to
    // redefine the default behviour for a prticular
    // indicator (let's say EMA),
    // just create a new overlay with the same type:
    // e.g. use_for() { return ['EMA'] }.
    use_for: function use_for() {
      return ['Range', 'RSI'];
    },
    // Colors for the legend, should have the
    // same dimention as a data point (excl. timestamp)
    data_colors: function data_colors() {
      return [this.color];
    },
    // Y-Range tansform. For example you need a fixed
    // Y-range for an indicator, you can do it here!
    // Gets estimated range, @return you favorite range
    y_range: function y_range(hi, lo) {
      return [Math.max(hi, this.sett.upper || 70), Math.min(lo, this.sett.lower || 30)];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      return this.sett.color || '#ec206e';
    },
    band_color: function band_color() {
      return this.sett.bandColor || '#ddd';
    },
    back_color: function back_color() {
      return this.sett.backColor || '#381e9c16';
    }
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Range.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Rangevue_type_script_lang_js_ = (Rangevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Range.vue
var Range_render, Range_staticRenderFns
;



/* normalize component */
;
var Range_component = normalizeComponent(
  overlays_Rangevue_type_script_lang_js_,
  Range_render,
  Range_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Range_api; }
Range_component.options.__file = "src/components/overlays/Range.vue"
/* harmony default export */ const Range = (Range_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Trades.vue?vue&type=script&lang=js&

/* harmony default export */ const Tradesvue_type_script_lang_js_ = ({
  name: 'Trades',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.2'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var data = this.$props.data;
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';

      for (var k = 0, n = data.length; k < n; k++) {
        var p = data[k];
        ctx.fillStyle = p[1] ? this.buy_color : this.sell_color;
        ctx.beginPath();
        var x = layout.t2screen(p[0]); // x - Mapping

        var y = layout.$2screen(p[2]); // y - Mapping

        ctx.arc(x, y, this.marker_size + 0.5, 0, Math.PI * 2, true);
        ctx.fill();
        ctx.stroke();

        if (this.show_label && p[3]) {
          this.draw_label(ctx, x, y, p);
        }
      }
    },
    draw_label: function draw_label(ctx, x, y, p) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(p[3], x, y - 25);
    },
    use_for: function use_for() {
      return ['Trades'];
    },
    // Defines legend format (values & colors)
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Sell';
          break;

        case 1:
          pos = 'Buy';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.text
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    buy_color: function buy_color() {
      return this.sett.buyColor || '#63df89';
    },
    sell_color: function sell_color() {
      return this.sett.sellColor || '#ec4662';
    },
    label_color: function label_color() {
      return this.sett.labelColor || '#999';
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Trades.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Tradesvue_type_script_lang_js_ = (Tradesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Trades.vue
var Trades_render, Trades_staticRenderFns
;



/* normalize component */
;
var Trades_component = normalizeComponent(
  overlays_Tradesvue_type_script_lang_js_,
  Trades_render,
  Trades_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Trades_api; }
Trades_component.options.__file = "src/components/overlays/Trades.vue"
/* harmony default export */ const Trades = (Trades_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Channel.vue?vue&type=script&lang=js&
// Channel renderer. (Keltner, Bollinger)
// TODO: allow color transparency
// TODO: improve performance: draw in one solid chunk

/* harmony default export */ const Channelvue_type_script_lang_js_ = ({
  name: 'Channel',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },

    /*draw(ctx) {
        ctx.lineWidth = this.line_width
        ctx.strokeStyle = this.color
        ctx.fillStyle = this.back_color
         for (var i = 0; i < this.$props.data.length - 1; i++) {
              let p1 = this.mapp(this.$props.data[i])
            let p2 = this.mapp(this.$props.data[i+1])
             if (!p2) continue
            if (p1.y1 !== p1.y1) continue // Fix NaN
             // Background
            ctx.beginPath()
            ctx.moveTo(p1.x, p1.y1)
            ctx.lineTo(p2.x + 0.1, p2.y1)
            ctx.lineTo(p2.x + 0.1, p2.y3)
            ctx.lineTo(p1.x, p1.y3)
            ctx.fill()
             // Lines
            ctx.beginPath()
            ctx.moveTo(p1.x, p1.y1)
            ctx.lineTo(p2.x, p2.y1)
            if (this.show_mid) {
                ctx.moveTo(p1.x, p1.y2)
                ctx.lineTo(p2.x, p2.y2)
            }
            ctx.moveTo(p1.x, p1.y3)
            ctx.lineTo(p2.x, p2.y3)
            ctx.stroke()
         }
    },*/
    draw: function draw(ctx) {
      // Background
      var data = this.data;
      var layout = this.layout;
      ctx.beginPath();
      ctx.fillStyle = this.back_color;

      for (var i = 0; i < data.length; i++) {
        var p = data[i];
        var x = layout.t2screen(p[0]);
        var y = layout.$2screen(p[1] || undefined);
        ctx.lineTo(x, y);
      }

      for (var i = data.length - 1; i >= 0; i--) {
        var _p = data[i];

        var _x = layout.t2screen(_p[0]);

        var _y = layout.$2screen(_p[3] || undefined);

        ctx.lineTo(_x, _y);
      }

      ctx.fill(); // Lines

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color; // Top line

      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p2 = data[i];

        var _x2 = layout.t2screen(_p2[0]);

        var _y2 = layout.$2screen(_p2[1] || undefined);

        ctx.lineTo(_x2, _y2);
      }

      ctx.stroke(); // Bottom line

      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p3 = data[i];

        var _x3 = layout.t2screen(_p3[0]);

        var _y3 = layout.$2screen(_p3[3] || undefined);

        ctx.lineTo(_x3, _y3);
      }

      ctx.stroke(); // Middle line

      if (!this.show_mid) return;
      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p4 = data[i];

        var _x4 = layout.t2screen(_p4[0]);

        var _y4 = layout.$2screen(_p4[2] || undefined);

        ctx.lineTo(_x4, _y4);
      }

      ctx.stroke();
    },
    mapp: function mapp(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        y1: layout.$2screen(p[1]),
        y2: layout.$2screen(p[2]),
        y3: layout.$2screen(p[3])
      };
    },
    use_for: function use_for() {
      return ['Channel', 'KC', 'BB'];
    },
    data_colors: function data_colors() {
      return [this.color, this.color, this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    },
    show_mid: function show_mid() {
      return 'showMid' in this.sett ? this.sett.showMid : true;
    },
    back_color: function back_color() {
      return this.sett.backColor || this.color + '11';
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Channel.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Channelvue_type_script_lang_js_ = (Channelvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Channel.vue
var Channel_render, Channel_staticRenderFns
;



/* normalize component */
;
var Channel_component = normalizeComponent(
  overlays_Channelvue_type_script_lang_js_,
  Channel_render,
  Channel_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Channel_api; }
Channel_component.options.__file = "src/components/overlays/Channel.vue"
/* harmony default export */ const Channel = (Channel_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Segment.vue?vue&type=script&lang=js&
// Segment renderer.

/* harmony default export */ const Segmentvue_type_script_lang_js_ = ({
  name: 'Segment',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.0'
      };
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var x1 = layout.t2screen(this.p1[0]);
      var y1 = layout.$2screen(this.p1[1]);
      ctx.moveTo(x1, y1);
      var x2 = layout.t2screen(this.p2[0]);
      var y2 = layout.$2screen(this.p2[1]);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Segment'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Segment.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Segmentvue_type_script_lang_js_ = (Segmentvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Segment.vue
var Segment_render, Segment_staticRenderFns
;



/* normalize component */
;
var Segment_component = normalizeComponent(
  overlays_Segmentvue_type_script_lang_js_,
  Segment_render,
  Segment_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Segment_api; }
Segment_component.options.__file = "src/components/overlays/Segment.vue"
/* harmony default export */ const Segment = (Segment_component.exports);
;// CONCATENATED MODULE: ./src/components/js/layout_cnv.js


// Claculates postions and sizes for candlestick
// and volume bars for the given subset of data

function layout_cnv(self) {
  var $p = self.$props;
  var sub = $p.data;
  var t2screen = $p.layout.t2screen;
  var layout = $p.layout;
  var candles = [];
  var volume = []; // The volume bar height is determined as a percentage of
  // the chart's height (VOLSCALE)

  var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
    return x[5];
  })));
  var vs = $p.config.VOLSCALE * layout.height / maxv;
  var x1,
      x2,
      w,
      avg_w,
      mid,
      prev = undefined; // Subset interval against main interval

  var _new_interval = new_interval(layout, $p, sub),
      _new_interval2 = _slicedToArray(_new_interval, 2),
      interval2 = _new_interval2[0],
      ratio = _new_interval2[1];

  var px_step2 = layout.px_step * ratio;
  var splitter = px_step2 > 5 ? 1 : 0; // A & B are current chart tranformations:
  // A === scale,  B === Y-axis shift

  for (var i = 0; i < sub.length; i++) {
    var p = sub[i];
    mid = t2screen(p[0]) + 1; // Clear volume bar if there is a time gap

    if (sub[i - 1] && p[0] - sub[i - 1][0] > interval2) {
      prev = null;
    }

    x1 = prev || Math.floor(mid - px_step2 * 0.5);
    x2 = Math.floor(mid + px_step2 * 0.5) - 0.5; // TODO: add log scale support

    candles.push({
      x: mid,
      w: layout.px_step * $p.config.CANDLEW * ratio,
      o: Math.floor(p[1] * layout.A + layout.B),
      h: Math.floor(p[2] * layout.A + layout.B),
      l: Math.floor(p[3] * layout.A + layout.B),
      c: Math.floor(p[4] * layout.A + layout.B),
      raw: p
    });
    volume.push({
      x1: x1,
      x2: x2,
      h: p[5] * vs,
      green: p[4] >= p[1],
      raw: p
    });
    prev = x2 + splitter;
  }

  return {
    candles: candles,
    volume: volume
  };
}
function layout_vol(self) {
  var $p = self.$props;
  var sub = $p.data;
  var t2screen = $p.layout.t2screen;
  var layout = $p.layout;
  var volume = []; // Detect data second dimention size:

  var dim = sub[0] ? sub[0].length : 0; // Support special volume data (see API book), or OHLCV
  // Data indices:

  self._i1 = dim < 6 ? 1 : 5;
  self._i2 = dim < 6 ? function (p) {
    return p[2];
  } : function (p) {
    return p[4] >= p[1];
  };
  var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
    return x[self._i1];
  })));
  var volscale = self.volscale || $p.config.VOLSCALE;
  var vs = volscale * layout.height / maxv;
  var x1,
      x2,
      mid,
      prev = undefined; // Subset interval against main interval

  var _new_interval3 = new_interval(layout, $p, sub),
      _new_interval4 = _slicedToArray(_new_interval3, 2),
      interval2 = _new_interval4[0],
      ratio = _new_interval4[1];

  var px_step2 = layout.px_step * ratio;
  var splitter = px_step2 > 5 ? 1 : 0; // A & B are current chart tranformations:
  // A === scale,  B === Y-axis shift

  for (var i = 0; i < sub.length; i++) {
    var p = sub[i];
    mid = t2screen(p[0]) + 1; // Clear volume bar if there is a time gap

    if (sub[i - 1] && p[0] - sub[i - 1][0] > interval2) {
      prev = null;
    }

    x1 = prev || Math.floor(mid - px_step2 * 0.5);
    x2 = Math.floor(mid + px_step2 * 0.5) - 0.5;
    volume.push({
      x1: x1,
      x2: x2,
      h: p[self._i1] * vs,
      green: self._i2(p),
      raw: p
    });
    prev = x2 + splitter;
  }

  return volume;
}

function new_interval(layout, $p, sub) {
  // Subset interval against main interval
  if (!layout.ti_map.ib) {
    var interval2 = $p.tf || utils.detect_interval(sub);
    var ratio = interval2 / $p.interval;
  } else {
    if ($p.tf) {
      var ratio = $p.tf / layout.ti_map.tf;
      var interval2 = ratio;
    } else {
      var interval2 = utils.detect_interval(sub);
      var ratio = interval2 / $p.interval;
    }
  }

  return [interval2, ratio];
}
;// CONCATENATED MODULE: ./src/components/primitives/candle.js



// Candle object for Candles overlay
var CandleExt = /*#__PURE__*/function () {
  function CandleExt(overlay, ctx, data) {
    classCallCheck_classCallCheck(this, CandleExt);

    this.ctx = ctx;
    this.self = overlay;
    this.style = data.raw[6] || this.self;
    this.draw(data);
  }

  createClass_createClass(CandleExt, [{
    key: "draw",
    value: function draw(data) {
      var green = data.raw[4] >= data.raw[1];
      var body_color = green ? this.style.colorCandleUp : this.style.colorCandleDw;
      var wick_color = green ? this.style.colorWickUp : this.style.colorWickDw;
      var w = Math.max(data.w, 1);
      var hw = Math.max(Math.floor(w * 0.5), 1);
      var h = Math.abs(data.o - data.c);
      var max_h = data.c === data.o ? 1 : 2;
      var x05 = Math.floor(data.x) - 0.5;
      this.ctx.strokeStyle = wick_color;
      this.ctx.beginPath();
      this.ctx.moveTo(x05, Math.floor(data.h));
      this.ctx.lineTo(x05, Math.floor(data.l));
      this.ctx.stroke();

      if (data.w > 1.5) {
        this.ctx.fillStyle = body_color; // TODO: Move common calculations to layout.js

        var s = green ? 1 : -1;
        this.ctx.fillRect(Math.floor(data.x - hw - 1), data.c, Math.floor(hw * 2 + 1), s * Math.max(h, max_h));
      } else {
        this.ctx.strokeStyle = body_color;
        this.ctx.beginPath();
        this.ctx.moveTo(x05, Math.floor(Math.min(data.o, data.c)));
        this.ctx.lineTo(x05, Math.floor(Math.max(data.o, data.c)) + (data.o === data.c ? 1 : 0));
        this.ctx.stroke();
      }
    }
  }]);

  return CandleExt;
}();


;// CONCATENATED MODULE: ./src/components/primitives/volbar.js



var VolbarExt = /*#__PURE__*/function () {
  function VolbarExt(overlay, ctx, data) {
    classCallCheck_classCallCheck(this, VolbarExt);

    this.ctx = ctx;
    this.$p = overlay.$props;
    this.self = overlay;
    this.style = data.raw[6] || this.self;
    this.draw(data);
  }

  createClass_createClass(VolbarExt, [{
    key: "draw",
    value: function draw(data) {
      var y0 = this.$p.layout.height;
      var w = data.x2 - data.x1;
      var h = Math.floor(data.h);
      this.ctx.fillStyle = data.green ? this.style.colorVolUp : this.style.colorVolDw;
      this.ctx.fillRect(Math.floor(data.x1), Math.floor(y0 - h - 0.5), Math.floor(w), Math.floor(h + 1));
    }
  }]);

  return VolbarExt;
}();


;// CONCATENATED MODULE: ./src/components/primitives/price.js



// Price bar & price line (shader)
var Price = /*#__PURE__*/function () {
  function Price(comp) {
    classCallCheck_classCallCheck(this, Price);

    this.comp = comp;
  } // Defines an inline shader (has access to both
  // target & overlay's contexts)


  createClass_createClass(Price, [{
    key: "init_shader",
    value: function init_shader() {
      var _this = this;

      var layout = this.comp.$props.layout;
      var config = this.comp.$props.config;
      var comp = this.comp;

      var last_bar = function last_bar() {
        return _this.last_bar();
      };

      this.comp.$emit('new-shader', {
        target: 'sidebar',
        draw: function draw(ctx) {
          var bar = last_bar();
          if (!bar) return;
          var w = ctx.canvas.width;
          var h = config.PANHEIGHT;
          var lbl = bar.price.toFixed(layout.prec);
          ctx.fillStyle = bar.color;
          var x = -0.5;
          var y = bar.y - h * 0.5 - 0.5;
          var a = 7;
          ctx.fillRect(x - 0.5, y, w + 1, h);
          ctx.fillStyle = comp.$props.colors.textHL;
          ctx.textAlign = 'left';
          ctx.fillText(lbl, a, y + 15);
        }
      });
      this.shader = true;
    } // Regular draw call for overaly

  }, {
    key: "draw",
    value: function draw(ctx) {
      if (!this.comp.$props.meta.last) return;
      if (!this.shader) this.init_shader();
      var layout = this.comp.$props.layout;
      var last = this.comp.$props.last;
      var dir = last[4] >= last[1];
      var color = dir ? this.green() : this.red();
      var y = layout.$2screen(last[4]) + (dir ? 1 : 0);
      ctx.strokeStyle = color;
      ctx.setLineDash([1, 1]);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(layout.width, y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }, {
    key: "last_bar",
    value: function last_bar() {
      if (!this.comp.data.length) return undefined;
      var layout = this.comp.$props.layout;
      var last = this.comp.data[this.comp.data.length - 1];
      var y = layout.$2screen(last[4]); //let cndl = layout.c_magnet(last[0])

      return {
        y: y,
        //Math.floor(cndl.c) - 0.5,
        price: last[4],
        color: last[4] >= last[1] ? this.green() : this.red()
      };
    }
  }, {
    key: "last_price",
    value: function last_price() {
      return this.comp.$props.meta.last ? this.comp.$props.meta.last[4] : undefined;
    }
  }, {
    key: "green",
    value: function green() {
      return this.comp.colorCandleUp;
    }
  }, {
    key: "red",
    value: function red() {
      return this.comp.colorCandleDw;
    }
  }]);

  return Price;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Candles.vue?vue&type=script&lang=js&
// Renedrer for candlesticks + volume (optional)
// It can be used as the main chart or an indicator





/* harmony default export */ const Candlesvue_type_script_lang_js_ = ({
  name: 'Candles',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.2.1'
      };
    },
    init: function init() {
      this.price = new Price(this);
    },
    draw: function draw(ctx) {
      // If data === main candlestick data
      // render as main chart:
      if (this.$props.sub === this.$props.data) {
        var cnv = {
          candles: this.$props.layout.candles,
          volume: this.$props.layout.volume
        }; // Else, as offchart / onchart indicator:
      } else {
        cnv = layout_cnv(this);
      }

      if (this.show_volume) {
        var cv = cnv.volume;

        for (var i = 0, n = cv.length; i < n; i++) {
          new VolbarExt(this, ctx, cv[i]);
        }
      }

      var cc = cnv.candles;

      for (var i = 0, n = cc.length; i < n; i++) {
        new CandleExt(this, ctx, cc[i]);
      }

      if (this.price_line) this.price.draw(ctx);
    },
    use_for: function use_for() {
      return ['Candles'];
    },
    // In case it's added as offchart overlay
    y_range: function y_range() {
      var hi = -Infinity,
          lo = Infinity;

      for (var i = 0, n = this.sub.length; i < n; i++) {
        var x = this.sub[i];
        if (x[2] > hi) hi = x[2];
        if (x[3] < lo) lo = x[3];
      }

      return [hi, lo];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    show_volume: function show_volume() {
      return 'showVolume' in this.sett ? this.sett.showVolume : true;
    },
    price_line: function price_line() {
      return 'priceLine' in this.sett ? this.sett.priceLine : true;
    },
    colorCandleUp: function colorCandleUp() {
      return this.sett.colorCandleUp || this.$props.colors.candleUp;
    },
    colorCandleDw: function colorCandleDw() {
      return this.sett.colorCandleDw || this.$props.colors.candleDw;
    },
    colorWickUp: function colorWickUp() {
      return this.sett.colorWickUp || this.$props.colors.wickUp;
    },
    colorWickDw: function colorWickDw() {
      return this.sett.colorWickDw || this.$props.colors.wickDw;
    },
    colorWickSm: function colorWickSm() {
      return this.sett.colorWickSm || this.$props.colors.wickSm;
    },
    colorVolUp: function colorVolUp() {
      return this.sett.colorVolUp || this.$props.colors.volUp;
    },
    colorVolDw: function colorVolDw() {
      return this.sett.colorVolDw || this.$props.colors.volDw;
    }
  },
  data: function data() {
    return {
      price: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Candles.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Candlesvue_type_script_lang_js_ = (Candlesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Candles.vue
var Candles_render, Candles_staticRenderFns
;



/* normalize component */
;
var Candles_component = normalizeComponent(
  overlays_Candlesvue_type_script_lang_js_,
  Candles_render,
  Candles_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Candles_api; }
Candles_component.options.__file = "src/components/overlays/Candles.vue"
/* harmony default export */ const Candles = (Candles_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Volume.vue?vue&type=script&lang=js&


function Volumevue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Volumevue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Volumevue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Volumevue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Volumevue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Volumevue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Standalone renedrer for the volume



/* harmony default export */ const Volumevue_type_script_lang_js_ = ({
  name: 'Volume',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    draw: function draw(ctx) {
      // TODO: volume average
      // TODO: Y-axis scaling
      var _iterator = Volumevue_type_script_lang_js_createForOfIteratorHelper(layout_vol(this)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var v = _step.value;
          new VolbarExt(this, ctx, v);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ['Volume'];
    },
    // Defines legend format (values & colors)
    // _i2 - detetected data index (see layout_cnv)
    legend: function legend(values) {
      var flag = this._i2 ? this._i2(values) : values[2];
      var color = flag ? this.colorVolUpLegend : this.colorVolDwLegend;
      return [{
        value: values[this._i1 || 1],
        color: color
      }];
    },
    // When added as offchart overlay
    // If data is OHLCV => recalc y-range
    // _i1 - detetected data index (see layout_cnv)
    y_range: function y_range(hi, lo) {
      var _this = this;

      if (this._i1 === 5) {
        var sub = this.$props.sub;
        return [Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
          return x[_this._i1];
        }))), Math.min.apply(Math, _toConsumableArray(sub.map(function (x) {
          return x[_this._i1];
        })))];
      } else {
        return [hi, lo];
      }
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    colorVolUp: function colorVolUp() {
      return this.sett.colorVolUp || this.$props.colors.volUp;
    },
    colorVolDw: function colorVolDw() {
      return this.sett.colorVolDw || this.$props.colors.volDw;
    },
    colorVolUpLegend: function colorVolUpLegend() {
      return this.sett.colorVolUpLegend || this.$props.colors.candleUp;
    },
    colorVolDwLegend: function colorVolDwLegend() {
      return this.sett.colorVolDwLegend || this.$props.colors.candleDw;
    },
    volscale: function volscale() {
      return this.sett.volscale || this.$props.grid_id > 0 ? 0.85 : this.$props.config.VOLSCALE;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Volume.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Volumevue_type_script_lang_js_ = (Volumevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Volume.vue
var Volume_render, Volume_staticRenderFns
;



/* normalize component */
;
var Volume_component = normalizeComponent(
  overlays_Volumevue_type_script_lang_js_,
  Volume_render,
  Volume_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Volume_api; }
Volume_component.options.__file = "src/components/overlays/Volume.vue"
/* harmony default export */ const Volume = (Volume_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Splitters.vue?vue&type=script&lang=js&
// Data section splitters (with labels)

/* harmony default export */ const Splittersvue_type_script_lang_js_ = ({
  name: 'Splitters',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },
    draw: function draw(ctx) {
      var _this = this;

      var layout = this.$props.layout;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.line_color;
      this.$props.data.forEach(function (p, i) {
        ctx.beginPath();
        var x = layout.t2screen(p[0]); // x - Mapping

        ctx.setLineDash([10, 10]);
        ctx.moveTo(x, 0);
        ctx.lineTo(x, _this.layout.height);
        ctx.stroke();
        if (p[1]) _this.draw_label(ctx, x, p);
      });
    },
    draw_label: function draw_label(ctx, x, p) {
      var side = p[2] ? 1 : -1;
      x += 2.5 * side;
      ctx.font = this.new_font;
      var pos = p[4] || this.y_position;
      var w = ctx.measureText(p[1]).width + 10;
      var y = this.layout.height * (1.0 - pos);
      y = Math.floor(y);
      ctx.fillStyle = p[3] || this.flag_color;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + 10 * side, y - 10 * side);
      ctx.lineTo(x + (w + 10) * side, y - 10 * side);
      ctx.lineTo(x + (w + 10) * side, y + 10 * side);
      ctx.lineTo(x + 10 * side, y + 10 * side);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = this.label_color;
      ctx.textAlign = side < 0 ? 'right' : 'left';
      ctx.fillText(p[1], x + 15 * side, y + 4);
    },
    use_for: function use_for() {
      return ['Splitters'];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    new_font: function new_font() {
      return this.sett.font || '12px ' + this.$props.font.split('px').pop();
    },
    flag_color: function flag_color() {
      return this.sett.flagColor || '#4285f4';
    },
    label_color: function label_color() {
      return this.sett.labelColor || '#fff';
    },
    line_color: function line_color() {
      return this.sett.lineColor || '#4285f4';
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 1.0;
    },
    y_position: function y_position() {
      return this.sett.yPosition || 0.9;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Splitters.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splittersvue_type_script_lang_js_ = (Splittersvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Splitters.vue
var Splitters_render, Splitters_staticRenderFns
;



/* normalize component */
;
var Splitters_component = normalizeComponent(
  overlays_Splittersvue_type_script_lang_js_,
  Splitters_render,
  Splitters_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Splitters_api; }
Splitters_component.options.__file = "src/components/overlays/Splitters.vue"
/* harmony default export */ const Splitters = (Splitters_component.exports);
;// CONCATENATED MODULE: ./src/stuff/keys.js



function keys_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = keys_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function keys_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return keys_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return keys_arrayLikeToArray(o, minLen); }

function keys_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Keyboard event handler for overlay
var Keys = /*#__PURE__*/function () {
  function Keys(comp) {
    classCallCheck_classCallCheck(this, Keys);

    this.comp = comp;
    this.map = {};
    this.listeners = 0;
    this.keymap = {};
  }

  createClass_createClass(Keys, [{
    key: "on",
    value: function on(name, handler) {
      if (!handler) return;
      this.map[name] = this.map[name] || [];
      this.map[name].push(handler);
      this.listeners++;
    } // Called by grid.js

  }, {
    key: "emit",
    value: function emit(name, event) {
      if (name in this.map) {
        var _iterator = keys_createForOfIteratorHelper(this.map[name]),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var f = _step.value;
            f(event);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (name === 'keydown') {
        if (!this.keymap[event.key]) {
          this.emit(event.key);
        }

        this.keymap[event.key] = true;
      }

      if (name === 'keyup') {
        this.keymap[event.key] = false;
      }
    }
  }, {
    key: "pressed",
    value: function pressed(key) {
      return this.keymap[key];
    }
  }]);

  return Keys;
}();


;// CONCATENATED MODULE: ./src/mixins/tool.js
function tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tool_arrayLikeToArray(o, minLen); }

function tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Usuful stuff for creating tools. Include as mixin


/* harmony default export */ const tool = ({
  methods: {
    init_tool: function init_tool() {
      var _this = this;

      // Collision functions (float, float) => bool,
      this.collisions = [];
      this.pins = [];
      this.mouse.on('mousemove', function (e) {
        if (_this.collisions.some(function (f) {
          return f(_this.mouse.x, _this.mouse.y);
        })) {
          _this.show_pins = true;
        } else {
          _this.show_pins = false;
        }

        if (_this.drag) _this.drag_update();
      });
      this.mouse.on('mousedown', function (e) {
        if (utils.default_prevented(e)) return;

        if (_this.collisions.some(function (f) {
          return f(_this.mouse.x, _this.mouse.y);
        })) {
          if (!_this.selected) {
            _this.$emit('object-selected');
          }

          _this.start_drag();

          e.preventDefault();

          _this.pins.forEach(function (x) {
            return x.mousedown(e, true);
          });
        }
      });
      this.mouse.on('mouseup', function (e) {
        _this.drag = null;

        _this.$emit('scroll-lock', false);
      });
      this.keys = new Keys(this);
      this.keys.on('Delete', this.remove_tool);
      this.keys.on('Backspace', this.remove_tool);
      this.show_pins = false;
      this.drag = null;
    },
    render_pins: function render_pins(ctx) {
      if (this.selected || this.show_pins) {
        this.pins.forEach(function (x) {
          return x.draw(ctx);
        });
      }
    },
    set_state: function set_state(name) {
      this.$emit('change-settings', {
        $state: name
      });
    },
    watch_uuid: function watch_uuid(n, p) {
      // If layer $uuid is changed, then re-init
      // pins & collisions
      if (n.$uuid !== p.$uuid) {
        var _iterator = tool_createForOfIteratorHelper(this.pins),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var p = _step.value;
            p.re_init();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.collisions = [];
        this.show_pins = false;
        this.drag = null;
      }
    },
    pre_draw: function pre_draw() {
      // Delete all collision functions before
      // the draw() call and let primitives set
      // them again
      this.collisions = [];
    },
    remove_tool: function remove_tool() {
      if (this.selected) this.$emit('remove-tool');
    },
    start_drag: function start_drag() {
      this.$emit('scroll-lock', true);
      var cursor = this.$props.cursor;
      this.drag = {
        t: cursor.t,
        y$: cursor.y$
      };
      this.pins.forEach(function (x) {
        return x.rec_position();
      });
    },
    drag_update: function drag_update() {
      var dt = this.$props.cursor.t - this.drag.t;
      var dy = this.$props.cursor.y$ - this.drag.y$;
      this.pins.forEach(function (x) {
        return x.update_from([x.t1 + dt, x.y$1 + dy], true);
      });
    }
  },
  computed: {
    // Settings starting with $ are reserved
    selected: function selected() {
      return this.$props.settings.$selected;
    },
    state: function state() {
      return this.$props.settings.$state;
    }
  }
});
;// CONCATENATED MODULE: ./src/stuff/icons.json
const icons_namespaceObject = JSON.parse('{"extended.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAANElEQVR4nGNggABGEMEEIlhABAeI+AASF0AlHmAqA4kzKAAx8wGQuAMKwd6AoYzBAWonAwAcLwTgNfJ3RQAAAABJRU5ErkJggg==","ray.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAMklEQVR4nGNgQAJMIIIFRHCACAEQoQAiHICYvQEkjkrwYypjAIkzwk2zAREuqIQFzD4AE3kE4BEmGggAAAAASUVORK5CYII=","segment.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAlQTFRFAAAATU1NJCQkCxcHIQAAAAN0Uk5TAP8SmutI5AAAACxJREFUeJxjYMACGAMgNAsLdpoVKi8AVe8A1QblQlWRKt0AoULw2w1zGxoAABdiAviQhF/mAAAAAElFTkSuQmCC","add.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAH5QTFRFAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoKBgYGGxsbKioqPz8/Pj4+BQUFCQkJAQEBZGRkh4eHAgICEBAQNjY2g4ODgYGBAAAAAwMDeXl5d3d3GBgYERERgICAgICANDQ0PDw8Y2NjCAgIhYWFGhoaJycnOjo6YWFhgICAdXV14Y16sQAAACp0Uk5TAAILDxIKESEnJiYoKCgTKSkpKCAnKSkFKCkpJiDl/ycpKSA2JyYpKSkpOkQ+xgAAARdJREFUeJzllNt2gyAQRTWiRsHLoDU0GpPYmMv//2BMS+sgl6Z9bM8bi73gnJkBz/sn8lcBIUHofwtG8TpJKUuTLI6cYF7QEqRKynP71VX9AkhNXVlsbMQrLLQVGyPZLsGHWgPrCxMJwHUPlXa79NBp2et5d9f3u3m1XxatQNn7SagOXCUjCjYUDuqxcWlHj4MSfw12FDJchFViRN8+1qcQoUH6lR1L1mEMEErofB6WzEUwylzomfzOQGiOJdXiWH7mQoUyMa4WXJQWOBvLFvPCGxt6FSr5kyH0qi0YddNG2/pgCsOjff4ZTizXPNwKIzl56OoGg9d9Z/+5cs6On+CFCfevFQ3ZaTycx1YMbvDdRvjkp/lHdAcPXzokxcwfDwAAAABJRU5ErkJggg==","cursor.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxQTFRFAAAATU1NTU1NTU1NwlMHHwAAAAR0Uk5TAOvhxbpPrUkAAAAkSURBVHicY2BgYHBggAByabxg1WoGBq2pRCk9AKUbcND43AEAufYHlSuusE4AAAAASUVORK5CYII=","display_off.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAU1QTFRFAAAAh4eHh4eHAAAAAAAAAAAAAwMDAAAAAAAAhoaGGBgYgYGBAAAAPz8/AgICg4ODCQkJhISEh4eHh4eHPj4+NjY2gYGBg4ODgYGBgYGBgoKCAQEBJycngoKChYWFEBAQg4ODCAgIKioqZGRkCgoKBQUFERERd3d3gYGBGxsbNDQ0hISEgYGBPDw8gYGBgYGBh4eHh4eHhYWFh4eHgoKChYWFgYGBgYGBg4ODhoaGg4ODYWFhgoKCBgYGdXV1goKCg4ODgYGBgICAgYGBAAAAg4ODhYWFhISEh4eHgoKChYWFOjo6goKCGhoah4eHh4eHh4eHgoKCh4eHeXl5hoaGgoKChISEgYGBgYGBgoKCY2NjgYGBgoKCh4eHgoKCgYGBhoaGg4ODhoaGhYWFh4eHgYGBhoaGhoaGhoaGg4ODgoKChISEgoKChYWFh4eHfKktUwAAAG90Uk5TACn/AhEFKA8SLCbxCigoVBNKUTYoJ/lh3PyAKSaTNiBtICYpISggKSkmJ0LEKef3lGxA8rn//+pcMSkpnCcptHPJKe0LUjnx5LzKKaMnX73hl64pLnhkzNSgKeLv17LQ+liIzaLe7PfTw5tFpz3K1fXR/gAAAgBJREFUeJzllNdXwjAUxknB0lIoCKVsGTIFQRAZ7r333nuv///R3LZ4mlDQZ/0ekp7b37n5bnITk+mfyDxv5Tir3fwjaElO5BIOKZFLJS1dQVfI0Y809TtEV+elo95RpFPWG+1go4fdQ5QybI8haaNBkM2ANbM09bnrwaPY7iFKrz7EMBdu7CHdVruXIt0M1hb+GKA3LTRKkp5lTA6Dg6xIkhaHhvQ1IlW/UCouQdJNJTRIpk1qO7+wUpcfpl537oBc7VNip3Gi/AmVPBAC1UrL6HXtSGVT+k2Yz0Focad07OMRf3P5BEbd63PFQx7HN+w61JoAm+uBlV48O/0jkLSMmtPCmQ8HwlYdykFV4/LJPp7e3hVyFdapHNehLk6PSjhSkBvwu/cFyJGIYvOyhoc1jjYQFGbygD4CWjoAMla/og3YoSw+KPhjPNoFcim4iFD+pFYA8zZ9WeYU5OBjZ3ORWyCfG03E+47kKpCIJTpGO4KP8XMgtw990xG/PBNTgmPEEXwf7P42oOdFIRAoBCtqTKL6Rcwq4Xsgh5xYC/mmSs6yJKk1YbnVeTq1NaEpmlHbmVn2EORkW2trF2ZzmHGTSUMGl1a9hp4ySRpdQ8yKGURpMmRIYg9pb1YPzg6kO79cLlE6bYFjEtv91bLEUxvhwbWwjY13BxUb9l8+mn9EX8x3Nki8ff5wAAAAAElFTkSuQmCC","display_on.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAR1QTFRFAAAAh4eHgYGBAAAAAAAAgYGBAAAAAwMDAAAAAAAAgYGBg4ODGBgYgYGBhISEAAAAPz8/AgIChoaGCQkJhYWFPj4+NjY2goKCgYGBAQEBJycngYGBgoKCEBAQCAgIhISEKioqZGRkCgoKBQUFERERd3d3gYGBg4ODgYGBGxsbNDQ0hISEgoKCgoKChYWFPDw8gYGBgYGBhoaGgoKCg4ODgoKCgYGBgoKCgoKCgoKCg4ODgoKChoaGgoKCgYGBhoaGg4ODYWFhBgYGdXV1gYGBg4ODgoKCgICAg4ODg4ODhISEAAAAg4ODOjo6gYGBGhoaeXl5goKCgYGBgoKChYWFgoKChISEgoKCY2NjgYGBg4ODgYGBgYGBg4ODgYGBo8n54AAAAF90Uk5TACn/AhH3BSgPEuhUJvFACigoLBM2KCeA6ykm+pMgIEkmKSEoICn9XCkmJ0u6nDop4sUypGuEzLZ6vmCYLZ/dLykpJynUYa8pcllCC1Ip2ycpisl1PadFsintbsPQZdi/bTW7AAAB4UlEQVR4nOWUZ1fCMBSGSSGWFiq0UDbIkr2XbBwMxS0b1P//M0xK9XSiftX7oel585zkvfcmMRj+SRhvzRRlthm/BU3Ry3TYzofTsajpIOjw2iNAjIiddehvHXSdA0mkXEEdG0fkE1DEKXmkSVqVIA6rBmsktUgAWLWHoGp30UNclbtLmwQgoyya91wPTbFy0mQXJ5zJQO6BgXRjfH0iSkX5stHIXr5r0bB/lu8syjR8rzsFbR2SpX+5J2eMP3csLtYsEY2K8BeTFuE2jaVCBw7bHOBuxq16AXmpbui3LtIfbRLUHMY2q4lcFo2WB4KA1SUAlWumNEKCzyxBKZxVHvYGaFguCBx1vM/x0IPzoqQoj5SdP4mns2cCGhBsrgj0uaeUBtzMyxQN8w4mYROTW8+r0oANp8W5mf6WQw5aCYJ2o7ymPaKMi2uVpmWM4TW6tdImgGo1bT4nK6DbbsCc0AZSdmLEFszzHrh6riVvRrNA3/9SE8QLWQu+Gjto9+gE9NBMwr9zi83gFeeFTe11zpm1CHE3HeyVCSknf3MIDcFTbfJKdbR1L4xX49L+/BoillV5uPJqkshD3JWSgpNMXP/lcrD8+hO84MnDr5YpFHv0Fe99VjJ0GBRs2H74aP6R+ACr+TFvZNAQ1wAAAABJRU5ErkJggg==","down.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAKVQTFRFAAAAg4ODgICAAAAAAAAAAAAACAgIAAAAAAAAAAAAAAAAOTk5hYWFEBAQfHx8ODg4dnZ2NDQ0XV1dGxsbKCgogICAFBQUIiIiZGRkgICAgICAFRUVAAAAgICAgICAgICAf39/Li4ugICAcHBwgoKCgICAgoKCgICAg4ODgYGBPj4+goKCgICAhISEgYGBgICAgoKCgICAgYGBgYGBf39/gICAgICAIdPQHAAAADd0Uk5TACn/KAIRIBMFDwooKyApKSknKSYmzCcmKfL7JRCUi2L3J7IpcLUrr0VbKXntNEnkMbxrUcG56CMpi50AAAFZSURBVHic5ZRpf4MgDIeFKFatWm/tfW091u7evv9Hm1Acoujm2y0vFPH5Jf+EEE37J6bblmlatv4jaBCI4rMfR0CMXtAEJ0fccgfM7tAkQHXzArdDxggmqGETGCnJWROkNlOwOqhIhKCtgbSicw1uK/dATSK0aRatIzytA8ik4XSiyJnLSm+VPxULgeyLI3uHRJH+qcB4WZGrKb4c20WwI7b3iUt74OS6XD+xZWrXUCtme0uKTvfcJ65CZFa9VOebqwXmft+oT8yF+/VymT4XeGB+Xx8L+j4gBcoFIDT+oMz6Qp93Y74pCeBpUXaLuW0rUk6r1iv3nP322ewYkgv2nZIvgpSPQDrY5wTjRJDNg9XAE/+uSXIVX812GdKEmtvR2rtWaw+5MAOuofJy79SXu9TgBl4d9DZdI0NjgyiswNCB/qk1J5Bmvp+lQOa9IJNhW4bxm6H5R+wLQYMSQXZNzbcAAAAASUVORK5CYII=","price_range.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAIUlEQVR4nGNggAPm/w9gTA4QIQMitECEJ1yMEgLNDiAAADfgBMRu78GgAAAAAElFTkSuQmCC","price_time.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAOklEQVR4nGNggAPm/w9gTA4QIQPEClpMQMITRHCACScQoQQihBgY9P//grKgYk5wdTACYhQHFjuAAABZFAlc4e1fcQAAAABJRU5ErkJggg==","remove.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAK5QTFRFAAAAh4eHgICAAAAAAAAAh4eHAAAAAwMDAAAAAAAAgICAGBgYAAAAPz8/AgICgICACQkJhoaGhoaGgICAPj4+NjY2gYGBg4ODgYGBAQEBJycngoKCEBAQgICAgICACAgIKioqZGRkCgoKBQUFERERd3d3gYGBGxsbNDQ0gICAPDw8YWFhBgYGdXV1gICAg4ODgICAAAAAOjo6GhoaeXl5gICAhYWFY2NjhYWFgICA9O0oCgAAADp0Uk5TACn/AhErBSgPEvEmCigowxMuMcgoJ7hWrCkmdCD6vSAmKSEoICkpJie6KSknKSkp0wspJynCMik11rrLte8AAAFwSURBVHic5ZTXkoIwFIZNAAPSpKkoRQV7Wcva3v/FFiRmEwise7t7bs7MP98k/ylJq/VPQjjKiiJrwo+gON0uxro7XiRTsRHs+voE4JjoRrf+6sD7AFTMvaDGRht9glLMUJtLqmUwD5XDCohHAmBUPQSV27GHtFK7xycBWJab5uPaR+Hlmue7GfZxHwyWFHVMQghXFgD2A8IOZtfssdNJIXcyFEaSfchzp9BuMVP+Fhvr5Qh0nGfqYTGhm3BcYFUaQBKOhMWzRqHyGFRY03ppQ5lCFZ30RloVZGQTaa3QqEt0OyrQnkSkk8I1YJkvAwPCMgY0UpbzXRZhVbosIWGbZTLNQszGMCM42FJEjWDDjIAMtp+xj6x2K+/DqNDc0r4Yc8yGl3uer2aIyT1iyd8sYSuY8cldZbVrH4zPebTvP8OMNSoedj6XzDyk3pwG98u0/ufqGu7tBW5c1PxriXFyHq5PQxXFzeDThvbmp/lH4gt6WxfZ03H8DwAAAABJRU5ErkJggg==","settings.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAW5QTFRFAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoKBgYGGxsbKioqQEBAPj4+BQUFCAgIAQEBPz8/ZWVlh4eHZGRkAgICCQkJDw8PNjY2g4ODgoKCNTU1EBAQAAAAAwMDeXl5d3d3AAAAGBgYAAAAERERioqKgoKCgoKCgoKCgYGBgoKChISEhoaGNDQ0g4ODgICAgICAgICAgYGBgYGBhYWFgICAgICAPT09AAAAgYGBgICAgICAgICAgICAY2NjCAgIgICAgICAhYWFhYWFgYGBHBwcgICAhYWFGhoagYGBgYGBg4ODhoaGJycnAAAAhISEgICAg4ODPDw8AAAAgoKCgICAhISEOjo6h4eHgoKCgYGBgICAf39/gYGBgoKCgICAGBgYgYGBg4ODg4ODgICACwsLgYGBgICAgYGBgYGBgYGBgICAgYGBYWFhf39/g4ODPj4+gYGBg4ODgICAhYWFgoKCgYGBgICAgYGBgoKCdXV1T0kC9QAAAHp0Uk5TAAILDxMKESEnJiYpKSgTKSgpKSkoEyAnKSknIAYoKSkFJQEgKl94jYVvVC4nU9f/+K8pOu71KBCi3NPq/ikg0e01Nokm1UUnsZVqQSYOT9lrKRJz5lIpK12jyu+sesgnhGVLxCG55a6Um+GaKfJCKKRgKUt8ocergymDQ9knAAABsElEQVR4nOWUV1vCMBSGg1AQpBZrcVdE3KJxo4LgnuCoe4F7orjHv7doTk3bgF7rd5OnX94nZ+SkCP0TWQqsNpuVs/wI2h2FTleR2+XkHfa8YLHgKRGJSj2SN3fosvIKkVJlVXWONGrkWtEgn1zHJP1GMCs/g7XILFIUpXoTWmaKTnIImGovh72Gxqbmlta2dvgOGpsmQO0dnfhTXd3E6JH0pN1DNnr7MFE/HDsQ0qEO6Pxg9sCh4XDkGx2J6sovBD+G8eiYuo5PxLTKeLoJBZNgT2EcnjY0YYajUKsL7Fk1gcjU3PwChcYTFGorAnsRqlpa1tAVhUbdmr+6RtjIOlgbCjMBUdzc2t7ZzbJ7zAQ4p6GSfRVNwkeKLsvCg31w2JBdjlT0GDxZNzEnpcQ+xWfnFxeXVyp6Tay07gq+L/YUOoBvbomV0V8skiq//DutWfeEfJD1JPLCED4+Pb8kX986tApNQ4iqfSJT76bRzvlgBPODQXW/foYqK5lyeBeYJEL1gaoeGnwIBhjRoQ9SZgTAdEbO/9cKRfmZ+MpGPCVHQ3nBzzS4hKIkuNyh/5g+ALiAXSSas9hwAAAAAElFTkSuQmCC","time_range.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAJElEQVR4nGNgwAsUGJhQCScQoQQihBgY9P//grKgYk4YOvACACOpBKG6Svj+AAAAAElFTkSuQmCC","trash.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAALUlEQVR4nGNgAIN6ENHQACX4//9gYBBgYIESYC4LkA0lPEkmGFAI5v8PILYCAHygDJxlK0RUAAAAAElFTkSuQmCC","up.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAMZQTFRFAAAAh4eHgICAAAAAAAAAAAAAAwMDAAAAAAAAGBgYAAAAPz8/AgICCQkJgICAh4eHPj4+NjY2AQEBJycnEBAQgICAgICACAgIKioqZGRkCgoKBQUFgYGBERERd3d3gYGBGxsbNDQ0gICAgYGBPDw8gYGBh4eHgICAYWFhBgYGgYGBdXV1goKCg4ODhYWFgICAgoKCAAAAhISEOjo6gICAGhoagYGBeXl5hoaGgICAY2Njg4ODgoKCgoKCgYGBgoKCg4ODgoKC64uw1gAAAEJ0Uk5TACn/AhEFKA8SJgooKBP7KignKSYg9c0gJikhKLQgKSkmJ7ywKY8s5SknlClxKTMpXwtFKe0neiku8ClKWmSbbFFjM5GHSgAAAW5JREFUeJzllGd/gjAQxk3AMFWWOHDvVa2rVbu//5cqhJWQQO3b9nkVjv/v7rnLKJX+iYS9JMuSKvwIiu3loKkZzYHXFgvBiqW1QKSWplfySzvmAyDUN50cG2X0DDLqoTKXVLJgIIXDCohHAqCzHhymeuShy/Ru8kkAhtmhWUTvW9fdEnPQaVLU0n8XF0L3kn5P6LTtZPKgNoK+RrUkcGtQ7S9TsgOxxinrkUPYD+LwLCIh7CTsWSVQqRmTuPqpitlZFLQlApXjrsYBc335wOw47ksmUSMMrgKi/gnAE/awCqNHmTUwDf5X34LlBuedsgbUsK15kPMxTIXzzvFSIdsSPBw7nGD1K+7bL3F9xStEnZhoCw71TbpL71GBBbUF1MZmZWTOi97PI3eIJn9zCEtOj0+umaOde2EszqW9/xr6rM54WFtc0vfQNak57Ibd/Jerohu3GFwYqPjVEhve2Z4cbQU1ikFsQ73z0fwj+ga3VBezGuggFQAAAABJRU5ErkJggg=="}');
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: ./src/components/primitives/pin.js



// Semi-automatic pin object. For stretching things.


var Pin = /*#__PURE__*/function () {
  // (Comp reference, a name in overlay settings,
  // pin parameters)
  function Pin(comp, name, params) {
    var _this = this;

    if (params === void 0) {
      params = {};
    }

    classCallCheck_classCallCheck(this, Pin);

    this.RADIUS = comp.$props.config.PIN_RADIUS || 5.5;
    this.RADIUS_SQ = Math.pow(this.RADIUS + 7, 2);

    if (utils.is_mobile) {
      this.RADIUS += 2;
      this.RADIUS_SQ *= 2.5;
    }

    this.COLOR_BACK = comp.$props.colors.back;
    this.COLOR_BR = comp.$props.colors.text;
    this.comp = comp;
    this.layout = comp.layout;
    this.mouse = comp.mouse;
    this.name = name;
    this.state = params.state || 'settled';
    this.hidden = params.hidden || false;
    this.mouse.on('mousemove', function (e) {
      return _this.mousemove(e);
    });
    this.mouse.on('mousedown', function (e) {
      return _this.mousedown(e);
    });
    this.mouse.on('mouseup', function (e) {
      return _this.mouseup(e);
    });

    if (comp.state === 'finished') {
      this.state = 'settled';
      this.update_from(comp.$props.settings[name]);
    } else {
      this.update();
    }

    if (this.state !== 'settled') {
      this.comp.$emit('scroll-lock', true);
    }
  }

  createClass_createClass(Pin, [{
    key: "re_init",
    value: function re_init() {
      this.update_from(this.comp.$props.settings[this.name]);
    }
  }, {
    key: "draw",
    value: function draw(ctx) {
      if (this.hidden) return;

      switch (this.state) {
        case 'tracking':
          break;

        case 'dragging':
          if (!this.moved) this.draw_circle(ctx);
          break;

        case 'settled':
          this.draw_circle(ctx);
          break;
      }
    }
  }, {
    key: "draw_circle",
    value: function draw_circle(ctx) {
      this.layout = this.comp.layout;

      if (this.comp.selected) {
        var r = this.RADIUS,
            lw = 1.5;
      } else {
        var r = this.RADIUS * 0.95,
            lw = 1;
      }

      ctx.lineWidth = lw;
      ctx.strokeStyle = this.COLOR_BR;
      ctx.fillStyle = this.COLOR_BACK;
      ctx.beginPath();
      ctx.arc(this.x = this.layout.t2screen(this.t), this.y = this.layout.$2screen(this.y$), r + 0.5, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.stroke();
    }
  }, {
    key: "update",
    value: function update() {
      this.y$ = this.comp.$props.cursor.y$;
      this.y = this.comp.$props.cursor.y;
      this.t = this.comp.$props.cursor.t;
      this.x = this.comp.$props.cursor.x; // Save pin as time in IB mode
      //if (this.layout.ti_map.ib) {
      //    this.t = this.layout.ti_map.i2t(this.t )
      //}
      // Reset the settings attahed to the pin (position)

      this.comp.$emit('change-settings', _defineProperty({}, this.name, [this.t, this.y$]));
    }
  }, {
    key: "update_from",
    value: function update_from(data, emit) {
      if (emit === void 0) {
        emit = false;
      }

      if (!data) return;
      this.layout = this.comp.layout;
      this.y$ = data[1];
      this.y = this.layout.$2screen(this.y$);
      this.t = data[0];
      this.x = this.layout.t2screen(this.t); // TODO: Save pin as time in IB mode
      //if (this.layout.ti_map.ib) {
      //    this.t = this.layout.ti_map.i2t(this.t )
      //}

      if (emit) this.comp.$emit('change-settings', _defineProperty({}, this.name, [this.t, this.y$]));
    }
  }, {
    key: "rec_position",
    value: function rec_position() {
      this.t1 = this.t;
      this.y$1 = this.y$;
    }
  }, {
    key: "mousemove",
    value: function mousemove(event) {
      switch (this.state) {
        case 'tracking':
        case 'dragging':
          this.moved = true;
          this.update();
          break;
      }
    }
  }, {
    key: "mousedown",
    value: function mousedown(event, force) {
      if (force === void 0) {
        force = false;
      }

      if (utils.default_prevented(event) && !force) return;

      switch (this.state) {
        case 'tracking':
          this.state = 'settled';
          if (this.on_settled) this.on_settled();
          this.comp.$emit('scroll-lock', false);
          break;

        case 'settled':
          if (this.hidden) return;

          if (this.hover()) {
            this.state = 'dragging';
            this.moved = false;
            this.comp.$emit('scroll-lock', true);
            this.comp.$emit('object-selected');
          }

          break;
      }

      if (this.hover()) {
        event.preventDefault();
      }
    }
  }, {
    key: "mouseup",
    value: function mouseup(event) {
      switch (this.state) {
        case 'dragging':
          this.state = 'settled';
          if (this.on_settled) this.on_settled();
          this.comp.$emit('scroll-lock', false);
          break;
      }
    }
  }, {
    key: "on",
    value: function on(name, handler) {
      switch (name) {
        case 'settled':
          this.on_settled = handler;
          break;
      }
    }
  }, {
    key: "hover",
    value: function hover() {
      var x = this.x;
      var y = this.y;
      return (x - this.mouse.x) * (x - this.mouse.x) + (y - this.mouse.y) * (y - this.mouse.y) < this.RADIUS_SQ;
    }
  }]);

  return Pin;
}();


;// CONCATENATED MODULE: ./src/components/primitives/seg.js


// Draws a segment, adds corresponding collision f-n



var Seg = /*#__PURE__*/function () {
  // Overlay ref, canvas ctx
  function Seg(overlay, ctx) {
    classCallCheck_classCallCheck(this, Seg);

    this.ctx = ctx;
    this.comp = overlay;
    this.T = overlay.$props.config.TOOL_COLL;
    if (utils.is_mobile) this.T *= 2;
  } // p1[t, $], p2[t, $] (time-price coordinates)


  createClass_createClass(Seg, [{
    key: "draw",
    value: function draw(p1, p2) {
      var layout = this.comp.$props.layout;
      var x1 = layout.t2screen(p1[0]);
      var y1 = layout.$2screen(p1[1]);
      var x2 = layout.t2screen(p2[0]);
      var y2 = layout.$2screen(p2[1]);
      this.ctx.moveTo(x1, y1);
      this.ctx.lineTo(x2, y2);
      this.comp.collisions.push(this.make([x1, y1], [x2, y2]));
    } // Collision function. x, y - mouse coord.

  }, {
    key: "make",
    value: function make(p1, p2) {
      var _this = this;

      return function (x, y) {
        return math.point2seg([x, y], p1, p2) < _this.T;
      };
    }
  }]);

  return Seg;
}();


;// CONCATENATED MODULE: ./src/components/primitives/line.js


// Draws a line, adds corresponding collision f-n



var Line = /*#__PURE__*/function () {
  // Overlay ref, canvas ctx
  function Line(overlay, ctx) {
    classCallCheck_classCallCheck(this, Line);

    this.ctx = ctx;
    this.comp = overlay;
    this.T = overlay.$props.config.TOOL_COLL;
    if (utils.is_mobile) this.T *= 2;
  } // p1[t, $], p2[t, $] (time-price coordinates)


  createClass_createClass(Line, [{
    key: "draw",
    value: function draw(p1, p2) {
      var layout = this.comp.$props.layout;
      var x1 = layout.t2screen(p1[0]);
      var y1 = layout.$2screen(p1[1]);
      var x2 = layout.t2screen(p2[0]);
      var y2 = layout.$2screen(p2[1]);
      this.ctx.moveTo(x1, y1);
      this.ctx.lineTo(x2, y2);
      var w = layout.width;
      var h = layout.height; // TODO: transform k (angle) to screen ratio
      // (this requires a new a2screen function)

      var k = (y2 - y1) / (x2 - x1);
      var s = Math.sign(x2 - x1 || y2 - y1);
      var dx = w * s * 2;
      var dy = w * k * s * 2;

      if (dy === Infinity) {
        dx = 0, dy = h * s;
      }

      this.ctx.moveTo(x2, y2);
      this.ctx.lineTo(x2 + dx, y2 + dy);

      if (!this.ray) {
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x1 - dx, y1 - dy);
      }

      this.comp.collisions.push(this.make([x1, y1], [x2, y2]));
    } // Collision function. x, y - mouse coord.

  }, {
    key: "make",
    value: function make(p1, p2) {
      var _this = this;

      var f = this.ray ? math.point2ray.bind(math) : math.point2line.bind(math);
      return function (x, y) {
        return f([x, y], p1, p2) < _this.T;
      };
    }
  }]);

  return Line;
}();


;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function typeof_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    typeof_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    typeof_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return typeof_typeof(obj);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(self, call) {
  if (call && (typeof_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
;// CONCATENATED MODULE: ./src/components/primitives/ray.js





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Draws a ray, adds corresponding collision f-n


var Ray = /*#__PURE__*/function (_Line) {
  _inherits(Ray, _Line);

  var _super = _createSuper(Ray);

  function Ray(overlay, ctx) {
    var _this;

    classCallCheck_classCallCheck(this, Ray);

    _this = _super.call(this, overlay, ctx);
    _this.ray = true;
    return _this;
  }

  return Ray;
}(Line);


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/LineTool.vue?vue&type=script&lang=js&
// Line drawing tool
// TODO: make an angle-snap when "Shift" is pressed







/* harmony default export */ const LineToolvue_type_script_lang_js_ = ({
  name: 'LineTool',
  mixins: [overlay, tool],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    tool: function tool() {
      return {
        // Descriptor for the tool
        group: 'Lines',
        icon: icons_namespaceObject["segment.png"],
        type: 'Segment',
        hint: 'This hint will be shown on hover',
        data: [],
        // Default data
        settings: {},
        // Default settings
        // Modifications
        mods: {
          'Extended': {
            // Rewrites the default setting fields
            settings: {
              extended: true
            },
            icon: icons_namespaceObject["extended.png"]
          },
          'Ray': {
            // Rewrites the default setting fields
            settings: {
              ray: true
            },
            icon: icons_namespaceObject["ray.png"]
          }
        }
      };
    },
    // Called after overlay mounted
    init: function init() {
      var _this = this;

      // First pin is settled at the mouse position
      this.pins.push(new Pin(this, 'p1')); // Second one is following mouse until it clicks

      this.pins.push(new Pin(this, 'p2', {
        state: 'tracking'
      }));
      this.pins[1].on('settled', function () {
        // Call when current tool drawing is finished
        // (Optionally) reset the mode back to 'Cursor'
        _this.set_state('finished');

        _this.$emit('drawing-mode-off');
      });
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      if (this.sett.ray) {
        new Ray(this, ctx).draw(this.p1, this.p2);
      } else if (this.sett.extended) {
        new Line(this, ctx).draw(this.p1, this.p2);
      } else {
        new Seg(this, ctx).draw(this.p1, this.p2);
      }

      ctx.stroke();
      this.render_pins(ctx);
    },
    use_for: function use_for() {
      return ['LineTool'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      return this.sett.color || '#42b28a';
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/LineTool.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_LineToolvue_type_script_lang_js_ = (LineToolvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/LineTool.vue
var LineTool_render, LineTool_staticRenderFns
;



/* normalize component */
;
var LineTool_component = normalizeComponent(
  overlays_LineToolvue_type_script_lang_js_,
  LineTool_render,
  LineTool_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LineTool_api; }
LineTool_component.options.__file = "src/components/overlays/LineTool.vue"
/* harmony default export */ const LineTool = (LineTool_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/RangeTool.vue?vue&type=script&lang=js&

// Price/Time measurment tool





/* harmony default export */ const RangeToolvue_type_script_lang_js_ = ({
  name: 'RangeTool',
  mixins: [overlay, tool],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '2.0.1'
      };
    },
    tool: function tool() {
      return {
        // Descriptor for the tool
        group: 'Measurements',
        icon: icons_namespaceObject["price_range.png"],
        type: 'Price',
        hint: 'Price Range',
        data: [],
        // Default data
        settings: {},
        // Default settings
        mods: {
          'Time': {
            // Rewrites the default setting fields
            icon: icons_namespaceObject["time_range.png"],
            settings: {
              price: false,
              time: true
            }
          },
          'PriceTime': {
            // Rewrites the default setting fields
            icon: icons_namespaceObject["price_time.png"],
            settings: {
              price: true,
              time: true
            }
          },
          'ShiftMode': {
            // Rewrites the default setting fields
            settings: {
              price: true,
              time: true,
              shiftMode: true
            },
            hidden: true
          }
        }
      };
    },
    // Called after overlay mounted
    init: function init() {
      var _this = this;

      // First pin is settled at the mouse position
      this.pins.push(new Pin(this, 'p1', {
        hidden: this.shift
      })); // Second one is following mouse until it clicks

      this.pins.push(new Pin(this, 'p2', {
        state: 'tracking',
        hidden: this.shift
      }));
      this.pins[1].on('settled', function () {
        // Call when current tool drawing is finished
        // (Optionally) reset the mode back to 'Cursor'
        _this.set_state('finished');

        _this.$emit('drawing-mode-off'); // Deselect the tool in shiftMode


        if (_this.shift) _this._$emit('custom-event', {
          event: 'object-selected',
          args: []
        });
      });
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      var dir = Math.sign(this.p2[1] - this.p1[1]);
      var layout = this.$props.layout;
      var xm = layout.t2screen((this.p1[0] + this.p2[0]) * 0.5);
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color; // Background

      ctx.fillStyle = this.back_color;
      var x1 = layout.t2screen(this.p1[0]);
      var y1 = layout.$2screen(this.p1[1]);
      var x2 = layout.t2screen(this.p2[0]);
      var y2 = layout.$2screen(this.p2[1]);
      ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      if (this.price) this.vertical(ctx, x1, y1, x2, y2, xm);
      if (this.time) this.horizontal(ctx, x1, y1, x2, y2, xm);
      this.draw_value(ctx, dir, xm, y2);
      this.render_pins(ctx);
    },
    vertical: function vertical(ctx, x1, y1, x2, y2, xm) {
      var layout = this.$props.layout;
      var dir = Math.sign(this.p2[1] - this.p1[1]);
      ctx.beginPath();

      if (!this.shift) {
        // Top
        new Seg(this, ctx).draw([this.p1[0], this.p2[1]], [this.p2[0], this.p2[1]]); // Bottom

        new Seg(this, ctx).draw([this.p1[0], this.p1[1]], [this.p2[0], this.p1[1]]);
      } // Vertical Arrow


      ctx.moveTo(xm - 4, y2 + 5 * dir);
      ctx.lineTo(xm, y2);
      ctx.lineTo(xm + 4, y2 + 5 * dir);
      ctx.stroke(); // Vertical Line

      ctx.beginPath();
      ctx.setLineDash([5, 5]);
      new Seg(this, ctx).draw([(this.p1[0] + this.p2[0]) * 0.5, this.p2[1]], [(this.p1[0] + this.p2[0]) * 0.5, this.p1[1]]);
      ctx.stroke();
      ctx.setLineDash([]);
    },
    horizontal: function horizontal(ctx, x1, y1, x2, y2, xm) {
      var layout = this.$props.layout;
      var xdir = Math.sign(this.p2[0] - this.p1[0]);
      var ym = (layout.$2screen(this.p1[1]) + layout.$2screen(this.p2[1])) / 2;
      ctx.beginPath();

      if (!this.shift) {
        // Left
        new Seg(this, ctx).draw([this.p1[0], this.p1[1]], [this.p1[0], this.p2[1]]); // Right

        new Seg(this, ctx).draw([this.p2[0], this.p1[1]], [this.p2[0], this.p2[1]]);
      } // Horizontal Arrow


      ctx.moveTo(x2 - 5 * xdir, ym - 4);
      ctx.lineTo(x2, ym);
      ctx.lineTo(x2 - 5 * xdir, ym + 4);
      ctx.stroke(); // Horizontal Line

      ctx.beginPath();
      ctx.setLineDash([5, 5]);
      ctx.moveTo(x1, ym);
      ctx.lineTo(x2, ym);
      ctx.stroke();
      ctx.setLineDash([]);
    },
    // WTF? I know dude, a lot of shitty code here
    draw_value: function draw_value(ctx, dir, xm, y) {
      var _this2 = this;

      ctx.font = this.new_font; // Price delta (anf percent)

      var d$ = (this.p2[1] - this.p1[1]).toFixed(this.prec);
      var p = (100 * (this.p2[1] / this.p1[1] - 1)).toFixed(this.prec); // Map interval to the actual tf (in ms)

      var f = function f(t) {
        return _this2.layout.ti_map.smth2t(t);
      };

      var dt = f(this.p2[0]) - f(this.p1[0]);
      var tf = this.layout.ti_map.tf; // Bars count (through the candle index)

      var f2 = function f2(t) {
        var c = _this2.layout.c_magnet(t);

        var cn = _this2.layout.candles || _this2.layout.master_grid.candles;
        return cn.indexOf(c);
      }; // Bars count (and handling the negative values)


      var b = f2(this.p2[0]) - f2(this.p1[0]); // Format time delta
      // Format time delta

      var dtstr = this.t2str(dt);
      var text = [];
      if (this.price) text.push("".concat(d$, "  (").concat(p, "%)"));
      if (this.time) text.push("".concat(b, " bars, ").concat(dtstr));
      text = text.join('\n'); // "Multiple" fillText

      var lines = text.split('\n');
      var w = Math.max.apply(Math, _toConsumableArray(lines.map(function (x) {
        return ctx.measureText(x).width + 20;
      })).concat([100]));
      var n = lines.length;
      var h = 20 * n;
      ctx.fillStyle = this.value_back;
      ctx.fillRect(xm - w * 0.5, y - (10 + h) * dir, w, h * dir);
      ctx.fillStyle = this.value_color;
      ctx.textAlign = 'center';
      lines.forEach(function (l, i) {
        ctx.fillText(l, xm, y + (dir > 0 ? 20 * i - 20 * n + 5 : 20 * i + 25));
      });
    },
    // Formats time from ms to `1D 12h` for example
    t2str: function t2str(t) {
      var sign = Math.sign(t);
      var abs = Math.abs(t);
      var tfs = [[1000, 's', 60], [60000, 'm', 60], [3600000, 'h', 24], [86400000, 'D', 7], [604800000, 'W', 4], [2592000000, 'M', 12], [31536000000, 'Y', Infinity], [Infinity, 'Eternity', Infinity]];

      for (var i = 0; i < tfs.length; i++) {
        tfs[i][0] = Math.floor(abs / tfs[i][0]);

        if (tfs[i][0] === 0) {
          var p1 = tfs[i - 1];
          var p2 = tfs[i - 2];
          var txt = sign < 0 ? '-' : '';

          if (p1) {
            txt += p1.slice(0, 2).join('');
          }

          var n2 = p2 ? p2[0] - p1[0] * p2[2] : 0;

          if (p2 && n2) {
            txt += ' ';
            txt += "".concat(n2).concat(p2[1]);
          }

          return txt;
        }
      }
    },
    use_for: function use_for() {
      return ['RangeTool'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      return this.sett.color || this.$props.colors.cross;
    },
    back_color: function back_color() {
      return this.sett.backColor || '#9b9ba316';
    },
    value_back: function value_back() {
      return this.sett.valueBack || '#9b9ba316';
    },
    value_color: function value_color() {
      return this.sett.valueColor || this.$props.colors.text;
    },
    prec: function prec() {
      return this.sett.precision || 2;
    },
    new_font: function new_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    price: function price() {
      return 'price' in this.sett ? this.sett.price : true;
    },
    time: function time() {
      return 'time' in this.sett ? this.sett.time : false;
    },
    shift: function shift() {
      return this.sett.shiftMode;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/RangeTool.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_RangeToolvue_type_script_lang_js_ = (RangeToolvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/RangeTool.vue
var RangeTool_render, RangeTool_staticRenderFns
;



/* normalize component */
;
var RangeTool_component = normalizeComponent(
  overlays_RangeToolvue_type_script_lang_js_,
  RangeTool_render,
  RangeTool_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var RangeTool_api; }
RangeTool_component.options.__file = "src/components/overlays/RangeTool.vue"
/* harmony default export */ const RangeTool = (RangeTool_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Grid.vue?vue&type=script&lang=js&
function Gridvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Gridvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Gridvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Gridvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Gridvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Gridvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Sets up all layers/overlays for the grid with 'grid_id'

















/* harmony default export */ const Gridvue_type_script_lang_js_ = ({
  name: 'Grid',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'overlays', 'width', 'height', 'data', 'grid_id', 'y_transform', 'font', 'tv_id', 'config', 'meta', 'shaders'],
  mixins: [canvas, uxlist],
  components: {
    Crosshair: components_Crosshair,
    KeyboardListener: KeyboardListener
  },
  created: function created() {
    var _this = this;

    // List of all possible overlays (builtin + custom)
    this._list = [Spline, Splines, Range, Trades, Channel, Segment, Candles, Volume, Splitters, LineTool, RangeTool].concat(this.$props.overlays);
    this._registry = {}; // We need to know which components we will use.
    // Custom overlay components overwrite built-ins:

    var tools = [];

    this._list.forEach(function (x, i) {
      var use_for = x.methods.use_for();
      if (x.methods.tool) tools.push({
        use_for: use_for,
        info: x.methods.tool()
      });
      use_for.forEach(function (indicator) {
        _this._registry[indicator] = i;
      });
    });

    this.$emit('custom-event', {
      event: 'register-tools',
      args: tools
    });
    this.$on('custom-event', function (e) {
      return _this.on_ux_event(e, 'grid');
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.renderer) this.renderer.destroy();
  },
  mounted: function mounted() {
    var _this2 = this;

    var el = this.$refs['canvas'];
    this.renderer = new Grid(el, this);
    this.setup();
    this.$nextTick(function () {
      return _this2.redraw();
    });
  },
  render: function render(h) {
    var id = this.$props.grid_id;
    var layout = this.$props.layout.grids[id];
    return this.create_canvas(h, "grid-".concat(id), {
      position: {
        x: 0,
        y: layout.offset || 0
      },
      attrs: {
        width: layout.width,
        height: layout.height,
        overflow: 'hidden'
      },
      style: {
        backgroundColor: this.$props.colors.back
      },
      hs: [h(components_Crosshair, {
        props: this.common_props(),
        on: this.layer_events
      }), h(KeyboardListener, {
        on: this.keyboard_events
      }), h(UxLayer, {
        props: {
          id: id,
          tv_id: this.$props.tv_id,
          uxs: this.uxs,
          colors: this.$props.colors,
          config: this.$props.config,
          updater: Math.random()
        },
        on: {
          'custom-event': this.emit_ux_event
        }
      })].concat(this.get_overlays(h))
    });
  },
  methods: {
    new_layer: function new_layer(layer) {
      var _this3 = this;

      this.$nextTick(function () {
        return _this3.renderer.new_layer(layer);
      });
    },
    del_layer: function del_layer(layer) {
      var _this4 = this;

      this.$nextTick(function () {
        return _this4.renderer.del_layer(layer);
      });
      var grid_id = this.$props.grid_id;
      this.$emit('custom-event', {
        event: 'remove-shaders',
        args: [grid_id, layer]
      }); // TODO: close all interfaces

      this.$emit('custom-event', {
        event: 'remove-layer-meta',
        args: [grid_id, layer]
      });
      this.remove_all_ux(layer);
    },
    get_overlays: function get_overlays(h) {
      var _this5 = this;

      // Distributes overlay data & settings according
      // to this._registry; returns compo list
      var comp_list = [],
          count = {};

      var _iterator = Gridvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var d = _step.value;
          var comp = this._list[this._registry[d.type]];

          if (comp) {
            if (comp.methods.calc) {
              comp = this.inject_renderer(comp);
            }

            comp_list.push({
              cls: comp,
              type: d.type,
              data: d.data,
              settings: d.settings,
              i0: d.i0,
              tf: d.tf,
              last: d.last
            });
            count[d.type] = 0;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return comp_list.map(function (x, i) {
        return h(x.cls, {
          on: _this5.layer_events,
          attrs: Object.assign(_this5.common_props(), {
            id: "".concat(x.type, "_").concat(count[x.type]++),
            type: x.type,
            data: x.data,
            settings: x.settings,
            i0: x.i0,
            tf: x.tf,
            num: i,
            grid_id: _this5.$props.grid_id,
            meta: _this5.$props.meta,
            last: x.last
          })
        });
      });
    },
    common_props: function common_props() {
      return {
        cursor: this.$props.cursor,
        colors: this.$props.colors,
        layout: this.$props.layout.grids[this.$props.grid_id],
        interval: this.$props.interval,
        sub: this.$props.sub,
        font: this.$props.font,
        config: this.$props.config
      };
    },
    emit_ux_event: function emit_ux_event(e) {
      var e_pass = this.on_ux_event(e, 'grid');
      if (e_pass) this.$emit('custom-event', e);
    },
    // Replace the current comp with 'renderer'
    inject_renderer: function inject_renderer(comp) {
      var src = comp.methods.calc();

      if (!src.conf || !src.conf.renderer || comp.__renderer__) {
        return comp;
      } // Search for an overlay with the target 'name'


      var f = this._list.find(function (x) {
        return x.name === src.conf.renderer;
      });

      if (!f) return comp;
      comp.mixins.push(f);
      comp.__renderer__ = src.conf.renderer;
      return comp;
    }
  },
  computed: {
    is_active: function is_active() {
      return this.$props.cursor.t !== undefined && this.$props.cursor.grid_id === this.$props.grid_id;
    }
  },
  watch: {
    range: {
      handler: function handler() {
        var _this6 = this;

        // TODO: Left-side render lag fix:
        // Overlay data is updated one tick later than
        // the main sub. Fast fix is to delay redraw()
        // call. It will be a solution until a better
        // one comes by.
        this.$nextTick(function () {
          return _this6.redraw();
        });
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        if (!this.$props.cursor.locked) this.redraw();
      },
      deep: true
    },
    overlays: {
      // Track changes in calc() functions
      handler: function handler(ovs) {
        var _iterator2 = Gridvue_type_script_lang_js_createForOfIteratorHelper(ovs),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var ov = _step2.value;

            var _iterator3 = Gridvue_type_script_lang_js_createForOfIteratorHelper(this.$children),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var comp = _step3.value;
                if (typeof comp.id !== 'string') continue;
                var tuple = comp.id.split('_');
                tuple.pop();

                if (tuple.join('_') === ov.name) {
                  comp.calc = ov.methods.calc;
                  if (!comp.calc) continue;
                  var calc = comp.calc.toString();

                  if (calc !== ov.__prevscript__) {
                    comp.exec_script();
                  }

                  ov.__prevscript__ = calc;
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      deep: true
    },
    // Redraw on the shader list change
    shaders: function shaders(n, p) {
      this.redraw();
    }
  },
  data: function data() {
    var _this7 = this;

    return {
      layer_events: {
        'new-grid-layer': this.new_layer,
        'delete-grid-layer': this.del_layer,
        'show-grid-layer': function showGridLayer(d) {
          _this7.renderer.show_hide_layer(d);

          _this7.redraw();
        },
        'redraw-grid': this.redraw,
        'layer-meta-props': function layerMetaProps(d) {
          return _this7.$emit('layer-meta-props', d);
        },
        'custom-event': function customEvent(d) {
          return _this7.$emit('custom-event', d);
        }
      },
      keyboard_events: {
        'register-kb-listener': function registerKbListener(event) {
          _this7.$emit('register-kb-listener', event);
        },
        'remove-kb-listener': function removeKbListener(event) {
          _this7.$emit('remove-kb-listener', event);
        },
        'keyup': function keyup(event) {
          if (!_this7.is_active) return;

          _this7.renderer.propagate('keyup', event);
        },
        'keydown': function keydown(event) {
          if (!_this7.is_active) return; // TODO: is this neeeded?

          _this7.renderer.propagate('keydown', event);
        },
        'keypress': function keypress(event) {
          if (!_this7.is_active) return;

          _this7.renderer.propagate('keypress', event);
        }
      }
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Grid.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Gridvue_type_script_lang_js_ = (Gridvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Grid.vue
var Grid_render, Grid_staticRenderFns
;



/* normalize component */
;
var Grid_component = normalizeComponent(
  components_Gridvue_type_script_lang_js_,
  Grid_render,
  Grid_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Grid_api; }
Grid_component.options.__file = "src/components/Grid.vue"
/* harmony default export */ const components_Grid = (Grid_component.exports);
;// CONCATENATED MODULE: ./src/components/js/sidebar.js



function sidebar_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = sidebar_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function sidebar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sidebar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sidebar_arrayLikeToArray(o, minLen); }

function sidebar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




var PANHEIGHT;

var Sidebar = /*#__PURE__*/function () {
  function Sidebar(canvas, comp, side) {
    if (side === void 0) {
      side = 'right';
    }

    classCallCheck_classCallCheck(this, Sidebar);

    PANHEIGHT = comp.config.PANHEIGHT;
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.id = this.$p.grid_id;
    this.layout = this.$p.layout.grids[this.id];
    this.side = side;
    this.listeners();
  }

  createClass_createClass(Sidebar, [{
    key: "listeners",
    value: function listeners() {
      var _this = this;

      var mc = this.mc = new hammer.Manager(this.canvas);
      mc.add(new hammer.Pan({
        direction: hammer.DIRECTION_VERTICAL,
        threshold: 0
      }));
      mc.add(new hammer.Tap({
        event: 'doubletap',
        taps: 2,
        posThreshold: 50
      }));
      mc.on('panstart', function (event) {
        if (_this.$p.y_transform) {
          _this.zoom = _this.$p.y_transform.zoom;
        } else {
          _this.zoom = 1.0;
        }

        _this.y_range = [_this.layout.$_hi, _this.layout.$_lo];
        _this.drug = {
          y: event.center.y,
          z: _this.zoom,
          mid: math.log_mid(_this.y_range, _this.layout.height),
          A: _this.layout.A,
          B: _this.layout.B
        };
      });
      mc.on('panmove', function (event) {
        if (_this.drug) {
          _this.zoom = _this.calc_zoom(event);

          _this.comp.$emit('sidebar-transform', {
            grid_id: _this.id,
            zoom: _this.zoom,
            auto: false,
            range: _this.calc_range(),
            drugging: true
          });

          _this.update();
        }
      });
      mc.on('panend', function () {
        _this.drug = null;

        _this.comp.$emit('sidebar-transform', {
          grid_id: _this.id,
          drugging: false
        });
      });
      mc.on('doubletap', function () {
        _this.comp.$emit('sidebar-transform', {
          grid_id: _this.id,
          zoom: 1.0,
          auto: true
        });

        _this.zoom = 1.0;

        _this.update();
      }); // TODO: Do later for mobile version
    }
  }, {
    key: "update",
    value: function update() {
      // Update reference to the grid
      this.layout = this.$p.layout.grids[this.id];
      var points = this.layout.ys;
      var x,
          y,
          w,
          h,
          side = this.side;
      var sb = this.layout.sb; //this.ctx.fillStyle = this.$p.colors.back

      this.ctx.font = this.$p.font;

      switch (side) {
        case 'left':
          x = 0;
          y = 0;
          w = Math.floor(sb);
          h = this.layout.height; //this.ctx.fillRect(x, y, w, h)

          this.ctx.clearRect(x, y, w, h);
          this.ctx.strokeStyle = this.$p.colors.scale;
          this.ctx.beginPath();
          this.ctx.moveTo(x + 0.5, 0);
          this.ctx.lineTo(x + 0.5, h);
          this.ctx.stroke();
          break;

        case 'right':
          x = 0;
          y = 0;
          w = Math.floor(sb);
          h = this.layout.height; //this.ctx.fillRect(x, y, w, h)

          this.ctx.clearRect(x, y, w, h);
          this.ctx.strokeStyle = this.$p.colors.scale;
          this.ctx.beginPath();
          this.ctx.moveTo(x + 0.5, 0);
          this.ctx.lineTo(x + 0.5, h);
          this.ctx.stroke();
          break;
      }

      this.ctx.fillStyle = this.$p.colors.text;
      this.ctx.beginPath();

      var _iterator = sidebar_createForOfIteratorHelper(points),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          if (p[0] > this.layout.height) continue;
          var x1 = side === 'left' ? w - 0.5 : x - 0.5;
          var x2 = side === 'left' ? x1 - 4.5 : x1 + 4.5;
          this.ctx.moveTo(x1, p[0] - 0.5);
          this.ctx.lineTo(x2, p[0] - 0.5);
          var offst = side === 'left' ? -10 : 10;
          this.ctx.textAlign = side === 'left' ? 'end' : 'start';
          var d = this.layout.prec;
          this.ctx.fillText(p[1].toFixed(d), x1 + offst, p[0] + 4);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.ctx.stroke();
      if (this.$p.grid_id) this.upper_border();
      this.apply_shaders();
      if (this.$p.cursor.y && this.$p.cursor.y$) this.panel();
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.$p.layout.grids[this.id];
      var props = {
        layout: layout,
        cursor: this.$p.cursor
      };

      var _iterator2 = sidebar_createForOfIteratorHelper(this.$p.shaders),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "upper_border",
    value: function upper_border() {
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(this.layout.width, 0.5);
      this.ctx.stroke();
    } // A gray bar behind the current price

  }, {
    key: "panel",
    value: function panel() {
      if (this.$p.cursor.grid_id !== this.layout.id) {
        return;
      }

      var lbl = this.$p.cursor.y$.toFixed(this.layout.prec);
      this.ctx.fillStyle = this.$p.colors.panel;
      var panwidth = this.layout.sb + 1;
      var x = -0.5;
      var y = this.$p.cursor.y - PANHEIGHT * 0.5 - 0.5;
      var a = 7;
      this.ctx.fillRect(x - 0.5, y, panwidth, PANHEIGHT);
      this.ctx.fillStyle = this.$p.colors.textHL;
      this.ctx.textAlign = 'left';
      this.ctx.fillText(lbl, a, y + 15);
    }
  }, {
    key: "calc_zoom",
    value: function calc_zoom(event) {
      var d = this.drug.y - event.center.y;
      var speed = d > 0 ? 3 : 1;
      var k = 1 + speed * d / this.layout.height;
      return utils.clamp(this.drug.z * k, 0.005, 100);
    } // Not the best place to calculate y-range but
    // this is the simplest solution I found up to
    // date

  }, {
    key: "calc_range",
    value: function calc_range(diff1, diff2) {
      var _this2 = this;

      if (diff1 === void 0) {
        diff1 = 1;
      }

      if (diff2 === void 0) {
        diff2 = 1;
      }

      var z = this.zoom / this.drug.z;
      var zk = (1 / z - 1) / 2;
      var range = this.y_range.slice();
      var delta = range[0] - range[1];

      if (!this.layout.grid.logScale) {
        range[0] = range[0] + delta * zk * diff1;
        range[1] = range[1] - delta * zk * diff2;
      } else {
        var px_mid = this.layout.height / 2;
        var new_hi = px_mid - px_mid * (1 / z);
        var new_lo = px_mid + px_mid * (1 / z); // Use old mapping to get a new range

        var f = function f(y) {
          return math.exp((y - _this2.drug.B) / _this2.drug.A);
        };

        var copy = range.slice();
        range[0] = f(new_hi);
        range[1] = f(new_lo);
      }

      return range;
    }
  }, {
    key: "rezoom_range",
    value: function rezoom_range(delta, diff1, diff2) {
      if (!this.$p.y_transform || this.$p.y_transform.auto) return;
      this.zoom = 1.0; // TODO: further work (improve scaling ratio)

      if (delta < 0) delta /= 3.75; // Btw, idk why 3.75, but it works

      delta *= 0.25;
      this.y_range = [this.layout.$_hi, this.layout.$_lo];
      this.drug = {
        y: 0,
        z: this.zoom,
        mid: math.log_mid(this.y_range, this.layout.height),
        A: this.layout.A,
        B: this.layout.B
      };
      this.zoom = this.calc_zoom({
        center: {
          y: delta * this.layout.height
        }
      });
      this.comp.$emit('sidebar-transform', {
        grid_id: this.id,
        zoom: this.zoom,
        auto: false,
        range: this.calc_range(diff1, diff2),
        drugging: true
      });
      this.drug = null;
      this.comp.$emit('sidebar-transform', {
        grid_id: this.id,
        drugging: false
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.mc) this.mc.destroy();
    }
  }, {
    key: "mousemove",
    value: function mousemove() {}
  }, {
    key: "mouseout",
    value: function mouseout() {}
  }, {
    key: "mouseup",
    value: function mouseup() {}
  }, {
    key: "mousedown",
    value: function mousedown() {}
  }]);

  return Sidebar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Sidebar.vue?vue&type=script&lang=js&
// The side bar (yep, that thing with a bunch of $$$)


/* harmony default export */ const Sidebarvue_type_script_lang_js_ = ({
  name: 'Sidebar',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'font', 'width', 'height', 'grid_id', 'rerender', 'y_transform', 'tv_id', 'config', 'shaders'],
  mixins: [canvas],
  mounted: function mounted() {
    var el = this.$refs['canvas'];
    this.renderer = new Sidebar(el, this);
    this.setup();
    this.redraw();
  },
  render: function render(h) {
    var id = this.$props.grid_id;
    var layout = this.$props.layout.grids[id];
    return this.create_canvas(h, "sidebar-".concat(id), {
      position: {
        x: layout.width,
        y: layout.offset || 0
      },
      attrs: {
        rerender: this.$props.rerender,
        width: this.$props.width,
        height: layout.height
      },
      style: {
        backgroundColor: this.$props.colors.back
      }
    });
  },
  watch: {
    range: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    rerender: function rerender() {
      var _this = this;

      this.$nextTick(function () {
        return _this.redraw();
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.renderer) this.renderer.destroy();
  }
});
;// CONCATENATED MODULE: ./src/components/Sidebar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Sidebarvue_type_script_lang_js_ = (Sidebarvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Sidebar.vue
var Sidebar_render, Sidebar_staticRenderFns
;



/* normalize component */
;
var Sidebar_component = normalizeComponent(
  components_Sidebarvue_type_script_lang_js_,
  Sidebar_render,
  Sidebar_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Sidebar_api; }
Sidebar_component.options.__file = "src/components/Sidebar.vue"
/* harmony default export */ const components_Sidebar = (Sidebar_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=template&id=34724886&
var Legendvue_type_template_id_34724886_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-legend", style: _vm.calc_style },
    [
      _vm.grid_id === 0
        ? _c(
            "div",
            {
              staticClass: "trading-vue-ohlcv",
              style: { "max-width": _vm.common.width + "px" }
            },
            [
              _c(
                "span",
                {
                  staticClass: "t-vue-title",
                  style: { color: _vm.common.colors.title }
                },
                [
                  _vm._v(
                    "\n              " +
                      _vm._s(_vm.common.title_txt) +
                      "\n        "
                  )
                ]
              ),
              _vm._v(" "),
              _vm.show_values
                ? _c("span", [
                    _vm._v("\n            O"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[0]))
                    ]),
                    _vm._v("\n            H"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[1]))
                    ]),
                    _vm._v("\n            L"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[2]))
                    ]),
                    _vm._v("\n            C"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[3]))
                    ]),
                    _vm._v("\n            V"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[4]))
                    ])
                  ])
                : _vm._e(),
              _vm._v(" "),
              !_vm.show_values
                ? _c(
                    "span",
                    {
                      staticClass: "t-vue-lspan",
                      style: { color: _vm.common.colors.text }
                    },
                    [
                      _vm._v(
                        "\n            " +
                          _vm._s((_vm.common.meta.last || [])[4]) +
                          "\n        "
                      )
                    ]
                  )
                : _vm._e()
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm._l(this.indicators, function(ind) {
        return _c(
          "div",
          { staticClass: "t-vue-ind" },
          [
            _c("span", { staticClass: "t-vue-iname" }, [
              _vm._v(_vm._s(ind.name))
            ]),
            _vm._v(" "),
            _c("button-group", {
              attrs: {
                buttons: _vm.common.buttons,
                config: _vm.common.config,
                ov_id: ind.id,
                grid_id: _vm.grid_id,
                index: ind.index,
                tv_id: _vm.common.tv_id,
                display: ind.v
              },
              on: { "legend-button-click": _vm.button_click }
            }),
            _vm._v(" "),
            ind.v
              ? _c(
                  "span",
                  { staticClass: "t-vue-ivalues" },
                  _vm._l(ind.values, function(v) {
                    return _vm.show_values
                      ? _c(
                          "span",
                          {
                            staticClass: "t-vue-lspan t-vue-ivalue",
                            style: { color: v.color }
                          },
                          [
                            _vm._v(
                              "\n                " +
                                _vm._s(v.value) +
                                "\n            "
                            )
                          ]
                        )
                      : _vm._e()
                  }),
                  0
                )
              : _vm._e(),
            _vm._v(" "),
            ind.unk
              ? _c("span", { staticClass: "t-vue-unknown" }, [
                  _vm._v("\n            (Unknown type)\n        ")
                ])
              : _vm._e(),
            _vm._v(" "),
            _c(
              "transition",
              { attrs: { name: "tvjs-appear" } },
              [
                ind.loading
                  ? _c("spinner", { attrs: { colors: _vm.common.colors } })
                  : _vm._e()
              ],
              1
            )
          ],
          1
        )
      })
    ],
    2
  )
}
var Legendvue_type_template_id_34724886_staticRenderFns = []
Legendvue_type_template_id_34724886_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=template&id=34724886&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=template&id=6f826426&
var ButtonGroupvue_type_template_id_6f826426_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "span",
    { staticClass: "t-vue-lbtn-grp" },
    _vm._l(_vm.buttons, function(b, i) {
      return _c("legend-button", {
        key: i,
        attrs: {
          id: b.name || b,
          tv_id: _vm.tv_id,
          ov_id: _vm.ov_id,
          grid_id: _vm.grid_id,
          index: _vm.index,
          display: _vm.display,
          icon: b.icon,
          config: _vm.config
        },
        on: { "legend-button-click": _vm.button_click }
      })
    }),
    1
  )
}
var ButtonGroupvue_type_template_id_6f826426_staticRenderFns = []
ButtonGroupvue_type_template_id_6f826426_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=template&id=6f826426&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=template&id=1ad87362&
var LegendButtonvue_type_template_id_1ad87362_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("img", {
    staticClass: "t-vue-lbtn",
    style: {
      width: _vm.config.L_BTN_SIZE + "px",
      height: _vm.config.L_BTN_SIZE + "px",
      margin: _vm.config.L_BTN_MARGIN
    },
    attrs: { src: _vm.base64, id: _vm.uuid },
    on: { click: _vm.onclick }
  })
}
var LegendButtonvue_type_template_id_1ad87362_staticRenderFns = []
LegendButtonvue_type_template_id_1ad87362_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=template&id=1ad87362&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//

/* harmony default export */ const LegendButtonvue_type_script_lang_js_ = ({
  name: 'LegendButton',
  props: ['id', 'tv_id', 'grid_id', 'ov_id', 'index', 'display', 'icon', 'config'],
  mounted: function mounted() {},
  computed: {
    base64: function base64() {
      return this.icon || icons_namespaceObject[this.file_name];
    },
    file_name: function file_name() {
      var id = this.$props.id;

      if (this.$props.id === 'display') {
        id = this.$props.display ? 'display_on' : 'display_off';
      }

      return id + '.png';
    },
    uuid: function uuid() {
      var tv = this.$props.tv_id;
      var gr = this.$props.grid_id;
      var ov = this.$props.ov_id;
      return "".concat(tv, "-btn-g").concat(gr, "-").concat(ov);
    },
    data_type: function data_type() {
      return this.$props.grid_id === 0 ? "onchart" : "offchart";
    },
    data_index: function data_index() {
      return this.$props.index;
    }
  },
  methods: {
    onclick: function onclick() {
      this.$emit('legend-button-click', {
        button: this.$props.id,
        type: this.data_type,
        dataIndex: this.data_index,
        grid: this.$props.grid_id,
        overlay: this.$props.ov_id
      });
    }
  }
});
;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_LegendButtonvue_type_script_lang_js_ = (LegendButtonvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=style&index=0&lang=css&
var LegendButtonvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(169);
;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/LegendButton.vue



;


/* normalize component */

var LegendButton_component = normalizeComponent(
  components_LegendButtonvue_type_script_lang_js_,
  LegendButtonvue_type_template_id_1ad87362_render,
  LegendButtonvue_type_template_id_1ad87362_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LegendButton_api; }
LegendButton_component.options.__file = "src/components/LegendButton.vue"
/* harmony default export */ const LegendButton = (LegendButton_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const ButtonGroupvue_type_script_lang_js_ = ({
  name: 'ButtonGroup',
  props: ['buttons', 'tv_id', 'ov_id', 'grid_id', 'index', 'display', 'config'],
  components: {
    LegendButton: LegendButton
  },
  methods: {
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ButtonGroupvue_type_script_lang_js_ = (ButtonGroupvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=style&index=0&lang=css&
var ButtonGroupvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(886);
;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue



;


/* normalize component */

var ButtonGroup_component = normalizeComponent(
  components_ButtonGroupvue_type_script_lang_js_,
  ButtonGroupvue_type_template_id_6f826426_render,
  ButtonGroupvue_type_template_id_6f826426_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ButtonGroup_api; }
ButtonGroup_component.options.__file = "src/components/ButtonGroup.vue"
/* harmony default export */ const ButtonGroup = (ButtonGroup_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=template&id=39432f99&
var Spinnervue_type_template_id_39432f99_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "tvjs-spinner" },
    _vm._l(4, function(i) {
      return _c("div", { key: i, style: { background: _vm.colors.text } })
    }),
    0
  )
}
var Spinnervue_type_template_id_39432f99_staticRenderFns = []
Spinnervue_type_template_id_39432f99_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=template&id=39432f99&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=script&lang=js&
//
//
//
//
//
//
/* harmony default export */ const Spinnervue_type_script_lang_js_ = ({
  name: 'Spinner',
  props: ['colors']
});
;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Spinnervue_type_script_lang_js_ = (Spinnervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=style&index=0&lang=css&
var Spinnervue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(372);
;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Spinner.vue



;


/* normalize component */

var Spinner_component = normalizeComponent(
  components_Spinnervue_type_script_lang_js_,
  Spinnervue_type_template_id_39432f99_render,
  Spinnervue_type_template_id_39432f99_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Spinner_api; }
Spinner_component.options.__file = "src/components/Spinner.vue"
/* harmony default export */ const Spinner = (Spinner_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const Legendvue_type_script_lang_js_ = ({
  name: 'ChartLegend',
  props: ['common', 'values', 'grid_id', 'meta_props'],
  components: {
    ButtonGroup: ButtonGroup,
    Spinner: Spinner
  },
  computed: {
    ohlcv: function ohlcv() {
      if (!this.$props.values || !this.$props.values.ohlcv) {
        return Array(6).fill('n/a');
      }

      var prec = this.layout.prec; // TODO: main the main legend more customizable

      var id = this.main_type + '_0';
      var meta = this.$props.meta_props[id] || {};

      if (meta.legend) {
        return (meta.legend() || []).map(function (x) {
          return x.value;
        });
      }

      return [this.$props.values.ohlcv[1].toFixed(prec), this.$props.values.ohlcv[2].toFixed(prec), this.$props.values.ohlcv[3].toFixed(prec), this.$props.values.ohlcv[4].toFixed(prec), this.$props.values.ohlcv[5] ? this.$props.values.ohlcv[5].toFixed(2) : 'n/a'];
    },
    // TODO: add support for { grid: { id : N }}
    indicators: function indicators() {
      var _this = this;

      var values = this.$props.values;
      var f = this.format;
      var types = {};
      return this.json_data.filter(function (x) {
        return x.settings.legend !== false && !x.main;
      }).map(function (x) {
        if (!(x.type in types)) types[x.type] = 0;
        var id = x.type + "_".concat(types[x.type]++);
        return {
          v: 'display' in x.settings ? x.settings.display : true,
          name: x.name || id,
          index: (_this.off_data || _this.json_data).indexOf(x),
          id: id,
          values: values ? f(id, values) : _this.n_a(1),
          unk: !(id in (_this.$props.meta_props || {})),
          loading: x.loading
        };
      });
    },
    calc_style: function calc_style() {
      var top = this.layout.height > 150 ? 10 : 5;
      var grids = this.$props.common.layout.grids;
      var w = grids[0] ? grids[0].width : undefined;
      return {
        top: "".concat(this.layout.offset + top, "px"),
        width: "".concat(w - 20, "px")
      };
    },
    layout: function layout() {
      var id = this.$props.grid_id;
      return this.$props.common.layout.grids[id];
    },
    json_data: function json_data() {
      return this.$props.common.data;
    },
    off_data: function off_data() {
      return this.$props.common.offchart;
    },
    main_type: function main_type() {
      var f = this.common.data.find(function (x) {
        return x.main;
      });
      return f ? f.type : undefined;
    },
    show_values: function show_values() {
      return this.common.cursor.mode !== 'explore';
    }
  },
  methods: {
    format: function format(id, values) {
      var meta = this.$props.meta_props[id] || {}; // Matches Overlay.data_colors with the data values
      // (see Spline.vue)

      if (!values[id]) return this.n_a(1); // Custom formatter

      if (meta.legend) return meta.legend(values[id]);
      return values[id].slice(1).map(function (x, i) {
        var cs = meta.data_colors ? meta.data_colors() : [];

        if (typeof x == 'number') {
          // Show 8 digits for small values
          x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
        }

        return {
          value: x,
          color: cs ? cs[i % cs.length] : undefined
        };
      });
    },
    n_a: function n_a(len) {
      return Array(len).fill({
        value: 'n/a'
      });
    },
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Legendvue_type_script_lang_js_ = (Legendvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=style&index=0&lang=css&
var Legendvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(600);
;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Legend.vue



;


/* normalize component */

var Legend_component = normalizeComponent(
  components_Legendvue_type_script_lang_js_,
  Legendvue_type_template_id_34724886_render,
  Legendvue_type_template_id_34724886_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Legend_api; }
Legend_component.options.__file = "src/components/Legend.vue"
/* harmony default export */ const Legend = (Legend_component.exports);
;// CONCATENATED MODULE: ./src/mixins/shaders.js
function shaders_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = shaders_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function shaders_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return shaders_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return shaders_arrayLikeToArray(o, minLen); }

function shaders_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Parser for shader events
/* harmony default export */ const shaders = ({
  methods: {
    // Init shaders from extensions
    init_shaders: function init_shaders(skin, prev) {
      if (skin !== prev) {
        if (prev) this.shaders = this.shaders.filter(function (x) {
          return x.owner !== prev.id;
        });

        var _iterator = shaders_createForOfIteratorHelper(skin.shaders),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var Shader = _step.value;
            var shader = new Shader();
            shader.owner = skin.id;
            this.shaders.push(shader);
          } // TODO: Sort by zIndex

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    },
    on_shader_event: function on_shader_event(d, target) {
      if (d.event === 'new-shader') {
        if (d.args[0].target === target) {
          d.args[0].id = "".concat(d.args[1], "-").concat(d.args[2]);
          this.shaders.push(d.args[0]);
          this.rerender++;
        }
      }

      if (d.event === 'remove-shaders') {
        var id = d.args.join('-');
        this.shaders = this.shaders.filter(function (x) {
          return x.id !== id;
        });
      }
    }
  },
  watch: {
    skin: function skin(n, p) {
      this.init_shaders(n, p);
    }
  },
  data: function data() {
    return {
      shaders: []
    };
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=script&lang=js&

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ const Sectionvue_type_script_lang_js_ = ({
  name: 'GridSection',
  props: ['common', 'grid_id'],
  mixins: [shaders],
  components: {
    Grid: components_Grid,
    Sidebar: components_Sidebar,
    ChartLegend: Legend
  },
  mounted: function mounted() {
    this.init_shaders(this.$props.common.skin);
  },
  methods: {
    range_changed: function range_changed(r) {
      this.$emit('range-changed', r);
    },
    cursor_changed: function cursor_changed(c) {
      c.grid_id = this.$props.grid_id;
      this.$emit('cursor-changed', c);
    },
    cursor_locked: function cursor_locked(state) {
      this.$emit('cursor-locked', state);
    },
    sidebar_transform: function sidebar_transform(s) {
      this.$emit('sidebar-transform', s);
    },
    emit_meta_props: function emit_meta_props(d) {
      this.$set(this.meta_props, d.layer_id, d);
      this.$emit('layer-meta-props', d);
    },
    emit_custom_event: function emit_custom_event(d) {
      this.on_shader_event(d, 'sidebar');
      this.$emit('custom-event', d);
    },
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    },
    register_kb: function register_kb(event) {
      this.$emit('register-kb-listener', event);
    },
    remove_kb: function remove_kb(event) {
      this.$emit('remove-kb-listener', event);
    },
    rezoom_range: function rezoom_range(event) {
      var id = 'sb-' + event.grid_id;

      if (this.$refs[id]) {
        this.$refs[id].renderer.rezoom_range(event.z, event.diff1, event.diff2);
      }
    },
    ghash: function ghash(val) {
      // Measures grid heights configuration
      var hs = val.layout.grids.map(function (x) {
        return x.height;
      });
      return hs.reduce(function (a, b) {
        return a + b;
      }, '');
    }
  },
  computed: {
    // Component-specific props subsets:
    grid_props: function grid_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common); // Split offchart data between offchart grids

      if (id > 0) {
        var _p$data;

        var all = p.data;
        p.data = [p.data[id - 1]]; // Merge offchart overlays with custom ids with
        // the existing onse (by comparing the grid ids)

        (_p$data = p.data).push.apply(_p$data, _toConsumableArray(all.filter(function (x) {
          return x.grid && x.grid.id === id;
        })));
      }

      p.width = p.layout.grids[id].width;
      p.height = p.layout.grids[id].height;
      p.y_transform = p.y_ts[id];
      p.shaders = this.grid_shaders;
      return p;
    },
    sidebar_props: function sidebar_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common);
      p.width = p.layout.grids[id].sb;
      p.height = p.layout.grids[id].height;
      p.y_transform = p.y_ts[id];
      p.shaders = this.sb_shaders;
      return p;
    },
    section_values: function section_values() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common);
      p.width = p.layout.grids[id].width;
      return p.cursor.values[id];
    },
    legend_props: function legend_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common); // Split offchart data between offchart grids

      if (id > 0) {
        var _p$data2;

        var all = p.data;
        p.offchart = all;
        p.data = [p.data[id - 1]];

        (_p$data2 = p.data).push.apply(_p$data2, _toConsumableArray(all.filter(function (x) {
          return x.grid && x.grid.id === id;
        })));
      }

      return p;
    },
    get_meta_props: function get_meta_props() {
      return this.meta_props;
    },
    grid_shaders: function grid_shaders() {
      return this.shaders.filter(function (x) {
        return x.target === 'grid';
      });
    },
    sb_shaders: function sb_shaders() {
      return this.shaders.filter(function (x) {
        return x.target === 'sidebar';
      });
    }
  },
  watch: {
    common: {
      handler: function handler(val, old_val) {
        var newhash = this.ghash(val);

        if (newhash !== this.last_ghash) {
          this.rerender++;
        }

        if (val.data.length !== old_val.data.length) {
          // Look at this nasty trick!
          this.rerender++;
        }

        this.last_ghash = newhash;
      },
      deep: true
    }
  },
  data: function data() {
    return {
      meta_props: {},
      rerender: 0,
      last_ghash: ''
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Sectionvue_type_script_lang_js_ = (Sectionvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=style&index=0&lang=css&
var Sectionvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(11);
;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Section.vue



;


/* normalize component */

var Section_component = normalizeComponent(
  components_Sectionvue_type_script_lang_js_,
  Sectionvue_type_template_id_8fbe9336_render,
  Sectionvue_type_template_id_8fbe9336_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Section_api; }
Section_component.options.__file = "src/components/Section.vue"
/* harmony default export */ const Section = (Section_component.exports);
;// CONCATENATED MODULE: ./src/components/js/botbar.js



function botbar_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = botbar_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function botbar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return botbar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return botbar_arrayLikeToArray(o, minLen); }

function botbar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



var botbar_MINUTE15 = constants.MINUTE15,
    botbar_MINUTE = constants.MINUTE,
    botbar_HOUR = constants.HOUR,
    botbar_DAY = constants.DAY,
    botbar_WEEK = constants.WEEK,
    botbar_MONTH = constants.MONTH,
    botbar_YEAR = constants.YEAR,
    botbar_MONTHMAP = constants.MONTHMAP;

var Botbar = /*#__PURE__*/function () {
  function Botbar(canvas, comp) {
    classCallCheck_classCallCheck(this, Botbar);

    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.layout = this.$p.layout;
  }

  createClass_createClass(Botbar, [{
    key: "update",
    value: function update() {
      this.grid_0 = this.layout.grids[0];
      var width = this.layout.botbar.width;
      var height = this.layout.botbar.height;
      var sb = this.layout.grids[0].sb; //this.ctx.fillStyle = this.$p.colors.back

      this.ctx.font = this.$p.font; //this.ctx.fillRect(0, 0, width, height)

      this.ctx.clearRect(0, 0, width, height);
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(Math.floor(width + 1), 0.5);
      this.ctx.stroke();
      this.ctx.fillStyle = this.$p.colors.text;
      this.ctx.beginPath();

      var _iterator = botbar_createForOfIteratorHelper(this.layout.botbar.xs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var lbl = this.format_date(p);
          if (p[0] > width - sb) continue;
          this.ctx.moveTo(p[0] - 0.5, 0);
          this.ctx.lineTo(p[0] - 0.5, 4.5);

          if (!this.lbl_highlight(p[1][0])) {
            this.ctx.globalAlpha = 0.85;
          }

          this.ctx.textAlign = 'center';
          this.ctx.fillText(lbl, p[0], 18);
          this.ctx.globalAlpha = 1;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.ctx.stroke();
      this.apply_shaders();
      if (this.$p.cursor.x && this.$p.cursor.t !== undefined) this.panel();
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.layout.grids[0];
      var props = {
        layout: layout,
        cursor: this.$p.cursor
      };

      var _iterator2 = botbar_createForOfIteratorHelper(this.comp.bot_shaders),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "panel",
    value: function panel() {
      var lbl = this.format_cursor_x();
      this.ctx.fillStyle = this.$p.colors.panel;
      var measure = this.ctx.measureText(lbl + '    ');
      var panwidth = Math.floor(measure.width);
      var cursor = this.$p.cursor.x;
      var x = Math.floor(cursor - panwidth * 0.5);
      var y = -0.5;
      var panheight = this.comp.config.PANHEIGHT;
      this.ctx.fillRect(x, y, panwidth, panheight + 0.5);
      this.ctx.fillStyle = this.$p.colors.textHL;
      this.ctx.textAlign = 'center';
      this.ctx.fillText(lbl, cursor, y + 16);
    }
  }, {
    key: "format_date",
    value: function format_date(p) {
      var t = p[1][0];
      t = this.grid_0.ti_map.i2t(t);
      var ti = this.$p.layout.grids[0].ti_map.tf; // Enable timezones only for tf < 1D

      var k = ti < botbar_DAY ? 1 : 0;
      var tZ = t + k * this.$p.timezone * botbar_HOUR; //t += new Date(t).getTimezoneOffset() * MINUTE

      var d = new Date(tZ);

      if (p[2] === botbar_YEAR || utils.year_start(t) === t) {
        return d.getUTCFullYear();
      }

      if (p[2] === botbar_MONTH || utils.month_start(t) === t) {
        return botbar_MONTHMAP[d.getUTCMonth()];
      } // TODO(*) see grid_maker.js


      if (utils.day_start(tZ) === tZ) return d.getUTCDate();
      var h = utils.add_zero(d.getUTCHours());
      var m = utils.add_zero(d.getUTCMinutes());
      return h + ":" + m;
    }
  }, {
    key: "format_cursor_x",
    value: function format_cursor_x() {
      var t = this.$p.cursor.t;
      t = this.grid_0.ti_map.i2t(t); //let ti = this.$p.interval

      var ti = this.$p.layout.grids[0].ti_map.tf; // Enable timezones only for tf < 1D

      var k = ti < botbar_DAY ? 1 : 0; //t += new Date(t).getTimezoneOffset() * MINUTE

      var d = new Date(t + k * this.$p.timezone * botbar_HOUR);

      if (ti === botbar_YEAR) {
        return d.getUTCFullYear();
      }

      if (ti < botbar_YEAR) {
        var yr = '`' + "".concat(d.getUTCFullYear()).slice(-2);
        var mo = botbar_MONTHMAP[d.getUTCMonth()];
        var dd = '01';
      }

      if (ti <= botbar_WEEK) dd = d.getUTCDate();
      var date = "".concat(dd, " ").concat(mo, " ").concat(yr);
      var time = '';

      if (ti < botbar_DAY) {
        var h = utils.add_zero(d.getUTCHours());
        var m = utils.add_zero(d.getUTCMinutes());
        time = h + ":" + m;
      }

      return "".concat(date, "  ").concat(time);
    } // Highlights the begining of a time interval
    // TODO: improve. Problem: let's say we have a new month,
    // but if there is no grid line in place, there
    // will be no month name on t-axis. Sad.
    // Solution: manipulate the grid, skew it, you know

  }, {
    key: "lbl_highlight",
    value: function lbl_highlight(t) {
      var ti = this.$p.interval;
      if (t === 0) return true;
      if (utils.month_start(t) === t) return true;
      if (utils.day_start(t) === t) return true;
      if (ti <= botbar_MINUTE15 && t % botbar_HOUR === 0) return true;
      return false;
    }
  }, {
    key: "mousemove",
    value: function mousemove() {}
  }, {
    key: "mouseout",
    value: function mouseout() {}
  }, {
    key: "mouseup",
    value: function mouseup() {}
  }, {
    key: "mousedown",
    value: function mousedown() {}
  }]);

  return Botbar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Botbar.vue?vue&type=script&lang=js&
// The bottom bar (yep, that thing with a bunch of dates)


/* harmony default export */ const Botbarvue_type_script_lang_js_ = ({
  name: 'Botbar',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'font', 'width', 'height', 'rerender', 'tv_id', 'config', 'shaders', 'timezone'],
  mixins: [canvas],
  mounted: function mounted() {
    var el = this.$refs['canvas'];
    this.renderer = new Botbar(el, this);
    this.setup();
    this.redraw();
  },
  render: function render(h) {
    var sett = this.$props.layout.botbar;
    return this.create_canvas(h, 'botbar', {
      position: {
        x: 0,
        y: sett.offset || 0
      },
      attrs: {
        rerender: this.$props.rerender,
        width: sett.width,
        height: sett.height
      },
      style: {
        backgroundColor: this.$props.colors.back
      }
    });
  },
  computed: {
    bot_shaders: function bot_shaders() {
      return this.$props.shaders.filter(function (x) {
        return x.target === 'botbar';
      });
    }
  },
  watch: {
    range: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    rerender: function rerender() {
      var _this = this;

      this.$nextTick(function () {
        return _this.redraw();
      });
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Botbar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Botbarvue_type_script_lang_js_ = (Botbarvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Botbar.vue?vue&type=style&index=0&lang=css&
var Botbarvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(124);
;// CONCATENATED MODULE: ./src/components/Botbar.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Botbar.vue
var Botbar_render, Botbar_staticRenderFns
;

;


/* normalize component */

var Botbar_component = normalizeComponent(
  components_Botbarvue_type_script_lang_js_,
  Botbar_render,
  Botbar_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Botbar_api; }
Botbar_component.options.__file = "src/components/Botbar.vue"
/* harmony default export */ const components_Botbar = (Botbar_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Keyboard.vue?vue&type=script&lang=js&
//
//
//
//
/* harmony default export */ const Keyboardvue_type_script_lang_js_ = ({
  name: 'Keyboard',
  created: function created() {
    window.addEventListener('keydown', this.keydown);
    window.addEventListener('keyup', this.keyup);
    window.addEventListener('keypress', this.keypress);
    this._listeners = {};
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('keydown', this.keydown);
    window.removeEventListener('keyup', this.keyup);
    window.removeEventListener('keypress', this.keypress);
  },
  render: function render(h) {
    return h();
  },
  methods: {
    keydown: function keydown(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keydown) {
          l.keydown(event);
        } else {
          console.warn("No 'keydown' listener for ".concat(id));
        }
      }
    },
    keyup: function keyup(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keyup) {
          l.keyup(event);
        } else {
          console.warn("No 'keyup' listener for ".concat(id));
        }
      }
    },
    keypress: function keypress(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keypress) {
          l.keypress(event);
        } else {
          console.warn("No 'keypress' listener for ".concat(id));
        }
      }
    },
    register: function register(listener) {
      this._listeners[listener.id] = listener;
    },
    remove: function remove(listener) {
      delete this._listeners[listener.id];
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Keyboard.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Keyboardvue_type_script_lang_js_ = (Keyboardvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Keyboard.vue
var Keyboard_render, Keyboard_staticRenderFns
;



/* normalize component */
;
var Keyboard_component = normalizeComponent(
  components_Keyboardvue_type_script_lang_js_,
  Keyboard_render,
  Keyboard_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Keyboard_api; }
Keyboard_component.options.__file = "src/components/Keyboard.vue"
/* harmony default export */ const Keyboard = (Keyboard_component.exports);
;// CONCATENATED MODULE: ./src/mixins/datatrack.js
// Data tracker/watcher

/* harmony default export */ const datatrack = ({
  methods: {
    data_changed: function data_changed() {
      var n = this.ohlcv;
      var changed = false;

      if (this._data_n0 !== n[0] && this._data_len !== n.length) {
        changed = true;
      }

      this.check_all_data(changed);

      if (this.ti_map.ib) {
        this.reindex_delta(n[0], this._data_n0);
      }

      this._data_n0 = n[0];
      this._data_len = n.length;
      this.save_data_t();
      return changed;
    },
    check_all_data: function check_all_data(changed) {
      // If length of data in the Structure changed by > 1 point
      // emit a special event for DC to recalc the scripts
      // TODO: check overlays data too
      var len = this._data_len || 0;

      if (Math.abs(this.ohlcv.length - len) > 1 || this._data_n0 !== this.ohlcv[0]) {
        this.$emit('custom-event', {
          event: 'data-len-changed',
          args: []
        });
      }
    },
    reindex_delta: function reindex_delta(n, p) {
      n = n || [[0]];
      p = p || [[0]];
      var dt = n[0] - p[0];

      if (dt !== 0 && this._data_t) {
        // Convert t back to index
        try {
          // More precise method first
          var nt = this._data_t + 0.01; // fix for the filter lib

          var res = utils.fast_nearest(this.ohlcv, nt);
          var cndl = this.ohlcv[res[0]];
          var off = (nt - cndl[0]) / this.interval_ms;
          this["goto"](res[0] + off);
        } catch (e) {
          this["goto"](this.ti_map.t2i(this._data_t));
        }
      }
    },
    save_data_t: function save_data_t() {
      this._data_t = this.ti_map.i2t(this.range[1]); // save as t
    }
  },
  data: function data() {
    return {
      _data_n0: null,
      _data_len: 0,
      _data_t: 0
    };
  }
});
;// CONCATENATED MODULE: ./src/components/js/ti_mapping.js




// Time-index mapping (for non-linear t-axis)

var MAX_ARR = Math.pow(2, 32); // 3 MODES of index calculation for overlays/subcharts:
// ::: indexSrc :::
// * "map"      -> use TI mapping functions to detect index
//                 (slowest, for stocks only. DEFAULT)
//
// * "calc"     -> calculate shift between sub & data
//                 (faster, but overlay data should be perfectly
//                  align with the main chart,
//                  1-1 candle/data point. Supports Renko)
//
// * "data"     -> overlay data should come with candle index
//                 (fastest, supports Renko)

var TI = /*#__PURE__*/function () {
  function TI() {
    classCallCheck_classCallCheck(this, TI);

    this.ib = false;
  }

  createClass_createClass(TI, [{
    key: "init",
    value: function init(params, res) {
      var sub = params.sub,
          interval = params.interval,
          meta = params.meta,
          $p = params.$props,
          interval_ms = params.interval_ms,
          sub_start = params.sub_start,
          ib = params.ib;
      this.ti_map = [];
      this.it_map = [];
      this.sub_i = [];
      this.ib = ib;
      this.sub = res;
      this.ss = sub_start;
      this.tf = interval_ms;
      var start = meta.sub_start; // Skip mapping for the regular mode

      if (this.ib) {
        this.map_sub(res);
      }
    } // Make maps for the main subset

  }, {
    key: "map_sub",
    value: function map_sub(res) {
      for (var i = 0; i < res.length; i++) {
        var t = res[i][0];

        var _i = this.ss + i;

        this.ti_map[t] = _i;
        this.it_map[_i] = t; // Overwrite t with i

        var copy = _toConsumableArray(res[i]);

        copy[0] = _i;
        this.sub_i.push(copy);
      }
    } // Map overlay data
    // TODO: parse() called 3 times instead of 2 for 'spx_sample.json'

  }, {
    key: "parse",
    value: function parse(data, mode) {
      if (!this.ib || !this.sub[0] || mode === 'data') return data;
      var res = [];
      var k = 0; // Candlestick index

      if (mode === 'calc') {
        var shift = utils.index_shift(this.sub, data);

        for (var i = 0; i < data.length; i++) {
          var _i = this.ss + i;

          var copy = _toConsumableArray(data[i]);

          copy[0] = _i + shift;
          res.push(copy);
        }

        return res;
      } // If indicator data starts after ohlcv, calc the first index


      if (data.length) {
        try {
          var k1 = utils.fast_nearest(this.sub, data[0][0])[0];
          if (k1 !== null && k1 >= 0) k = k1;
        } catch (e) {}
      }

      var t0 = this.sub[0][0];
      var tN = this.sub[this.sub.length - 1][0];

      for (var i = 0; i < data.length; i++) {
        var _copy = _toConsumableArray(data[i]);

        var tk = this.sub[k][0];
        var t = data[i][0];
        var index = this.ti_map[t];

        if (index === undefined) {
          // Linear extrapolation
          if (t < t0 || t > tN) {
            index = this.ss + k - (tk - t) / this.tf;
            t = data[i + 1] ? data[i + 1][0] : undefined;
          } // Linear interpolation
          else {
              var tk2 = this.sub[k + 1][0];
              index = tk === tk2 ? this.ss + k : this.ss + k + (t - tk) / (tk2 - tk);
              t = data[i + 1] ? data[i + 1][0] : undefined;
            }
        } // Race of data points & sub points (ohlcv)
        // (like turn based increments)


        while (k + 1 < this.sub.length - 1 && t > this.sub[k + 1][0]) {
          k++;
          tk = this.sub[k][0];
        }

        _copy[0] = index;
        res.push(_copy);
      }

      return res;
    } // index => time

  }, {
    key: "i2t",
    value: function i2t(i) {
      if (!this.ib || !this.sub.length) return i; // Regular mode
      // Discrete mapping

      var res = this.it_map[i];
      if (res !== undefined) return res; // Linear extrapolation
      else if (i >= this.ss + this.sub_i.length) {
          var di = i - (this.ss + this.sub_i.length) + 1;
          var last = this.sub[this.sub.length - 1];
          return last[0] + di * this.tf;
        } else if (i < this.ss) {
          var _di = i - this.ss;

          return this.sub[0][0] + _di * this.tf;
        } // Linear Interpolation

      var i1 = Math.floor(i) - this.ss;
      var i2 = i1 + 1;
      var len = this.sub.length;
      if (i2 >= len) i2 = len - 1;
      var sub1 = this.sub[i1];
      var sub2 = this.sub[i2];

      if (sub1 && sub2) {
        var t1 = sub1[0];
        var t2 = sub2[0];
        return t1 + (t2 - t1) * (i - i1 - this.ss);
      }

      return undefined;
    } // Map or bypass depending on the mode

  }, {
    key: "i2t_mode",
    value: function i2t_mode(i, mode) {
      return mode === 'data' ? i : this.i2t(i);
    } // time => index
    // TODO: when switch from IB mode to regular tools
    // disappear (bc there is no more mapping)

  }, {
    key: "t2i",
    value: function t2i(t) {
      if (!this.sub.length) return undefined; // Discrete mapping

      var res = this.ti_map[t];
      if (res !== undefined) return res;
      var t0 = this.sub[0][0];
      var tN = this.sub[this.sub.length - 1][0]; // Linear extrapolation

      if (t < t0) {
        return this.ss - (t0 - t) / this.tf;
      } else if (t > tN) {
        var k = this.sub.length - 1;
        return this.ss + k - (tN - t) / this.tf;
      }

      try {
        // Linear Interpolation
        var i = utils.fast_nearest(this.sub, t);
        var tk = this.sub[i[0]][0];
        var tk2 = this.sub[i[1]][0];

        var _k = (t - tk) / (tk2 - tk);

        return this.ss + i[0] + _k * (i[1] - i[0]);
      } catch (e) {}

      return undefined;
    } // Auto detect: is it time or index?
    // Assuming that index-based mode is ON

  }, {
    key: "smth2i",
    value: function smth2i(smth) {
      if (smth > MAX_ARR) {
        return this.t2i(smth); // it was time
      } else {
          return smth; // it was an index
        }
    }
  }, {
    key: "smth2t",
    value: function smth2t(smth) {
      if (smth < MAX_ARR) {
        return this.i2t(smth); // it was an index
      } else {
          return smth; // it was time
        }
    } // Global Time => Index (uses all data, approx. method)
    // Used by tv.goto()

  }, {
    key: "gt2i",
    value: function gt2i(smth, ohlcv) {
      if (smth > MAX_ARR) {
        var E = 0.1; // Fixes the arrayslicer bug

        var _Utils$fast_nearest = utils.fast_nearest(ohlcv, smth + E),
            _Utils$fast_nearest2 = _slicedToArray(_Utils$fast_nearest, 2),
            i1 = _Utils$fast_nearest2[0],
            i2 = _Utils$fast_nearest2[1];

        if (typeof i1 === 'number') {
          return i1;
        } else {
          return this.t2i(smth); // fallback
        }
      } else {
          return smth; // it was an index
        }
    }
  }]);

  return TI;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Chart.vue?vue&type=script&lang=js&


//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//











/* harmony default export */ const Chartvue_type_script_lang_js_ = ({
  name: 'Chart',
  props: ['title_txt', 'data', 'width', 'height', 'font', 'colors', 'overlays', 'tv_id', 'config', 'buttons', 'toolbar', 'ib', 'skin', 'timezone'],
  mixins: [shaders, datatrack],
  components: {
    GridSection: Section,
    Botbar: components_Botbar,
    Keyboard: Keyboard
  },
  created: function created() {
    // Context for text measurements
    this.ctx = new context(this.$props); // Initial layout (All measurments for the chart)

    this.init_range();
    this.sub = this.subset();
    utils.overwrite(this.range, this.range); // Fix for IB mode

    this._layout = new layout(this); // Updates current cursor values

    this.updater = new updater(this);
    this.update_last_values();
    this.init_shaders(this.skin);
  },
  methods: {
    range_changed: function range_changed(r) {
      // Overwite & keep the original references
      // Quick fix for IB mode (switch 2 next lines)
      // TODO: wtf?
      var sub = this.subset(r);
      utils.overwrite(this.range, r);
      utils.overwrite(this.sub, sub);
      this.update_layout();
      this.$emit('range-changed', r);
      if (this.$props.ib) this.save_data_t();
    },
    "goto": function goto(t) {
      var dt = this.range[1] - this.range[0];
      this.range_changed([t - dt, t]);
    },
    setRange: function setRange(t1, t2) {
      this.range_changed([t1, t2]);
    },
    cursor_changed: function cursor_changed(e) {
      if (e.mode) this.cursor.mode = e.mode;

      if (this.cursor.mode !== 'explore') {
        this.updater.sync(e);
      }

      if (this._hook_xchanged) this.ce('?x-changed', e);
    },
    cursor_locked: function cursor_locked(state) {
      if (this.cursor.scroll_lock && state) return;
      this.cursor.locked = state;
      if (this._hook_xlocked) this.ce('?x-locked', state);
    },
    calc_interval: function calc_interval() {
      var _this = this;

      var tf = utils.parse_tf(this.forced_tf);
      if (this.ohlcv.length < 2 && !tf) return;
      this.interval_ms = tf || utils.detect_interval(this.ohlcv);
      this.interval = this.$props.ib ? 1 : this.interval_ms;
      utils.warn(function () {
        return _this.$props.ib && !_this.chart.tf;
      }, constants.IB_TF_WARN, constants.SECOND);
    },
    set_ytransform: function set_ytransform(s) {
      var obj = this.y_transforms[s.grid_id] || {};
      Object.assign(obj, s);
      this.$set(this.y_transforms, s.grid_id, obj);
      this.update_layout();
      utils.overwrite(this.range, this.range);
    },
    default_range: function default_range() {
      var dl = this.$props.config.DEFAULT_LEN;
      var ml = this.$props.config.MINIMUM_LEN + 0.5;
      var l = this.ohlcv.length - 1;
      if (this.ohlcv.length < 2) return;

      if (this.ohlcv.length <= dl) {
        var s = 0,
            d = ml;
      } else {
        s = l - dl, d = 0.5;
      }

      if (!this.$props.ib) {
        utils.overwrite(this.range, [this.ohlcv[s][0] - this.interval * d, this.ohlcv[l][0] + this.interval * ml]);
      } else {
        utils.overwrite(this.range, [s - this.interval * d, l + this.interval * ml]);
      }
    },
    subset: function subset(range) {
      if (range === void 0) {
        range = this.range;
      }

      var _this$filter = this.filter(this.ohlcv, range[0] - this.interval, range[1]),
          _this$filter2 = _slicedToArray(_this$filter, 2),
          res = _this$filter2[0],
          index = _this$filter2[1];

      this.ti_map = new TI();

      if (res) {
        this.sub_start = index;
        this.ti_map.init(this, res);
        if (!this.$props.ib) return res || [];
        return this.ti_map.sub_i;
      }

      return [];
    },
    common_props: function common_props() {
      return {
        title_txt: this.chart.name || this.$props.title_txt,
        layout: this._layout,
        sub: this.sub,
        range: this.range,
        interval: this.interval,
        cursor: this.cursor,
        colors: this.$props.colors,
        font: this.$props.font,
        y_ts: this.y_transforms,
        tv_id: this.$props.tv_id,
        config: this.$props.config,
        buttons: this.$props.buttons,
        meta: this.meta,
        skin: this.$props.skin
      };
    },
    overlay_subset: function overlay_subset(source, side) {
      var _this2 = this;

      return source.map(function (d, i) {
        var res = utils.fast_filter(d.data, _this2.ti_map.i2t_mode(_this2.range[0] - _this2.interval, d.indexSrc), _this2.ti_map.i2t_mode(_this2.range[1], d.indexSrc));
        return {
          type: d.type,
          name: utils.format_name(d),
          data: _this2.ti_map.parse(res[0] || [], d.indexSrc || 'map'),
          settings: d.settings || _this2.settings_ov,
          grid: d.grid || {},
          tf: utils.parse_tf(d.tf),
          i0: res[1],
          loading: d.loading,
          last: (_this2.last_values[side] || [])[i]
        };
      });
    },
    section_props: function section_props(i) {
      return i === 0 ? this.main_section : this.sub_section;
    },
    init_range: function init_range() {
      this.calc_interval();
      this.default_range();
    },
    layer_meta_props: function layer_meta_props(d) {
      // TODO: check reactivity when layout is changed
      if (!(d.grid_id in this.layers_meta)) {
        this.$set(this.layers_meta, d.grid_id, {});
      }

      this.$set(this.layers_meta[d.grid_id], d.layer_id, d); // Rerender

      this.update_layout();
    },
    remove_meta_props: function remove_meta_props(grid_id, layer_id) {
      if (grid_id in this.layers_meta) {
        this.$delete(this.layers_meta[grid_id], layer_id);
      }
    },
    emit_custom_event: function emit_custom_event(d) {
      this.on_shader_event(d, 'botbar');
      this.$emit('custom-event', d);

      if (d.event === 'remove-layer-meta') {
        this.remove_meta_props.apply(this, _toConsumableArray(d.args));
      }
    },
    update_layout: function update_layout(clac_tf) {
      if (clac_tf) this.calc_interval();
      var lay = new layout(this);
      utils.copy_layout(this._layout, lay);
      if (this._hook_update) this.ce('?chart-update', lay);
    },
    legend_button_click: function legend_button_click(event) {
      this.$emit('legend-button-click', event);
    },
    register_kb: function register_kb(event) {
      if (!this.$refs.keyboard) return;
      this.$refs.keyboard.register(event);
    },
    remove_kb: function remove_kb(event) {
      if (!this.$refs.keyboard) return;
      this.$refs.keyboard.remove(event);
    },
    update_last_values: function update_last_values() {
      var _this3 = this;

      this.last_candle = this.ohlcv ? this.ohlcv[this.ohlcv.length - 1] : undefined;
      this.last_values = {
        onchart: [],
        offchart: []
      };
      this.onchart.forEach(function (x, i) {
        var d = x.data || [];
        _this3.last_values.onchart[i] = d[d.length - 1];
      });
      this.offchart.forEach(function (x, i) {
        var d = x.data || [];
        _this3.last_values.offchart[i] = d[d.length - 1];
      });
    },
    // Hook events for extensions
    ce: function ce(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.emit_custom_event({
        event: event,
        args: args
      });
    },
    // Set hooks list (called from an extension)
    hooks: function hooks() {
      var _this4 = this;

      for (var _len2 = arguments.length, list = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        list[_key2] = arguments[_key2];
      }

      list.forEach(function (x) {
        return _this4["_hook_".concat(x)] = true;
      });
    }
  },
  computed: {
    // Component-specific props subsets:
    main_section: function main_section() {
      var p = Object.assign({}, this.common_props());
      p.data = this.overlay_subset(this.onchart, 'onchart');
      p.data.push({
        type: this.chart.type || 'Candles',
        main: true,
        data: this.sub,
        i0: this.sub_start,
        settings: this.chart.settings || this.settings_ohlcv,
        grid: this.chart.grid || {},
        last: this.last_candle
      });
      p.overlays = this.$props.overlays;
      return p;
    },
    sub_section: function sub_section() {
      var p = Object.assign({}, this.common_props());
      p.data = this.overlay_subset(this.offchart, 'offchart');
      p.overlays = this.$props.overlays;
      return p;
    },
    botbar_props: function botbar_props() {
      var p = Object.assign({}, this.common_props());
      p.width = p.layout.botbar.width;
      p.height = p.layout.botbar.height;
      p.rerender = this.rerender;
      return p;
    },
    offsub: function offsub() {
      return this.overlay_subset(this.offchart, 'offchart');
    },
    // Datasets: candles, onchart, offchart indicators
    ohlcv: function ohlcv() {
      return this.$props.data.ohlcv || this.chart.data || [];
    },
    chart: function chart() {
      return this.$props.data.chart || {
        grid: {}
      };
    },
    onchart: function onchart() {
      return this.$props.data.onchart || [];
    },
    offchart: function offchart() {
      return this.$props.data.offchart || [];
    },
    filter: function filter() {
      return this.$props.ib ? utils.fast_filter_i : utils.fast_filter;
    },
    styles: function styles() {
      var w = this.$props.toolbar ? this.$props.config.TOOLBAR : 0;
      return {
        'margin-left': "".concat(w, "px")
      };
    },
    meta: function meta() {
      return {
        last: this.last_candle,
        sub_start: this.sub_start,
        activated: this.activated
      };
    },
    forced_tf: function forced_tf() {
      return this.chart.tf;
    }
  },
  data: function data() {
    return {
      // Current data slice
      sub: [],
      // Time range
      range: [],
      // Candlestick interval
      interval: 0,
      // Crosshair states
      cursor: {
        x: null,
        y: null,
        t: null,
        y$: null,
        grid_id: null,
        locked: false,
        values: {},
        scroll_lock: false,
        mode: utils.xmode()
      },
      // A trick to re-render botbar
      rerender: 0,
      // Layers meta-props (changing behaviour)
      layers_meta: {},
      // Y-transforms (for y-zoom and -shift)
      y_transforms: {},
      // Default OHLCV settings (when using DataStructure v1.0)
      settings_ohlcv: {},
      // Default overlay settings
      settings_ov: {},
      // Meta data
      last_candle: [],
      last_values: {},
      sub_start: undefined,
      activated: false
    };
  },
  watch: {
    width: function width() {
      this.update_layout();
      if (this._hook_resize) this.ce('?chart-resize');
    },
    height: function height() {
      this.update_layout();
      if (this._hook_resize) this.ce('?chart-resize');
    },
    ib: function ib(nw) {
      if (!nw) {
        // Change range index => time
        var t1 = this.ti_map.i2t(this.range[0]);
        var t2 = this.ti_map.i2t(this.range[1]);
        utils.overwrite(this.range, [t1, t2]);
        this.interval = this.interval_ms;
      } else {
        this.init_range(); // TODO: calc index range instead

        utils.overwrite(this.range, this.range);
        this.interval = 1;
      }

      var sub = this.subset();
      utils.overwrite(this.sub, sub);
      this.update_layout();
    },
    timezone: function timezone() {
      this.update_layout();
    },
    colors: function colors() {
      utils.overwrite(this.range, this.range);
    },
    forced_tf: function forced_tf(n, p) {
      this.update_layout(true);
      this.ce('exec-all-scripts');
    },
    data: {
      handler: function handler(n, p) {
        if (!this.sub.length) this.init_range();
        var sub = this.subset(); // Fixes Infinite loop warn, when the subset is empty
        // TODO: Consider removing 'sub' from data entirely

        if (this.sub.length || sub.length) {
          utils.overwrite(this.sub, sub);
        }

        var nw = this.data_changed();
        this.update_layout(nw);
        utils.overwrite(this.range, this.range);
        this.cursor.scroll_lock = !!n.scrollLock;

        if (n.scrollLock && this.cursor.locked) {
          this.cursor.locked = false;
        }

        if (this._hook_data) this.ce('?chart-data', nw);
        this.update_last_values(); // TODO: update legend values for overalys

        this.rerender++;
      },
      deep: true
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Chart.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Chartvue_type_script_lang_js_ = (Chartvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Chart.vue





/* normalize component */
;
var Chart_component = normalizeComponent(
  components_Chartvue_type_script_lang_js_,
  Chartvue_type_template_id_4d06a4de_render,
  Chartvue_type_template_id_4d06a4de_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Chart_api; }
Chart_component.options.__file = "src/components/Chart.vue"
/* harmony default export */ const Chart = (Chart_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=template&id=021887fb&
var Toolbarvue_type_template_id_021887fb_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      key: _vm.tool_count,
      staticClass: "trading-vue-toolbar",
      style: _vm.styles
    },
    _vm._l(_vm.groups, function(tool, i) {
      return tool.icon && !tool.hidden
        ? _c("toolbar-item", {
            key: i,
            attrs: {
              data: tool,
              subs: _vm.sub_map,
              dc: _vm.data,
              config: _vm.config,
              colors: _vm.colors,
              selected: _vm.is_selected(tool)
            },
            on: { "item-selected": _vm.selected }
          })
        : _vm._e()
    }),
    1
  )
}
var Toolbarvue_type_template_id_021887fb_staticRenderFns = []
Toolbarvue_type_template_id_021887fb_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=template&id=021887fb&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=template&id=227b3c2e&
var ToolbarItemvue_type_template_id_227b3c2e_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      class: ["trading-vue-tbitem", _vm.selected ? "selected-item" : ""],
      style: _vm.item_style,
      on: {
        click: function($event) {
          return _vm.emit_selected("click")
        },
        mousedown: _vm.mousedown,
        touchstart: _vm.mousedown,
        touchend: function($event) {
          return _vm.emit_selected("touch")
        }
      }
    },
    [
      _c("div", {
        staticClass: "trading-vue-tbicon tvjs-pixelated",
        style: _vm.icon_style
      }),
      _vm._v(" "),
      _vm.data.group
        ? _c(
            "div",
            {
              staticClass: "trading-vue-tbitem-exp",
              style: _vm.exp_style,
              on: {
                click: _vm.exp_click,
                mousedown: _vm.expmousedown,
                mouseover: _vm.expmouseover,
                mouseleave: _vm.expmouseleave
              }
            },
            [_vm._v("\n        \n    ")]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.show_exp_list
        ? _c("item-list", {
            attrs: {
              config: _vm.config,
              items: _vm.data.items,
              colors: _vm.colors,
              dc: _vm.dc
            },
            on: {
              "close-list": _vm.close_list,
              "item-selected": _vm.emit_selected_sub
            }
          })
        : _vm._e()
    ],
    1
  )
}
var ToolbarItemvue_type_template_id_227b3c2e_staticRenderFns = []
ToolbarItemvue_type_template_id_227b3c2e_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=template&id=227b3c2e&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=template&id=c50b23fe&
var ItemListvue_type_template_id_c50b23fe_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "tvjs-item-list",
      style: _vm.list_style(),
      on: { mousedown: _vm.thismousedown }
    },
    _vm._l(_vm.items, function(item) {
      return !item.hidden
        ? _c(
            "div",
            {
              class: _vm.item_class(item),
              style: _vm.item_style(item),
              on: {
                click: function(e) {
                  return _vm.item_click(e, item)
                }
              }
            },
            [
              _c("div", {
                staticClass: "trading-vue-tbicon tvjs-pixelated",
                style: _vm.icon_style(item)
              }),
              _vm._v(" "),
              _c("div", [_vm._v(_vm._s(item.type))])
            ]
          )
        : _vm._e()
    }),
    0
  )
}
var ItemListvue_type_template_id_c50b23fe_staticRenderFns = []
ItemListvue_type_template_id_c50b23fe_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=template&id=c50b23fe&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const ItemListvue_type_script_lang_js_ = ({
  name: 'ItemList',
  props: ['config', 'items', 'colors', 'dc'],
  mounted: function mounted() {
    window.addEventListener('mousedown', this.onmousedown);
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('mousedown', this.onmousedown);
  },
  methods: {
    list_style: function list_style() {
      var conf = this.$props.config;
      var w = conf.TOOLBAR;
      var brd = this.colors.tbListBorder || this.colors.grid;
      var bstl = "1px solid ".concat(brd);
      return {
        left: "".concat(w, "px"),
        background: this.colors.back,
        borderTop: bstl,
        borderRight: bstl,
        borderBottom: bstl
      };
    },
    item_class: function item_class(item) {
      if (this.dc.tool === item.type) {
        return "tvjs-item-list-item selected-item";
      }

      return "tvjs-item-list-item";
    },
    item_style: function item_style(item) {
      var conf = this.$props.config;
      var h = conf.TB_ICON + conf.TB_ITEM_M * 2 + 8;
      var sel = this.dc.tool === item.type;
      return {
        height: "".concat(h, "px"),
        color: sel ? undefined : "#888888"
      };
    },
    icon_style: function icon_style(data) {
      var conf = this.$props.config;
      var br = conf.TB_ICON_BRI;
      var im = conf.TB_ITEM_M;
      return {
        'background-image': "url(".concat(data.icon, ")"),
        'width': '25px',
        'height': '25px',
        'margin': "".concat(im, "px"),
        'filter': "brightness(".concat(br, ")")
      };
    },
    item_click: function item_click(e, item) {
      e.cancelBubble = true;
      this.$emit('item-selected', item);
      this.$emit('close-list');
    },
    onmousedown: function onmousedown() {
      this.$emit('close-list');
    },
    thismousedown: function thismousedown(e) {
      e.stopPropagation();
    }
  },
  computed: {},
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ItemListvue_type_script_lang_js_ = (ItemListvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=style&index=0&lang=css&
var ItemListvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(807);
;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ItemList.vue



;


/* normalize component */

var ItemList_component = normalizeComponent(
  components_ItemListvue_type_script_lang_js_,
  ItemListvue_type_template_id_c50b23fe_render,
  ItemListvue_type_template_id_c50b23fe_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ItemList_api; }
ItemList_component.options.__file = "src/components/ItemList.vue"
/* harmony default export */ const ItemList = (ItemList_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const ToolbarItemvue_type_script_lang_js_ = ({
  name: 'ToolbarItem',
  props: ['data', 'selected', 'colors', 'tv_id', 'config', 'dc', 'subs'],
  components: {
    ItemList: ItemList
  },
  mounted: function mounted() {
    if (this.data.group) {
      var type = this.subs[this.data.group];
      var item = this.data.items.find(function (x) {
        return x.type === type;
      });
      if (item) this.sub_item = item;
    }
  },
  methods: {
    mousedown: function mousedown(e) {
      var _this = this;

      this.click_start = utils.now();
      this.click_id = setTimeout(function () {
        _this.show_exp_list = true;
      }, this.config.TB_ICON_HOLD);
    },
    expmouseover: function expmouseover() {
      this.exp_hover = true;
    },
    expmouseleave: function expmouseleave() {
      this.exp_hover = false;
    },
    expmousedown: function expmousedown(e) {
      if (this.show_exp_list) e.stopPropagation();
    },
    emit_selected: function emit_selected(src) {
      if (utils.now() - this.click_start > this.config.TB_ICON_HOLD) return;
      clearTimeout(this.click_id); //if (Utils.is_mobile && src === 'click') return
      // TODO: double firing

      if (!this.data.group) {
        this.$emit('item-selected', this.data);
      } else {
        var item = this.sub_item || this.data.items[0];
        this.$emit('item-selected', item);
      }
    },
    emit_selected_sub: function emit_selected_sub(item) {
      this.$emit('item-selected', item);
      this.sub_item = item;
    },
    exp_click: function exp_click(e) {
      if (!this.data.group) return;
      e.cancelBubble = true;
      this.show_exp_list = !this.show_exp_list;
    },
    close_list: function close_list() {
      this.show_exp_list = false;
    }
  },
  computed: {
    item_style: function item_style() {
      if (this.$props.data.type === 'System:Splitter') {
        return this.splitter;
      }

      var conf = this.$props.config;
      var im = conf.TB_ITEM_M;
      var m = (conf.TOOLBAR - conf.TB_ICON) * 0.5 - im;
      var s = conf.TB_ICON + im * 2;
      var b = this.exp_hover ? 0 : 3;
      return {
        'width': "".concat(s, "px"),
        'height': "".concat(s, "px"),
        'margin': "8px ".concat(m, "px 0px ").concat(m, "px"),
        'border-radius': "3px ".concat(b, "px ").concat(b, "px 3px")
      };
    },
    icon_style: function icon_style() {
      if (this.$props.data.type === 'System:Splitter') {
        return {};
      }

      var conf = this.$props.config;
      var br = conf.TB_ICON_BRI;
      var sz = conf.TB_ICON;
      var im = conf.TB_ITEM_M;
      var ic = this.sub_item ? this.sub_item.icon : this.$props.data.icon;
      return {
        'background-image': "url(".concat(ic, ")"),
        'width': "".concat(sz, "px"),
        'height': "".concat(sz, "px"),
        'margin': "".concat(im, "px"),
        'filter': "brightness(".concat(br, ")")
      };
    },
    exp_style: function exp_style() {
      var conf = this.$props.config;
      var im = conf.TB_ITEM_M;
      var s = conf.TB_ICON * 0.5 + im;
      var p = (conf.TOOLBAR - s * 2) / 4;
      return {
        padding: "".concat(s, "px ").concat(p, "px"),
        transform: this.show_exp_list ? "scale(-0.6, 1)" : "scaleX(0.6)"
      };
    },
    splitter: function splitter() {
      var conf = this.$props.config;
      var colors = this.$props.colors;
      var c = colors.grid;
      var im = conf.TB_ITEM_M;
      var m = (conf.TOOLBAR - conf.TB_ICON) * 0.5 - im;
      var s = conf.TB_ICON + im * 2;
      return {
        'width': "".concat(s, "px"),
        'height': '1px',
        'margin': "8px ".concat(m, "px 8px ").concat(m, "px"),
        'background-color': c
      };
    }
  },
  data: function data() {
    return {
      exp_hover: false,
      show_exp_list: false,
      sub_item: null
    };
  }
});
;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ToolbarItemvue_type_script_lang_js_ = (ToolbarItemvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=style&index=0&lang=css&
var ToolbarItemvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(501);
;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue



;


/* normalize component */

var ToolbarItem_component = normalizeComponent(
  components_ToolbarItemvue_type_script_lang_js_,
  ToolbarItemvue_type_template_id_227b3c2e_render,
  ToolbarItemvue_type_template_id_227b3c2e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ToolbarItem_api; }
ToolbarItem_component.options.__file = "src/components/ToolbarItem.vue"
/* harmony default export */ const ToolbarItem = (ToolbarItem_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=script&lang=js&
function Toolbarvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Toolbarvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Toolbarvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Toolbarvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Toolbarvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Toolbarvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const Toolbarvue_type_script_lang_js_ = ({
  name: 'Toolbar',
  props: ['data', 'height', 'colors', 'tv_id', 'config'],
  components: {
    ToolbarItem: ToolbarItem
  },
  mounted: function mounted() {},
  methods: {
    selected: function selected(tool) {
      this.$emit('custom-event', {
        event: 'tool-selected',
        args: [tool.type]
      });

      if (tool.group) {
        // TODO: emit the sub map to DC (save)
        this.sub_map[tool.group] = tool.type;
      }
    },
    is_selected: function is_selected(tool) {
      var _this = this;

      if (tool.group) {
        return !!tool.items.find(function (x) {
          return x.type === _this.data.tool;
        });
      }

      return tool.type === this.data.tool;
    }
  },
  computed: {
    styles: function styles() {
      var colors = this.$props.colors;
      var b = this.$props.config.TB_BORDER;
      var w = this.$props.config.TOOLBAR - b;
      var c = colors.grid;
      var cb = colors.tbBack || colors.back;
      var brd = colors.tbBorder || colors.scale;
      var st = this.$props.config.TB_B_STYLE;
      return {
        'width': "".concat(w, "px"),
        'height': "".concat(this.$props.height - 3, "px"),
        'background-color': cb,
        'border-right': "".concat(b, "px ").concat(st, " ").concat(brd)
      };
    },
    groups: function groups() {
      var arr = [];

      var _iterator = Toolbarvue_type_script_lang_js_createForOfIteratorHelper(this.data.tools || []),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tool = _step.value;

          if (!tool.group) {
            arr.push(tool);
            continue;
          }

          var g = arr.find(function (x) {
            return x.group === tool.group;
          });

          if (!g) {
            arr.push({
              group: tool.group,
              icon: tool.icon,
              items: [tool]
            });
          } else {
            g.items.push(tool);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return arr;
    }
  },
  watch: {
    data: {
      handler: function handler(n) {
        // For some reason Vue.js doesn't want to
        // update 'tools' automatically when new item
        // is pushed/removed. Yo, Vue, I herd you
        // you want more dirty tricks?
        if (n.tools) this.tool_count = n.tools.length;
      },
      deep: true
    }
  },
  data: function data() {
    return {
      tool_count: 0,
      sub_map: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Toolbarvue_type_script_lang_js_ = (Toolbarvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=style&index=0&lang=css&
var Toolbarvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(153);
;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Toolbar.vue



;


/* normalize component */

var Toolbar_component = normalizeComponent(
  components_Toolbarvue_type_script_lang_js_,
  Toolbarvue_type_template_id_021887fb_render,
  Toolbarvue_type_template_id_021887fb_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Toolbar_api; }
Toolbar_component.options.__file = "src/components/Toolbar.vue"
/* harmony default export */ const Toolbar = (Toolbar_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=template&id=5fe4312f&
var Widgetsvue_type_template_id_5fe4312f_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "tvjs-widgets",
      style: { width: _vm.width + "px", height: _vm.height + "px" }
    },
    _vm._l(Object.keys(_vm.map), function(id) {
      return _c(_vm.initw(id), {
        key: id,
        tag: "component",
        attrs: {
          id: id,
          main: _vm.map[id].ctrl,
          data: _vm.map[id].data,
          tv: _vm.tv,
          dc: _vm.dc
        }
      })
    }),
    1
  )
}
var Widgetsvue_type_template_id_5fe4312f_staticRenderFns = []
Widgetsvue_type_template_id_5fe4312f_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=template&id=5fe4312f&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const Widgetsvue_type_script_lang_js_ = ({
  name: 'Widgets',
  props: ['width', 'height', 'map', 'tv', 'dc'],
  methods: {
    initw: function initw(id) {
      return this.$props.map[id].cls;
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Widgetsvue_type_script_lang_js_ = (Widgetsvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=style&index=0&lang=css&
var Widgetsvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(5);
;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Widgets.vue



;


/* normalize component */

var Widgets_component = normalizeComponent(
  components_Widgetsvue_type_script_lang_js_,
  Widgetsvue_type_template_id_5fe4312f_render,
  Widgetsvue_type_template_id_5fe4312f_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Widgets_api; }
Widgets_component.options.__file = "src/components/Widgets.vue"
/* harmony default export */ const Widgets = (Widgets_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=template&id=2c1770cc&
var TheTipvue_type_template_id_2c1770cc_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", {
    staticClass: "tvjs-the-tip",
    style: _vm.style,
    domProps: { innerHTML: _vm._s(_vm.data.text) },
    on: {
      mousedown: function($event) {
        return _vm.$emit("remove-me")
      }
    }
  })
}
var TheTipvue_type_template_id_2c1770cc_staticRenderFns = []
TheTipvue_type_template_id_2c1770cc_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=template&id=2c1770cc&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=script&lang=js&
//
//
//
//
//
//
/* harmony default export */ const TheTipvue_type_script_lang_js_ = ({
  name: 'TheTip',
  props: ['data'],
  mounted: function mounted() {
    var _this = this;

    setTimeout(function () {
      return _this.$emit('remove-me');
    }, 3000);
  },
  computed: {
    style: function style() {
      return {
        background: this.data.color
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_TheTipvue_type_script_lang_js_ = (TheTipvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=style&index=0&lang=css&
var TheTipvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(477);
;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/TheTip.vue



;


/* normalize component */

var TheTip_component = normalizeComponent(
  components_TheTipvue_type_script_lang_js_,
  TheTipvue_type_template_id_2c1770cc_render,
  TheTipvue_type_template_id_2c1770cc_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TheTip_api; }
TheTip_component.options.__file = "src/components/TheTip.vue"
/* harmony default export */ const TheTip = (TheTip_component.exports);
;// CONCATENATED MODULE: ./src/mixins/xcontrol.js
function xcontrol_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = xcontrol_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function xcontrol_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return xcontrol_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return xcontrol_arrayLikeToArray(o, minLen); }

function xcontrol_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// extensions control
/* harmony default export */ const xcontrol = ({
  mounted: function mounted() {
    this.ctrllist();
    this.skin_styles();
  },
  methods: {
    // Build / rebuild component list
    ctrllist: function ctrllist() {
      this.ctrl_destroy();
      this.controllers = [];

      var _iterator = xcontrol_createForOfIteratorHelper(this.$props.extensions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var x = _step.value;
          var name = x.Main.__name__;

          if (!this.xSettings[name]) {
            this.$set(this.xSettings, name, {});
          }

          var nc = new x.Main(this, // tv inst
          this.data, // dc
          this.xSettings[name] // settings
          );
          nc.name = name;
          this.controllers.push(nc);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return this.controllers;
    },
    // TODO: preventDefault
    pre_dc: function pre_dc(e) {
      var _iterator2 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ctrl = _step2.value;

          if (ctrl.update) {
            ctrl.update(e);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    post_dc: function post_dc(e) {
      var _iterator3 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var ctrl = _step3.value;

          if (ctrl.post_update) {
            ctrl.post_update(e);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    },
    ctrl_destroy: function ctrl_destroy() {
      var _iterator4 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var ctrl = _step4.value;
          if (ctrl.destroy) ctrl.destroy();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    },
    skin_styles: function skin_styles() {
      var id = 'tvjs-skin-styles';
      var stbr = document.getElementById(id);

      if (stbr) {
        var parent = stbr.parentNode;
        parent.removeChild(stbr);
      }

      if (this.skin_proto && this.skin_proto.styles) {
        var sheet = document.createElement('style');
        sheet.setAttribute("id", id);
        sheet.innerHTML = this.skin_proto.styles;
        this.$el.appendChild(sheet);
      }
    }
  },
  computed: {
    ws: function ws() {
      var ws = {};

      var _iterator5 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ctrl = _step5.value;

          if (ctrl.widgets) {
            for (var id in ctrl.widgets) {
              ws[id] = ctrl.widgets[id];
              ws[id].ctrl = ctrl;
            }
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return ws;
    },
    skins: function skins() {
      var sks = {};

      var _iterator6 = xcontrol_createForOfIteratorHelper(this.$props.extensions),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var x = _step6.value;

          for (var id in x.skins || {}) {
            sks[id] = x.skins[id];
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return sks;
    },
    skin_proto: function skin_proto() {
      return this.skins[this.$props.skin];
    },
    colorpack: function colorpack() {
      var sel = this.skins[this.$props.skin];
      return sel ? sel.colors : undefined;
    }
  },
  watch: {
    // TODO: This is fast & dirty fix, need
    // to fix the actual reactivity problem
    skin: function skin(n, p) {
      if (n !== p) this.resetChart();
      this.skin_styles();
    },
    extensions: function extensions() {
      this.ctrllist();
    },
    xSettings: {
      handler: function handler(n, p) {
        var _iterator7 = xcontrol_createForOfIteratorHelper(this.controllers),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var ctrl = _step7.value;

            if (ctrl.onsettings) {
              ctrl.onsettings(n, p);
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      },
      deep: true
    }
  },
  data: function data() {
    return {
      controllers: []
    };
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=script&lang=js&


function TradingVuevue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = TradingVuevue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function TradingVuevue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TradingVuevue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TradingVuevue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function TradingVuevue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ const TradingVuevue_type_script_lang_js_ = ({
  name: 'TradingVue',
  components: {
    Chart: Chart,
    Toolbar: Toolbar,
    Widgets: Widgets,
    TheTip: TheTip
  },
  mixins: [xcontrol],
  props: {
    titleTxt: {
      type: String,
      "default": 'TradingVue.js'
    },
    id: {
      type: String,
      "default": 'trading-vue-js'
    },
    width: {
      type: Number,
      "default": 800
    },
    height: {
      type: Number,
      "default": 421
    },
    colorTitle: {
      type: String,
      "default": '#42b883'
    },
    colorBack: {
      type: String,
      "default": '#121826'
    },
    colorGrid: {
      type: String,
      "default": '#2f3240'
    },
    colorText: {
      type: String,
      "default": '#dedddd'
    },
    colorTextHL: {
      type: String,
      "default": '#fff'
    },
    colorScale: {
      type: String,
      "default": '#838383'
    },
    colorCross: {
      type: String,
      "default": '#8091a0'
    },
    colorCandleUp: {
      type: String,
      "default": '#23a776'
    },
    colorCandleDw: {
      type: String,
      "default": '#e54150'
    },
    colorWickUp: {
      type: String,
      "default": '#23a77688'
    },
    colorWickDw: {
      type: String,
      "default": '#e5415088'
    },
    colorWickSm: {
      type: String,
      "default": 'transparent' // deprecated

    },
    colorVolUp: {
      type: String,
      "default": '#79999e42'
    },
    colorVolDw: {
      type: String,
      "default": '#ef535042'
    },
    colorPanel: {
      type: String,
      "default": '#565c68'
    },
    colorTbBack: {
      type: String
    },
    colorTbBorder: {
      type: String,
      "default": '#8282827d'
    },
    colors: {
      type: Object
    },
    font: {
      type: String,
      "default": constants.ChartConfig.FONT
    },
    toolbar: {
      type: Boolean,
      "default": false
    },
    data: {
      type: Object,
      required: true
    },
    // Your overlay classes here
    overlays: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    // Overwrites ChartConfig values,
    // see constants.js
    chartConfig: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    legendButtons: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    indexBased: {
      type: Boolean,
      "default": false
    },
    extensions: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    xSettings: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    skin: {
      type: String // Skin Name

    },
    timezone: {
      type: Number,
      "default": 0
    }
  },
  computed: {
    // Copy a subset of TradingVue props
    chart_props: function chart_props() {
      var offset = this.$props.toolbar ? this.chart_config.TOOLBAR : 0;
      var chart_props = {
        title_txt: this.$props.titleTxt,
        overlays: this.$props.overlays.concat(this.mod_ovs),
        data: this.decubed,
        width: this.$props.width - offset,
        height: this.$props.height,
        font: this.font_comp,
        buttons: this.$props.legendButtons,
        toolbar: this.$props.toolbar,
        ib: this.$props.indexBased || this.index_based || false,
        colors: Object.assign({}, this.$props.colors || this.colorpack),
        skin: this.skin_proto,
        timezone: this.$props.timezone
      };
      this.parse_colors(chart_props.colors);
      return chart_props;
    },
    chart_config: function chart_config() {
      return Object.assign({}, constants.ChartConfig, this.$props.chartConfig);
    },
    decubed: function decubed() {
      var data = this.$props.data;

      if (data.data !== undefined) {
        // DataCube detected
        data.init_tvjs(this);
        return data.data;
      } else {
        return data;
      }
    },
    index_based: function index_based() {
      var base = this.$props.data;

      if (base.chart) {
        return base.chart.indexBased;
      } else if (base.data) {
        return base.data.chart.indexBased;
      }

      return false;
    },
    mod_ovs: function mod_ovs() {
      var arr = [];

      var _iterator = TradingVuevue_type_script_lang_js_createForOfIteratorHelper(this.$props.extensions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var x = _step.value;
          arr.push.apply(arr, _toConsumableArray(Object.values(x.overlays)));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return arr;
    },
    font_comp: function font_comp() {
      return this.skin_proto && this.skin_proto.font ? this.skin_proto.font : this.font;
    }
  },
  data: function data() {
    return {
      reset: 0,
      tip: null
    };
  },
  beforeDestroy: function beforeDestroy() {
    this.custom_event({
      event: 'before-destroy'
    });
    this.ctrl_destroy();
  },
  methods: {
    // TODO: reset extensions?
    resetChart: function resetChart(resetRange) {
      var _this = this;

      if (resetRange === void 0) {
        resetRange = true;
      }

      this.reset++;
      var range = this.getRange();

      if (!resetRange && range[0] && range[1]) {
        this.$nextTick(function () {
          return _this.setRange.apply(_this, _toConsumableArray(range));
        });
      }

      this.$nextTick(function () {
        return _this.custom_event({
          event: 'chart-reset',
          args: []
        });
      });
    },
    "goto": function goto(t) {
      // TODO: limit goto & setRange (out of data error)
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        t = ti_map.gt2i(t, this.$refs.chart.ohlcv);
      }

      this.$refs.chart["goto"](t);
    },
    setRange: function setRange(t1, t2) {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        var ohlcv = this.$refs.chart.ohlcv;
        t1 = ti_map.gt2i(t1, ohlcv);
        t2 = ti_map.gt2i(t2, ohlcv);
      }

      this.$refs.chart.setRange(t1, t2);
    },
    getRange: function getRange() {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map; // Time range => index range

        return this.$refs.chart.range.map(function (x) {
          return ti_map.i2t(x);
        });
      }

      return this.$refs.chart.range;
    },
    getCursor: function getCursor() {
      var cursor = this.$refs.chart.cursor;

      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        var copy = Object.assign({}, cursor);
        copy.i = copy.t;
        copy.t = ti_map.i2t(copy.t);
        return copy;
      }

      return cursor;
    },
    showTheTip: function showTheTip(text, color) {
      if (color === void 0) {
        color = "orange";
      }

      this.tip = {
        text: text,
        color: color
      };
    },
    legend_button: function legend_button(event) {
      this.custom_event({
        event: 'legend-button-click',
        args: [event]
      });
    },
    custom_event: function custom_event(d) {
      if ('args' in d) {
        this.$emit.apply(this, [d.event].concat(_toConsumableArray(d.args)));
      } else {
        this.$emit(d.event);
      }

      var data = this.$props.data;
      var ctrl = this.controllers.length !== 0;
      if (ctrl) this.pre_dc(d);

      if (data.tv) {
        // If the data object is DataCube
        data.on_custom_event(d.event, d.args);
      }

      if (ctrl) this.post_dc(d);
    },
    range_changed: function range_changed(r) {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        r = r.map(function (x) {
          return ti_map.i2t(x);
        });
      }

      this.$emit('range-changed', r);
      this.custom_event({
        event: 'range-changed',
        args: [r]
      });
      if (this.onrange) this.onrange(r);
    },
    set_loader: function set_loader(dc) {
      var _this2 = this;

      this.onrange = function (r) {
        var pf = _this2.chart_props.ib ? '_ms' : '';
        var tf = _this2.$refs.chart['interval' + pf];
        dc.range_changed(r, tf);
      };
    },
    parse_colors: function parse_colors(colors) {
      for (var k in this.$props) {
        if (k.indexOf('color') === 0 && k !== 'colors') {
          var k2 = k.replace('color', '');
          k2 = k2[0].toLowerCase() + k2.slice(1);
          if (colors[k2]) continue;
          colors[k2] = this.$props[k];
        }
      }
    },
    mousedown: function mousedown() {
      this.$refs.chart.activated = true;
    },
    mouseleave: function mouseleave() {
      this.$refs.chart.activated = false;
    }
  }
});
;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=script&lang=js&
 /* harmony default export */ const src_TradingVuevue_type_script_lang_js_ = (TradingVuevue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=style&index=0&lang=css&
var TradingVuevue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(863);
;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/TradingVue.vue



;


/* normalize component */

var TradingVue_component = normalizeComponent(
  src_TradingVuevue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TradingVue_api; }
TradingVue_component.options.__file = "src/TradingVue.vue"
/* harmony default export */ const TradingVue = (TradingVue_component.exports);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __nested_webpack_require_9759__(757);
var regenerator_default = /*#__PURE__*/__nested_webpack_require_9759__.n(regenerator);
;// CONCATENATED MODULE: ./src/helpers/tmp/ww$$$.json
const ww$$$_namespaceObject = JSON.parse('["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"]');
// EXTERNAL MODULE: ./node_modules/lz-string/libs/lz-string.js
var lz_string = __nested_webpack_require_9759__(961);
var lz_string_default = /*#__PURE__*/__nested_webpack_require_9759__.n(lz_string);
;// CONCATENATED MODULE: ./src/helpers/script_ww_api.js




// Webworker interface
// Compiled webworker (see webpack/ww_plugin.js)



 // For webworker-loader to find the ww

var WebWork = /*#__PURE__*/function () {
  function WebWork(dc) {
    classCallCheck_classCallCheck(this, WebWork);

    this.dc = dc;
    this.tasks = {};

    this.onevent = function () {};

    this.start();
  }

  createClass_createClass(WebWork, [{
    key: "start",
    value: function start() {
      var _this = this;

      if (this.worker) this.worker.terminate(); // URL.createObjectURL

      window.URL = window.URL || window.webkitURL;
      var data = lz_string_default().decompressFromBase64(ww$$$_namespaceObject[0]);
      var blob;

      try {
        blob = new Blob([data], {
          type: 'application/javascript'
        });
      } catch (e) {
        // Backwards-compatibility
        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(data);
        blob = blob.getBlob();
      }

      this.worker = new Worker(URL.createObjectURL(blob));

      this.worker.onmessage = function (e) {
        return _this.onmessage(e);
      };
    }
  }, {
    key: "start_socket",
    value: function start_socket() {
      var _this2 = this;

      if (!this.dc.sett.node_url) return;
      this.socket = new WebSocket(this.dc.sett.node_url);
      this.socket.addEventListener('message', function (e) {
        _this2.onmessage({
          data: JSON.parse(e.data)
        });
      });
      this.msg_queue = [];
    }
  }, {
    key: "send",
    value: function send(msg, tx_keys) {
      if (this.dc.sett.node_url) {
        return this.send_node(msg, tx_keys);
      }

      if (tx_keys) {
        var tx_objs = tx_keys.map(function (k) {
          return msg.data[k];
        });
        this.worker.postMessage(msg, tx_objs);
      } else {
        this.worker.postMessage(msg);
      }
    } // Send to node.js via websocket

  }, {
    key: "send_node",
    value: function send_node(msg, tx_keys) {
      if (!this.socket) this.start_socket();

      if (this.socket && this.socket.readyState) {
        // Send the old messages first
        while (this.msg_queue.length) {
          var m = this.msg_queue.shift();
          this.socket.send(JSON.stringify(m));
        }

        this.socket.send(JSON.stringify(msg));
      } else {
        this.msg_queue.push(msg);
      }
    }
  }, {
    key: "onmessage",
    value: function onmessage(e) {
      if (e.data.id in this.tasks) {
        this.tasks[e.data.id](e.data.data);
        delete this.tasks[e.data.id];
      } else {
        this.onevent(e);
      }
    } // Execute a task

  }, {
    key: "exec",
    value: function () {
      var _exec = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee(type, data, tx_keys) {
        var _this3 = this;

        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (rs, rj) {
                  var id = utils.uuid();

                  _this3.send({
                    type: type,
                    id: id,
                    data: data
                  }, tx_keys);

                  _this3.tasks[id] = function (res) {
                    rs(res);
                  };
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function exec(_x, _x2, _x3) {
        return _exec.apply(this, arguments);
      }

      return exec;
    }() // Execute a task, but just fucking do it,
    // do not wait for the result

  }, {
    key: "just",
    value: function just(type, data, tx_keys) {
      var id = utils.uuid();
      this.send({
        type: type,
        id: id,
        data: data
      }, tx_keys);
    } // Relay an event from iframe postMessage
    // (for the future)

  }, {
    key: "relay",
    value: function () {
      var _relay = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee2(event, just) {
        var _this4 = this;

        return regenerator_default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (just === void 0) {
                  just = false;
                }

                return _context2.abrupt("return", new Promise(function (rs, rj) {
                  _this4.send(event, event.tx_keys);

                  if (!just) {
                    _this4.tasks[event.id] = function (res) {
                      rs(res);
                    };
                  }
                }));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function relay(_x4, _x5) {
        return _relay.apply(this, arguments);
      }

      return relay;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.worker) this.worker.terminate();
    }
  }]);

  return WebWork;
}();

/* harmony default export */ const script_ww_api = (WebWork);
;// CONCATENATED MODULE: ./src/helpers/script_utils.js


var FDEFS = /(function |)([$A-Z_][0-9A-Z_$\.]*)[\s]*?\((.*?)\)/gmi;
var SBRACKETS = /([$A-Z_][0-9A-Z_$\.]*)[\s]*?\[([^"^\[^\]]+?)\]/gmi;
var TFSTR = /(\d+)(\w*)/gm;
var BUF_INC = 5;
var tf_cache = {};
function f_args(src) {
  FDEFS.lastIndex = 0;
  var m = FDEFS.exec(src);

  if (m) {
    var fkeyword = m[1].trim();
    var fname = m[2].trim();
    var fargs = m[3].trim();
    return fargs.split(',').map(function (x) {
      return x.trim();
    });
  }

  return [];
}
function f_body(src) {
  return src.slice(src.indexOf("{") + 1, src.lastIndexOf("}"));
}
function wrap_idxs(src, pre) {
  if (pre === void 0) {
    pre = '';
  }

  SBRACKETS.lastIndex = 0;
  var changed = false;

  do {
    var m = SBRACKETS.exec(src);

    if (m) {
      var vname = m[1].trim();
      var vindex = m[2].trim();

      if (vindex === '0' || parseInt(vindex) < BUF_INC) {
        continue;
      }

      switch (vname) {
        case 'let':
        case 'var':
        case 'return':
          continue;
      } //let wrap = `${pre}_v(${vname}, ${vindex})[${vindex}]`


      var wrap = "".concat(vname, "[").concat(pre, "_i(").concat(vindex, ", ").concat(vname, ")]");
      src = src.replace(m[0], wrap);
      changed = true;
    }
  } while (m);

  return changed ? src : src;
} // Get all module helper classes

function make_module_lib(mod) {
  var lib = {};

  for (var k in mod) {
    if (k === 'main' || k === 'id') continue;
    var a = f_args(mod[k]);
    lib[k] = new Function(a, f_body(mod[k]));
  }

  return lib;
}
function get_raw_src(f) {
  if (typeof f === 'string') return f;
  var src = f.toString();
  return src.slice(src.indexOf("{") + 1, src.lastIndexOf("}"));
} // Get tf in ms from pairs such (`15`, `m`)

function tf_from_pair(num, pf) {
  var mult = 1;

  switch (pf) {
    case 's':
      mult = Const.SECOND;
      break;

    case 'm':
      mult = Const.MINUTE;
      break;

    case 'H':
      mult = Const.HOUR;
      break;

    case 'D':
      mult = Const.DAY;
      break;

    case 'W':
      mult = Const.WEEK;
      break;

    case 'M':
      mult = Const.MONTH;
      break;

    case 'Y':
      mult = Const.YEAR;
      break;
  }

  return parseInt(num) * mult;
}
function tf_from_str(str) {
  if (typeof str === 'number') return str;
  if (tf_cache[str]) return tf_cache[str];
  TFSTR.lastIndex = 0;
  var m = TFSTR.exec(str);

  if (m) {
    tf_cache[str] = tf_from_pair(m[1], m[2]);
    return tf_cache[str];
  }

  return undefined;
}
function get_fn_id(pre, id) {
  return pre + '-' + id.split('<-').pop();
} // Apply filter for all new overlays

function ovf(obj, f) {
  var nw = {};

  for (var id in obj) {
    nw[id] = {};

    for (var k in obj[id]) {
      if (k === 'data') continue;
      nw[id][k] = obj[id][k];
    }

    nw[id].data = f(obj[id].data);
  }

  return nw;
} // Return index of the next element in
// dataset (since t). Impl: simple binary search
// TODO: optimize (remember the penultimate
// iteration and start from there)

function nextt(data, t, ti) {
  if (ti === void 0) {
    ti = 0;
  }

  var i0 = 0;
  var iN = data.length - 1;

  while (i0 <= iN) {
    var mid = Math.floor((i0 + iN) / 2);

    if (data[mid][ti] === t) {
      return mid;
    } else if (data[mid][ti] < t) {
      i0 = mid + 1;
    } else {
      iN = mid - 1;
    }
  }

  return t < data[mid][ti] ? mid : mid + 1;
} // Estimated size of datasets

function size_of_dss(data) {
  var bytes = 0;

  for (var id in data) {
    if (data[id].data && data[id].data[0]) {
      var s0 = size_of(data[id].data[0]);
      bytes += s0 * data[id].data.length;
    }
  }

  return bytes;
} // Used to measure the size of dataset

function size_of(object) {
  var list = [],
      stack = [object],
      bytes = 0;

  while (stack.length) {
    var value = stack.pop();

    var type = _typeof(value);

    if (type === 'boolean') {
      bytes += 4;
    } else if (type === 'string') {
      bytes += value.length * 2;
    } else if (type === 'number') {
      bytes += 8;
    } else if (type === 'object' && list.indexOf(value) === -1) {
      list.push(value);

      for (var i in value) {
        stack.push(value[i]);
      }
    }
  }

  return bytes;
} // Update onchart/offchart

function update(data, val) {
  var i = data.length - 1;
  var last = data[i];

  if (!last || val[0] > last[0]) {
    data.push(val);
  } else {
    data[i] = val;
  }
}
function script_utils_now() {
  return new Date().getTime();
}
;// CONCATENATED MODULE: ./src/helpers/dataset.js





function dataset_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dataset_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dataset_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataset_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataset_arrayLikeToArray(o, minLen); }

function dataset_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


// Dataset proxy between vuejs & WebWorker


var Dataset = /*#__PURE__*/function () {
  function Dataset(dc, desc) {
    classCallCheck_classCallCheck(this, Dataset);

    // TODO: dataset url arrow fn tells WW
    // to load the ds directly from web
    this.type = desc.type;
    this.id = desc.id;
    this.dc = dc; // Send the data to WW

    if (desc.data) {
      this.dc.ww.just('upload-data', _defineProperty({}, this.id, desc)); // Remove the data from the descriptor

      delete desc.data;
    }

    var proto = Object.getPrototypeOf(this);
    Object.setPrototypeOf(desc, proto);
    Object.defineProperty(desc, 'dc', {
      get: function get() {
        return dc;
      }
    });
  } // Watch for the changes of descriptors


  createClass_createClass(Dataset, [{
    key: "set",
    value: // Set data (overwrite the whole dataset)
    function set(data, exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'set',
        data: data,
        exec: exec
      });
    } // Update with new data (array of data points)

  }, {
    key: "update",
    value: function update(arr) {
      this.dc.ww.just('update-data', _defineProperty({}, this.id, arr));
    } // Send WW a chunk to merge. The merge algo
    // here is simpler than in DC. It just adds
    // data at the beginning or/and the end of ds

  }, {
    key: "merge",
    value: function merge(data, exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'mrg',
        data: data,
        exec: exec
      });
    } // Remove the ds from WW

  }, {
    key: "remove",
    value: function remove(exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.del("datasets.".concat(this.id));
      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'del',
        exec: exec
      });
      delete this.dc.dss[this.id];
    } // Fetch data from WW

  }, {
    key: "data",
    value: function () {
      var _data = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {
        var ds;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.dc.ww.exec('get-dataset', this.id);

              case 2:
                ds = _context.sent;

                if (ds) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return");

              case 5:
                return _context.abrupt("return", ds.data);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function data() {
        return _data.apply(this, arguments);
      }

      return data;
    }()
  }], [{
    key: "watcher",
    value: function watcher(n, p) {
      var nids = n.map(function (x) {
        return x.id;
      });
      var pids = p.map(function (x) {
        return x.id;
      });

      var _iterator = dataset_createForOfIteratorHelper(nids),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var id = _step.value;

          if (!pids.includes(id)) {
            var ds = n.filter(function (x) {
              return x.id === id;
            })[0];
            this.dss[id] = new Dataset(this, ds);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = dataset_createForOfIteratorHelper(pids),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var id = _step2.value;

          if (!nids.includes(id) && this.dss[id]) {
            this.dss[id].remove();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } // Make an object for data transfer

  }, {
    key: "make_tx",
    value: function make_tx(dc, types) {
      var main = dc.data.chart.data;
      var base = {};

      if (types.find(function (x) {
        return x.type === 'OHLCV';
      })) {
        base = {
          ohlcv: main
        };
      } // TODO: add more sophisticated search
      // (using 'script.datasets' paramerter)

      /*for (var req of types) {
          let ds = Object.values(dc.dss || {})
              .find(x => x.type === req.type)
          if (ds && ds.data) {
              base[ds.id] = {
                  id: ds.id,
                  type: ds.type,
                  data: ds.data
              }
          }
      }*/
      // TODO: Data request callback ?


      return base;
    }
  }]);

  return Dataset;
}(); // Dataset reciever (created on WW)



var DatasetWW = /*#__PURE__*/(/* unused pure expression or super */ null && (0));
;// CONCATENATED MODULE: ./src/helpers/dc_events.js





function dc_events_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dc_events_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dc_events_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dc_events_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dc_events_arrayLikeToArray(o, minLen); }

function dc_events_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// DataCube event handlers





var DCEvents = /*#__PURE__*/function () {
  function DCEvents() {
    var _this = this;

    classCallCheck_classCallCheck(this, DCEvents);

    this.ww = new script_ww_api(this); // Listen to the web-worker events

    this.ww.onevent = function (e) {
      var _iterator = dc_events_createForOfIteratorHelper(_this.tv.controllers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ctrl = _step.value;
          if (ctrl.ww) ctrl.ww(e.data);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      switch (e.data.type) {
        case 'request-data':
          // TODO: DataTunnel class for smarter data transfer
          if (_this.ww._data_uploading) break;
          var data = Dataset.make_tx(_this, e.data.data);

          _this.send_meta_2_ww();

          _this.ww.just('upload-data', data);

          _this.ww._data_uploading = true;
          break;

        case 'overlay-data':
          _this.on_overlay_data(e.data.data);

          break;

        case 'overlay-update':
          _this.on_overlay_update(e.data.data);

          break;

        case 'data-uploaded':
          _this.ww._data_uploading = false;
          break;

        case 'engine-state':
          _this.se_state = Object.assign(_this.se_state || {}, e.data.data);
          break;

        case 'modify-overlay':
          _this.modify_overlay(e.data.data);

          break;

        case 'script-signal':
          _this.tv.$emit('signal', e.data.data);

          break;
      }

      var _iterator2 = dc_events_createForOfIteratorHelper(_this.tv.controllers),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ctrl = _step2.value;
          if (ctrl.post_ww) ctrl.post_ww(e.data);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    };
  } // Called when overalay/tv emits 'custom-event'


  createClass_createClass(DCEvents, [{
    key: "on_custom_event",
    value: function on_custom_event(event, args) {
      switch (event) {
        case 'register-tools':
          this.register_tools(args);
          break;

        case 'exec-script':
          this.exec_script(args);
          break;

        case 'exec-all-scripts':
          this.exec_all_scripts();
          break;

        case 'data-len-changed':
          this.data_changed(args);
          break;

        case 'tool-selected':
          if (!args[0]) break; // TODO: Quick fix, investigate

          if (args[0].split(':')[0] === 'System') {
            this.system_tool(args[0].split(':')[1]);
            break;
          }

          this.tv.$set(this.data, 'tool', args[0]);

          if (args[0] === 'Cursor') {
            this.drawing_mode_off();
          }

          break;

        case 'grid-mousedown':
          this.grid_mousedown(args);
          break;

        case 'drawing-mode-off':
          this.drawing_mode_off();
          break;

        case 'change-settings':
          this.change_settings(args);
          break;

        case 'range-changed':
          this.scripts_onrange.apply(this, _toConsumableArray(args));
          break;

        case 'scroll-lock':
          this.on_scroll_lock(args[0]);
          break;

        case 'object-selected':
          this.object_selected(args);
          break;

        case 'remove-tool':
          this.system_tool('Remove');
          break;

        case 'before-destroy':
          this.before_destroy();
          break;
      }
    } // Triggered when one or multiple settings are changed
    // We select only the changed ones & re-exec them on the
    // web worker

  }, {
    key: "on_settings",
    value: function on_settings(values, prev) {
      var _this2 = this;

      if (!this.sett.scripts) return;
      var delta = {};
      var changed = false;

      var _loop = function _loop() {
        var n = values[i];
        var arr = prev.filter(function (x) {
          return x.v === n.v;
        });

        if (!arr.length && n.p.settings.$props) {
          var id = n.p.settings.$uuid;

          if (utils.is_scr_props_upd(n, prev) && utils.delayed_exec(n.p)) {
            delta[id] = n.v;
            changed = true;

            _this2.tv.$set(n.p, 'loading', true);
          }
        }
      };

      for (var i = 0; i < values.length; i++) {
        _loop();
      }

      if (changed && Object.keys(delta).length) {
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();
        this.ww.just('update-ov-settings', {
          delta: delta,
          tf: tf,
          range: range
        });
      }
    } // When the set of $uuids is changed

  }, {
    key: "on_ids_changed",
    value: function on_ids_changed(values, prev) {
      var rem = prev.filter(function (x) {
        return x !== undefined && !values.includes(x);
      });

      if (rem.length) {
        this.ww.just('remove-scripts', rem);
      }
    } // Combine all tools and their mods

  }, {
    key: "register_tools",
    value: function register_tools(tools) {
      var preset = {};

      var _iterator3 = dc_events_createForOfIteratorHelper(this.data.tools || []),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tool = _step3.value;
          preset[tool.type] = tool;
          delete tool.type;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.tv.$set(this.data, 'tools', []);
      var list = [{
        type: 'Cursor',
        icon: icons_namespaceObject["cursor.png"]
      }];

      var _iterator4 = dc_events_createForOfIteratorHelper(tools),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var tool = _step4.value;
          var proto = Object.assign({}, tool.info);
          var type = tool.info.type || 'Default';
          proto.type = "".concat(tool.use_for, ":").concat(type);
          this.merge_presets(proto, preset[tool.use_for]);
          this.merge_presets(proto, preset[proto.type]);
          delete proto.mods;
          list.push(proto);

          for (var mod in tool.info.mods) {
            var mp = Object.assign({}, proto);
            mp = Object.assign(mp, tool.info.mods[mod]);
            mp.type = "".concat(tool.use_for, ":").concat(mod);
            this.merge_presets(mp, preset[tool.use_for]);
            this.merge_presets(mp, preset[mp.type]);
            list.push(mp);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      this.tv.$set(this.data, 'tools', list);
      this.tv.$set(this.data, 'tool', 'Cursor');
    }
  }, {
    key: "exec_script",
    value: function exec_script(args) {
      if (args.length && this.sett.scripts) {
        var obj = this.get_overlay(args[0]);
        if (!obj || obj.scripts === false) return;

        if (obj.script && obj.script.src) {
          args[0].src = obj.script.src; // opt, override the src
        } // Parse script props & get the values from the ov
        // TODO: remove unnecessary script initializations


        var s = obj.settings;
        var props = args[0].src.props || {};
        if (!s.$uuid) s.$uuid = "".concat(obj.type, "-").concat(utils.uuid2());
        args[0].uuid = s.$uuid;
        args[0].sett = s;

        for (var k in props || {}) {
          var proto = props[k];

          if (s[k] !== undefined) {
            proto.val = s[k]; // use the existing val

            continue;
          }

          if (proto.def === undefined) {
            // TODO: add support of info / errors to the legend
            console.error("Overlay ".concat(obj.id, ": script prop '").concat(k, "' ") + "doesn't have a default value");
            return;
          }

          s[k] = proto.val = proto.def; // set the default
        } // Remove old props (dropped by the current exec)


        if (s.$props) {
          for (var k in s) {
            if (s.$props.includes(k) && !(k in props)) {
              delete s[k];
            }
          }
        }

        s.$props = Object.keys(args[0].src.props || {});
        this.tv.$set(obj, 'loading', true);
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();

        if (obj.script && obj.script.output != null) {
          args[0].output = obj.script.output;
        }

        this.ww.just('exec-script', {
          s: args[0],
          tf: tf,
          range: range
        });
      }
    }
  }, {
    key: "exec_all_scripts",
    value: function exec_all_scripts() {
      if (!this.sett.scripts) return;
      this.set_loading(true);
      var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
      var range = this.tv.getRange();
      this.ww.just('exec-all-scripts', {
        tf: tf,
        range: range
      });
    }
  }, {
    key: "scripts_onrange",
    value: function scripts_onrange(r) {
      if (!this.sett.scripts) return;
      var delta = {};
      this.get('.').forEach(function (v) {
        if (v.script && v.script.execOnRange && v.settings.$uuid) {
          // TODO: execInterrupt flag?
          if (utils.delayed_exec(v)) {
            delta[v.settings.$uuid] = v.settings;
          }
        }
      });

      if (Object.keys(delta).length) {
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();
        this.ww.just('update-ov-settings', {
          delta: delta,
          tf: tf,
          range: range
        });
      }
    } // Overlay modification from WW

  }, {
    key: "modify_overlay",
    value: function modify_overlay(upd) {
      var obj = this.get_overlay(upd);

      if (obj) {
        for (var k in upd.fields || {}) {
          if (typeof_typeof(obj[k]) === 'object') {
            this.merge("".concat(upd.uuid, ".").concat(k), upd.fields[k]);
          } else {
            this.tv.$set(obj, k, upd.fields[k]);
          }
        }
      }
    }
  }, {
    key: "data_changed",
    value: function data_changed(args) {
      if (!this.sett.scripts) return;
      if (this.sett.data_change_exec === false) return;
      var main = this.data.chart.data;
      if (this.ww._data_uploading) return;
      if (!this.se_state.scripts) return;
      this.send_meta_2_ww();
      this.ww.just('upload-data', {
        ohlcv: main
      });
      this.ww._data_uploading = true;
      this.set_loading(true);
    }
  }, {
    key: "set_loading",
    value: function set_loading(flag) {
      var skrr = this.get('.').filter(function (x) {
        return x.settings.$props;
      });

      var _iterator5 = dc_events_createForOfIteratorHelper(skrr),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var s = _step5.value;
          this.merge("".concat(s.id), {
            loading: flag
          });
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  }, {
    key: "send_meta_2_ww",
    value: function send_meta_2_ww() {
      var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
      var range = this.tv.getRange();
      this.ww.just('send-meta-info', {
        tf: tf,
        range: range
      });
    }
  }, {
    key: "merge_presets",
    value: function merge_presets(proto, preset) {
      if (!preset) return;

      for (var k in preset) {
        if (k === 'settings') {
          Object.assign(proto[k], preset[k]);
        } else {
          proto[k] = preset[k];
        }
      }
    }
  }, {
    key: "grid_mousedown",
    value: function grid_mousedown(args) {
      var _this3 = this;

      // TODO: tool state finished?
      this.object_selected([]); // Remove the previous RangeTool

      var rem = function rem() {
        return _this3.get('RangeTool').filter(function (x) {
          return x.settings.shiftMode;
        }).forEach(function (x) {
          return _this3.del(x.id);
        });
      };

      if (this.data.tool && this.data.tool !== 'Cursor' && !this.data.drawingMode) {
        // Prevent from "null" tools (tool created with HODL)
        if (args[1].type !== 'tap') {
          this.tv.$set(this.data, 'drawingMode', true);
          this.build_tool(args[0]);
        } else {
          this.tv.showTheTip("<b>Hodl</b>+<b>Drug</b> to create, " + "<b>Tap</b> to finish a tool");
        }
      } else if (this.sett.shift_measure && args[1].shiftKey) {
        rem();
        this.tv.$nextTick(function () {
          return _this3.build_tool(args[0], 'RangeTool:ShiftMode');
        });
      } else {
        rem();
      }
    }
  }, {
    key: "drawing_mode_off",
    value: function drawing_mode_off() {
      this.tv.$set(this.data, 'drawingMode', false);
      this.tv.$set(this.data, 'tool', 'Cursor');
    } // Place a new tool

  }, {
    key: "build_tool",
    value: function build_tool(grid_id, type) {
      var list = this.data.tools;
      type = type || this.data.tool;
      var proto = list.find(function (x) {
        return x.type === type;
      });
      if (!proto) return;
      var sett = Object.assign({}, proto.settings || {});
      var data = (proto.data || []).slice();
      if (!('legend' in sett)) sett.legend = false;
      if (!('z-index' in sett)) sett['z-index'] = 100;
      sett.$selected = true;
      sett.$state = 'wip';
      var side = grid_id ? 'offchart' : 'onchart';
      var id = this.add(side, {
        name: proto.name,
        type: type.split(':')[0],
        settings: sett,
        data: data,
        grid: {
          id: grid_id
        }
      });
      sett.$uuid = "".concat(id, "-").concat(utils.now());
      this.tv.$set(this.data, 'selected', sett.$uuid);
      this.add_trash_icon();
    } // Remove selected / Remove all, etc

  }, {
    key: "system_tool",
    value: function system_tool(type) {
      switch (type) {
        case 'Remove':
          if (this.data.selected) {
            this.del(this.data.selected);
            this.remove_trash_icon();
            this.drawing_mode_off();
            this.on_scroll_lock(false);
          }

          break;
      }
    } // Apply new overlay settings

  }, {
    key: "change_settings",
    value: function change_settings(args) {
      var settings = args[0];
      delete settings.id;
      var grid_id = args[1];
      this.merge("".concat(args[3], ".settings"), settings);
    } // Lock the scrolling mechanism

  }, {
    key: "on_scroll_lock",
    value: function on_scroll_lock(flag) {
      this.tv.$set(this.data, 'scrollLock', flag);
    } // When new object is selected / unselected

  }, {
    key: "object_selected",
    value: function object_selected(args) {
      var q = this.data.selected;

      if (q) {
        // Check if current drawing is finished
        //let res = this.get_one(`${q}.settings`)
        //if (res && res.$state !== 'finished') return
        this.merge("".concat(q, ".settings"), {
          $selected: false
        });
        this.remove_trash_icon();
      }

      this.tv.$set(this.data, 'selected', null);
      if (!args.length) return;
      this.tv.$set(this.data, 'selected', args[2]);
      this.merge("".concat(args[2], ".settings"), {
        $selected: true
      });
      this.add_trash_icon();
    }
  }, {
    key: "add_trash_icon",
    value: function add_trash_icon() {
      var type = 'System:Remove';

      if (this.data.tools.find(function (x) {
        return x.type === type;
      })) {
        return;
      }

      this.data.tools.push({
        type: type,
        icon: icons_namespaceObject["trash.png"]
      });
    }
  }, {
    key: "remove_trash_icon",
    value: function remove_trash_icon() {
      // TODO: Does not call Toolbar render (distr version)
      var type = 'System:Remove';
      utils.overwrite(this.data.tools, this.data.tools.filter(function (x) {
        return x.type !== type;
      }));
    } // Set overlay data from the web-worker

  }, {
    key: "on_overlay_data",
    value: function on_overlay_data(data) {
      var _this4 = this;

      this.get('.').forEach(function (x) {
        if (x.settings.$synth) _this4.del("".concat(x.id));
      });

      var _iterator6 = dc_events_createForOfIteratorHelper(data),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var ov = _step6.value;
          var obj = this.get_one("".concat(ov.id));

          if (obj) {
            this.tv.$set(obj, 'loading', false);
            if (!ov.data) continue;
            obj.data = ov.data;
          }

          if (!ov.new_ovs) continue;

          for (var id in ov.new_ovs.onchart) {
            if (!this.get_one("onchart.".concat(id))) {
              this.add('onchart', ov.new_ovs.onchart[id]);
            }
          }

          for (var id in ov.new_ovs.offchart) {
            if (!this.get_one("offchart.".concat(id))) {
              this.add('offchart', ov.new_ovs.offchart[id]);
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    } // Push overlay updates from the web-worker

  }, {
    key: "on_overlay_update",
    value: function on_overlay_update(data) {
      var _iterator7 = dc_events_createForOfIteratorHelper(data),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var ov = _step7.value;
          if (!ov.data) continue;
          var obj = this.get_one("".concat(ov.id));

          if (obj) {
            this.fast_merge(obj.data, ov.data, false);
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    } // Clean-up unfinished business (tools)

  }, {
    key: "before_destroy",
    value: function before_destroy() {
      var f = function f(x) {
        return !x.settings.$state || x.settings.$state === 'finished';
      };

      this.data.onchart = this.data.onchart.filter(f);
      this.data.offchart = this.data.offchart.filter(f);
      this.drawing_mode_off();
      this.on_scroll_lock(false);
      this.object_selected([]);
      this.ww.destroy();
    } // Get overlay by grid-layer id

  }, {
    key: "get_overlay",
    value: function get_overlay(obj) {
      var id = obj.id || "g".concat(obj.grid_id, "_").concat(obj.layer_id);
      var dcid = obj.uuid || this.gldc[id];
      return this.get_one("".concat(dcid));
    }
  }]);

  return DCEvents;
}();


;// CONCATENATED MODULE: ./src/helpers/dc_core.js









function dc_core_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dc_core_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dc_core_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dc_core_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dc_core_arrayLikeToArray(o, minLen); }

function dc_core_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function dc_core_createSuper(Derived) { var hasNativeReflectConstruct = dc_core_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function dc_core_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// DataCube "private" methods




var DCCore = /*#__PURE__*/function (_DCEvents) {
  _inherits(DCCore, _DCEvents);

  var _super = dc_core_createSuper(DCCore);

  function DCCore() {
    classCallCheck_classCallCheck(this, DCCore);

    return _super.apply(this, arguments);
  }

  createClass_createClass(DCCore, [{
    key: "init_tvjs",
    value: // Set TV instance (once). Called by TradingVue itself
    function init_tvjs($root) {
      var _this = this;

      if (!this.tv) {
        this.tv = $root;
        this.init_data();
        this.update_ids(); // Listen to all setting changes
        // TODO: works only with merge()

        this.tv.$watch(function () {
          return _this.get_by_query('.settings');
        }, function (n, p) {
          return _this.on_settings(n, p);
        }); // Listen to all indices changes

        this.tv.$watch(function () {
          return _this.get('.').map(function (x) {
            return x.settings.$uuid;
          });
        }, function (n, p) {
          return _this.on_ids_changed(n, p);
        }); // Watch for all 'datasets' changes

        this.tv.$watch(function () {
          return _this.get('datasets');
        }, Dataset.watcher.bind(this));
      }
    } // Init Data Structure v1.1

  }, {
    key: "init_data",
    value: function init_data($root) {
      if (!('chart' in this.data)) {
        this.tv.$set(this.data, 'chart', {
          type: 'Candles',
          data: this.data.ohlcv || []
        });
      }

      if (!('onchart' in this.data)) {
        this.tv.$set(this.data, 'onchart', []);
      }

      if (!('offchart' in this.data)) {
        this.tv.$set(this.data, 'offchart', []);
      }

      if (!this.data.chart.settings) {
        this.tv.$set(this.data.chart, 'settings', {});
      } // Remove ohlcv cuz we have Data v1.1^


      delete this.data.ohlcv;

      if (!('datasets' in this.data)) {
        this.tv.$set(this.data, 'datasets', []);
      } // Init dataset proxies


      var _iterator = dc_core_createForOfIteratorHelper(this.data.datasets),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ds = _step.value;
          if (!this.dss) this.dss = {};
          this.dss[ds.id] = new Dataset(this, ds);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } // Range change callback (called by TradingVue)
    // TODO: improve (reliablity + chunk with limited size)

  }, {
    key: "range_changed",
    value: function () {
      var _range_changed = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee(range, tf, check) {
        var _this2 = this;

        var first, prom;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (check === void 0) {
                  check = false;
                }

                if (this.loader) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                if (this.loading) {
                  _context.next = 19;
                  break;
                }

                first = this.data.chart.data[0][0];

                if (!(range[0] < first)) {
                  _context.next = 19;
                  break;
                }

                this.loading = true;
                _context.next = 9;
                return utils.pause(250);

              case 9:
                // Load bigger chunks
                range = range.slice(); // copy

                range[0] = Math.floor(range[0]);
                range[1] = Math.floor(first);
                prom = this.loader(range, tf, function (d) {
                  // Callback way
                  _this2.chunk_loaded(d);
                });

                if (!(prom && prom.then)) {
                  _context.next = 19;
                  break;
                }

                _context.t0 = this;
                _context.next = 17;
                return prom;

              case 17:
                _context.t1 = _context.sent;

                _context.t0.chunk_loaded.call(_context.t0, _context.t1);

              case 19:
                if (!check) this.last_chunk = [range, tf];

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function range_changed(_x, _x2, _x3) {
        return _range_changed.apply(this, arguments);
      }

      return range_changed;
    }() // A new chunk of data is loaded
    // TODO: bulletproof fetch

  }, {
    key: "chunk_loaded",
    value: function chunk_loaded(data) {
      // Updates only candlestick data, or
      if (Array.isArray(data)) {
        this.merge('chart.data', data);
      } else {
        // Bunch of overlays, including chart.data
        for (var k in data) {
          this.merge(k, data[k]);
        }
      }

      this.loading = false;

      if (this.last_chunk) {
        this.range_changed.apply(this, _toConsumableArray(this.last_chunk).concat([true]));
        this.last_chunk = null;
      }
    } // Update ids for all overlays

  }, {
    key: "update_ids",
    value: function update_ids() {
      this.data.chart.id = "chart.".concat(this.data.chart.type);
      var count = {}; // grid_id,layer_id => DC id mapping

      this.gldc = {}, this.dcgl = {};

      var _iterator2 = dc_core_createForOfIteratorHelper(this.data.onchart),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ov = _step2.value;

          if (count[ov.type] === undefined) {
            count[ov.type] = 0;
          }

          var i = count[ov.type]++;
          ov.id = "onchart.".concat(ov.type).concat(i);
          if (!ov.name) ov.name = ov.type + " ".concat(i);
          if (!ov.settings) this.tv.$set(ov, 'settings', {}); // grid_id,layer_id => DC id mapping

          this.gldc["g0_".concat(ov.type, "_").concat(i)] = ov.id;
          this.dcgl[ov.id] = "g0_".concat(ov.type, "_").concat(i);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      count = {};
      var grids = [{}];
      var gid = 0;

      var _iterator3 = dc_core_createForOfIteratorHelper(this.data.offchart),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var ov = _step3.value;

          if (count[ov.type] === undefined) {
            count[ov.type] = 0;
          }

          var _i = count[ov.type]++;

          ov.id = "offchart.".concat(ov.type).concat(_i);
          if (!ov.name) ov.name = ov.type + " ".concat(_i);
          if (!ov.settings) this.tv.$set(ov, 'settings', {}); // grid_id,layer_id => DC id mapping

          gid++;
          var rgid = (ov.grid || {}).id || gid; // real grid_id
          // When we merge grid, skip ++

          if ((ov.grid || {}).id) gid--;
          if (!grids[rgid]) grids[rgid] = {};

          if (grids[rgid][ov.type] === undefined) {
            grids[rgid][ov.type] = 0;
          }

          var ri = grids[rgid][ov.type]++;
          this.gldc["g".concat(rgid, "_").concat(ov.type, "_").concat(ri)] = ov.id;
          this.dcgl[ov.id] = "g".concat(rgid, "_").concat(ov.type, "_").concat(ri);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    } // TODO: chart refine (from the exchange chart)

  }, {
    key: "update_candle",
    value: function update_candle(data) {
      var ohlcv = this.data.chart.data;
      var last = ohlcv[ohlcv.length - 1];
      var candle = data['candle'];
      var tf = this.tv.$refs.chart.interval_ms;
      var t_next = last[0] + tf;
      var now = data.t || utils.now();
      var t = now >= t_next ? now - now % tf : last[0]; // Update the entire candle

      if (candle.length >= 6) {
        t = candle[0];
      } else {
        candle = [t].concat(_toConsumableArray(candle));
      }

      this.agg.push('ohlcv', candle);
      this.update_overlays(data, t, tf);
      return t >= t_next;
    }
  }, {
    key: "update_tick",
    value: function update_tick(data) {
      var ohlcv = this.data.chart.data;
      var last = ohlcv[ohlcv.length - 1];
      var tick = data['price'];
      var volume = data['volume'] || 0;
      var tf = this.tv.$refs.chart.interval_ms;

      if (!tf) {
        return console.warn('Define the main timeframe');
      }

      var now = data.t || utils.now();
      if (!last) last = [now - now % tf];
      var t_next = last[0] + tf;
      var t = now >= t_next ? now - now % tf : last[0];

      if ((t >= t_next || !ohlcv.length) && tick !== undefined) {
        // And new zero-height candle
        var nc = [t, tick, tick, tick, tick, volume];
        this.agg.push('ohlcv', nc, tf);
        ohlcv.push(nc);
        this.scroll_to(t);
      } else if (tick !== undefined) {
        // Update an existing one
        // TODO: make a separate class Sampler
        last[2] = Math.max(tick, last[2]);
        last[3] = Math.min(tick, last[3]);
        last[4] = tick;
        last[5] += volume;
        this.agg.push('ohlcv', last, tf);
      }

      this.update_overlays(data, t, tf);
      return t >= t_next;
    } // Updates all overlays with given values.

  }, {
    key: "update_overlays",
    value: function update_overlays(data, t, tf) {
      for (var k in data) {
        if (k === 'price' || k === 'volume' || k === 'candle' || k === 't') {
          continue;
        }

        if (k.includes('datasets.')) {
          this.agg.push(k, data[k], tf);
          continue;
        }

        if (!Array.isArray(data[k])) {
          var val = [data[k]];
        } else {
          val = data[k];
        }

        if (!k.includes('.data')) k += '.data';
        this.agg.push(k, [t].concat(_toConsumableArray(val)), tf);
      }
    } // Returns array of objects matching query.
    // Object contains { parent, index, value }
    // TODO: query caching

  }, {
    key: "get_by_query",
    value: function get_by_query(query, chuck) {
      var tuple = query.split('.');

      switch (tuple[0]) {
        case 'chart':
          var result = this.chart_as_piv(tuple);
          break;

        case 'onchart':
        case 'offchart':
          result = this.query_search(query, tuple);
          break;

        case 'datasets':
          result = this.query_search(query, tuple);

          var _iterator4 = dc_core_createForOfIteratorHelper(result),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var r = _step4.value;

              if (r.i === 'data') {
                r.v = this.dss[r.p.id].data();
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          break;

        default:
          /* Should get('.') return also the chart? */

          /*let ch = this.chart_as_query([
              'chart',
              tuple[1]
          ])*/
          var on = this.query_search(query, ['onchart', tuple[0], tuple[1]]);
          var off = this.query_search(query, ['offchart', tuple[0], tuple[1]]);
          result = [].concat(_toConsumableArray(on), _toConsumableArray(off));
          break;
      }

      return result.filter(function (x) {
        return !(x.v || {}).locked || chuck;
      });
    }
  }, {
    key: "chart_as_piv",
    value: function chart_as_piv(tuple) {
      var field = tuple[1];
      if (field) return [{
        p: this.data.chart,
        i: field,
        v: this.data.chart[field]
      }];else return [{
        p: this.data,
        i: 'chart',
        v: this.data.chart
      }];
    }
  }, {
    key: "query_search",
    value: function query_search(query, tuple) {
      var _this3 = this;

      var side = tuple[0];
      var path = tuple[1] || '';
      var field = tuple[2];
      var arr = this.data[side].filter(function (x) {
        return x.id === query || x.id && x.id.includes(path) || x.name === query || x.name && x.name.includes(path) || query.includes((x.settings || {}).$uuid);
      });

      if (field) {
        return arr.map(function (x) {
          return {
            p: x,
            i: field,
            v: x[field]
          };
        });
      }

      return arr.map(function (x, i) {
        return {
          p: _this3.data[side],
          i: _this3.data[side].indexOf(x),
          v: x
        };
      });
    }
  }, {
    key: "merge_objects",
    value: function merge_objects(obj, data, new_obj) {
      if (new_obj === void 0) {
        new_obj = {};
      }

      // The only way to get Vue to update all stuff
      // reactively is to create a brand new object.
      // TODO: Is there a simpler approach?
      Object.assign(new_obj, obj.v);
      Object.assign(new_obj, data);
      this.tv.$set(obj.p, obj.i, new_obj);
    } // Merge overlapping time series

  }, {
    key: "merge_ts",
    value: function merge_ts(obj, data) {
      // Assume that both arrays are pre-sorted
      if (!data.length) return obj.v;
      var r1 = [obj.v[0][0], obj.v[obj.v.length - 1][0]];
      var r2 = [data[0][0], data[data.length - 1][0]]; // Overlap

      var o = [Math.max(r1[0], r2[0]), Math.min(r1[1], r2[1])];

      if (o[1] >= o[0]) {
        var _obj$v, _data;

        var _this$ts_overlap = this.ts_overlap(obj.v, data, o),
            od = _this$ts_overlap.od,
            d1 = _this$ts_overlap.d1,
            d2 = _this$ts_overlap.d2;

        (_obj$v = obj.v).splice.apply(_obj$v, _toConsumableArray(d1));

        (_data = data).splice.apply(_data, _toConsumableArray(d2)); // Dst === Overlap === Src


        if (!obj.v.length && !data.length) {
          this.tv.$set(obj.p, obj.i, od);
          return obj.v;
        } // If src is totally contained in dst


        if (!data.length) {
          data = obj.v.splice(d1[0]);
        } // If dst is totally contained in src


        if (!obj.v.length) {
          obj.v = data.splice(d2[0]);
        }

        this.tv.$set(obj.p, obj.i, this.combine(obj.v, od, data));
      } else {
        this.tv.$set(obj.p, obj.i, this.combine(obj.v, [], data));
      }

      return obj.v;
    } // TODO: review performance, move to worker

  }, {
    key: "ts_overlap",
    value: function ts_overlap(arr1, arr2, range) {
      var t1 = range[0];
      var t2 = range[1];
      var ts = {}; // timestamp map

      var a1 = arr1.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      });
      var a2 = arr2.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }); // Indices of segments

      var id11 = arr1.indexOf(a1[0]);
      var id12 = arr1.indexOf(a1[a1.length - 1]);
      var id21 = arr2.indexOf(a2[0]);
      var id22 = arr2.indexOf(a2[a2.length - 1]);

      for (var i = 0; i < a1.length; i++) {
        ts[a1[i][0]] = a1[i];
      }

      for (var i = 0; i < a2.length; i++) {
        ts[a2[i][0]] = a2[i];
      }

      var ts_sorted = Object.keys(ts).sort();
      return {
        od: ts_sorted.map(function (x) {
          return ts[x];
        }),
        d1: [id11, id12 - id11 + 1],
        d2: [id21, id22 - id21 + 1]
      };
    } // Combine parts together:
    // (destination, overlap, source)

  }, {
    key: "combine",
    value: function combine(dst, o, src) {
      function last(arr) {
        return arr[arr.length - 1][0];
      }

      if (!dst.length) {
        dst = o;
        o = [];
      }

      if (!src.length) {
        src = o;
        o = [];
      } // The overlap right in the middle


      if (src[0][0] >= dst[0][0] && last(src) <= last(dst)) {
        return Object.assign(dst, o); // The overlap is on the right
      } else if (last(src) > last(dst)) {
        // Psh(...) is faster but can overflow the stack
        if (o.length < 100000 && src.length < 100000) {
          var _dst;

          (_dst = dst).push.apply(_dst, _toConsumableArray(o).concat(_toConsumableArray(src)));

          return dst;
        } else {
          return dst.concat(o, src);
        } // The overlap is on the left

      } else if (src[0][0] < dst[0][0]) {
        // Push(...) is faster but can overflow the stack
        if (o.length < 100000 && src.length < 100000) {
          var _src;

          (_src = src).push.apply(_src, _toConsumableArray(o).concat(_toConsumableArray(dst)));

          return src;
        } else {
          return src.concat(o, dst);
        }
      } else {
        return [];
      }
    } // Simple data-point merge (faster)

  }, {
    key: "fast_merge",
    value: function fast_merge(data, point, main) {
      if (main === void 0) {
        main = true;
      }

      if (!data) return;
      var last_t = (data[data.length - 1] || [])[0];
      var upd_t = point[0];

      if (!data.length || upd_t > last_t) {
        data.push(point);

        if (main && this.sett.auto_scroll) {
          this.scroll_to(upd_t);
        }
      } else if (upd_t === last_t) {
        if (main) {
          this.tv.$set(data, data.length - 1, point);
        } else {
          data[data.length - 1] = point;
        }
      }
    }
  }, {
    key: "scroll_to",
    value: function scroll_to(t) {
      if (this.tv.$refs.chart.cursor.locked) return;
      var last = this.tv.$refs.chart.last_candle;
      if (!last) return;
      var tl = last[0];
      var d = this.tv.getRange()[1] - tl;
      if (d > 0) this.tv["goto"](t + d);
    }
  }]);

  return DCCore;
}(DCEvents);


;// CONCATENATED MODULE: ./src/helpers/sett_proxy.js
// Sends all dc.sett changes to the web-worker
/* harmony default export */ function sett_proxy(sett, ww) {
  var h = {
    get: function get(sett, k) {
      return sett[k];
    },
    set: function set(sett, k, v) {
      sett[k] = v;
      ww.just('update-dc-settings', sett);
      return true;
    }
  };
  ww.just('update-dc-settings', sett);
  return new Proxy(sett, h);
}
;// CONCATENATED MODULE: ./src/helpers/agg_tool.js


// Tick aggregation


var AggTool = /*#__PURE__*/function () {
  function AggTool(dc, _int) {
    if (_int === void 0) {
      _int = 100;
    }

    classCallCheck_classCallCheck(this, AggTool);

    this.symbols = {};
    this["int"] = _int; // Itarval in ms

    this.dc = dc;
    this.st_id = null;
    this.data_changed = false;
  }

  createClass_createClass(AggTool, [{
    key: "push",
    value: function push(sym, upd, tf) {
      var _this = this;

      // Start auto updates
      if (!this.st_id) {
        this.st_id = setTimeout(function () {
          return _this.update();
        });
      }

      tf = parseInt(tf);
      var old = this.symbols[sym];
      var t = utils.now();
      var isds = sym.includes('datasets.');
      this.data_changed = true;

      if (!old) {
        this.symbols[sym] = {
          upd: upd,
          t: t,
          data: []
        };
      } else if (upd[0] >= old.upd[0] + tf && !isds) {
        // Refine the previous data point
        this.refine(sym, old.upd.slice());
        this.symbols[sym] = {
          upd: upd,
          t: t,
          data: []
        };
      } else {
        // Tick updates the current
        this.symbols[sym].upd = upd;
        this.symbols[sym].t = t;
      }

      if (isds) {
        this.symbols[sym].data.push(upd);
      }
    }
  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      var out = {};

      for (var sym in this.symbols) {
        var upd = this.symbols[sym].upd;

        switch (sym) {
          case 'ohlcv':
            var data = this.dc.data.chart.data;
            this.dc.fast_merge(data, upd);
            out.ohlcv = data.slice(-2);
            break;

          default:
            if (sym.includes('datasets.')) {
              this.update_ds(sym, out);
              continue;
            }

            var data = this.dc.get_one("".concat(sym));
            if (!data) continue;
            this.dc.fast_merge(data, upd, false);
            break;
        }
      } // TODO: fill gaps


      if (this.data_changed) {
        this.dc.ww.just('update-data', out);
        this.data_changed = false;
      }

      setTimeout(function () {
        return _this2.update();
      }, this["int"]);
    }
  }, {
    key: "refine",
    value: function refine(sym, upd) {
      if (sym === 'ohlcv') {
        var data = this.dc.data.chart.data;
        this.dc.fast_merge(data, upd);
      } else {
        var data = this.dc.get_one("".concat(sym));
        if (!data) return;
        this.dc.fast_merge(data, upd, false);
      }
    }
  }, {
    key: "update_ds",
    value: function update_ds(sym, out) {
      var data = this.symbols[sym].data;

      if (data.length) {
        out[sym] = data;
        this.symbols[sym].data = [];
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.symbols = {};
    }
  }]);

  return AggTool;
}();


;// CONCATENATED MODULE: ./src/helpers/datacube.js








function datacube_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = datacube_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function datacube_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return datacube_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return datacube_arrayLikeToArray(o, minLen); }

function datacube_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function datacube_createSuper(Derived) { var hasNativeReflectConstruct = datacube_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function datacube_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Main DataHelper class. A container for data,
// which works as a proxy and CRUD interface



 // Interface methods. Private methods in dc_core.js

var DataCube = /*#__PURE__*/function (_DCCore) {
  _inherits(DataCube, _DCCore);

  var _super = datacube_createSuper(DataCube);

  function DataCube(data, sett) {
    var _this;

    if (data === void 0) {
      data = {};
    }

    if (sett === void 0) {
      sett = {};
    }

    classCallCheck_classCallCheck(this, DataCube);

    var def_sett = {
      aggregation: 100,
      // Update aggregation interval
      script_depth: 0,
      // 0 === Exec on all data
      auto_scroll: true,
      // Auto scroll to a new candle
      scripts: true,
      // Enable overlays scripts,
      ww_ram_limit: 0,
      // WebWorker RAM limit (MB)
      node_url: null,
      // Use node.js instead of WW
      shift_measure: true // Draw measurment shift+click

    };
    sett = Object.assign(def_sett, sett);
    _this = _super.call(this);
    _this.sett = sett;
    _this.data = data;
    _this.sett = sett_proxy(sett, _this.ww);
    _this.agg = new AggTool(_assertThisInitialized(_this), sett.aggregation);
    _this.se_state = {}; //this.agg.update = this.agg_update.bind(this)

    return _this;
  } // Add new overlay


  createClass_createClass(DataCube, [{
    key: "add",
    value: function add(side, overlay) {
      if (side !== 'onchart' && side !== 'offchart' && side !== 'datasets') {
        return;
      }

      this.data[side].push(overlay);
      this.update_ids();
      return overlay.id;
    } // Get all objects matching the query

  }, {
    key: "get",
    value: function get(query) {
      return this.get_by_query(query).map(function (x) {
        return x.v;
      });
    } // Get first object matching the query

  }, {
    key: "get_one",
    value: function get_one(query) {
      return this.get_by_query(query).map(function (x) {
        return x.v;
      })[0];
    } // Set data (reactively)

  }, {
    key: "set",
    value: function set(query, data) {
      var objects = this.get_by_query(query);

      var _iterator = datacube_createForOfIteratorHelper(objects),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var obj = _step.value;
          var i = obj.i !== undefined ? obj.i : obj.p.indexOf(obj.v);

          if (i !== -1) {
            this.tv.$set(obj.p, i, data);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.update_ids();
    } // Merge object or array (reactively)

  }, {
    key: "merge",
    value: function merge(query, data) {
      var objects = this.get_by_query(query);

      var _iterator2 = datacube_createForOfIteratorHelper(objects),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var obj = _step2.value;

          if (Array.isArray(obj.v)) {
            if (!Array.isArray(data)) continue; // If array is a timeseries, merge it by timestamp
            // else merge by item index

            if (obj.v[0] && obj.v[0].length >= 2) {
              this.merge_ts(obj, data);
            } else {
              this.merge_objects(obj, data, []);
            }
          } else if (typeof_typeof(obj.v) === 'object') {
            this.merge_objects(obj, data);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.update_ids();
    } // Remove an overlay by query (id/type/name/...)

  }, {
    key: "del",
    value: function del(query) {
      var objects = this.get_by_query(query);

      var _iterator3 = datacube_createForOfIteratorHelper(objects),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var obj = _step3.value;
          // Find current index of the field (if not defined)
          var i = typeof obj.i !== 'number' ? obj.i : obj.p.indexOf(obj.v);

          if (i !== -1) {
            this.tv.$delete(obj.p, i);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.update_ids();
    } // Update/append data point, depending on timestamp

  }, {
    key: "update",
    value: function update(data) {
      if (data['candle']) {
        return this.update_candle(data);
      } else {
        return this.update_tick(data);
      }
    } // Lock overlays from being pulled by query_search
    // TODO: subject to review

  }, {
    key: "lock",
    value: function lock(query) {
      var objects = this.get_by_query(query);
      objects.forEach(function (x) {
        if (x.v && x.v.id && x.v.type) {
          x.v.locked = true;
        }
      });
    } // Unlock overlays from being pulled by query_search
    //

  }, {
    key: "unlock",
    value: function unlock(query) {
      var objects = this.get_by_query(query, true);
      objects.forEach(function (x) {
        if (x.v && x.v.id && x.v.type) {
          x.v.locked = false;
        }
      });
    } // Show indicator

  }, {
    key: "show",
    value: function show(query) {
      if (query === 'offchart' || query === 'onchart') {
        query += '.';
      } else if (query === '.') {
        query = '';
      }

      this.merge(query + '.settings', {
        display: true
      });
    } // Hide indicator

  }, {
    key: "hide",
    value: function hide(query) {
      if (query === 'offchart' || query === 'onchart') {
        query += '.';
      } else if (query === '.') {
        query = '';
      }

      this.merge(query + '.settings', {
        display: false
      });
    } // Set data loader callback

  }, {
    key: "onrange",
    value: function onrange(callback) {
      var _this2 = this;

      this.loader = callback;
      setTimeout(function () {
        return _this2.tv.set_loader(callback ? _this2 : null);
      }, 0);
    }
  }]);

  return DataCube;
}(DCCore);


;// CONCATENATED MODULE: ./src/mixins/interface.js
// Html interface, shown on top of the grid.
// Can be static (a tooltip) or interactive,
// e.g. a control panel.
/* harmony default export */ const mixins_interface = ({
  props: ['ux', 'updater', 'colors', 'wrapper'],
  mounted: function mounted() {
    this._$emit = this.$emit;
    this.$emit = this.custom_event;
    if (this.init) this.init();
  },
  methods: {
    close: function close() {
      this.$emit('custom-event', {
        event: 'close-interface',
        args: [this.$props.ux.uuid]
      });
    },
    // TODO: emit all the way to the uxlist
    // add apply the changes there
    modify: function modify(obj) {
      this.$emit('custom-event', {
        event: 'modify-interface',
        args: [this.$props.ux.uuid, obj]
      });
    },
    custom_event: function custom_event(event) {
      if (event.split(':')[0] === 'hook') return;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this._$emit('custom-event', {
        event: event,
        args: args
      });
    }
  },
  computed: {
    overlay: function overlay() {
      return this.$props.ux.overlay;
    },
    layout: function layout() {
      return this.overlay.layout;
    },
    uxr: function uxr() {
      return this.$props.ux;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/index.js















var primitives = {
  Candle: CandleExt,
  Volbar: VolbarExt,
  Line: Line,
  Pin: Pin,
  Price: Price,
  Ray: Ray,
  Seg: Seg
};

TradingVue.install = function (Vue) {
  Vue.component(TradingVue.name, TradingVue);
};

if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(TradingVue);
  window.TradingVueLib = {
    TradingVue: TradingVue,
    Overlay: overlay,
    Utils: utils,
    Constants: constants,
    Candle: CandleExt,
    Volbar: VolbarExt,
    layout_cnv: layout_cnv,
    layout_vol: layout_vol,
    DataCube: DataCube,
    Tool: tool,
    Interface: mixins_interface,
    primitives: primitives
  };
}

/* harmony default export */ const src = (TradingVue);


/***/ }),

/***/ 418:
/***/ ((module, exports, __nested_webpack_require_449538__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_449538__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* Anit-boostrap tactix */\n.trading-vue *, ::after, ::before {\n    box-sizing: content-box;\n}\n.trading-vue img {\n    vertical-align: initial;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 976:
/***/ ((module, exports, __nested_webpack_require_450696__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_450696__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-botbar {\n    position: relative !important;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 449:
/***/ ((module, exports, __nested_webpack_require_451035__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_451035__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.t-vue-lbtn-grp {\n    margin-left: 0.5em;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 108:
/***/ ((module, exports, __nested_webpack_require_451359__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_451359__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-item-list {\n    position: absolute;\n    user-select: none;\n    margin-top: -5px;\n}\n.tvjs-item-list-item {\n    display: flex;\n    align-items: center;\n    padding-right: 20px;\n    font-size: 1.15em;\n    letter-spacing: 0.05em;\n}\n.tvjs-item-list-item:hover {\n    background-color: #76878319;\n}\n.tvjs-item-list-item * {\n    position: relative !important;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 988:
/***/ ((module, exports, __nested_webpack_require_452014__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_452014__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-legend {\n    position: relative;\n    z-index: 100;\n    font-size: 1.25em;\n    margin-left: 10px;\n    pointer-events: none;\n    text-align: left;\n    user-select: none;\n    font-weight: 300;\n}\n@media (min-resolution: 2x) {\n.trading-vue-legend {\n        font-weight: 400;\n}\n}\n.trading-vue-ohlcv {\n    pointer-events: none;\n    margin-bottom: 0.5em;\n}\n.t-vue-lspan {\n    font-variant-numeric: tabular-nums;\n    font-size: 0.95em;\n    color: #999999; /* TODO: move => params */\n    margin-left: 0.1em;\n    margin-right: 0.2em;\n}\n.t-vue-title {\n    margin-right: 0.25em;\n    font-size: 1.45em;\n}\n.t-vue-ind {\n    margin-left: 0.2em;\n    margin-bottom: 0.5em;\n    font-size: 1.0em;\n    margin-top: 0.3em;\n}\n.t-vue-ivalue {\n    margin-left: 0.5em;\n}\n.t-vue-unknown {\n    color: #999999; /* TODO: move => params */\n}\n.tvjs-appear-enter-active,\n.tvjs-appear-leave-active\n{\n    transition: all .25s ease;\n}\n.tvjs-appear-enter, .tvjs-appear-leave-to\n{\n    opacity: 0;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 423:
/***/ ((module, exports, __nested_webpack_require_453314__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_453314__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.t-vue-lbtn {\n    z-index: 100;\n    pointer-events: all;\n    cursor: pointer;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 661:
/***/ ((module, exports, __nested_webpack_require_453676__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_453676__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-section {\n    height: 0;\n    position: absolute;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 168:
/***/ ((module, exports, __nested_webpack_require_454021__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_454021__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-spinner {\n    display: inline-block;\n    position: relative;\n    width: 20px;\n    height: 16px;\n    margin: -4px 0px -1px 0px;\n    opacity: 0.7;\n}\n.tvjs-spinner div {\n    position: absolute;\n    top: 8px;\n    width: 4px;\n    height: 4px;\n    border-radius: 50%;\n    animation-timing-function: cubic-bezier(1, 1, 1, 1);\n}\n.tvjs-spinner div:nth-child(1) {\n    left: 2px;\n    animation: tvjs-spinner1 0.6s infinite;\n    opacity: 0.9;\n}\n.tvjs-spinner div:nth-child(2) {\n    left: 2px;\n    animation: tvjs-spinner2 0.6s infinite;\n}\n.tvjs-spinner div:nth-child(3) {\n    left: 9px;\n    animation: tvjs-spinner2 0.6s infinite;\n}\n.tvjs-spinner div:nth-child(4) {\n    left: 16px;\n    animation: tvjs-spinner3 0.6s infinite;\n    opacity: 0.9;\n}\n@keyframes tvjs-spinner1 {\n0% {\n        transform: scale(0);\n}\n100% {\n        transform: scale(1);\n}\n}\n@keyframes tvjs-spinner3 {\n0% {\n        transform: scale(1);\n}\n100% {\n        transform: scale(0);\n}\n}\n@keyframes tvjs-spinner2 {\n0% {\n        transform: translate(0, 0);\n}\n100% {\n        transform: translate(7px, 0);\n}\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 29:
/***/ ((module, exports, __nested_webpack_require_455420__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_455420__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-drift-enter-active {\n    transition: all .3s ease;\n}\n.tvjs-drift-leave-active {\n    transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.tvjs-drift-enter, .tvjs-drift-leave-to\n{\n    transform: translateX(10px);\n    opacity: 0;\n}\n.tvjs-the-tip {\n    position: absolute;\n    width: 200px;\n    text-align: center;\n    z-index: 10001;\n    color: #ffffff;\n    font-size: 1.5em;\n    line-height: 1.15em;\n    padding: 10px;\n    border-radius: 3px;\n    right: 70px;\n    top: 10px;\n    text-shadow: 1px 1px black;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 935:
/***/ ((module, exports, __nested_webpack_require_456239__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_456239__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-toolbar {\n    position: absolute;\n    border-right: 1px solid black;\n    z-index: 101;\n    padding-top: 3px;\n    user-select: none;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 379:
/***/ ((module, exports, __nested_webpack_require_456670__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_456670__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-tbitem {\n}\n.trading-vue-tbitem:hover {\n    background-color: #76878319;\n}\n.trading-vue-tbitem-exp {\n    position: absolute;\n    right: -3px;\n    padding: 18.5px 5px;\n    font-stretch: extra-condensed;\n    transform: scaleX(0.6);\n    font-size: 0.6em;\n    opacity: 0.0;\n    user-select: none;\n    line-height: 0;\n}\n.trading-vue-tbitem:hover\n.trading-vue-tbitem-exp {\n    opacity: 0.5;\n}\n.trading-vue-tbitem-exp:hover {\n    background-color: #76878330;\n    opacity: 0.9 !important;\n}\n.trading-vue-tbicon {\n    position: absolute;\n}\n.trading-vue-tbitem.selected-item > .trading-vue-tbicon,\n.tvjs-item-list-item.selected-item > .trading-vue-tbicon {\n     filter: brightness(1.45) sepia(1) hue-rotate(90deg) saturate(4.5) !important;\n}\n.tvjs-pixelated {\n    -ms-interpolation-mode: nearest-neighbor;\n    image-rendering: -webkit-optimize-contrast;\n    image-rendering: -webkit-crisp-edges;\n    image-rendering: -moz-crisp-edges;\n    image-rendering: -o-crisp-edges;\n    image-rendering: pixelated;\n}\n\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 72:
/***/ ((module, exports, __nested_webpack_require_457995__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_457995__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-ux-wrapper {\n    position: absolute;\n    display: flex;\n}\n.tvjs-ux-wrapper-pin {\n    position: absolute;\n    width: 9px;\n    height: 9px;\n    z-index: 100;\n    background-color: #23a776;\n    border-radius: 10px;\n    margin-left: -6px;\n    margin-top: -6px;\n    pointer-events: none;\n}\n.tvjs-ux-wrapper-head {\n    position: absolute;\n    height: 23px;\n    width: 100%;\n}\n.tvjs-ux-wrapper-close {\n    position: absolute;\n    width: 11px;\n    height: 11px;\n    font-size: 1.5em;\n    line-height: 0.5em;\n    padding: 1px 1px 1px 1px;\n    border-radius: 10px;\n    right: 5px;\n    top: 5px;\n    user-select: none;\n    text-align: center;\n    z-index: 100;\n}\n.tvjs-ux-wrapper-close-hb {\n}\n.tvjs-ux-wrapper-close:hover {\n    background-color: #FF605C !important;\n    color: #692324 !important;\n}\n.tvjs-ux-wrapper-full {\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 983:
/***/ ((module, exports, __nested_webpack_require_459141__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_459141__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-widgets {\n    position: absolute;\n    z-index: 1000;\n    pointer-events: none;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 645:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ 840:
/***/ ((module, exports, __nested_webpack_require_462074__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Hammer;
    }).call(exports, __nested_webpack_require_462074__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

})(window, document, 'Hammer');


/***/ }),

/***/ 981:
/***/ ((module) => {

/*
 * Hamster.js v1.1.2
 * (c) 2013 Monospaced http://monospaced.com
 * License: MIT
 */

(function(window, document){
'use strict';

/**
 * Hamster
 * use this to create instances
 * @returns {Hamster.Instance}
 * @constructor
 */
var Hamster = function(element) {
  return new Hamster.Instance(element);
};

// default event name
Hamster.SUPPORT = 'wheel';

// default DOM methods
Hamster.ADD_EVENT = 'addEventListener';
Hamster.REMOVE_EVENT = 'removeEventListener';
Hamster.PREFIX = '';

// until browser inconsistencies have been fixed...
Hamster.READY = false;

Hamster.Instance = function(element){
  if (!Hamster.READY) {
    // fix browser inconsistencies
    Hamster.normalise.browser();

    // Hamster is ready...!
    Hamster.READY = true;
  }

  this.element = element;

  // store attached event handlers
  this.handlers = [];

  // return instance
  return this;
};

/**
 * create new hamster instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @returns {Hamster.Instance}
 * @constructor
 */
Hamster.Instance.prototype = {
  /**
   * bind events to the instance
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   * @returns {Hamster.Instance}
   */
  wheel: function onEvent(handler, useCapture){
    Hamster.event.add(this, Hamster.SUPPORT, handler, useCapture);

    // handle MozMousePixelScroll in older Firefox
    if (Hamster.SUPPORT === 'DOMMouseScroll') {
      Hamster.event.add(this, 'MozMousePixelScroll', handler, useCapture);
    }

    return this;
  },

  /**
   * unbind events to the instance
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   * @returns {Hamster.Instance}
   */
  unwheel: function offEvent(handler, useCapture){
    // if no handler argument,
    // unbind the last bound handler (if exists)
    if (handler === undefined && (handler = this.handlers.slice(-1)[0])) {
      handler = handler.original;
    }

    Hamster.event.remove(this, Hamster.SUPPORT, handler, useCapture);

    // handle MozMousePixelScroll in older Firefox
    if (Hamster.SUPPORT === 'DOMMouseScroll') {
      Hamster.event.remove(this, 'MozMousePixelScroll', handler, useCapture);
    }

    return this;
  }
};

Hamster.event = {
  /**
   * cross-browser 'addWheelListener'
   * @param   {Instance}    hamster
   * @param   {String}      eventName
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   */
  add: function add(hamster, eventName, handler, useCapture){
    // store the original handler
    var originalHandler = handler;

    // redefine the handler
    handler = function(originalEvent){

      if (!originalEvent) {
        originalEvent = window.event;
      }

      // create a normalised event object,
      // and normalise "deltas" of the mouse wheel
      var event = Hamster.normalise.event(originalEvent),
          delta = Hamster.normalise.delta(originalEvent);

      // fire the original handler with normalised arguments
      return originalHandler(event, delta[0], delta[1], delta[2]);

    };

    // cross-browser addEventListener
    hamster.element[Hamster.ADD_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);

    // store original and normalised handlers on the instance
    hamster.handlers.push({
      original: originalHandler,
      normalised: handler
    });
  },

  /**
   * removeWheelListener
   * @param   {Instance}    hamster
   * @param   {String}      eventName
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   */
  remove: function remove(hamster, eventName, handler, useCapture){
    // find the normalised handler on the instance
    var originalHandler = handler,
        lookup = {},
        handlers;
    for (var i = 0, len = hamster.handlers.length; i < len; ++i) {
      lookup[hamster.handlers[i].original] = hamster.handlers[i];
    }
    handlers = lookup[originalHandler];
    handler = handlers.normalised;

    // cross-browser removeEventListener
    hamster.element[Hamster.REMOVE_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);

    // remove original and normalised handlers from the instance
    for (var h in hamster.handlers) {
      if (hamster.handlers[h] == handlers) {
        hamster.handlers.splice(h, 1);
        break;
      }
    }
  }
};

/**
 * these hold the lowest deltas,
 * used to normalise the delta values
 * @type {Number}
 */
var lowestDelta,
    lowestDeltaXY;

Hamster.normalise = {
  /**
   * fix browser inconsistencies
   */
  browser: function normaliseBrowser(){
    // detect deprecated wheel events
    if (!('onwheel' in document || document.documentMode >= 9)) {
      Hamster.SUPPORT = document.onmousewheel !== undefined ?
                        'mousewheel' : // webkit and IE < 9 support at least "mousewheel"
                        'DOMMouseScroll'; // assume remaining browsers are older Firefox
    }

    // detect deprecated event model
    if (!window.addEventListener) {
      // assume IE < 9
      Hamster.ADD_EVENT = 'attachEvent';
      Hamster.REMOVE_EVENT = 'detachEvent';
      Hamster.PREFIX = 'on';
    }

  },

  /**
   * create a normalised event object
   * @param   {Function}    originalEvent
   * @returns {Object}      event
   */
   event: function normaliseEvent(originalEvent){
    var event = {
          // keep a reference to the original event object
          originalEvent: originalEvent,
          target: originalEvent.target || originalEvent.srcElement,
          type: 'wheel',
          deltaMode: originalEvent.type === 'MozMousePixelScroll' ? 0 : 1,
          deltaX: 0,
          deltaZ: 0,
          preventDefault: function(){
            if (originalEvent.preventDefault) {
              originalEvent.preventDefault();
            } else {
              originalEvent.returnValue = false;
            }
          },
          stopPropagation: function(){
            if (originalEvent.stopPropagation) {
              originalEvent.stopPropagation();
            } else {
              originalEvent.cancelBubble = false;
            }
          }
        };

    // calculate deltaY (and deltaX) according to the event

    // 'mousewheel'
    if (originalEvent.wheelDelta) {
      event.deltaY = - 1/40 * originalEvent.wheelDelta;
    }
    // webkit
    if (originalEvent.wheelDeltaX) {
      event.deltaX = - 1/40 * originalEvent.wheelDeltaX;
    }

    // 'DomMouseScroll'
    if (originalEvent.detail) {
      event.deltaY = originalEvent.detail;
    }

    return event;
  },

  /**
   * normalise 'deltas' of the mouse wheel
   * @param   {Function}    originalEvent
   * @returns {Array}       deltas
   */
  delta: function normaliseDelta(originalEvent){
    var delta = 0,
      deltaX = 0,
      deltaY = 0,
      absDelta = 0,
      absDeltaXY = 0,
      fn;

    // normalise deltas according to the event

    // 'wheel' event
    if (originalEvent.deltaY) {
      deltaY = originalEvent.deltaY * -1;
      delta  = deltaY;
    }
    if (originalEvent.deltaX) {
      deltaX = originalEvent.deltaX;
      delta  = deltaX * -1;
    }

    // 'mousewheel' event
    if (originalEvent.wheelDelta) {
      delta = originalEvent.wheelDelta;
    }
    // webkit
    if (originalEvent.wheelDeltaY) {
      deltaY = originalEvent.wheelDeltaY;
    }
    if (originalEvent.wheelDeltaX) {
      deltaX = originalEvent.wheelDeltaX * -1;
    }

    // 'DomMouseScroll' event
    if (originalEvent.detail) {
      delta = originalEvent.detail * -1;
    }

    // Don't return NaN
    if (delta === 0) {
      return [0, 0, 0];
    }

    // look for lowest delta to normalize the delta values
    absDelta = Math.abs(delta);
    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta;
    }
    absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
    if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
      lowestDeltaXY = absDeltaXY;
    }

    // convert deltas to whole numbers
    fn = delta > 0 ? 'floor' : 'ceil';
    delta  = Math[fn](delta / lowestDelta);
    deltaX = Math[fn](deltaX / lowestDeltaXY);
    deltaY = Math[fn](deltaY / lowestDeltaXY);

    return [delta, deltaX, deltaY];
  }
};

if (typeof window.define === 'function' && window.define.amd) {
  // AMD
  window.define('hamster', [], function(){
    return Hamster;
  });
} else if (true) {
  // CommonJS
  module.exports = Hamster;
} else {}

})(window, window.document);


/***/ }),

/***/ 961:
/***/ ((module, exports, __nested_webpack_require_544513__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

// private property
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  compressToBase64 : function (input) {
    if (input == null) return "";
    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
    switch (res.length % 4) { // To produce valid Base64
    default: // When could this happen ?
    case 0 : return res;
    case 1 : return res+"===";
    case 2 : return res+"==";
    case 3 : return res+"=";
    }
  },

  decompressFromBase64 : function (input) {
    if (input == null) return "";
    if (input == "") return null;
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  },

  compressToUTF16 : function (input) {
    if (input == null) return "";
    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  },

  decompressFromUTF16: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  },

  //compress into uint8array (UCS-2 big endian format)
  compressToUint8Array: function (uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      var current_value = compressed.charCodeAt(i);
      buf[i*2] = current_value >>> 8;
      buf[i*2+1] = current_value % 256;
    }
    return buf;
  },

  //decompress from uint8array (UCS-2 big endian format)
  decompressFromUint8Array:function (compressed) {
    if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
    } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

    }

  },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();

if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __nested_webpack_require_544513__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


/***/ }),

/***/ 666:
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
    true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ 863:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_585176__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_585176__(418);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_585176__(346)/* .default */ .Z
var update = add("550b47ab", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 124:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_585736__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_585736__(976);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_585736__(346)/* .default */ .Z
var update = add("1b34bfeb", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 886:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_586296__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_586296__(449);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_586296__(346)/* .default */ .Z
var update = add("9895d3a6", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 807:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_586856__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_586856__(108);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_586856__(346)/* .default */ .Z
var update = add("8139036a", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 600:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_587416__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_587416__(988);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_587416__(346)/* .default */ .Z
var update = add("1db01c0b", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 169:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_587976__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_587976__(423);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_587976__(346)/* .default */ .Z
var update = add("68f243ea", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 11:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_588535__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_588535__(661);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_588535__(346)/* .default */ .Z
var update = add("12d2309d", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 372:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_589095__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_589095__(168);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_589095__(346)/* .default */ .Z
var update = add("5b620605", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 477:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_589655__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_589655__(29);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_589655__(346)/* .default */ .Z
var update = add("143dffab", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 153:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_590214__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_590214__(935);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_590214__(346)/* .default */ .Z
var update = add("f32fd36e", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 501:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_590774__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_590774__(379);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_590774__(346)/* .default */ .Z
var update = add("604bf5ef", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 565:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_591334__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_591334__(72);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_591334__(346)/* .default */ .Z
var update = add("21fde573", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 5:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_591891__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_591891__(983);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_591891__(346)/* .default */ .Z
var update = add("fd83689e", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 346:
/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_592463__) => {

"use strict";

// EXPORTS
__nested_webpack_require_592463__.d(__webpack_exports__, {
  "Z": () => (/* binding */ addStylesClient)
});

;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}

;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_599798__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_599798__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_599798__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__nested_webpack_require_599798__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_599798__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_599798__.o(definition, key) && !__nested_webpack_require_599798__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_599798__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_599798__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module doesn't tell about it's top-level declarations so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_599798__(851);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=trading-vue.js.map

/***/ }),

/***/ "./node_modules/tvjs-overlays/dist/tvjs-overlays.js":
/*!**********************************************************!*\
  !*** ./node_modules/tvjs-overlays/dist/tvjs-overlays.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * TVJS Overlays - v0.5.0 - Fri Jul 09 2021
 *     https://github.com/tvjsx/trading-vue-js
 *     Copyright (c) 2020 c451 Code's All Right;
 *     Licensed under the MIT license
 */
(function webpackUniversalModuleDefinition(root, factory) {
    if (!root['trading-vue-js']) {
        root['trading-vue-js'] = root['TradingVueJs']
    }
	if(true)
		module.exports = factory(__webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js"));
	else {}
})(self, function(__WEBPACK_EXTERNAL_MODULE__954__) {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 954:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__954__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_1194__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_1194__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_1194__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_1194__.o(definition, key) && !__nested_webpack_require_1194__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_1194__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_1194__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
// ESM COMPAT FLAG
__nested_webpack_require_1194__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_1194__.d(__webpack_exports__, {
  "ALMA": () => (/* reexport */ ALMA),
  "ATR": () => (/* reexport */ ATR),
  "ATRp": () => (/* reexport */ ATRp),
  "Area51": () => (/* reexport */ Area51),
  "BB": () => (/* reexport */ BB),
  "BBW": () => (/* reexport */ BBW),
  "CCI": () => (/* reexport */ CCI),
  "CMO": () => (/* reexport */ CMO),
  "COG": () => (/* reexport */ COG),
  "DHistogram": () => (/* reexport */ DHistogram),
  "DMI": () => (/* reexport */ DMI),
  "EMA": () => (/* reexport */ EMA),
  "HMA": () => (/* reexport */ HMA),
  "Histogram": () => (/* reexport */ Histogram),
  "Ichi": () => (/* reexport */ Ichi),
  "Ichimoku": () => (/* reexport */ Ichimoku),
  "KC": () => (/* reexport */ KC),
  "KCW": () => (/* reexport */ KCW),
  "LongShortTrades": () => (/* reexport */ LongShortTrades),
  "MACD": () => (/* reexport */ MACD),
  "MFI": () => (/* reexport */ MFI),
  "MOM": () => (/* reexport */ MOM),
  "Markers": () => (/* reexport */ Markers),
  "PlotCross": () => (/* reexport */ PlotCross),
  "ROC": () => (/* reexport */ ROC),
  "RSI": () => (/* reexport */ RSI),
  "Ribbon": () => (/* reexport */ Ribbon),
  "SAR": () => (/* reexport */ SAR),
  "SMA": () => (/* reexport */ SMA),
  "SWMA": () => (/* reexport */ SWMA),
  "Stoch": () => (/* reexport */ Stoch),
  "TSI": () => (/* reexport */ TSI),
  "TradesPlus": () => (/* reexport */ TradesPlus),
  "VWMA": () => (/* reexport */ VWMA),
  "WilliamsR": () => (/* reexport */ WilliamsR),
  "XOhlcBars": () => (/* reexport */ XOhlcBars),
  "default": () => (/* binding */ index_prod)
});

// EXTERNAL MODULE: external "trading-vue-js"
var external_trading_vue_js_ = __nested_webpack_require_1194__(954);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ALMA/ALMA.vue?vue&type=script&lang=js&

/* harmony default export */ const ALMAvue_type_script_lang_js_ = ({
  name: 'ALMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Arnaud Legoux Moving Average',
        preset: {
          name: 'ALMA $length $offset $sigma',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ALMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          },
          offset: {
            def: 0.9,
            text: 'Offset'
          },
          sigma: {
            def: 5,
            text: 'Sigma'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return alma(close, length, offset, sigma)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ALMA/ALMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const ALMA_ALMAvue_type_script_lang_js_ = (ALMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

;// CONCATENATED MODULE: ./src/overlays/ALMA/ALMA.vue
var render, staticRenderFns
;



/* normalize component */
;
var component = normalizeComponent(
  ALMA_ALMAvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/overlays/ALMA/ALMA.vue"
/* harmony default export */ const ALMA = (component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ATR/ATR.vue?vue&type=script&lang=js&

/* harmony default export */ const ATRvue_type_script_lang_js_ = ({
  name: 'ATR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Average True Range',
        preset: {
          name: 'ATR $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#e52468'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ATR'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return atr(length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ATR/ATR.vue?vue&type=script&lang=js&
 /* harmony default export */ const ATR_ATRvue_type_script_lang_js_ = (ATRvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ATR/ATR.vue
var ATR_render, ATR_staticRenderFns
;



/* normalize component */
;
var ATR_component = normalizeComponent(
  ATR_ATRvue_type_script_lang_js_,
  ATR_render,
  ATR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ATR_api; }
ATR_component.options.__file = "src/overlays/ATR/ATR.vue"
/* harmony default export */ const ATR = (ATR_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ATRp/ATRp.vue?vue&type=script&lang=js&

/* harmony default export */ const ATRpvue_type_script_lang_js_ = ({
  name: 'ATRp',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Average True Range, %',
        preset: {
          name: 'ATR% $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#f44336'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ATRp'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return 100 * atr(length)[0] / close[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ATRp/ATRp.vue?vue&type=script&lang=js&
 /* harmony default export */ const ATRp_ATRpvue_type_script_lang_js_ = (ATRpvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ATRp/ATRp.vue
var ATRp_render, ATRp_staticRenderFns
;



/* normalize component */
;
var ATRp_component = normalizeComponent(
  ATRp_ATRpvue_type_script_lang_js_,
  ATRp_render,
  ATRp_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ATRp_api; }
ATRp_component.options.__file = "src/overlays/ATRp/ATRp.vue"
/* harmony default export */ const ATRp = (ATRp_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Area51/Area51.vue?vue&type=script&lang=js&
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Area51vue_type_script_lang_js_ = ({
  name: 'Area51',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: '',
        version: '1.0.0',
        desc: 'Gradient area chart'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var data = this.$props.data;
      var grd = ctx.createLinearGradient(0, 0, 0, layout.height);
      grd.addColorStop(0, this.back1);
      grd.addColorStop(1, this.back2); // Line

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      var _iterator = _createForOfIteratorHelper(data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[1]);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke(); // Area

      ctx.fillStyle = grd;
      ctx.beginPath();
      var p0 = (data[0] || [])[0];
      var pN = (data[data.length - 1] || [])[0];
      ctx.lineTo(layout.t2screen(p0), layout.height);

      var _iterator2 = _createForOfIteratorHelper(data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[1]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.lineTo(layout.t2screen(pN), layout.height);
      ctx.fill();
    },
    use_for: function use_for() {
      return ['Area51'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 1.25;
    },
    color: function color() {
      return this.sett.color || '#2fd68f';
    },
    back1: function back1() {
      return this.sett.back1 || this.color + '15';
    },
    back2: function back2() {
      return this.sett.back2 || this.color + '01';
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/overlays/Area51/Area51.vue?vue&type=script&lang=js&
 /* harmony default export */ const Area51_Area51vue_type_script_lang_js_ = (Area51vue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Area51/Area51.vue
var Area51_render, Area51_staticRenderFns
;



/* normalize component */
;
var Area51_component = normalizeComponent(
  Area51_Area51vue_type_script_lang_js_,
  Area51_render,
  Area51_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Area51_api; }
Area51_component.options.__file = "src/overlays/Area51/Area51.vue"
/* harmony default export */ const Area51 = (Area51_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/BB/BB.vue?vue&type=script&lang=js&

/* harmony default export */ const BBvue_type_script_lang_js_ = ({
  name: 'BB',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Bollinger Bands',
        preset: {
          name: 'BB $length $stddev',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#2cc6c9ab',
            showMid: true,
            backColor: '#2cc6c90a'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['BB'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          },
          stddev: {
            def: 2,
            text: 'StdDev'
          }
        },
        conf: {
          renderer: 'Channel'
        },
        update: "\n                    let [m, h, l] = bb(close, length, stddev)\n                    return [h[0], m[0], l[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/BB/BB.vue?vue&type=script&lang=js&
 /* harmony default export */ const BB_BBvue_type_script_lang_js_ = (BBvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/BB/BB.vue
var BB_render, BB_staticRenderFns
;



/* normalize component */
;
var BB_component = normalizeComponent(
  BB_BBvue_type_script_lang_js_,
  BB_render,
  BB_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var BB_api; }
BB_component.options.__file = "src/overlays/BB/BB.vue"
/* harmony default export */ const BB = (BB_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/BBW/BBW.vue?vue&type=script&lang=js&

/* harmony default export */ const BBWvue_type_script_lang_js_ = ({
  name: 'BBW',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Bollinger Bands Width',
        preset: {
          name: 'BBW $length $stddev',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#2cc6c9ab'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['BBW'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          },
          stddev: {
            def: 2,
            text: 'StdDev'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return bbw(close, length, stddev)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/BBW/BBW.vue?vue&type=script&lang=js&
 /* harmony default export */ const BBW_BBWvue_type_script_lang_js_ = (BBWvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/BBW/BBW.vue
var BBW_render, BBW_staticRenderFns
;



/* normalize component */
;
var BBW_component = normalizeComponent(
  BBW_BBWvue_type_script_lang_js_,
  BBW_render,
  BBW_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var BBW_api; }
BBW_component.options.__file = "src/overlays/BBW/BBW.vue"
/* harmony default export */ const BBW = (BBW_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/CCI/CCI.vue?vue&type=script&lang=js&

/* harmony default export */ const CCIvue_type_script_lang_js_ = ({
  name: 'CCI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Commodity Channel Index',
        preset: {
          name: 'CCI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#e28a3dee',
            backColor: '#e28a3d11',
            bandColor: '#aaaaaa',
            upper: 100,
            lower: -100
          }
        }
      };
    },
    use_for: function use_for() {
      return ['CCI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "return cci(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/CCI/CCI.vue?vue&type=script&lang=js&
 /* harmony default export */ const CCI_CCIvue_type_script_lang_js_ = (CCIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/CCI/CCI.vue
var CCI_render, CCI_staticRenderFns
;



/* normalize component */
;
var CCI_component = normalizeComponent(
  CCI_CCIvue_type_script_lang_js_,
  CCI_render,
  CCI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var CCI_api; }
CCI_component.options.__file = "src/overlays/CCI/CCI.vue"
/* harmony default export */ const CCI = (CCI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/CMO/CMO.vue?vue&type=script&lang=js&

/* harmony default export */ const CMOvue_type_script_lang_js_ = ({
  name: 'CMO',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Chande Momentum Oscillator',
        preset: {
          name: 'CMO $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['CMO'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "return cmo(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/CMO/CMO.vue?vue&type=script&lang=js&
 /* harmony default export */ const CMO_CMOvue_type_script_lang_js_ = (CMOvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/CMO/CMO.vue
var CMO_render, CMO_staticRenderFns
;



/* normalize component */
;
var CMO_component = normalizeComponent(
  CMO_CMOvue_type_script_lang_js_,
  CMO_render,
  CMO_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var CMO_api; }
CMO_component.options.__file = "src/overlays/CMO/CMO.vue"
/* harmony default export */ const CMO = (CMO_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/COG/COG.vue?vue&type=script&lang=js&

/* harmony default export */ const COGvue_type_script_lang_js_ = ({
  name: 'COG',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Center of Gravity',
        preset: {
          name: 'COG $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['COG'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "return cog(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/COG/COG.vue?vue&type=script&lang=js&
 /* harmony default export */ const COG_COGvue_type_script_lang_js_ = (COGvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/COG/COG.vue
var COG_render, COG_staticRenderFns
;



/* normalize component */
;
var COG_component = normalizeComponent(
  COG_COGvue_type_script_lang_js_,
  COG_render,
  COG_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var COG_api; }
COG_component.options.__file = "src/overlays/COG/COG.vue"
/* harmony default export */ const COG = (COG_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/DHistogram/DHistogram.vue?vue&type=script&lang=js&
function DHistogramvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = DHistogramvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function DHistogramvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return DHistogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return DHistogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function DHistogramvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const DHistogramvue_type_script_lang_js_ = ({
  name: "DHistogram",
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: "Acid3croco",
        version: "1.0.0",
        desc: "Double Histogram Plot",
        preset: {
          name: "DHistogram",
          side: "offchart",
          settings: {
            histWidth: 4,
            thresholdSize: 0,
            posColor: "#35a776",
            negColor: "#e54150"
          }
        }
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.hist_width;
      ctx.strokeStyle = this.color;
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.hist_width % 2 ? 0 : 0.5; // Color changed

      var changed = false;

      var _iterator = DHistogramvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var pos_value = p[1];
          var neg_value = p[2];
          var x = layout.t2screen(p[0]) - off;
          var y1 = layout.$2screen(pos_value) - 0.5;
          var y2 = layout.$2screen(neg_value) - 0.5;

          if (pos_value > this.threshold_size) {
            ctx.strokeStyle = this.pos_color;
            ctx.beginPath();
            ctx.moveTo(x, base);
            ctx.lineTo(x, y1);
            ctx.stroke();
          }

          if (neg_value < -this.threshold_size) {
            ctx.strokeStyle = this.neg_color;
            ctx.beginPath();
            ctx.moveTo(x, base);
            ctx.lineTo(x, y2);
            ctx.stroke();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ["DHistogram"];
    },
    legend: function legend(values) {
      var xs = values.slice(1, 3).map(function (x) {
        return x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      });
      return [{
        value: xs[0],
        color: this.pos_color
      }, {
        value: xs[1],
        color: this.neg_color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    hist_width: function hist_width() {
      return this.sett.histWidth || 4;
    },
    threshold_size: function threshold_size() {
      return this.sett.thresholdSize || 0;
    },
    pos_color: function pos_color() {
      return this.sett.posColor || "#35a776";
    },
    neg_color: function neg_color() {
      return this.sett.negColor || "#e54150";
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/overlays/DHistogram/DHistogram.vue?vue&type=script&lang=js&
 /* harmony default export */ const DHistogram_DHistogramvue_type_script_lang_js_ = (DHistogramvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/DHistogram/DHistogram.vue
var DHistogram_render, DHistogram_staticRenderFns
;



/* normalize component */
;
var DHistogram_component = normalizeComponent(
  DHistogram_DHistogramvue_type_script_lang_js_,
  DHistogram_render,
  DHistogram_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var DHistogram_api; }
DHistogram_component.options.__file = "src/overlays/DHistogram/DHistogram.vue"
/* harmony default export */ const DHistogram = (DHistogram_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/DMI/DMI.vue?vue&type=script&lang=js&

/* harmony default export */ const DMIvue_type_script_lang_js_ = ({
  name: 'DMI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Directional Movement Index',
        preset: {
          name: 'DMI $length $smooth',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#ef1360", "#3782f2", "#f48709"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['DMI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'DI Length'
          },
          smooth: {
            def: 15,
            text: 'ADX Smothing'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    let [adx, dp, dn] = dmi(length, smooth)\n                    return [adx[0], dp[0], dn[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/DMI/DMI.vue?vue&type=script&lang=js&
 /* harmony default export */ const DMI_DMIvue_type_script_lang_js_ = (DMIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/DMI/DMI.vue
var DMI_render, DMI_staticRenderFns
;



/* normalize component */
;
var DMI_component = normalizeComponent(
  DMI_DMIvue_type_script_lang_js_,
  DMI_render,
  DMI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var DMI_api; }
DMI_component.options.__file = "src/overlays/DMI/DMI.vue"
/* harmony default export */ const DMI = (DMI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/EMA/EMA.vue?vue&type=script&lang=js&

/* harmony default export */ const EMAvue_type_script_lang_js_ = ({
  name: 'EMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Exponential Moving Average',
        preset: {
          name: 'EMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#f7890c'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['EMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 12,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return ema(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/EMA/EMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const EMA_EMAvue_type_script_lang_js_ = (EMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/EMA/EMA.vue
var EMA_render, EMA_staticRenderFns
;



/* normalize component */
;
var EMA_component = normalizeComponent(
  EMA_EMAvue_type_script_lang_js_,
  EMA_render,
  EMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var EMA_api; }
EMA_component.options.__file = "src/overlays/EMA/EMA.vue"
/* harmony default export */ const EMA = (EMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/HMA/HMA.vue?vue&type=script&lang=js&

/* harmony default export */ const HMAvue_type_script_lang_js_ = ({
  name: 'HMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Hull Moving Average',
        preset: {
          name: 'HMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#3af475'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['HMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return hma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/HMA/HMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const HMA_HMAvue_type_script_lang_js_ = (HMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/HMA/HMA.vue
var HMA_render, HMA_staticRenderFns
;



/* normalize component */
;
var HMA_component = normalizeComponent(
  HMA_HMAvue_type_script_lang_js_,
  HMA_render,
  HMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var HMA_api; }
HMA_component.options.__file = "src/overlays/HMA/HMA.vue"
/* harmony default export */ const HMA = (HMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Histogram/Histogram.vue?vue&type=script&lang=js&
function Histogramvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Histogramvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Histogramvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Histogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Histogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Histogramvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Histogramvue_type_script_lang_js_ = ({
  name: 'Histogram',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Histogram plot'
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.line_width % 2 ? 0 : 0.5; // Color changed

      var changed = false;

      var _iterator = Histogramvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - 0.5;
          var _changed = false;

          if (p[2]) {
            if (ctx.strokeStyle !== p[2]) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = p[2];
          } else {
            if (ctx.strokeStyle !== this.color) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = this.color;
          }

          if (_changed) ctx.beginPath();
          ctx.moveTo(x, base);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Histogram'];
    },
    legend: function legend(values) {
      var x = values[1];

      if (typeof x === "number") {
        x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      }

      return [{
        value: x,
        color: values[2] || this.color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 2;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#888888', '#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Histogram/Histogram.vue?vue&type=script&lang=js&
 /* harmony default export */ const Histogram_Histogramvue_type_script_lang_js_ = (Histogramvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Histogram/Histogram.vue
var Histogram_render, Histogram_staticRenderFns
;



/* normalize component */
;
var Histogram_component = normalizeComponent(
  Histogram_Histogramvue_type_script_lang_js_,
  Histogram_render,
  Histogram_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Histogram_api; }
Histogram_component.options.__file = "src/overlays/Histogram/Histogram.vue"
/* harmony default export */ const Histogram = (Histogram_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ichi/Ichi.vue?vue&type=script&lang=js&
// Cloud renderer. (Ichimoku)

/* harmony default export */ const Ichivue_type_script_lang_js_ = ({
  name: 'Ichi',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.0',
        desc: 'Ichimoku Cloud based on scripts'
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;

      for (var i = 0; i < this.$props.data.length - 1; i++) {
        var p1 = this.mapp(this.$props.data[i]);
        var p2 = this.mapp(this.$props.data[i + 1]);
        if (!p2) continue;
        if (p1.y1 !== p1.y1) continue; // Fix NaN
        // Background

        ctx.beginPath();
        ctx.fillStyle = p1.y1 < p1.y2 ? this.back1 : this.back2;
        ctx.moveTo(p1.x, p1.y1);
        ctx.lineTo(p2.x + 0.1, p2.y1);
        ctx.lineTo(p2.x + 0.1, p2.y2);
        ctx.lineTo(p1.x, p1.y2);
        ctx.fill(); // Lines

        if (!this.draw_lines) continue;
        ctx.beginPath();
        ctx.strokeStyle = this.color1;
        ctx.moveTo(p1.x, p1.y1);
        ctx.lineTo(p2.x, p2.y1);
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = this.color2;
        ctx.moveTo(p1.x, p1.y2);
        ctx.lineTo(p2.x, p2.y2);
        ctx.stroke();
      }
    },
    mapp: function mapp(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        y1: layout.$2screen(p[1]),
        y2: layout.$2screen(p[2])
      };
    },
    use_for: function use_for() {
      return ['Ichi'];
    },
    data_colors: function data_colors() {
      return [this.color1, this.color2];
    },
    calc: function calc() {
      return {
        props: {
          CP: {
            def: 9,
            text: 'Conversion Line Length'
          },
          BP: {
            def: 26,
            text: 'Base Line Length'
          },
          LSP: {
            def: 52,
            text: 'Lagging Span 2 Length'
          },
          DIZ: {
            def: 26,
            text: 'Displacement'
          },
          baseColor: {
            def: 'brown',
            text: 'Base Line Color'
          },
          conversionColor: {
            def: 'lightblue',
            text: 'Conversion Line Color'
          },
          laggingColor: {
            def: '#66CC66',
            text: 'Lagging Span Color'
          }
        },
        update: "\n                    let donchian = (len, id) => ts(\n                        avg(lowest(low, len)[0], highest(high, len)[0]), id\n                    )\n                    let conversionLine = donchian(CP, 1)\n                    let baseLine = donchian(BP, 2)\n                    let leadLine1 = ts(avg(conversionLine[0], baseLine[0]))\n                    let leadLine2 = donchian(LSP, 3)\n                    let lagging = ts(close[0])\n\n\n                    offset(this, DIZ - 1)\n                    offset(lagging, -DIZ + 1)\n                    onchart([conversionLine, baseLine], 'Base Lines', {\n                        colors: [conversionColor, baseColor]\n                    })\n                    onchart(lagging, 'Lagging Span', {\n                        color: laggingColor\n                    })\n                    return [leadLine1[0], leadLine2[0]]\n                "
      };
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color1: function color1() {
      return this.sett.color1 || 'lightgreen';
    },
    color2: function color2() {
      return this.sett.color2 || 'orange';
    },
    back1: function back1() {
      return this.sett.back1 || '#79ff9e22';
    },
    back2: function back2() {
      return this.sett.back2 || '#ef535022';
    },
    draw_lines: function draw_lines() {
      return this.sett.drawLines;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ichi/Ichi.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ichi_Ichivue_type_script_lang_js_ = (Ichivue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ichi/Ichi.vue
var Ichi_render, Ichi_staticRenderFns
;



/* normalize component */
;
var Ichi_component = normalizeComponent(
  Ichi_Ichivue_type_script_lang_js_,
  Ichi_render,
  Ichi_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ichi_api; }
Ichi_component.options.__file = "src/overlays/Ichi/Ichi.vue"
/* harmony default export */ const Ichi = (Ichi_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ichimoku/Ichimoku.vue?vue&type=script&lang=js&
function Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Ichimokuvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Ichimokuvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Ichimokuvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ichimokuvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Ichimokuvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//Ichimoku Indicator Overlay. Expected Format: [ <timestamp>, <ConversionLine>, <BaseLine>, <Lead1>, <Lead2>, <Lagging> ]

/* harmony default export */ const Ichimokuvue_type_script_lang_js_ = ({
  name: "Ichimoku",
  mixins: [external_trading_vue_js_.Overlay],
  data: function data() {
    return {
      ctxTenkan: {},
      ctxKijun: {},
      ctxSenkouSpanA: {},
      ctxSenkouSpanB: {},
      ctxChinkou: {},
      ctxFillKumo: {},
      tenkan: [],
      kijun: [],
      senkouSpanA: [],
      senkouSpanB: [],
      chinkou: [],
      offset: 26,
      tenkanLineWidth: 1,
      kijunLineWidth: 1,
      senkouSpanALineWidth: 1,
      senkouSpanBLineWidth: 1,
      chinkouLineWidth: 1,
      colorTenkan: "#52A634",
      colorKijun: "#52A59D",
      colorSenkouSpanA: "#438625",
      colorSenkouSpanB: "#bd003c",
      colorChinkou: "#BF2A64",
      colorKumoUp: "#063f0f",
      colorKumoDown: "#391c19",
      showTenkan: true,
      showKijun: true,
      showSenkouSpanA: true,
      showSenkouSpanB: true,
      showChinkou: true,
      showFillKumo: true
    };
  },
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    tenkan_color: function tenkan_color() {
      return this.sett['tenkan-color'] || this.colorTenkan;
    },
    kijun_color: function kijun_color() {
      return this.sett['kijun-color'] || this.colorKijun;
    },
    senkou_spanA_color: function senkou_spanA_color() {
      return this.sett['senkou_spanA_color'] || this.colorSenkouSpanA;
    },
    senkou_spanB_color: function senkou_spanB_color() {
      return this.sett['senkou_spanB_color'] || this.colorSenkouSpanB;
    },
    chinkou_color: function chinkou_color() {
      return this.sett['chinkou_color'] || this.colorChinkou;
    },
    kumo_up_color: function kumo_up_color() {
      return this.sett['kumo_up_color'] || this.colorKumoUp;
    },
    kumo_down_color: function kumo_down_color() {
      return this.sett['kumo_down_color'] || this.colorKumoDown;
    },
    tenkan_line_width: function tenkan_line_width() {
      return this.sett['tenkan_line_width'] || this.tenkanLineWidth;
    },
    kijun_line_width: function kijun_line_width() {
      return this.sett['kijun_line_width'] || this.kijunLineWidth;
    },
    senkou_spanA_line_width: function senkou_spanA_line_width() {
      return this.sett['senkou_spanA_line_width'] || this.senkouSpanALineWidth;
    },
    senkou_spanB_line_width: function senkou_spanB_line_width() {
      return this.sett['senkou_spanB_line_width'] || this.senkouSpanBLineWidth;
    },
    chinkou_line_width: function chinkou_line_width() {
      return this.sett['chinkou_line_width'] || this.chinkouLineWidth;
    }
  },
  methods: {
    meta_info: function meta_info() {
      return {
        author: "Sudeep Batra",
        version: "1.0.0"
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var propsSub = this.$props.sub;
      this.ctxTenkan = ctx;
      this.ctxKijun = ctx;
      this.ctxSenkouSpanA = ctx;
      this.ctxSenkouSpanB = ctx;
      this.ctxChinkou = ctx;
      this.ctxFillKumo = ctx;
      var subdata = this.$props.data.slice(0, propsSub.length);
      var subdataSenkouSpan = this.$props.data.slice(0, propsSub.length + this.offset);
      var subdataChinkou = this.$props.data.slice(0, propsSub.length - this.offset);

      if (this.showFillKumo) {
        this.ctxFillKumo.beginPath();
        var ind = 0;

        var _iterator = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var currItem = _step.value;

            if (ind > 1) {
              var p1 = this.map_senkou_span_values(subdataSenkouSpan[ind - 1]);
              var p2 = this.map_senkou_span_values(currItem);
              this.ctxSenkouSpanB.beginPath();
              this.ctxSenkouSpanB.moveTo(p1.x, p1.senkouSpanA);
              this.ctxSenkouSpanB.lineTo(p2.x + 0.1, p2.senkouSpanA);
              this.ctxSenkouSpanB.lineTo(p2.x + 0.1, p2.senkouSpanB);
              this.ctxSenkouSpanB.lineTo(p1.x, p1.senkouSpanB);

              if (p1.senkouSpanA >= p1.senkouSpanB) {
                this.ctxSenkouSpanB.fillStyle = this.kumo_down_color;
              } else {
                this.ctxSenkouSpanB.fillStyle = this.kumo_up_color;
              }

              this.ctxSenkouSpanB.fill();
            }

            ind++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.ctxSenkouSpanB.stroke();
      }

      if (this.showTenkan) {
        this.ctxTenkan.beginPath();

        var _iterator2 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdata),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var pTenkan = _step2.value;
            this.ctxTenkan.strokeStyle = this.tenkan_color;
            this.ctxTenkan.lineWidth = this.tenkan_line_width;
            this.ctxTenkan.lineTo(layout.t2screen(pTenkan[0]), layout.$2screen(pTenkan[1]));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        this.ctxTenkan.stroke();
      }

      if (this.showKijun) {
        this.ctxKijun.beginPath();

        var _iterator3 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdata),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var pKijun = _step3.value;
            this.ctxKijun.strokeStyle = this.kijun_color;
            this.ctxKijun.lineWidth = this.kijun_line_width;
            this.ctxKijun.lineTo(layout.t2screen(pKijun[0]), layout.$2screen(pKijun[2]));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        this.ctxKijun.stroke();
      }

      if (this.showSenkouSpanA) {
        this.ctxSenkouSpanA.beginPath();

        var _iterator4 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var pSenkouSpanA = _step4.value;
            this.ctxSenkouSpanA.strokeStyle = this.senkou_spanA_color;
            this.ctxSenkouSpanA.lineWidth = this.senkou_spanA_line_width;
            this.ctxSenkouSpanA.lineTo(layout.t2screen(pSenkouSpanA[0]), layout.$2screen(pSenkouSpanA[3]));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        this.ctxSenkouSpanA.stroke();
      }

      if (this.colorSenkouSpanB) {
        this.ctxSenkouSpanB.beginPath();

        var _iterator5 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var pSenkouSpanB = _step5.value;
            this.ctxSenkouSpanB.strokeStyle = this.senkou_spanB_color;
            this.ctxSenkouSpanB.lineWidth = this.senkou_spanB_line_width;
            this.ctxSenkouSpanB.lineTo(layout.t2screen(pSenkouSpanB[0]), layout.$2screen(pSenkouSpanB[4]));
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        this.ctxSenkouSpanB.stroke();
      }

      if (this.showChinkou) {
        this.ctxChinkou.beginPath();

        var _iterator6 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataChinkou),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var pChikou = _step6.value;
            this.ctxChinkou.strokeStyle = this.chinkou_color;
            this.ctxChinkou.lineWidth = this.chinkou_line_width;
            this.ctxChinkou.lineTo(layout.t2screen(pChikou[0]), layout.$2screen(pChikou[5]));
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        this.ctxChinkou.stroke();
      }
    },
    map_senkou_span_values: function map_senkou_span_values(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        senkouSpanA: layout.$2screen(p[3]),
        senkouSpanB: layout.$2screen(p[4])
      };
    },
    use_for: function use_for() {
      return ["Ichimoku"];
    },
    data_colors: function data_colors() {
      var colors = [];
      colors.push(this.tenkan_color);
      colors.push(this.kijun_color);
      colors.push(this.senkou_spanA_color);
      colors.push(this.senkou_spanB_color);
      colors.push(this.chinkou_color);
      return colors;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ichimoku/Ichimoku.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ichimoku_Ichimokuvue_type_script_lang_js_ = (Ichimokuvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ichimoku/Ichimoku.vue
var Ichimoku_render, Ichimoku_staticRenderFns
;



/* normalize component */
;
var Ichimoku_component = normalizeComponent(
  Ichimoku_Ichimokuvue_type_script_lang_js_,
  Ichimoku_render,
  Ichimoku_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ichimoku_api; }
Ichimoku_component.options.__file = "src/overlays/Ichimoku/Ichimoku.vue"
/* harmony default export */ const Ichimoku = (Ichimoku_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/KC/KC.vue?vue&type=script&lang=js&

/* harmony default export */ const KCvue_type_script_lang_js_ = ({
  name: 'KC',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Keltner Channels',
        preset: {
          name: 'KC $length $mult',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#4c8dffab',
            showMid: true,
            backColor: '#4c8dff0a'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['KC'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          },
          mult: {
            def: 1,
            text: 'Multiplier'
          },
          use_tr: {
            def: true,
            text: 'Use True Range'
          }
        },
        conf: {
          renderer: 'Channel'
        },
        update: "\n                    let [m, h, l] = kc(close, length, mult, use_tr)\n                    return [h[0], m[0], l[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/KC/KC.vue?vue&type=script&lang=js&
 /* harmony default export */ const KC_KCvue_type_script_lang_js_ = (KCvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/KC/KC.vue
var KC_render, KC_staticRenderFns
;



/* normalize component */
;
var KC_component = normalizeComponent(
  KC_KCvue_type_script_lang_js_,
  KC_render,
  KC_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KC_api; }
KC_component.options.__file = "src/overlays/KC/KC.vue"
/* harmony default export */ const KC = (KC_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/KCW/KCW.vue?vue&type=script&lang=js&

/* harmony default export */ const KCWvue_type_script_lang_js_ = ({
  name: 'KCW',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Keltner Channels Width',
        preset: {
          name: 'KCW $length $mult',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#4c8dffab'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['KCW'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          },
          mult: {
            def: 1,
            text: 'Multiplier'
          },
          use_tr: {
            def: true,
            text: 'Use True Range'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return kcw(close, length, mult, use_tr)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/KCW/KCW.vue?vue&type=script&lang=js&
 /* harmony default export */ const KCW_KCWvue_type_script_lang_js_ = (KCWvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/KCW/KCW.vue
var KCW_render, KCW_staticRenderFns
;



/* normalize component */
;
var KCW_component = normalizeComponent(
  KCW_KCWvue_type_script_lang_js_,
  KCW_render,
  KCW_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KCW_api; }
KCW_component.options.__file = "src/overlays/KCW/KCW.vue"
/* harmony default export */ const KCW = (KCW_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/LongShortTrades/LongShortTrades.vue?vue&type=script&lang=js&
function LongShortTradesvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = LongShortTradesvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function LongShortTradesvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LongShortTradesvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LongShortTradesvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function LongShortTradesvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//Long Short Overlay. Expected Format: [ <timestamp>, <Short:0 Long:1 ShortCover: 2 LongCover:3>, <Price Change>, <Percent Price Change>, <Open Price>, <High Price>, <Low Price>, <Close Price> ]

/* harmony default export */ const LongShortTradesvue_type_script_lang_js_ = ({
  name: 'LongShortTrades',
  mixins: [external_trading_vue_js_.Overlay],
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    currency_symbol: function currency_symbol() {
      return this.sett.currency || '';
    },
    long_color: function long_color() {
      return this.sett.longColor || '#63df89';
    },
    short_color: function short_color() {
      return this.sett.shortColor || '#ffd581';
    },
    long_cover_color: function long_cover_color() {
      return this.sett.longCoverColor || '#fc7e2f';
    },
    short_cover_color: function short_cover_color() {
      return this.sett.shortCoverColor || '#ff6bd6';
    },
    label_color: function label_color() {
      return '#4BECF9';
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  },
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'Sudeep Batra',
        version: '1.0.1'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';

      var _iterator = LongShortTradesvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var tradeTime = p[0];
          var longShortEntryExit = p[1];
          var priceChange = p[2];
          var percentPriceChange = p[3];
          var openPrice = p[4];
          var highPrice = p[5];
          var lowPrice = p[6];
          var closePrice = p[7];
          var x = layout.t2screen(tradeTime);
          var lowPriceY = layout.$2screen(lowPrice);
          var highPriceY = layout.$2screen(highPrice);

          switch (longShortEntryExit) {
            case 0:
              this.filledArrowDownFilledBottom(ctx, x, highPriceY - 25, 5, 5, 3, 20, this.short_color);
              this.draw_label(ctx, x + 30, highPriceY - 35, this.currency_symbol + closePrice);
              break;

            case 1:
              this.filledArrowUpFilledBottom(ctx, x, lowPriceY + 20, 5, 5, 3, 20, this.long_color);
              this.draw_label(ctx, x + 30, lowPriceY + 40, this.currency_symbol + closePrice);
              break;

            case 2:
              this.upTriangle(ctx, x, lowPriceY + 25, 5, 7, this.short_cover_color);

              if (this.show_label && priceChange) {
                this.draw_label(ctx, x, lowPriceY + 50, priceChange + " (" + percentPriceChange + ")");
              }

              break;

            case 3:
              this.downTriangle(ctx, x, highPriceY - 25, 5, 7, this.long_cover_color);

              if (this.show_label && priceChange) {
                this.draw_label(ctx, x, highPriceY - 45, priceChange + " (" + percentPriceChange + ")");
              }

              break;

            default:
              ctx.fillStyle = 'black';
          } // this.simpleArrowUp(ctx, x, z - 25, '#84e5b1')
          // this.simpleArrowDown(ctx, x, z - 25, '#84e5b1')
          // this.filledArrowUp(ctx, x, z - 25, 5, 5, 20, '#84e5b1')
          // this.filledDownArrow(ctx, x, z - 25, 5, 5, 20, '#84e5b1')
          // this.filledArrowUpFilledBottom(ctx, x, z - 25, 5, 5, 3, 20, '#84e5b1')
          // this.filledArrowDownFilledBottom(ctx, x, z - 25, 5, 5, 3, 20, '#84e5b1')
          // this.upTriangle(ctx, x, z-60, 5, 7, '#84e5b1')
          // this.downTriangle(ctx, x, z - 25, 5, 7, '#84e5b1')

        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    draw_label: function draw_label(ctx, x, y, labelText) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(labelText, x, y);
    },
    use_for: function use_for() {
      return ['LongShortTrades'];
    },
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Short';
          break;

        case 1:
          pos = 'Long';
          break;

        case 2:
          pos = 'Short Cover';
          break;

        case 3:
          pos = 'Long Cover';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.colorText
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    },
    simpleArrowUp: function simpleArrowUp(ctx, x, y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - 5, y + 5);
      ctx.lineTo(x, y);
      ctx.lineTo(x + 5, y + 5);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + 15);
      ctx.stroke();
      ctx.closePath();
    },
    simpleArrowDown: function simpleArrowDown(ctx, x, y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - 5, y - 5);
      ctx.lineTo(x, y);
      ctx.lineTo(x + 5, y - 5);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - 15);
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowUp: function filledArrowUp(ctx, x, y, width, height, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledDownArrow: function filledDownArrow(ctx, x, y, width, height, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowUpFilledBottom: function filledArrowUpFilledBottom(ctx, x, y, width, height, bottom, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.moveTo(x, y);
      ctx.rect(x - bottom / 2, y + height, bottom, depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowDownFilledBottom: function filledArrowDownFilledBottom(ctx, x, y, width, height, bottom, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.moveTo(x, y);
      ctx.rect(x - bottom / 2, y - height - depth, bottom, depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    upTriangle: function upTriangle(ctx, x, y, width, height, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    downTriangle: function downTriangle(ctx, x, y, width, height, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/LongShortTrades/LongShortTrades.vue?vue&type=script&lang=js&
 /* harmony default export */ const LongShortTrades_LongShortTradesvue_type_script_lang_js_ = (LongShortTradesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/LongShortTrades/LongShortTrades.vue
var LongShortTrades_render, LongShortTrades_staticRenderFns
;



/* normalize component */
;
var LongShortTrades_component = normalizeComponent(
  LongShortTrades_LongShortTradesvue_type_script_lang_js_,
  LongShortTrades_render,
  LongShortTrades_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LongShortTrades_api; }
LongShortTrades_component.options.__file = "src/overlays/LongShortTrades/LongShortTrades.vue"
/* harmony default export */ const LongShortTrades = (LongShortTrades_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MACD/MACD.vue?vue&type=script&lang=js&
function MACDvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = MACDvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function MACDvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return MACDvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return MACDvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function MACDvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// TODO: pass colors from settings to the script
// TODO: hist lines => recangles (like in volbar.js)

/* harmony default export */ const MACDvue_type_script_lang_js_ = ({
  name: 'MACD',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.2',
        desc: 'Moving Average Convergence/Divergence',
        preset: {
          name: 'MACD $fast $slow $smooth',
          side: 'offchart',
          settings: {
            histWidth: 4,
            macdWidth: 1,
            signalWidth: 1,
            defColor: "#42b28a",
            macdColor: "#3782f2",
            signalColor: "#f48709",
            histColors: ["#35a776", "#79e0b3", "#e54150", "#ea969e"]
          }
        }
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout; // HISTOGRAM

      var base = layout.$2screen(0) + 0.5;
      var off = this.hist_width % 2 ? 0 : 0.5;
      ctx.lineWidth = this.hist_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      var _iterator = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - 0.5;
          ctx.strokeStyle = this.sett.histColors[p[4]];
          ctx.beginPath();
          ctx.moveTo(x, base);
          ctx.lineTo(x, y);
          ctx.stroke();
        } // MACD LINE

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.beginPath();
      ctx.lineWidth = this.macd_width;
      ctx.strokeStyle = this.macd_color;

      var _iterator2 = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[2]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.stroke(); // SIGNAL LINE

      ctx.beginPath();
      ctx.lineWidth = this.signal_width;
      ctx.strokeStyle = this.signal_color;

      var _iterator3 = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var p = _step3.value;

          var _x2 = layout.t2screen(p[0]);

          var _y2 = layout.$2screen(p[3]);

          ctx.lineTo(_x2, _y2);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['MACD'];
    },
    legend: function legend(values) {
      var xs = values.slice(1, 4).map(function (x) {
        return x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      });
      return [{
        value: xs[0],
        color: this.hist_colors[values[4]]
      }, {
        value: xs[1],
        color: this.macd_color
      }, {
        value: xs[2],
        color: this.signal_color
      }];
    },
    calc: function calc() {
      return {
        props: {
          fast: {
            def: 12,
            text: 'Fast Length'
          },
          slow: {
            def: 26,
            text: 'Slow Length'
          },
          smooth: {
            def: 9,
            text: 'Signal EMA'
          }
        },
        update: "\n                    let [macd, signal, hist] =\n                        macd(close, fast, slow, smooth)\n\n                    if (hist[0] >= 0) {\n                         var color = 0\n                         if (hist[0] < hist[1]) color = 1\n                    } else {\n                        color = 2\n                        if (hist[0] > hist[1]) color = 3\n                    }\n\n                    return [hist[0], macd[0], signal[0], color]\n                "
      };
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    hist_width: function hist_width() {
      return this.sett.histWidth || 4;
    },
    macd_width: function macd_width() {
      return this.sett.macdWidth || 1;
    },
    signal_width: function signal_width() {
      return this.sett.signalWidth || 1;
    },
    color: function color() {
      return this.sett.defColor || "#42b28a";
    },
    macd_color: function macd_color() {
      return this.sett.macdColor || "#3782f2";
    },
    signal_color: function signal_color() {
      return this.sett.signalColor || "#f48709";
    },
    hist_colors: function hist_colors() {
      return this.sett.histColors;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MACD/MACD.vue?vue&type=script&lang=js&
 /* harmony default export */ const MACD_MACDvue_type_script_lang_js_ = (MACDvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MACD/MACD.vue
var MACD_render, MACD_staticRenderFns
;



/* normalize component */
;
var MACD_component = normalizeComponent(
  MACD_MACDvue_type_script_lang_js_,
  MACD_render,
  MACD_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MACD_api; }
MACD_component.options.__file = "src/overlays/MACD/MACD.vue"
/* harmony default export */ const MACD = (MACD_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MFI/MFI.vue?vue&type=script&lang=js&

/* harmony default export */ const MFIvue_type_script_lang_js_ = ({
  name: 'MFI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Money Flow Index',
        preset: {
          name: 'MFI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#85c427ee',
            bandColor: '#aaaaaa',
            backColor: '#85c42711',
            upper: 80,
            lower: 20
          }
        }
      };
    },
    use_for: function use_for() {
      return ['MFI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "\n                    let hlc3 = ts((high[0] + low[0] + close[0]) / 3)\n                    return mfi(hlc3, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MFI/MFI.vue?vue&type=script&lang=js&
 /* harmony default export */ const MFI_MFIvue_type_script_lang_js_ = (MFIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MFI/MFI.vue
var MFI_render, MFI_staticRenderFns
;



/* normalize component */
;
var MFI_component = normalizeComponent(
  MFI_MFIvue_type_script_lang_js_,
  MFI_render,
  MFI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MFI_api; }
MFI_component.options.__file = "src/overlays/MFI/MFI.vue"
/* harmony default export */ const MFI = (MFI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MOM/MOM.vue?vue&type=script&lang=js&

/* harmony default export */ const MOMvue_type_script_lang_js_ = ({
  name: 'MOM',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Momentum',
        preset: {
          name: 'MOM $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#bcc427ee'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['MOM'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 11,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return mom(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MOM/MOM.vue?vue&type=script&lang=js&
 /* harmony default export */ const MOM_MOMvue_type_script_lang_js_ = (MOMvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MOM/MOM.vue
var MOM_render, MOM_staticRenderFns
;



/* normalize component */
;
var MOM_component = normalizeComponent(
  MOM_MOMvue_type_script_lang_js_,
  MOM_render,
  MOM_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MOM_api; }
MOM_component.options.__file = "src/overlays/MOM/MOM.vue"
/* harmony default export */ const MOM = (MOM_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Markers/Markers.vue?vue&type=script&lang=js&
function Markersvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Markersvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Markersvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Markersvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Markersvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Markersvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Markersvue_type_script_lang_js_ = ({
  name: 'Markers',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1',
        desc: 'Interactive markers'
      };
    },
    init: function init() {
      this.mouse.on('mousemove', function () {});
    },
    draw: function draw(ctx) {
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';
      document.body.style.cursor = 'auto';
      this.selected = null;

      var _iterator = Markersvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          this.draw_point(ctx, p);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var f = this.data.find(function (x) {
        return x[1].sel;
      });

      if (f) {
        this.draw_point(ctx, f);
      }
    },
    draw_point: function draw_point(ctx, p) {
      var layout = this.$props.layout;
      var stroke = this.colors.back;
      var fill = p[1].color || 'orange';
      var radius = 2;
      var height = p[1].sel ? 20 : 14;
      var width = p[1].sel ? 17 : 13;
      var x = layout.t2screen(p[0]) - width * 0.5;
      var y = layout.$2screen(p[1].$) - (p[1].sel ? 27 : 20); // Collisions

      if (this.mouse.x > x && this.mouse.x < x + width && this.mouse.y > y && this.mouse.y < y + height) {
        document.body.style.cursor = 'pointer';
        this.selected = p;
        stroke = this.colors.text;
      }

      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + width * 1 / 2, y + height + height / 5);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.lineWidth = 1;
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.fill();
      ctx.stroke();
      ctx.textAlign = 'center';
      ctx.fillStyle = p[1].textColor || this.colors.back;
      ctx.font = "".concat(p[1].sel ? 15 : 11, "px Arial");
      ctx.fillText(p[1].text || '$', x + width / 2, y + height * 0.8);
    },
    use_for: function use_for() {
      return ['Markers'];
    },
    legend: function legend() {
      return [];
    },
    mousedown: function mousedown() {
      this.$emit('marker-selected', this.selected);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  },
  data: function data() {
    return {
      selected: null
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Markers/Markers.vue?vue&type=script&lang=js&
 /* harmony default export */ const Markers_Markersvue_type_script_lang_js_ = (Markersvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Markers/Markers.vue
var Markers_render, Markers_staticRenderFns
;



/* normalize component */
;
var Markers_component = normalizeComponent(
  Markers_Markersvue_type_script_lang_js_,
  Markers_render,
  Markers_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Markers_api; }
Markers_component.options.__file = "src/overlays/Markers/Markers.vue"
/* harmony default export */ const Markers = (Markers_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/PlotCross/PlotCross.vue?vue&type=script&lang=js&
function PlotCrossvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = PlotCrossvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function PlotCrossvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return PlotCrossvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PlotCrossvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function PlotCrossvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const PlotCrossvue_type_script_lang_js_ = ({
  name: 'PlotCross',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Plot line with crosses'
      };
    },
    draw: function draw(ctx) {
      var w = ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.line_width % 2 ? 0 : 0.5;
      var off2 = this.line_width % 2 ? 0.5 : 1; // Color changed

      var changed = false;

      var _iterator = PlotCrossvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - off;
          var _changed = false;

          if (p[2]) {
            if (ctx.strokeStyle !== p[2]) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = p[2];
          } else {
            if (ctx.strokeStyle !== this.color) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = this.color;
          }

          if (_changed) ctx.beginPath();
          ctx.moveTo(x, y - w * 2 + off2);
          ctx.lineTo(x, y + w * 2 - off2);
          ctx.moveTo(x - w * 2 + off2, y);
          ctx.lineTo(x + w * 2 - off2, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['PlotCross'];
    },
    legend: function legend(values) {
      var x = values[1];

      if (typeof x === "number") {
        x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      }

      return [{
        value: x,
        color: values[2] || this.color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 2;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#888888', '#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/PlotCross/PlotCross.vue?vue&type=script&lang=js&
 /* harmony default export */ const PlotCross_PlotCrossvue_type_script_lang_js_ = (PlotCrossvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/PlotCross/PlotCross.vue
var PlotCross_render, PlotCross_staticRenderFns
;



/* normalize component */
;
var PlotCross_component = normalizeComponent(
  PlotCross_PlotCrossvue_type_script_lang_js_,
  PlotCross_render,
  PlotCross_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var PlotCross_api; }
PlotCross_component.options.__file = "src/overlays/PlotCross/PlotCross.vue"
/* harmony default export */ const PlotCross = (PlotCross_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ROC/ROC.vue?vue&type=script&lang=js&

/* harmony default export */ const ROCvue_type_script_lang_js_ = ({
  name: 'ROC',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Rate of Change',
        preset: {
          name: 'ROC $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#279fc4'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ROC'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 9,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return roc(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ROC/ROC.vue?vue&type=script&lang=js&
 /* harmony default export */ const ROC_ROCvue_type_script_lang_js_ = (ROCvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ROC/ROC.vue
var ROC_render, ROC_staticRenderFns
;



/* normalize component */
;
var ROC_component = normalizeComponent(
  ROC_ROCvue_type_script_lang_js_,
  ROC_render,
  ROC_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ROC_api; }
ROC_component.options.__file = "src/overlays/ROC/ROC.vue"
/* harmony default export */ const ROC = (ROC_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/RSI/RSI.vue?vue&type=script&lang=js&

/* harmony default export */ const RSIvue_type_script_lang_js_ = ({
  name: 'RSI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Relative Strength Index',
        preset: {
          name: 'RSI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#ec206e',
            bandColor: '#aaa',
            backColor: '#9b9ba316'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['RSI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "return rsi(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/RSI/RSI.vue?vue&type=script&lang=js&
 /* harmony default export */ const RSI_RSIvue_type_script_lang_js_ = (RSIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/RSI/RSI.vue
var RSI_render, RSI_staticRenderFns
;



/* normalize component */
;
var RSI_component = normalizeComponent(
  RSI_RSIvue_type_script_lang_js_,
  RSI_render,
  RSI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var RSI_api; }
RSI_component.options.__file = "src/overlays/RSI/RSI.vue"
/* harmony default export */ const RSI = (RSI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ribbon/Ribbon.vue?vue&type=script&lang=js&

/* harmony default export */ const Ribbonvue_type_script_lang_js_ = ({
  name: 'Ribbon',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Moving Average Ribbon',
        preset: {
          name: 'EMA x $number',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#3aaaf4ee"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['Ribbon'];
    },
    calc: function calc() {
      return {
        props: {
          start: {
            def: 10,
            text: 'Start Length'
          },
          number: {
            def: 5,
            text: 'Number of Lines'
          },
          step: {
            def: 10,
            text: 'Length Step'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    this[0] = []\n                    for (var i = 0; i < number; i++) {\n                        let l = start + i * step\n                        this[0].push(ema(close, l)[0])\n                    }\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ribbon/Ribbon.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ribbon_Ribbonvue_type_script_lang_js_ = (Ribbonvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ribbon/Ribbon.vue
var Ribbon_render, Ribbon_staticRenderFns
;



/* normalize component */
;
var Ribbon_component = normalizeComponent(
  Ribbon_Ribbonvue_type_script_lang_js_,
  Ribbon_render,
  Ribbon_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ribbon_api; }
Ribbon_component.options.__file = "src/overlays/Ribbon/Ribbon.vue"
/* harmony default export */ const Ribbon = (Ribbon_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SAR/SAR.vue?vue&type=script&lang=js&

/* harmony default export */ const SARvue_type_script_lang_js_ = ({
  name: 'SAR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Parabolic SAR',
        preset: {
          name: 'SAR $start $inc $max',
          side: 'onchart',
          settings: {
            lineWidth: 2,
            color: '#35a9c6'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SAR'];
    },
    calc: function calc() {
      return {
        props: {
          start: {
            def: 0.02,
            text: 'Start'
          },
          inc: {
            def: 0.02,
            text: 'Increment'
          },
          max: {
            def: 0.2,
            text: 'Maximum'
          }
        },
        conf: {
          renderer: 'PlotCross'
        },
        update: "\n                    return sar(start, inc, max)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SAR/SAR.vue?vue&type=script&lang=js&
 /* harmony default export */ const SAR_SARvue_type_script_lang_js_ = (SARvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SAR/SAR.vue
var SAR_render, SAR_staticRenderFns
;



/* normalize component */
;
var SAR_component = normalizeComponent(
  SAR_SARvue_type_script_lang_js_,
  SAR_render,
  SAR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SAR_api; }
SAR_component.options.__file = "src/overlays/SAR/SAR.vue"
/* harmony default export */ const SAR = (SAR_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SMA/SMA.vue?vue&type=script&lang=js&

/* harmony default export */ const SMAvue_type_script_lang_js_ = ({
  name: 'SMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Simple Moving Average',
        preset: {
          name: 'SMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#d1385c'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 25,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return sma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SMA/SMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const SMA_SMAvue_type_script_lang_js_ = (SMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SMA/SMA.vue
var SMA_render, SMA_staticRenderFns
;



/* normalize component */
;
var SMA_component = normalizeComponent(
  SMA_SMAvue_type_script_lang_js_,
  SMA_render,
  SMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SMA_api; }
SMA_component.options.__file = "src/overlays/SMA/SMA.vue"
/* harmony default export */ const SMA = (SMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SWMA/SWMA.vue?vue&type=script&lang=js&

/* harmony default export */ const SWMAvue_type_script_lang_js_ = ({
  name: 'SWMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Symmetrically Weighted Moving Average',
        preset: {
          name: 'SWMA',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#e57440'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SWMA'];
    },
    calc: function calc() {
      return {
        props: {},
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return swma(close)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SWMA/SWMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const SWMA_SWMAvue_type_script_lang_js_ = (SWMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SWMA/SWMA.vue
var SWMA_render, SWMA_staticRenderFns
;



/* normalize component */
;
var SWMA_component = normalizeComponent(
  SWMA_SWMAvue_type_script_lang_js_,
  SWMA_render,
  SWMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SWMA_api; }
SWMA_component.options.__file = "src/overlays/SWMA/SWMA.vue"
/* harmony default export */ const SWMA = (SWMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Stoch/Stoch.vue?vue&type=script&lang=js&
function Stochvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Stochvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Stochvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Stochvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Stochvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Stochvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Stochvue_type_script_lang_js_ = ({
  name: 'Stoch',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Stochastic',
        preset: {
          name: 'Stoch $param_k $param_d $smooth',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            kColor: '#3782f2',
            dColor: '#f48709',
            bandColor: '#ddd',
            backColor: '#381e9c16'
          }
        }
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var upper = layout.$2screen(this.sett.upper || 80);
      var lower = layout.$2screen(this.sett.lower || 20); // K

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.k_color;
      ctx.beginPath();

      var _iterator = Stochvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[1]);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke(); // D

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.d_color;
      ctx.beginPath();

      var _iterator2 = Stochvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[2]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.stroke();
      ctx.strokeStyle = this.band_color;
      ctx.setLineDash([5]); // Will be removed after draw()

      ctx.beginPath(); // Fill the area between the bands

      ctx.fillStyle = this.back_color;
      ctx.fillRect(0, upper, layout.width, lower - upper); // Upper band

      ctx.moveTo(0, upper);
      ctx.lineTo(layout.width, upper); // Lower band

      ctx.moveTo(0, lower);
      ctx.lineTo(layout.width, lower);
      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Stoch'];
    },
    data_colors: function data_colors() {
      return [this.color];
    },
    y_range: function y_range(hi, lo) {
      return [Math.max(hi, this.sett.upper || 80), Math.min(lo, this.sett.lower || 20)];
    },
    calc: function calc() {
      return {
        props: {
          param_k: {
            def: 14,
            text: 'K'
          },
          param_d: {
            def: 3,
            text: 'D'
          },
          smooth: {
            def: 3,
            text: 'Smooth'
          }
        },
        update: "\n                    let k = sma(stoch(close, high, low, param_k), smooth)\n                    let d = sma(k, param_d)\n                    return [k[0], d[0]]\n                "
      };
    }
  },
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    k_color: function k_color() {
      return this.sett.kColor || '#3782f2';
    },
    d_color: function d_color() {
      return this.sett.dColor || '#f48709';
    },
    band_color: function band_color() {
      return this.sett.bandColor || '#ddd';
    },
    back_color: function back_color() {
      return this.sett.backColor || '#381e9c16';
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Stoch/Stoch.vue?vue&type=script&lang=js&
 /* harmony default export */ const Stoch_Stochvue_type_script_lang_js_ = (Stochvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Stoch/Stoch.vue
var Stoch_render, Stoch_staticRenderFns
;



/* normalize component */
;
var Stoch_component = normalizeComponent(
  Stoch_Stochvue_type_script_lang_js_,
  Stoch_render,
  Stoch_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Stoch_api; }
Stoch_component.options.__file = "src/overlays/Stoch/Stoch.vue"
/* harmony default export */ const Stoch = (Stoch_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/TSI/TSI.vue?vue&type=script&lang=js&

/* harmony default export */ const TSIvue_type_script_lang_js_ = ({
  name: 'TSI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'True Strength Index',
        preset: {
          name: 'TSI $long $short $signal',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#3bb3e4", "#f7046d"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['TSI'];
    },
    calc: function calc() {
      return {
        props: {
          "long": {
            def: 25,
            text: 'Long Length'
          },
          "short": {
            def: 13,
            text: 'Short Length'
          },
          signal: {
            def: 13,
            text: 'Signal Length'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    let val = tsi(close, short, long)\n                    let sig = ema(val, signal)\n                    return [val[0] * 100, sig[0] * 100]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/TSI/TSI.vue?vue&type=script&lang=js&
 /* harmony default export */ const TSI_TSIvue_type_script_lang_js_ = (TSIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/TSI/TSI.vue
var TSI_render, TSI_staticRenderFns
;



/* normalize component */
;
var TSI_component = normalizeComponent(
  TSI_TSIvue_type_script_lang_js_,
  TSI_render,
  TSI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TSI_api; }
TSI_component.options.__file = "src/overlays/TSI/TSI.vue"
/* harmony default export */ const TSI = (TSI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/TradesPlus/TradesPlus.vue?vue&type=script&lang=js&
function TradesPlusvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = TradesPlusvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function TradesPlusvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TradesPlusvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TradesPlusvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function TradesPlusvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


var CROSS = "m512.001 84.853-84.853-84.853-171.147 171.147-171.148-171.147-84.853\n84.853 171.148 171.147-171.148 171.148 84.853 84.853 171.148-171.147\n171.147 171.147 84.853-84.853-171.148-171.148z";
/* harmony default export */ const TradesPlusvue_type_script_lang_js_ = ({
  name: 'TradesPlus',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1',
        desc: 'Trades overlay with stops'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      ctx.strokeStyle = 'black';

      var _iterator = TradesPlusvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          ctx.fillStyle = p[1] ? this.buy_color : this.sell_color;
          var x = layout.t2screen(p[0]); // x - Mapping

          var y = layout.$2screen(p[2]); // y - Mapping

          if (p[3] === 'Stop') {
            this.draw_cross(ctx, x, y);
          } else {
            this.draw_circle(ctx, x, y);
          }

          if (this.show_label && p[3] && p[3] !== 'Stop') {
            this.draw_label(ctx, x, y, p);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    draw_label: function draw_label(ctx, x, y, p) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(p[3], x, y - 25);
    },
    draw_circle: function draw_circle(ctx, x, y) {
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x, y, this.marker_size + 0.5, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.stroke();
    },
    draw_cross: function draw_cross(ctx, x, y) {
      ctx.save();
      var p = new Path2D(CROSS);
      ctx.lineWidth = 150;
      ctx.translate(x - 5, y - 5);
      ctx.scale(0.0175, 0.0175);
      ctx.stroke(p);
      ctx.fill(p);
      ctx.scale(1, 1);
      ctx.restore();
    },
    use_for: function use_for() {
      return ['TradesPlus'];
    },
    // Defines legend format (values & colors)
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Sell';
          break;

        case 1:
          pos = 'Buy';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.colorText
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    buy_color: function buy_color() {
      return this.sett.buyColor || '#63df89';
    },
    sell_color: function sell_color() {
      return this.sett.sellColor || '#ec4662';
    },
    label_color: function label_color() {
      return this.sett.labelColor || this.colors.text;
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/TradesPlus/TradesPlus.vue?vue&type=script&lang=js&
 /* harmony default export */ const TradesPlus_TradesPlusvue_type_script_lang_js_ = (TradesPlusvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/TradesPlus/TradesPlus.vue
var TradesPlus_render, TradesPlus_staticRenderFns
;



/* normalize component */
;
var TradesPlus_component = normalizeComponent(
  TradesPlus_TradesPlusvue_type_script_lang_js_,
  TradesPlus_render,
  TradesPlus_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TradesPlus_api; }
TradesPlus_component.options.__file = "src/overlays/TradesPlus/TradesPlus.vue"
/* harmony default export */ const TradesPlus = (TradesPlus_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/VWMA/VWMA.vue?vue&type=script&lang=js&

/* harmony default export */ const VWMAvue_type_script_lang_js_ = ({
  name: 'VWMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Volume Weighted Moving Average',
        preset: {
          name: 'VWMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#db0670'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['VWMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return vwma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/VWMA/VWMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const VWMA_VWMAvue_type_script_lang_js_ = (VWMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/VWMA/VWMA.vue
var VWMA_render, VWMA_staticRenderFns
;



/* normalize component */
;
var VWMA_component = normalizeComponent(
  VWMA_VWMAvue_type_script_lang_js_,
  VWMA_render,
  VWMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var VWMA_api; }
VWMA_component.options.__file = "src/overlays/VWMA/VWMA.vue"
/* harmony default export */ const VWMA = (VWMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/WilliamsR/WilliamsR.vue?vue&type=script&lang=js&

/* harmony default export */ const WilliamsRvue_type_script_lang_js_ = ({
  name: 'WilliamsR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Williams %R',
        preset: {
          name: '%R $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#0980e8',
            bandColor: '#aaa',
            backColor: '#9b9ba316',
            upper: -20,
            lower: -80
          }
        }
      };
    },
    use_for: function use_for() {
      return ['WilliamsR'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "\n                    return wpr(length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/WilliamsR/WilliamsR.vue?vue&type=script&lang=js&
 /* harmony default export */ const WilliamsR_WilliamsRvue_type_script_lang_js_ = (WilliamsRvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/WilliamsR/WilliamsR.vue
var WilliamsR_render, WilliamsR_staticRenderFns
;



/* normalize component */
;
var WilliamsR_component = normalizeComponent(
  WilliamsR_WilliamsRvue_type_script_lang_js_,
  WilliamsR_render,
  WilliamsR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var WilliamsR_api; }
WilliamsR_component.options.__file = "src/overlays/WilliamsR/WilliamsR.vue"
/* harmony default export */ const WilliamsR = (WilliamsR_component.exports);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function arrayLikeToArray_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray_arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function unsupportedIterableToArray_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray_arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || unsupportedIterableToArray_unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/primitives/xohlcbar.js



// Ohlc object for Ohlcs overlay
var XOhlcBar = /*#__PURE__*/function () {
  function XOhlcBar(overlay, ctx, data) {
    _classCallCheck(this, XOhlcBar);

    this.ctx = ctx;
    this.self = overlay;
    this.style = data.raw[6] || this.self;

    this._draw(data);
  }

  _createClass(XOhlcBar, [{
    key: "_draw",
    value: function _draw(data) {
      var line_width = this.style.lineWidth;
      var hlc_only = this.style.chartType == "HLC";
      var line_width_half = line_width / 2; // Bar color

      var bar_color = data.c <= data.o ? this.style.upBarColor : this.style.downBarColor;
      var width = Math.max(data.w, 1);
      var halfwidth = Math.max(Math.floor(width * 0.5), 1);
      var height = Math.abs(data.o - data.c);
      var max_h = data.c === data.o ? 1 : 2;
      var s = line_width % 2 === 0 ? 0 : 0.5; // Draw the line from low to high and open and close also

      this.ctx.strokeStyle = bar_color;
      this.ctx.lineWidth = line_width;
      this.ctx.beginPath(); // Draw high to low

      this.ctx.moveTo(Math.floor(data.x - line_width_half) + s, Math.floor(data.h));
      this.ctx.lineTo(Math.floor(data.x - line_width_half) + s, Math.floor(data.l));

      if (width > 1) {
        // Draw open notch
        if (hlc_only) {
          // No open price in consideration
          // Draw open notch with close price
          this.ctx.moveTo(Math.floor(data.x - halfwidth - line_width_half - 1), Math.floor(data.c) - s);
          this.ctx.lineTo(Math.floor(data.x - line_width_half), Math.floor(data.c) - s);
        } else {
          // Draw open notch with open price
          this.ctx.moveTo(Math.floor(data.x - halfwidth - line_width_half - 1), Math.floor(data.o) - s);
          this.ctx.lineTo(Math.floor(data.x - line_width_half), Math.floor(data.o) - s);
        } // Draw close notch


        this.ctx.moveTo(Math.floor(data.x - line_width_half), Math.floor(data.c) - s);
        this.ctx.lineTo(Math.floor(data.x + halfwidth - line_width_half + 1), Math.floor(data.c) - s);
      }

      this.ctx.stroke();
    }
  }]);

  return XOhlcBar;
}();


;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/primitives/xvolbar.js



var XVolbar = /*#__PURE__*/function () {
  function XVolbar(overlay, ctx, data, barData, thinVolumeBar) {
    _classCallCheck(this, XVolbar);

    this.ctx = ctx;
    this.$p = overlay.$props;
    this.self = overlay;
    this.style = data.raw[6] || this.self;

    this._draw(data, barData, thinVolumeBar);
  }

  _createClass(XVolbar, [{
    key: "_draw",
    value: function _draw(data, barData, thinVolumeBar) {
      if (thinVolumeBar) {
        // Thin Volume Bar
        var bar_color = data.green ? this.style.upVolBarColor : this.style.downVolBarColor;
        var line_width = this.style.volBarWidth;
        var line_width_half = line_width / 2;
        var y0 = this.$p.layout.height;
        var w = data.x2 - data.x1;
        var h = Math.floor(data.h);
        this.ctx.strokeStyle = bar_color;
        this.ctx.lineWidth = line_width;
        this.ctx.beginPath(); // Draw high to low

        this.ctx.moveTo(Math.floor(barData.x - line_width_half), Math.floor(y0 - h - 0.5));
        this.ctx.lineTo(Math.floor(barData.x - line_width_half), Math.floor(y0 + 0.5));
        this.ctx.stroke();
      } else {
        // Thick Volume Bar
        var _y = this.$p.layout.height;

        var _w = data.x2 - data.x1;

        var _h = Math.floor(data.h);

        this.ctx.fillStyle = data.green ? this.style.upVolBarColor : this.style.downVolBarColor;
        this.ctx.fillRect(Math.floor(data.x1), Math.floor(_y - _h - 0.5), Math.floor(_w), Math.floor(_h + 1));
      }
    }
  }]);

  return XVolbar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/XOhlcBars/XOhlcBars.vue?vue&type=script&lang=js&


function XOhlcBarsvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = XOhlcBarsvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function XOhlcBarsvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Renedrer for ohlcbar + volume (optional)
// It can be used as the main chart or an indicator



/* harmony default export */ const XOhlcBarsvue_type_script_lang_js_ = ({
  name: 'XOhlcBars',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'X',
        version: '1.3.0',
        desc: 'Bar Chart'
      };
    },
    init: function init() {//this.price = new Price(this) // TODO:
    },
    draw: function draw(ctx) {
      //console.log("XOhlcBar.draw() called. this.$props.data.length = " + this.$props.data.length)
      // render as main chart:
      if (this.$props.sub === this.$props.data) {
        var cnv = {
          ohlcbars: this.$props.layout.candles,
          volume: this.$props.layout.volume
        }; // Else, as offchart / onchart indicator:
      } else {
        cnv = (0,external_trading_vue_js_.layout_cnv)(this);
      }

      if (this.show_volume) {
        for (var i = 0; i < cnv.volume.length; i++) {
          var volumeData = cnv.volume[i];
          var _barData = cnv.ohlcbars[i];
          new XVolbar(this, ctx, volumeData, _barData);
        }
      }

      var _iterator = XOhlcBarsvue_type_script_lang_js_createForOfIteratorHelper(cnv.ohlcbars),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var barData = _step.value;
          new XOhlcBar(this, ctx, barData);
        } //if (this.price_line) this.price.draw(ctx)  // TODO:

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ['XOhlcBars'];
    },
    // When added as offchart overlay
    y_range: function y_range() {
      return [Math.max.apply(Math, _toConsumableArray(this.$props.sub.map(function (x) {
        return x[2];
      }))), Math.min.apply(Math, _toConsumableArray(this.$props.sub.map(function (x) {
        return x[3];
      })))];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    show_volume: function show_volume() {
      return 'showVolume' in this.sett ? this.sett.showVolume : true;
    },
    price_line: function price_line() {
      return 'priceLine' in this.sett ? this.sett.priceLine : true;
    },
    upVolBarColor: function upVolBarColor() {
      return this.sett.upBarColor || "#23a77655";
    },
    downVolBarColor: function downVolBarColor() {
      return this.sett.downBarColor || "#e5415055";
    },
    volBarWidth: function volBarWidth() {
      return this.sett.barWidth || 2;
    },
    upBarColor: function upBarColor() {
      return this.sett.upBarColor || "#23a776";
    },
    downBarColor: function downBarColor() {
      return this.sett.downBarColor || "#e54150";
    },
    barWidth: function barWidth() {
      return this.sett.barWidth || 1;
    },
    hlcOnly: function hlcOnly() {
      return this.sett.hlcOnly || false;
    },
    lineWidth: function lineWidth() {
      return this.sett.lineWidth || 1;
    }
  },
  data: function data() {
    return {
      price: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/XOhlcBars.vue?vue&type=script&lang=js&
 /* harmony default export */ const XOhlcBars_XOhlcBarsvue_type_script_lang_js_ = (XOhlcBarsvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/XOhlcBars.vue
var XOhlcBars_render, XOhlcBars_staticRenderFns
;



/* normalize component */
;
var XOhlcBars_component = normalizeComponent(
  XOhlcBars_XOhlcBarsvue_type_script_lang_js_,
  XOhlcBars_render,
  XOhlcBars_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var XOhlcBars_api; }
XOhlcBars_component.options.__file = "src/overlays/XOhlcBars/XOhlcBars.vue"
/* harmony default export */ const XOhlcBars = (XOhlcBars_component.exports);
;// CONCATENATED MODULE: ./src/index_prod.js
// -------- Production overlay index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// Do not commit this file, the final index is
// compiled by the repo owner, use index_dev.js to
// experiment: 'npm run compile'




































var Pack = {
  ALMA: ALMA,
  ATR: ATR,
  ATRp: ATRp,
  Area51: Area51,
  BB: BB,
  BBW: BBW,
  CCI: CCI,
  CMO: CMO,
  COG: COG,
  DHistogram: DHistogram,
  DMI: DMI,
  EMA: EMA,
  HMA: HMA,
  Histogram: Histogram,
  Ichi: Ichi,
  Ichimoku: Ichimoku,
  KC: KC,
  KCW: KCW,
  LongShortTrades: LongShortTrades,
  MACD: MACD,
  MFI: MFI,
  MOM: MOM,
  Markers: Markers,
  PlotCross: PlotCross,
  ROC: ROC,
  RSI: RSI,
  Ribbon: Ribbon,
  SAR: SAR,
  SMA: SMA,
  SWMA: SWMA,
  Stoch: Stoch,
  TSI: TSI,
  TradesPlus: TradesPlus,
  VWMA: VWMA,
  WilliamsR: WilliamsR,
  XOhlcBars: XOhlcBars
};

if (typeof window !== 'undefined' && window.Vue) {
  window.TvjsOverlays = Pack;
}

/* harmony default export */ const index_prod = (Pack);

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./src/Main.vue":
/*!**********************!*\
  !*** ./src/Main.vue ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Main.vue?vue&type=template&id=3ffae6b2& */ "./src/Main.vue?vue&type=template&id=3ffae6b2&");
/* harmony import */ var _Main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Main.vue?vue&type=script&lang=js& */ "./src/Main.vue?vue&type=script&lang=js&");
/* harmony import */ var _Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Main.vue?vue&type=style&index=0&lang=css& */ "./src/Main.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__.render,
  _Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/Main.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/StdInput.vue":
/*!*************************************!*\
  !*** ./src/components/StdInput.vue ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StdInput.vue?vue&type=template&id=5e1f1c17& */ "./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&");
/* harmony import */ var _StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StdInput.vue?vue&type=script&lang=js& */ "./src/components/StdInput.vue?vue&type=script&lang=js&");
/* harmony import */ var _StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StdInput.vue?vue&type=style&index=0&lang=css& */ "./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.render,
  _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/StdInput.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/Window.vue":
/*!***********************************!*\
  !*** ./src/components/Window.vue ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Window.vue?vue&type=template&id=5b030a20& */ "./src/components/Window.vue?vue&type=template&id=5b030a20&");
/* harmony import */ var _Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Window.vue?vue&type=script&lang=js& */ "./src/components/Window.vue?vue&type=script&lang=js&");
/* harmony import */ var _Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Window.vue?vue&type=style&index=0&lang=css& */ "./src/components/Window.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.render,
  _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/Window.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue":
/*!*************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Splitter.vue?vue&type=template&id=189fccad&scoped=true& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&");
/* harmony import */ var _Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Splitter.vue?vue&type=script&lang=js& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&");
/* harmony import */ var _Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "189fccad",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/grid-resize/Splitter.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue":
/*!**************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AddWin.vue?vue&type=template&id=53408ac7&scoped=true& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&");
/* harmony import */ var _AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddWin.vue?vue&type=script&lang=js& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&");
/* harmony import */ var _AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "53408ac7",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/legend-buttons/AddWin.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue":
/*!*****************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&");
/* harmony import */ var _SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=script&lang=js& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&");
/* harmony import */ var _SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "5d223b0e",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/settings-win/SettingsWin.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/Main.vue?vue&type=script&lang=js&":
/*!***********************************************!*\
  !*** ./src/Main.vue?vue&type=script&lang=js& ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Main.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=script&lang=js&":
/*!**************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=script&lang=js& ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/Window.vue?vue&type=script&lang=js&":
/*!************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=script&lang=js& ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&":
/*!**************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js& ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&":
/*!***************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js& ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&":
/*!******************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js& ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/Main.vue?vue&type=style&index=0&lang=css&":
/*!*******************************************************!*\
  !*** ./src/Main.vue?vue&type=style&index=0&lang=css& ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/style-loader/dist/cjs.js!../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Main.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!**********************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!********************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!**********************************************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");


/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!***********************************************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");


/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!**************************************************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");


/***/ }),

/***/ "./src/Main.vue?vue&type=template&id=3ffae6b2&":
/*!*****************************************************!*\
  !*** ./src/Main.vue?vue&type=template&id=3ffae6b2& ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Main.vue?vue&type=template&id=3ffae6b2& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=template&id=3ffae6b2&");


/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&":
/*!********************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=template&id=5e1f1c17& ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=template&id=5e1f1c17& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&");


/***/ }),

/***/ "./src/components/Window.vue?vue&type=template&id=5b030a20&":
/*!******************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=template&id=5b030a20& ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=template&id=5b030a20& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20&");


/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&":
/*!********************************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true& ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=template&id=189fccad&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&");


/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&":
/*!*********************************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true& ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=template&id=53408ac7&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&");


/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&":
/*!************************************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=template&id=3ffae6b2&":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=template&id=3ffae6b2& ***!
  \********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass:
        "flex-start col-10 col-xll-10 col-xl-10 col-lg-10 col-md-9 col-sm-12",
    },
    [
      _c("div", { attrs: { id: "tvjs-header" } }, [
        _vm._m(0),
        _vm._v(" "),
        _c("a", [
          _c(
            "span",
            {
              staticClass: "me-1 badge bg-light-secondary",
              on: { click: _vm.candles },
            },
            [
              _c("i", { staticClass: "bi bi-bar-chart" }),
              _c("div", { staticClass: "d-md-inline d-none" }, [
                _vm._v("  Candles"),
              ]),
            ]
          ),
        ]),
        _vm._v(" "),
        _c("a", [
          _c(
            "span",
            {
              staticClass: "me-1 badge bg-light-secondary",
              on: { click: _vm.spline },
            },
            [
              _c("i", { staticClass: "bi bi-graph-up" }),
              _c("div", { staticClass: "d-md-inline d-none" }, [
                _vm._v("  Spline"),
              ]),
            ]
          ),
        ]),
        _vm._v(" "),
        _vm._m(1),
        _vm._v(" "),
        _vm._m(2),
        _vm._v(" "),
        _vm._m(3),
      ]),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass:
            "collapse col-lg-4 col-md-5 col-sm-6 position-absolute sticky-top card-110 ",
          attrs: { id: "collapseInfos" },
        },
        [
          _c(
            "div",
            {
              staticClass: "card",
              staticStyle: {
                background: "#131722e6!important",
                "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
              },
            },
            [
              _c("div", { staticClass: "card-header" }, [
                _c("div", { staticClass: "col-md-8" }, [
                  _c("h4", { staticClass: "card-title" }, [
                    _vm._v(
                      "\n                        " +
                        _vm._s(_vm.symbol) +
                        "\n                    "
                    ),
                  ]),
                ]),
              ]),
              _vm._v(" "),
              _vm._m(4),
            ]
          ),
        ]
      ),
      _vm._v(" "),
      _vm._m(5),
      _vm._v(" "),
      _vm._m(6),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "app-container", staticStyle: { "margin-top": "40px" } },
        [
          _c("trading-vue", {
            key: _vm.resetkey,
            ref: "tvjs",
            attrs: {
              data: _vm.dc,
              width: _vm.width,
              height: _vm.height,
              "title-txt": _vm.title,
              "color-title": "#ff9f43",
              "legend-buttons": [
                "display",
                "settings",
                "up",
                "down",
                "add",
                "remove",
              ],
              "chart-config": { DEFAULT_LEN: 60, MIN_ZOOM: 1 },
              toolbar: true,
              "color-back": _vm.colors.colorBack,
              "color-grid": _vm.colors.colorGrid,
              "color-text": _vm.colors.colorText,
              extensions: _vm.ext,
              overlays: _vm.ovs,
              night: _vm.night,
              resetkey: _vm.resetkey,
              "x-settings": _vm.xsett,
              timezone: _vm.timezone,
            },
          }),
        ],
        1
      ),
    ]
  )
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-info",
          attrs: {
            id: "toggleContracts",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseContracts",
            "aria-expanded": "false",
            "aria-controls": "collapseContracts",
          },
        },
        [
          _c("i", { staticClass: "bi bi-briefcase" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [
            _vm._v(" Contracts"),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-info",
          attrs: {
            id: "toggleInfo",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseInfos",
            "aria-expanded": "false",
            "aria-controls": "collapseInfos",
          },
        },
        [
          _c("i", { staticClass: "bi bi-info-circle" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [_vm._v("  Info")]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-primary ",
          attrs: {
            id: "toggleDepth",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseDepth",
            "aria-expanded": "false",
            "aria-controls": "collapseDepth",
          },
        },
        [
          _c("i", { staticClass: "bi bi-kanban" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [
            _vm._v("  Depth View"),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-warning ",
          attrs: {
            id: "toggleOrders",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseOrders",
            "aria-expanded": "false",
            "aria-controls": "collapseOrders",
          },
        },
        [
          _c("i", { staticClass: "bi bi-file-bar-graph" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [
            _vm._v("  Order Book"),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "card-content" }, [
      _c("div", { staticClass: "card-body" }, [
        _c("div", { staticClass: "row" }, [
          _c("div", { staticClass: "col-8" }, [
            _c(
              "div",
              { staticClass: "text-start fs-1", attrs: { id: "show_b" } },
              [
                _vm._v(
                  "\n                                ...\n                            "
                ),
              ]
            ),
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "col-4" }, [
            _c(
              "div",
              {
                staticClass: "text-end",
                staticStyle: { "font-size": "14px" },
                attrs: { id: "show_p" },
              },
              [
                _vm._v(
                  "\n                                ...\n                            "
                ),
              ]
            ),
            _vm._v(" "),
            _c(
              "div",
              {
                staticClass: "text-end",
                staticStyle: { "font-size": "14px" },
                attrs: { id: "show_P" },
              },
              [
                _vm._v(
                  "\n                                ...\n                            "
                ),
              ]
            ),
          ]),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row mt-1" }, [
          _c(
            "div",
            { staticClass: "progress", attrs: { id: "myRangeColor" } },
            [
              _c("div", {
                staticClass:
                  "progress-bar progress-bar-striped progress-bar-animated",
                staticStyle: { width: "80%" },
                attrs: {
                  id: "myRange",
                  role: "progressbar",
                  "aria-valuenow": "50",
                  "aria-valuemin": "0",
                  "aria-valuemax": "100",
                },
              }),
            ]
          ),
        ]),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass:
              "row d-flex justify-content-between align-items-center",
          },
          [
            _c("div", {
              staticClass: "col text-start text-danger",
              staticStyle: { "font-size": "10px" },
              attrs: { id: "show_l" },
            }),
            _vm._v(" "),
            _c(
              "div",
              {
                staticClass: "col text-dark text-center",
                staticStyle: { "font-size": "10px" },
              },
              [
                _vm._v(
                  "\n                            Day Range\n                        "
                ),
              ]
            ),
            _vm._v(" "),
            _c("div", {
              staticClass: "col text-end text-success",
              staticStyle: { "font-size": "10px" },
              attrs: { id: "show_h" },
            }),
          ]
        ),
        _vm._v(" "),
        _c("div", { staticClass: "row mt-1" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Volume 24H"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_v" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Market Cap"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_mc" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Total Supply"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_ts" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
      ]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      {
        staticClass:
          "collapse col-lg-6 col-md-10 col-sm-12 col-12 position-absolute sticky-top card-110 ",
        attrs: { id: "collapseDepth" },
      },
      [
        _c(
          "div",
          {
            staticClass: "card",
            staticStyle: {
              background: "#131722e6!important",
              "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
            },
          },
          [
            _c("div", { staticClass: "card-content" }, [
              _c("div", { attrs: { id: "chartdiv" } }),
            ]),
          ]
        ),
      ]
    )
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      {
        staticClass:
          "collapse col-lg-4 col-md-4 col-sm-6 col-12 position-absolute sticky-top card-110",
        staticStyle: { "max-width": "280px" },
        attrs: { id: "collapseOrders" },
      },
      [
        _c(
          "div",
          {
            staticClass: "card",
            staticStyle: {
              background: "#131722e6!important",
              "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
            },
          },
          [
            _c("div", { staticClass: "card-content my-1" }, [
              _c("div", { staticClass: "box" }, [
                _c("table", [
                  _c("thead", [
                    _c("tr", { staticClass: "mb-1" }, [
                      _c("th", { staticClass: "text-start ps-1 text-dark" }, [
                        _vm._v(
                          "\n                                    Price\n                                "
                        ),
                      ]),
                      _vm._v(" "),
                      _c("th", { staticClass: "text-center ps-1 text-dark" }, [
                        _vm._v(
                          "\n                                    Quantity\n                                "
                        ),
                      ]),
                      _vm._v(" "),
                      _c("th", { staticClass: "text-end pe-1 text-dark" }, [
                        _vm._v(
                          "\n                                    Total\n                                "
                        ),
                      ]),
                    ]),
                  ]),
                ]),
                _vm._v(" "),
                _c("table", { staticClass: "asks" }),
                _vm._v(" "),
                _c("div", { staticClass: "newest" }),
                _vm._v(" "),
                _c("table", { staticClass: "bids" }),
              ]),
            ]),
          ]
        ),
      ]
    )
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17& ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("span", [
    _vm.type === "text" || !_vm.type
      ? _c("input", {
          staticClass: "tvjs-std-input",
          style: _vm.style,
          attrs: { placeholder: _vm.name },
          domProps: { value: _vm.value },
          on: {
            change: function ($event) {
              return _vm.$emit("change", $event.target.value)
            },
            input: function ($event) {
              return _vm.$emit("input", $event.target.value)
            },
          },
        })
      : _vm.type === "select"
      ? _c(
          "select",
          {
            staticClass: "tvjs-std-input",
            style: _vm.style,
            domProps: { value: _vm.value },
            on: {
              input: function ($event) {
                return _vm.$emit("input", $event.target.value)
              },
            },
          },
          _vm._l(_vm.list, function (opt) {
            return _c("option", [_vm._v(_vm._s(opt))])
          }),
          0
        )
      : _vm._e(),
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20&":
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20& ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { ref: "win", staticClass: "tvjs-x-window", style: _vm.style },
    [
      _c("div", { staticClass: "tvjs-x-window-head" }, [
        _c(
          "div",
          {
            staticClass: "tvjs-x-window-title",
            on: { mousedown: _vm.onMouseDown },
          },
          [_vm._v("\n                " + _vm._s(_vm.title) + "\n            ")]
        ),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass: "tvjs-x-window-close",
            on: {
              click: function ($event) {
                return _vm.$emit("close")
              },
            },
          },
          [_vm._v("\n                \n            ")]
        ),
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "tvjs-x-window-body" }, [_vm._t("default")], 2),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&":
/*!***********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true& ***!
  \***********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("span", {
    staticClass: "h-splitter",
    style: _vm.hs_style,
    on: { mousedown: _vm.hs_mousedown },
  })
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "window",
    {
      staticClass: "add-win",
      attrs: { title: "Add Indicator", tv: _vm.tv },
      on: { close: _vm.on_close },
    },
    [
      _c(
        "div",
        { staticClass: "add-win-list" },
        _vm._l(_vm.ovs, function (ov) {
          return _c(
            "div",
            {
              staticClass: "add-win-item",
              on: {
                click: function ($event) {
                  return _vm.on_click(ov.name)
                },
              },
            },
            [
              _c("span", [_vm._v(_vm._s(ov.name))]),
              _vm._v(" "),
              _c("span", { staticClass: "add-win-item-desc" }, [
                _vm._v(
                  "\n                " +
                    _vm._s(ov.methods.meta_info().desc) +
                    "\n            "
                ),
              ]),
            ]
          )
        }),
        0
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&":
/*!***************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& ***!
  \***************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "window",
    {
      staticClass: "sett-win",
      attrs: { title: _vm.data.ov.name, tv: _vm.tv },
      on: { close: _vm.on_close },
    },
    [
      _vm._l(_vm.settlist, function (k) {
        return _c(
          "div",
          { staticClass: "sett-win-item" },
          [
            _c("label", [_vm._v(_vm._s(_vm.s2d(k)))]),
            _vm._v(" "),
            _c("std-input", {
              attrs: { value: _vm.sett[k] },
              on: {
                input: function ($event) {
                  return _vm.update_sett(k, $event)
                },
              },
            }),
          ],
          1
        )
      }),
      _vm._v(" "),
      !_vm.settlist.length
        ? _c("span", { staticClass: "sett-win-empty" }, [
            _c("i", [_vm._v("No script settings")]),
          ])
        : _vm._e(),
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeComponent)
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ( true && customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ( true && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    true
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ( true && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i], vm);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
  if (!valid && haveExpectedTypes) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;

function assertType (value, type, vm) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    try {
      valid = value instanceof type;
    } catch (e) {
      warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
      valid = false;
    }
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

var functionTypeCheckRE = /^\s*function (\w+)/;

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  // check if we need to specify expected value
  if (
    expectedTypes.length === 1 &&
    isExplicable(expectedType) &&
    isExplicable(typeof value) &&
    !isBoolean(expectedType, receivedType)
  ) {
    message += " with value " + (styleValue(value, expectedType));
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + (styleValue(value, receivedType)) + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable (value) {
  return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals. ' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       true && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    var vnode = res && res[0];
    return res && (
      !vnode ||
      (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallbackRender,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes =
      scopedSlotFn(props) ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  } else {
    nodes =
      this.$slots[name] ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
  return eventKeyCode === undefined
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       true && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  // we know it's MountedComponentVNode but flow doesn't
  vnode,
  // activeInstance in lifecycle state
  parent
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     true && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ( true &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
        warn(
          ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
          context
        );
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       true && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : 0
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
    (!newScopedSlots && vm.$scopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : 0;
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       true && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        var info = "callback for watcher \"" + (this.expression) + "\"";
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {}
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     true && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
       true && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ( true && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn(("The computed property \"" + key + "\" is already defined as a method."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if ( true &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      var info = "callback for immediate watcher \"" + (watcher.expression) + "\"";
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {}
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if ( true &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */





function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var entry = cache[key];
    if (entry) {
      var name = entry.name;
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var entry = cache[key];
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  methods: {
    cacheVNode: function cacheVNode() {
      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var vnodeToCache = ref.vnodeToCache;
      var keyToCache = ref.keyToCache;
      if (vnodeToCache) {
        var tag = vnodeToCache.tag;
        var componentInstance = vnodeToCache.componentInstance;
        var componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: getComponentName(componentOptions),
          tag: tag,
          componentInstance: componentInstance,
        };
        keys.push(keyToCache);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
        this.vnodeToCache = null;
      }
    }
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.cacheVNode();
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  updated: function updated () {
    this.cacheVNode();
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        // delay setting the cache until update
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.14';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
       true && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key &&
    a.asyncFactory === b.asyncFactory && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (true) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
  }
}

/*  */



/* eslint-disable no-unused-vars */
function baseWarn (msg, range) {
  console.error(("[Vue compiler]: " + msg));
}
/* eslint-enable no-unused-vars */

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

function addAttr (el, name, value, range, dynamic) {
  var attrs = dynamic
    ? (el.dynamicAttrs || (el.dynamicAttrs = []))
    : (el.attrs || (el.attrs = []));
  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr (el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  isDynamicArg,
  modifiers,
  range
) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker (symbol, name, dynamic) {
  return dynamic
    ? ("_p(" + name + ",\"" + symbol + "\")")
    : symbol + name // mark the event as captured
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn,
  range,
  dynamic
) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
     true && warn &&
    modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.',
      range
    );
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr (
  el,
  name
) {
  return el.rawAttrsMap[':' + name] ||
    el.rawAttrsMap['v-bind:' + name] ||
    el.rawAttrsMap[name]
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

function getAndRemoveAttrByRegex (
  el,
  name
) {
  var list = el.attrsList;
  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];
    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr
    }
  }
}

function rangeSetItem (
  item,
  range
) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }
    if (range.end != null) {
      item.end = range.end;
    }
  }
  return item
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
      "? " + baseValueExpression + ".trim()" +
      ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: JSON.stringify(value),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len, str, chr, index$1, expressionPos, expressionEndPos;



function parseModel (val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead.",
        el.rawAttrsMap['v-model']
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (true) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.',
      el.rawAttrsMap['v-model']
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
    "?_i(" + value + "," + valueBinding + ")>-1" + (
      trueValueBinding === 'true'
        ? (":(" + value + ")")
        : (":_q(" + value + "," + trueValueBinding + ")")
    )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
      "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  if (true) {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(
        binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
        'because the latter already expands to a value binding internally',
        el.rawAttrsMap[binding]
      );
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecessary `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
     true && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if ( true && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if ( true &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        true
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if ( true &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});



function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ( true && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.',
        el.rawAttrsMap['class']
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.',
          el.rawAttrsMap['style']
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being passed as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ( true && !stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
      if ( true && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    // Find the closest opened tag of the same type
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag."),
            { start: stack[i].start, end: stack[i].end }
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;

var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

var slotRE = /^v-slot(:|$)|^#/;

var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /[ \f\t\r\n]+/g;

var invalidAttributeRE = /[\s"'<>\/=]/;

var decodeHTMLCached = cached(he.decode);

var emptySlotScopeToken = "_empty_";

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;
  maybeComponent = function (el) { return !!(
    el.component ||
    el.attrsMap[':is'] ||
    el.attrsMap['v-bind:is'] ||
    !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag))
  ); };
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement (element) {
    trimEndingWhitespace(element);
    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    }
    // tree management
    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (true) {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (true) {
        warnOnce(
          "Component template should contain exactly one root element. " +
          "If you are using v-if on multiple elements, " +
          "use v-else-if to chain them instead.",
          { start: element.start }
        );
      }
    }
    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"'
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }
        currentParent.children.push(element);
        element.parent = currentParent;
      }
    }

    // final children cleanup
    // filter out scoped slots
    element.children = element.children.filter(function (c) { return !(c).slotScope; });
    // remove trailing whitespace node again
    trimEndingWhitespace(element);

    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace (el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;
      while (
        (lastNode = el.children[el.children.length - 1]) &&
        lastNode.type === 3 &&
        lastNode.text === ' '
      ) {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints (el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce(
        "Cannot use <" + (el.tag) + "> as component root element because it may " +
        'contain multiple nodes.',
        { start: el.start }
      );
    }
    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce(
        'Cannot use v-for on stateful component root element because ' +
        'it renders multiple elements.',
        el.rawAttrsMap['v-for']
      );
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start (tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (true) {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated
          }, {});
        }
        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2(
              "Invalid dynamic argument expression: attribute names cannot contain " +
              "spaces, quotes, <, >, / or =.",
              {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
              }
            );
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
         true && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.',
          { start: element.start }
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        if (true) {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end (tag, start, end$1) {
      var element = stack[stack.length - 1];
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      if ( true && options.outputSourceRange) {
        element.end = end$1;
      }
      closeElement(element);
    },

    chars: function chars (text, start, end) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start: start }
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored."),
              { start: start }
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }
      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }
        var res;
        var child;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }
        if (child) {
          if ( true && options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          children.push(child);
        }
      }
    },
    comment: function comment (text, start, end) {
      // adding anything as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };
        if ( true && options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }
        currentParent.children.push(child);
      }
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var list = el.attrsList;
  var len = list.length;
  if (len) {
    var attrs = el.attrs = new Array(len);
    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };
      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (
  element,
  options
) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = (
    !element.key &&
    !element.scopedSlots &&
    !element.attrsList.length
  );

  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
  return element
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (true) {
      if (el.tag === 'template') {
        warn$2(
          "<template> cannot be keyed. Place the key on real elements instead.",
          getRawBindingAttr(el, 'key')
        );
      }
      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;
        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2(
            "Do not use v-for index as key on <transition-group> children, " +
            "this is the same as not using keys.",
            getRawBindingAttr(el, 'key'),
            true /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else if (true) {
      warn$2(
        ("Invalid v-for expression: " + exp),
        el.rawAttrsMap['v-for']
      );
    }
  }
}



function parseFor (exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) { return }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if.",
      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if ( true && children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored.",
          children[i]
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent (el) {
  var slotScope;
  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */
    if ( true && slotScope) {
      warn$2(
        "the \"scope\" attribute for scoped slots have been deprecated and " +
        "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
        "can also be used on plain elements in addition to <template> to " +
        "denote scoped slots.",
        el.rawAttrsMap['scope'],
        true
      );
    }
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
    /* istanbul ignore if */
    if ( true && el.attrsMap['v-for']) {
      warn$2(
        "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
        "(v-for takes higher priority). Use a wrapper <template> for the " +
        "scoped slot to make it clearer.",
        el.rawAttrsMap['slot-scope'],
        true
      );
    }
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }

  // 2.6 v-slot syntax
  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding) {
        if (true) {
          if (el.slotTarget || el.slotScope) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.parent && !maybeComponent(el.parent)) {
            warn$2(
              "<template v-slot> can only appear at the root level inside " +
              "the receiving component",
              el
            );
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding$1) {
        if (true) {
          if (!maybeComponent(el)) {
            warn$2(
              "v-slot can only be used on components or <template>.",
              slotBinding$1
            );
          }
          if (el.slotScope || el.slotTarget) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.scopedSlots) {
            warn$2(
              "To avoid scope ambiguity, the default slot should also use " +
              "<template> syntax when there are other named slots.",
              slotBinding$1
            );
          }
        }
        // add the component's children to its default slot
        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
        // remove children as they are returned from scopedSlots now
        el.children = [];
        // mark el non-plain so data gets generated
        el.plain = false;
      }
    }
  }
}

function getSlotName (binding) {
  var name = binding.name.replace(slotRE, '');
  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (true) {
      warn$2(
        "v-slot shorthand syntax requires a slot name.",
        binding
      );
    }
  }
  return dynamicArgRE.test(name)
    // dynamic [name]
    ? { name: name.slice(1, -1), dynamic: true }
    // static name
    : { name: ("\"" + name + "\""), dynamic: false }
}

// handle <slot/> outlets
function processSlotOutlet (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ( true && el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead.",
        getRawBindingAttr(el, 'key')
      );
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name.replace(dirRE, ''));
      // support .foo shorthand syntax for the .prop modifier
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        if (
           true &&
          value.trim().length === 0
        ) {
          warn$2(
            ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
          );
        }
        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");
            if (!isDynamic) {
              addHandler(
                el,
                ("update:" + (camelize(name))),
                syncGen,
                null,
                false,
                warn$2,
                list[i]
              );
              if (hyphenate(name) !== camelize(name)) {
                addHandler(
                  el,
                  ("update:" + (hyphenate(name))),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i]
                );
              }
            } else {
              // handler w/ dynamic event name
              addHandler(
                el,
                ("\"update:\"+(" + name + ")"),
                syncGen,
                null,
                false,
                warn$2,
                list[i],
                true // dynamic
              );
            }
          }
        }
        if ((modifiers && modifiers.prop) || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
        if ( true && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.',
            list[i]
          );
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]);
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
       true &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead.",
        el.rawAttrsMap['v-model']
      );
    }
    _el = _el.parent;
  }
}

/*  */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + (map['v-bind']) + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

var model$1 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$1
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative
) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";
  for (var name in events) {
    var handlerCode = genHandler(events[name]);
    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }
  staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
  } else {
    return prefix + staticHandlers
  }
}

function genHandler (handler) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value
    }
    return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? ("return " + (handler.value) + ".apply(null, arguments)")
      : isFunctionExpression
        ? ("return (" + (handler.value) + ").apply(null, arguments)")
        : isFunctionInvocation
          ? ("return " + (handler.value))
          : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" +
    (keys.map(genFilterCode).join('&&')) + ")return null;"
  )
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(keyCode)) + "," +
    "$event.key," +
    "" + (JSON.stringify(keyName)) +
    ")"
  )
}

/*  */

function on (el, dir) {
  if ( true && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */





var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  // fix #11483, Root level <script> tags should not be rendered.
  var code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.
  var originalPreState = state.pre;
  if (el.pre) {
    state.pre = el.pre;
  }
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  state.pre = originalPreState;
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
       true && state.warn(
        "v-once can only be used inside v-for that is keyed. ",
        el.rawAttrsMap['v-once']
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if ( true &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      el.rawAttrsMap['v-for'],
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:" + (genProps(el.attrs)) + ",";
  }
  // DOM props
  if (el.props) {
    data += "domProps:" + (genProps(el.props)) + ",";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.
  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
  }
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if ( true && (
    el.children.length !== 1 || ast.type !== 1
  )) {
    state.warn(
      'Inline-template components must have exactly one child element.',
      { start: el.start }
    );
  }
  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  el,
  slots,
  state
) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return (
      slot.slotTargetDynamic ||
      slot.if ||
      slot.for ||
      containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    )
  });

  // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.
  var needsKey = !!el.if;

  // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.
  if (!needsForceUpdate) {
    var parent = el.parent;
    while (parent) {
      if (
        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
        parent.for
      ) {
        needsForceUpdate = true;
        break
      }
      if (parent.if) {
        needsKey = true;
      }
      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots)
    .map(function (key) { return genScopedSlot(slots[key], state); })
    .join(',');

  return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
}

function hash(str) {
  var hash = 5381;
  var i = str.length;
  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }
  return hash >>> 0
}

function containsSlotChild (el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true
    }
    return el.children.some(containsSlotChild)
  }
  return false
}

function genScopedSlot (
  el,
  state
) {
  var isLegacySyntax = el.attrsMap['slot-scope'];
  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null")
  }
  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot)
  }
  var slotScope = el.slotScope === emptySlotScopeToken
    ? ""
    : String(el.slotScope);
  var fn = "function(" + slotScope + "){" +
    "return " + (el.tag === 'template'
      ? el.if && isLegacySyntax
        ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  // reverse proxy v-slot without scope on this.$slots
  var reverseProxy = slotScope ? "" : ",proxy:true";
  return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      var normalizationType = checkSkip
        ? state.maybeComponent(el$1) ? ",1" : ",0"
        : "";
      return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
    }
    var normalizationType$1 = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } else if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? (",function(){return " + children + "}") : '');
  var attrs = el.attrs || el.dynamicAttrs
    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      }); }))
    : null;
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var staticProps = "";
  var dynamicProps = "";
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);
    if (prop.dynamic) {
      dynamicProps += (prop.name) + "," + value + ",";
    } else {
      staticProps += "\"" + (prop.name) + "\":" + value + ",";
    }
  }
  staticProps = "{" + (staticProps.slice(0, -1)) + "}";
  if (dynamicProps) {
    return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
  } else {
    return staticProps
  }
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */



// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode (node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          var range = node.rawAttrsMap[name];
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), warn, range);
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, (name + "=\"" + value + "\""), warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), warn, range);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), warn, range);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent (exp, text, warn, range) {
  var stripped = exp.replace(stripStringRE, '');
  var keywordMatch = stripped.match(unaryOperatorsRE);
  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim()),
      range
    );
  }
  checkExpression(exp, text, warn, range);
}

function checkFor (node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier (
  ident,
  type,
  text,
  warn,
  range
) {
  if (typeof ident === 'string') {
    try {
      new Function(("var " + ident + "=_"));
    } catch (e) {
      warn(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())), range);
    }
  }
}

function checkExpression (exp, text, warn, range) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      warn(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
        range
      );
    } else {
      warn(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n",
        range
      );
    }
  }
}

function checkFunctionParameterExpression (exp, text, warn, range) {
  try {
    new Function(exp, '');
  } catch (e) {
    warn(
      "invalid function parameter expression: " + (e.message) + " in\n\n" +
      "    " + exp + "\n\n" +
      "  Raw expression: " + (text.trim()) + "\n",
      range
    );
  }
}

/*  */

var range = 2;

function generateCodeFrame (
  source,
  start,
  end
) {
  if ( start === void 0 ) start = 0;
  if ( end === void 0 ) end = source.length;

  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];
  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) { continue }
        res.push(("" + (j + 1) + (repeat$1(" ", 3 - String(j + 1).length)) + "|  " + (lines[j])));
        var lineLength = lines[j].length;
        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }
          count += lineLength + 1;
        }
      }
      break
    }
  }
  return res.join('\n')
}

function repeat$1 (str, n) {
  var result = '';
  if (n > 0) {
    while (true) { // eslint-disable-line
      if (n & 1) { result += str; }
      n >>>= 1;
      if (n <= 0) { break }
      str += str;
    }
  }
  return result
}

/*  */



function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (true) {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1(
              "Error compiling template:\n\n" + (e.msg) + "\n\n" +
              generateCodeFrame(template, e.start, e.end),
              vm
            );
          });
        } else {
          warn$$1(
            "Error compiling template:\n\n" + template + "\n\n" +
            compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
            vm
          );
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
        } else {
          compiled.tips.forEach(function (msg) { return tip(msg, vm); });
        }
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if ( true && options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = { msg: msg };
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }
            (tip ? tips : errors).push(data);
          };
        }
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;

      var compiled = baseCompile(template.trim(), finalOptions);
      if (true) {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
     true && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ( true && !template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);


/***/ }),

/***/ "./resources/data/data.json":
/*!**********************************!*\
  !*** ./resources/data/data.json ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ohlcv":[],"offchart":[{"name":"MACD","type":"MACD","data":[],"settings":{"histColors":["#35a776","#79e0b3","#e54150","#ea969e"]}}],"tools":[{"type":"Cursor","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxQTFRFAAAATU1NTU1NTU1NwlMHHwAAAAR0Uk5TAOvhxbpPrUkAAAAkSURBVHicY2BgYHBggAByabxg1WoGBq2pRCk9AKUbcND43AEAufYHlSuusE4AAAAASUVORK5CYII="},{"type":"LineToolSegment","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAlQTFRFAAAATU1NJCQkCxcHIQAAAAN0Uk5TAP8SmutI5AAAACxJREFUeJxjYMACGAMgNAsLdpoVKi8AVe8A1QblQlWRKt0AoULw2w1zGxoAABdiAviQhF/mAAAAAElFTkSuQmCC"},{"type":"LineToolExtended","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAANElEQVR4nGNggABGEMEEIlhABAeI+AASF0AlHmAqA4kzKAAx8wGQuAMKwd6AoYzBAWonAwAcLwTgNfJ3RQAAAABJRU5ErkJggg=="}],"tool":"Cursor"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/main": 0,
/******/ 			"css/base/plugins/extensions/ext-component-media-player": 0,
/******/ 			"css/base/plugins/extensions/ext-component-drag-drop": 0,
/******/ 			"css/base/plugins/extensions/ext-component-context-menu": 0,
/******/ 			"css/base/plugins/charts/chart-apex": 0,
/******/ 			"css/style": 0,
/******/ 			"css-rtl/style-rtl": 0,
/******/ 			"css-rtl/custom-rtl": 0,
/******/ 			"css/overrides": 0,
/******/ 			"css/core": 0,
/******/ 			"css/base/themes/semi-dark-layout": 0,
/******/ 			"css/base/themes/bordered-layout": 0,
/******/ 			"css/base/themes/dark-layout": 0,
/******/ 			"css/base/core/mixins/transitions": 0,
/******/ 			"css/base/core/mixins/main-menu-mixin": 0,
/******/ 			"css/base/core/mixins/hex2rgb": 0,
/******/ 			"css/base/core/mixins/alert": 0,
/******/ 			"css/base/core/menu/menu-types/vertical-overlay-menu": 0,
/******/ 			"css/base/core/menu/menu-types/vertical-menu": 0,
/******/ 			"css/base/core/menu/menu-types/horizontal-menu": 0,
/******/ 			"css/base/core/colors/palette-variables": 0,
/******/ 			"css/base/core/colors/palette-noui": 0,
/******/ 			"css/base/core/colors/palette-gradient": 0,
/******/ 			"css/base/pages/ui-feather": 0,
/******/ 			"css/base/pages/page-profile": 0,
/******/ 			"css/base/pages/page-pricing": 0,
/******/ 			"css/base/pages/page-misc": 0,
/******/ 			"css/base/pages/page-knowledge-base": 0,
/******/ 			"css/base/pages/page-faq": 0,
/******/ 			"css/base/pages/page-coming-soon": 0,
/******/ 			"css/base/pages/page-blog": 0,
/******/ 			"css/base/pages/modal-create-app": 0,
/******/ 			"css/base/pages/dashboard-ecommerce": 0,
/******/ 			"css/base/pages/authentication": 0,
/******/ 			"css/base/pages/app-todo": 0,
/******/ 			"css/base/pages/app-kanban": 0,
/******/ 			"css/base/pages/app-invoice": 0,
/******/ 			"css/base/pages/app-invoice-print": 0,
/******/ 			"css/base/pages/app-invoice-list": 0,
/******/ 			"css/base/pages/app-file-manager": 0,
/******/ 			"css/base/pages/app-email": 0,
/******/ 			"css/base/pages/app-ecommerce": 0,
/******/ 			"css/base/pages/app-ecommerce-details": 0,
/******/ 			"css/base/pages/app-chat": 0,
/******/ 			"css/base/pages/app-chat-list": 0,
/******/ 			"css/base/pages/app-calendar": 0,
/******/ 			"css/base/plugins/ui/coming-soon": 0,
/******/ 			"css/base/plugins/maps/map-leaflet": 0,
/******/ 			"css/base/plugins/forms/pickers/form-pickadate": 0,
/******/ 			"css/base/plugins/forms/pickers/form-flat-pickr": 0,
/******/ 			"css/base/plugins/forms/form-wizard": 0,
/******/ 			"css/base/plugins/forms/form-validation": 0,
/******/ 			"css/base/plugins/forms/form-quill-editor": 0,
/******/ 			"css/base/plugins/forms/form-number-input": 0,
/******/ 			"css/base/plugins/forms/form-file-uploader": 0,
/******/ 			"css/base/plugins/extensions/ext-component-tree": 0,
/******/ 			"css/base/plugins/extensions/ext-component-tour": 0,
/******/ 			"css/base/plugins/extensions/ext-component-toastr": 0,
/******/ 			"css/base/plugins/extensions/ext-component-swiper": 0,
/******/ 			"css/base/plugins/extensions/ext-component-sweet-alerts": 0,
/******/ 			"css/base/plugins/extensions/ext-component-sliders": 0,
/******/ 			"css/base/plugins/extensions/ext-component-ratings": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./src/main.js")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/charts/chart-apex.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-context-menu.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-drag-drop.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-media-player.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-ratings.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-sliders.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-sweet-alerts.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-swiper.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-toastr.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-tour.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-tree.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-file-uploader.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-number-input.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-quill-editor.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-validation.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-wizard.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/pickers/form-flat-pickr.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/pickers/form-pickadate.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/maps/map-leaflet.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/ui/coming-soon.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-calendar.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-chat-list.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-chat.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-ecommerce-details.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-ecommerce.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-email.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-file-manager.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-invoice-list.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-invoice-print.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-invoice.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-kanban.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-todo.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/authentication.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/dashboard-ecommerce.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/modal-create-app.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-blog.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-coming-soon.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-faq.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-knowledge-base.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-misc.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-pricing.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-profile.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/ui-feather.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/colors/palette-gradient.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/colors/palette-noui.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/colors/palette-variables.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/menu/menu-types/horizontal-menu.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/menu/menu-types/vertical-menu.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/menu/menu-types/vertical-overlay-menu.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/mixins/alert.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/mixins/hex2rgb.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/mixins/main-menu-mixin.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/mixins/transitions.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/themes/dark-layout.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/themes/bordered-layout.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/themes/semi-dark-layout.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/core.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/overrides.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/custom-rtl.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/assets/scss/style-rtl.scss")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css-rtl/style-rtl","css-rtl/custom-rtl","css/overrides","css/core","css/base/themes/semi-dark-layout","css/base/themes/bordered-layout","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/assets/scss/style.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSxzREFBc0QsK0JBQW1COztBQUV6RTtBQUNBO0FBQ0EsK0JBQW1COztBQUVuQjtBQUNBLCtCQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGVBQWUsWUFBWTtBQUMzQixZQUFZO0FBQ1osS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRCxzQkFBc0I7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRzs7QUFFckcsaVNBQWlTOztBQUVqUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBcUQ7QUFDM0Q7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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R0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixDQUFDO0FBQ0QsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7Ozs7O0FBT0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7QUFHRCxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsd0JBQXdCO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLFlBQVk7QUFDdkI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7O0FBR0QsQ0FBQztBQUNEO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Qsc0ZBQXNGLFFBQVEsbUVBQW1FLHFKQUFxSixnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLDRCQUE0QixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRWhnQywrRUFBK0UsZ0JBQWdCLDZGQUE2Rix3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFdlcsb0VBQW9FLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFdE07Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FB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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7QUFHRCxDQUFDOzs7QUFHRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7QUFHRCxDQUFDOzs7QUFHRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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QUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUEsNkRBQTZEOztBQUU3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0EsK0NBQStDLCtCQUFtQjtBQUNsRSxDQUFDOztBQUVELENBQUM7Ozs7QUFJRDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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QVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0IsSUFBSSxLQUFLLE1BQU0sSUFBSSxPQUFPLElBQUksT0FBTzs7O0FBRzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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RVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTs7QUFFQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLHNDQUFzQztBQUN0QyxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7QUFFVixRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLElBQUk7QUFDdkIsV0FBVyxRQUFRLElBQUk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtB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QTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSwrQkFBK0IsK0JBQW1CO0FBQ2xELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7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QUFDQSxJQUFJLEtBQUssRUFBRSxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsZUFBZTtBQUMxQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEZBQTBGLGlGQUFpRixXQUFXLHlKQUF5SixnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRS9nQyxtRkFBbUYsZ0JBQWdCLGlHQUFpRyx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFL1csd0VBQXdFLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7O0FBRzFNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULHlGQUF5RixZQUFZLE1BQU0saUlBQWlJO0FBQzVPO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBLENBQUM7QUFDRCxxRkFBcUYsaUZBQWlGLFdBQVcsb0pBQW9KLGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0Isa0JBQWtCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTs7QUFFcmdDLDhFQUE4RSxnQkFBZ0IsNEZBQTRGLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUVyVyxtRUFBbUUsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COzs7QUFHck07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUIsdUJBQXVCOztBQUV2QjtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7QUFDRCwwRkFBMEYsaUZBQWlGLFdBQVcseUpBQXlKLGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0Isa0JBQWtCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTs7QUFFL2dDLG1GQUFtRixnQkFBZ0IsaUdBQWlHLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUUvVyx3RUFBd0UsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COzs7QUFHMU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekMseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtB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QUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFNBQVM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtC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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUVRO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FB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QUFDVCxRQUFRLEtBQUssRUFFTjtBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUyxJQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzRkFBc0Y7QUFDNUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBD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QUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7O0FBRXBEO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLEtBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFxQztBQUN6RDtBQUNBLE1BQU0sQ0FBRTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSix5QkFBeUI7QUFDekI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxLQUFLLEVBRU47QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxJQUFxQztBQUNwRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLCtCQUErQjtBQUMvQixNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxNQUFNLEtBQUssRUFFTjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBLDJDQUEyQyw2QkFBNkI7QUFDeEUsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLE1BQU07QUFDTix5Q0FBeUM7QUFDekMsTUFBTTtBQUNOLHlDQUF5QztBQUN6QyxNQUFNO0FBQ04seUNBQXlDO0FBQ3pDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsNENBQTRDO0FBQzVDLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0Isd0JBQXdCLFdBQVc7QUFDcEY7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCw0Q0FBNEM7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBNEM7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxJQUFJO0FBQ0oseUNBQXlDO0FBQ3pDOztBQUVBLGtDQUFrQyx1Q0FBdUM7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsSUFBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRiw0QkFBNEI7QUFDNUI7QUFDQSwyQkFBMkI7QUFDM0Isd0JBQXdCLGlFQUFpRTtBQUN6RixZQUFZLDBGQUEwRjtBQUN0RyxNQUFNLEtBQUssMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRCxzQkFBc0IsK0NBQStDO0FBQ3JFLGlEQUFpRDs7QUFFakQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwr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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1AsU0FBUztBQUNULFFBQVE7QUFDUixRQUFRO0FBQ1IsT0FBTztBQUNQLFFBQVE7QUFDUjtBQUNBLDJDQUEyQztBQUMzQyw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQSw4Q0FBOEMsNEJBQTRCO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0MsbUZBQW1GLDRCQUE0QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxJQUFxQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGFBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLEdBQUcsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDendYbkI7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLCtCQUErQix3Q0FBd0M7V0FDdkU7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQkFBaUIscUJBQXFCO1dBQ3RDO1dBQ0E7V0FDQSxrQkFBa0IscUJBQXFCO1dBQ3ZDO1dBQ0E7V0FDQSxLQUFLO1dBQ0w7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQzNCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNLHFCQUFxQjtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTs7Ozs7VUU3R0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheXNsaWNlci9saWIvY29tcGFyZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXJyYXlzbGljZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheXNsaWNlci9saWIvc2VhcmNoL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXJyYXlzbGljZXIvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vYnVpbGQvY2hhcnQtbGluay9jaGFydC1saW5rLWRldi5qcyIsIndlYnBhY2s6Ly8vLi9idWlsZC9ncmlkLXJlc2l6ZS9ncmlkLXJlc2l6ZS1kZXYuanMiLCJ3ZWJwYWNrOi8vLy4vYnVpbGQvbGVnZW5kLWJ1dHRvbnMvbGVnZW5kLWJ1dHRvbnMtZGV2LmpzIiwid2VicGFjazovLy8uL2J1aWxkL3NldHRpbmdzLXdpbi9zZXR0aW5ncy13aW4tZGV2LmpzIiwid2VicGFjazovLy9zcmMvTWFpbi52dWUiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZSIsIndlYnBhY2s6Ly8vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlIiwid2VicGFjazovLy9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9BZGRXaW4udnVlIiwid2VicGFjazovLy9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2RyYWdnLmpzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2NoYXJ0LWxpbmsvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9jaGFydC1saW5rL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9jaGFydC1saW5rL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4X2Rldi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RyZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHVmZi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0dWZmL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9NYWluLnZ1ZT83MjZlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZT84M2I1Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1dpbmRvdy52dWU/ZTk3NyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS9TcGxpdHRlci52dWU/MjM0NiIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9BZGRXaW4udnVlPzI5NjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvc2V0dGluZ3Mtd2luL1NldHRpbmdzV2luLnZ1ZT9mMzlmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3Muc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnMuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0cy5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHIuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXIuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWUuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvbi5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZC5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrci5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXQuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb24uc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhci5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdC5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlscy5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludC5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2Uuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC10b2RvLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvbi5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZS5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcC5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLWZhcS5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZS5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmcuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZS5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlci5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudC5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlcy5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnUuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXQuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXQuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvY29yZS5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL292ZXJyaWRlcy5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvY3VzdG9tLXJ0bC5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvc2Nzcy9zdHlsZS1ydGwuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3Njc3Mvc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXguc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudS5zY3NzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXIuc2NzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9NYWluLnZ1ZT8yMjI0Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZT80Y2MxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1dpbmRvdy52dWU/MGMxMCIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS9TcGxpdHRlci52dWU/NmExMyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9BZGRXaW4udnVlPzIyNjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvc2V0dGluZ3Mtd2luL1NldHRpbmdzV2luLnZ1ZT9hYzU2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHJhZGluZy12dWUtanMvZGlzdC90cmFkaW5nLXZ1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHZqcy1vdmVybGF5cy9kaXN0L3R2anMtb3ZlcmxheXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01haW4udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL1NwbGl0dGVyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9BZGRXaW4udnVlIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL01haW4udnVlPzgwOGQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlPzRmYmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZT84MzI3Iiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL1NwbGl0dGVyLnZ1ZT9kYzZkIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWU/MDkxYiIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlPzJhMDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL01haW4udnVlPzcyMzQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlP2RmZWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZT80YmMwIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL1NwbGl0dGVyLnZ1ZT8xZDQ5Iiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWU/OGE4ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlPzg1MzAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9jaHVuayBsb2FkZWQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9qc29ucCBjaHVuayBsb2FkaW5nIiwid2VicGFjazovLy93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovLy93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLyoqXG4gKiBVdGlsaXR5IGNvbXBhcmUgZnVuY3Rpb25zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IDEgaWYgYSA+IGIsIDAgaWYgYSA9IGIsIC0xIGlmIGEgPCBiXG4gICAgICovXG4gICAgbnVtY21wOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAxIGlmIGEgPiBiLCAwIGlmIGEgPSBiLCAtMSBpZiBhIDwgYlxuICAgICAqL1xuICAgIHN0cmNtcDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH1cblxufTtcbiIsIi8qKlxuICogSW5kZXhlZCBBcnJheSBCaW5hcnkgU2VhcmNoIG1vZHVsZVxuICovXG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBjbXAgPSByZXF1aXJlKFwiLi9jb21wYXJlXCIpLFxuICAgIGJpbiA9IHJlcXVpcmUoXCIuL3NlYXJjaC9iaW5hcnlcIik7XG5cbi8qKlxuICogTW9kdWxlIGludGVyZmFjZSBkZWZpbml0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhlZEFycmF5O1xuXG4vKipcbiAqIEluZGV4ZWQgQXJyYXkgY29uc3RydWN0b3JcbiAqXG4gKiBJdCBsb2FkcyB0aGUgYXJyYXkgZGF0YSwgZGVmaW5lcyB0aGUgaW5kZXggZmllbGQgYW5kIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKiB0byBiZSB1c2VkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IGluZGV4IGlzIHRoZSBvYmplY3QncyBwcm9wZXJ0eSB1c2VkIHRvIHNlYXJjaCB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZEFycmF5KGRhdGEsIGluZGV4KSB7XG5cbiAgICAvLyBpcyBkYXRhIHNvcnRhYmxlIGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0P1xuICAgIGlmICghdXRpbC5pc1NvcnRhYmxlQXJyYXlMaWtlKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGFcIik7XG5cbiAgICAvLyBpcyBpbmRleCBhIHZhbGlkIHByb3BlcnR5P1xuICAgIGlmICghaW5kZXggfHwgZGF0YS5sZW5ndGggPiAwICYmICEoaW5kZXggaW4gZGF0YVswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kZXhcIik7XG5cbiAgICAvLyBkYXRhIGFycmF5XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIC8vIG5hbWUgb2YgdGhlIGluZGV4IHByb3BlcnR5XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuXG4gICAgLy8gc2V0IGluZGV4IGJvdW5kYXJ5IHZhbHVlc1xuICAgIHRoaXMuc2V0Qm91bmRhcmllcygpO1xuXG4gICAgLy8gZGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgdGhpcy5jb21wYXJlID0gdHlwZW9mIHRoaXMubWludiA9PT0gXCJudW1iZXJcIiA/IGNtcC5udW1jbXAgOiBjbXAuc3RyY21wO1xuXG4gICAgLy8gZGVmYXVsdCBzZWFyY2ggZnVuY3Rpb25cbiAgICB0aGlzLnNlYXJjaCA9IGJpbi5zZWFyY2g7XG5cbiAgICAvLyBjYWNoZSBvZiBpbmRleCB2YWx1ZXMgdG8gYXJyYXkgcG9zaXRpb25zXG4gICAgLy8gZWFjaCB2YWx1ZSBzdG9yZXMgYW4gb2JqZWN0IGFzIHsgZm91bmQ6IHRydWV8ZmFsc2UsIGluZGV4OiBhcnJheS1pbmRleCB9XG4gICAgdGhpcy52YWxwb3MgPSB7fTtcblxuICAgIC8vIGN1cnNvciBhbmQgYWRqYWNlbnQgcG9zaXRpb25zXG4gICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gY29tcGFyZSBpbmRleCB2YWx1ZXMgdGhhdCByZXR1cm5lcyAxLCAwLCAtMVxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLnNldENvbXBhcmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG5cbiAgICB0aGlzLmNvbXBhcmUgPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzZWFyY2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0byBzZWFyY2ggaW5kZXggdmFsdWVzIGluIHRoZSBhcnJheSBvZiBvYmplY3RzXG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuc2V0U2VhcmNoID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuXG4gICAgdGhpcy5zZWFyY2ggPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCB0aGUgZGF0YSBhcnJheSBieSBpdHMgaW5kZXggcHJvcGVydHlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgLy8gc29ydCB0aGUgYXJyYXlcbiAgICB0aGlzLmRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gc2VsZi5jb21wYXJlKGFbaW5kZXhdLCBiW2luZGV4XSk7XG4gICAgfSk7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBib3VuZGFyeSB2YWx1ZXNcbiAgICB0aGlzLnNldEJvdW5kYXJpZXMoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnNwZWN0IGFuZCBzZXQgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIGludGVybmFsIGRhdGEgYXJyYXlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zZXRCb3VuZGFyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICB0aGlzLm1pbnYgPSBkYXRhLmxlbmd0aCAmJiBkYXRhWzBdW2luZGV4XTtcbiAgICB0aGlzLm1heHYgPSBkYXRhLmxlbmd0aCAmJiBkYXRhW2RhdGEubGVuZ3RoIC0gMV1baW5kZXhdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmRleFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIGRhdGEgaGFzIG9iamVjdHNcbiAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGhpZ2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBjaGVjayB0aGUgcmVxdWVzdCBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiAodGhpcy5jb21wYXJlKHZhbHVlLCB0aGlzLm1pbnYpID09PSAtMSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGhpZ2ggPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29tcGFyZSh2YWx1ZSwgdGhpcy5tYXh2KSA9PT0gMSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IHRoaXMuZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLm5leHRoaWdoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHZhbHBvcyA9IHRoaXMudmFscG9zLFxuICAgICAgICBwb3MgPSB2YWxwb3NbdmFsdWVdO1xuXG4gICAgLy8gaWYgdGhlIHJlcXVlc3QgaXMgbWVtb3JpemVkLCBqdXN0IGdpdmUgaXQgYmFja1xuICAgIGlmIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcy5mb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBwb3MuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5leHRsb3cgPSBwb3MucHJldjtcbiAgICAgICAgICAgIHRoaXMubmV4dGhpZ2ggPSBwb3MubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBpZiBub3QsIGRvIHRoZSBzZWFyY2hcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZWFyY2guY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgdGhpcy5jdXJzb3IgPSByZXN1bHQuaW5kZXg7XG4gICAgdGhpcy5uZXh0bG93ID0gcmVzdWx0LnByZXY7XG4gICAgdGhpcy5uZXh0aGlnaCA9IHJlc3VsdC5uZXh0O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmRleFxuICpcbiAqIFdoZW4gbm8gdmFsdWUgaXMgZ2l2ZW4sIHRoZSBmdW5jdGlvbiB3aWxsIGRlZmF1bHQgdG8gdGhlIGxhc3QgZmV0Y2hlZCBpdGVtLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbmFsXSBpbmRleCBpcyB0aGUgaWQgb2YgdGhlIHJlcXVlc3RlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBmb3VuZCBvYmplY3Qgb3IgbnVsbFxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgdGhpcy5mZXRjaCh2YWx1ZSk7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5jdXJzb3I7XG4gICAgcmV0dXJuIHBvcyAhPT0gbnVsbCA/IHRoaXMuZGF0YVtwb3NdIDogbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGFuIHNsaWNlIG9mIHRoZSBkYXRhIGFycmF5XG4gKlxuICogQm91bmRhcmllcyBoYXZlIHRvIGJlIGluIG9yZGVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYmVnaW4gaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGVuZCBpbmRleCBpcyB0aGUgaWQgb2YgdGhlIHJlcXVlc3RlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBzbGljZSBvZiBkYXRhIGFycmF5IG9yIFtdXG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCkge1xuICAgIC8vIGNoZWNrIGlmIGJvdW5kYXJpZXMgYXJlIGluIG9yZGVyXG4gICAgaWYgKHRoaXMuY29tcGFyZShiZWdpbiwgZW5kKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gZmV0Y2ggc3RhcnQgYW5kIGRlZmF1bHQgdG8gdGhlIG5leHQgaW5kZXggYWJvdmVcbiAgICB0aGlzLmZldGNoKGJlZ2luKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmN1cnNvciB8fCB0aGlzLm5leHRoaWdoO1xuXG4gICAgLy8gZmV0Y2ggZmluaXNoIGFuZCBkZWZhdWx0IHRvIHRoZSBuZXh0IGluZGV4IGJlbG93XG4gICAgdGhpcy5mZXRjaChlbmQpO1xuICAgIHZhciBmaW5pc2ggPSB0aGlzLmN1cnNvciB8fCB0aGlzLm5leHRsb3c7XG5cbiAgICAvLyBpZiBhbnkgYm91bmRhcnkgaXMgbm90IHNldCwgcmV0dXJuIG5vIHJhbmdlXG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGZpbmlzaCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHJhbmdlXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zbGljZShzdGFydCwgZmluaXNoICsgMSk7XG59O1xuIiwiLyoqXG4gKiBCaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBNYWluIHNlYXJjaCByZWN1cnNpdmUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gbG9vcChkYXRhLCBtaW4sIG1heCwgaW5kZXgsIHZhbHBvcykge1xuXG4gICAgLy8gc2V0IGN1cnJlbnQgcG9zaXRpb24gYXMgdGhlIG1pZGRsZSBwb2ludCBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgdmFyIGN1cnIgPSAobWF4ICsgbWluKSA+Pj4gMTtcblxuICAgIC8vIGNvbXBhcmUgY3VycmVudCBpbmRleCB2YWx1ZSB3aXRoIHRoZSBvbmUgd2UgYXJlIGxvb2tpbmcgZm9yXG4gICAgdmFyIGRpZmYgPSB0aGlzLmNvbXBhcmUoZGF0YVtjdXJyXVt0aGlzLmluZGV4XSwgaW5kZXgpO1xuXG4gICAgLy8gZm91bmQ/XG4gICAgaWYgKCFkaWZmKSB7XG4gICAgICAgIHJldHVybiB2YWxwb3NbaW5kZXhdID0ge1xuICAgICAgICAgICAgXCJmb3VuZFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJpbmRleFwiOiBjdXJyLFxuICAgICAgICAgICAgXCJwcmV2XCI6IG51bGwsXG4gICAgICAgICAgICBcIm5leHRcIjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgcG9zaXRpb25zIGF2YWlsYWJsZT9cbiAgICBpZiAobWluID49IG1heCkge1xuICAgICAgICByZXR1cm4gdmFscG9zW2luZGV4XSA9IHtcbiAgICAgICAgICAgIFwiZm91bmRcIjogZmFsc2UsXG4gICAgICAgICAgICBcImluZGV4XCI6IG51bGwsXG4gICAgICAgICAgICBcInByZXZcIjogKGRpZmYgPCAwKSA/IG1heCA6IG1heCAtIDEsXG4gICAgICAgICAgICBcIm5leHRcIjogKGRpZmYgPCAwKSA/IG1heCArIDEgOiBtYXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBjb250aW51ZSBsb29raW5nIGZvciBpbmRleCBpbiBvbmUgb2YgdGhlIHJlbWFpbmluZyBhcnJheSBoYWx2ZXNcbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGNhbiBiZSBza2VwdCBhcyBpbmRleCBpcyBub3QgdGhlcmUuLi5cbiAgICBpZiAoZGlmZiA+IDApXG4gICAgICAgIHJldHVybiBsb29wLmNhbGwodGhpcywgZGF0YSwgbWluLCBjdXJyIC0gMSwgaW5kZXgsIHZhbHBvcyk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gbG9vcC5jYWxsKHRoaXMsIGRhdGEsIGN1cnIgKyAxLCBtYXgsIGluZGV4LCB2YWxwb3MpO1xufVxuXG4vKipcbiAqIFNlYXJjaCBib290c3RyYXBcbiAqIFRoZSBmdW5jdGlvbiBoYXMgdG8gYmUgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIEluZGV4ZWRBcnJheSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc2VhcmNoKGluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgcmV0dXJuIGxvb3AuY2FsbCh0aGlzLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCAtIDEsIGluZGV4LCB0aGlzLnZhbHBvcyk7XG59XG5cbi8qKlxuICogRXhwb3J0IHNlYXJjaCBmdW5jdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5zZWFyY2ggPSBzZWFyY2g7XG4iLCIvKipcbiAqIFV0aWxzIG1vZHVsZVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0XG4gKlxuICogQGNyZWRpdCBKYXZhc2NyaXB0OiBUaGUgRGVmaW5pdGl2ZSBHdWlkZSwgTydSZWlsbHksIDIwMTFcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2Uobykge1xuICAgIGlmIChvICYmICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbyBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmICAgICAgICAgICAgIC8vIG8gaXMgYW4gb2JqZWN0XG4gICAgICAgIGlzRmluaXRlKG8ubGVuZ3RoKSAmJiAgICAgICAgICAgICAgICAvLyBvLmxlbmd0aCBpcyBhIGZpbml0ZSBudW1iZXJcbiAgICAgICAgby5sZW5ndGggPj0gMCAmJiAgICAgICAgICAgICAgICAgICAgIC8vIG8ubGVuZ3RoIGlzIG5vbi1uZWdhdGl2ZVxuICAgICAgICBvLmxlbmd0aCA9PT0gTWF0aC5mbG9vcihvLmxlbmd0aCkgJiYgLy8gby5sZW5ndGggaXMgYW4gaW50ZWdlclxuICAgICAgICBvLmxlbmd0aCA8IDQyOTQ5NjcyOTYpICAgICAgICAgICAgICAgLy8gby5sZW5ndGggPCAyXjMyXG4gICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIG8gaXMgYXJyYXktbGlrZVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBpcyBub3Rcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgc29ydCBmdW5jdGlvbiBpbiB0aGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzU29ydGFibGUobykge1xuICAgIGlmIChvICYmICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbyBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmICAgICAgICAgICAgIC8vIG8gaXMgYW4gb2JqZWN0XG4gICAgICAgIHR5cGVvZiBvLnNvcnQgPT09IFwiZnVuY3Rpb25cIikgICAgICAgIC8vIG8uc29ydCBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIG8gaXMgYXJyYXktbGlrZVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBpcyBub3Rcbn1cblxuLyoqXG4gKiBDaGVjayBmb3Igc29ydGFibGUtYXJyYXktbGlrZSBvYmplY3RzXG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzU29ydGFibGVBcnJheUxpa2UgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvKSAmJiBpc1NvcnRhYmxlKG8pO1xufTtcbiIsIlxuXG4vLyAtLS0tLS0tLSBEZXZlbG9wbWVudCBleHRlbnNpb24gaW5kZXggLS0tLS0tLS0tXG4vLyAgICAgICEgVEhJUyBGSUxFIFdBUyBBVVRPLUdFTkVSQVRFRCAhXG4vL1xuLy8gWW91IGNhbiBvdmVyd3JpdGUgaXQgYW5kIGhhdmUgZnVuLCB0byByZXN0b3JlXG4vLyB0aGUgZGVmYXVsdCBzdGF0ZTogJ25wbSBydW4gY29tcGlsZSdcblxuaW1wb3J0IE1haW4gZnJvbSAnLi4vLi4vc3JjL2V4dGVuc2lvbnMvY2hhcnQtbGluay9tYWluLmpzJ1xuTWFpbi5fX25hbWVfXyA9ICdjaGFydC1saW5rJ1xuXG5jb25zdCB3aWRnZXRzID0geyAgfVxuY29uc3QgY29tcG9uZW50cyA9IHsgIH1cbmNvbnN0IG92ZXJsYXlzID0geyAgfVxuY29uc3QgY29sb3JwYWNrcyA9IHsgIH1cbmNvbnN0IHNraW5zID0geyAgfVxuXG5jb25zdCBQYWNrID0ge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFja1xuXG5leHBvcnQge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn0iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBNYWluIGZyb20gJy4uLy4uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL21haW4uanMnXG5NYWluLl9fbmFtZV9fID0gJ2dyaWQtcmVzaXplJ1xuXG5jb25zdCB3aWRnZXRzID0geyAgfVxuY29uc3QgY29tcG9uZW50cyA9IHsgIH1cbmNvbnN0IG92ZXJsYXlzID0geyAgfVxuY29uc3QgY29sb3JwYWNrcyA9IHsgIH1cbmNvbnN0IHNraW5zID0geyAgfVxuXG5jb25zdCBQYWNrID0ge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFja1xuXG5leHBvcnQge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn0iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBNYWluIGZyb20gJy4uLy4uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL21haW4uanMnXG5NYWluLl9fbmFtZV9fID0gJ2xlZ2VuZC1idXR0b25zJ1xuXG5jb25zdCB3aWRnZXRzID0geyAgfVxuY29uc3QgY29tcG9uZW50cyA9IHsgIH1cbmNvbnN0IG92ZXJsYXlzID0geyAgfVxuY29uc3QgY29sb3JwYWNrcyA9IHsgIH1cbmNvbnN0IHNraW5zID0geyAgfVxuXG5jb25zdCBQYWNrID0ge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFja1xuXG5leHBvcnQge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn0iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBTZXR0aW5nc1dpbiBmcm9tICcuLi8uLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlJ1xuaW1wb3J0IE1haW4gZnJvbSAnLi4vLi4vc3JjL2V4dGVuc2lvbnMvc2V0dGluZ3Mtd2luL21haW4uanMnXG5NYWluLl9fbmFtZV9fID0gJ3NldHRpbmdzLXdpbidcblxuY29uc3Qgd2lkZ2V0cyA9IHsgU2V0dGluZ3NXaW4gfVxuY29uc3QgY29tcG9uZW50cyA9IHsgIH1cbmNvbnN0IG92ZXJsYXlzID0geyAgfVxuY29uc3QgY29sb3JwYWNrcyA9IHsgIH1cbmNvbnN0IHNraW5zID0geyAgfVxuXG5jb25zdCBQYWNrID0ge1xuICAgIHdpZGdldHMsXG4gICAgU2V0dGluZ3NXaW4sXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFja1xuXG5leHBvcnQge1xuICAgIHdpZGdldHMsXG4gICAgU2V0dGluZ3NXaW4sXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn0iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImZsZXgtc3RhcnQgY29sLTEwIGNvbC14bGwtMTAgY29sLXhsLTEwIGNvbC1sZy0xMCBjb2wtbWQtOSBjb2wtc20tMTJcIj5cbiAgICAgICAgPGRpdiBpZD1cInR2anMtaGVhZGVyXCI+XG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cInRvZ2dsZUNvbnRyYWN0c1wiIGNsYXNzPVwibWUtMSBiYWRnZSBiZy1saWdodC1pbmZvXCIgZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVwiI2NvbGxhcHNlQ29udHJhY3RzXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCIgYXJpYS1jb250cm9scz1cImNvbGxhcHNlQ29udHJhY3RzXCI+PGlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmkgYmktYnJpZWZjYXNlXCIgLz48ZGl2IGNsYXNzPVwiZC1tZC1pbmxpbmUgZC1ub25lXCI+IENvbnRyYWN0czwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiB2LW9uOmNsaWNrPVwiY2FuZGxlc1wiIGNsYXNzPVwibWUtMSBiYWRnZSBiZy1saWdodC1zZWNvbmRhcnlcIj48aSBjbGFzcz1cImJpIGJpLWJhci1jaGFydFwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiAgQ2FuZGxlczwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiB2LW9uOmNsaWNrPVwic3BsaW5lXCIgY2xhc3M9XCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXNlY29uZGFyeVwiPjxpIGNsYXNzPVwiYmkgYmktZ3JhcGgtdXBcIiAvPjxkaXYgY2xhc3M9XCJkLW1kLWlubGluZSBkLW5vbmVcIj4gIFNwbGluZTwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cInRvZ2dsZUluZm9cIiBjbGFzcz1cIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1wiIGRhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cIiNjb2xsYXBzZUluZm9zXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCIgYXJpYS1jb250cm9scz1cImNvbGxhcHNlSW5mb3NcIj48aVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJiaSBiaS1pbmZvLWNpcmNsZVwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiAgSW5mbzwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cInRvZ2dsZURlcHRoXCIgY2xhc3M9XCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXByaW1hcnkgXCIgZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVwiI2NvbGxhcHNlRGVwdGhcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIiBhcmlhLWNvbnRyb2xzPVwiY29sbGFwc2VEZXB0aFwiPjxpXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJpIGJpLWthbmJhblwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiAgRGVwdGggVmlldzwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cInRvZ2dsZU9yZGVyc1wiIGNsYXNzPVwibWUtMSBiYWRnZSBiZy1saWdodC13YXJuaW5nIFwiIGRhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIlxuICAgICAgICAgICAgZGF0YS1icy10YXJnZXQ9XCIjY29sbGFwc2VPcmRlcnNcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIiBhcmlhLWNvbnRyb2xzPVwiY29sbGFwc2VPcmRlcnNcIj48aVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJiaSBiaS1maWxlLWJhci1ncmFwaFwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiAgT3JkZXIgQm9vazwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiY29sbGFwc2VJbmZvc1wiXG4gICAgICAgICAgICBjbGFzcz1cImNvbGxhcHNlIGNvbC1sZy00IGNvbC1tZC01IGNvbC1zbS02IHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTAgXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiIHN0eWxlPVwiYmFja2dyb3VuZDojMTMxNzIyZTYhaW1wb3J0YW50O2JveC1zaGFkb3c6IDAgNHB4IDI0cHggMCByZ2IoMCAwIDAgLyAzMCUpO1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cImNhcmQtdGl0bGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyBzeW1ib2wgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtOFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwic2hvd19iXCIgY2xhc3M9XCJ0ZXh0LXN0YXJ0IGZzLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInNob3dfcFwiIGNsYXNzPVwidGV4dC1lbmRcIiBzdHlsZT1cImZvbnQtc2l6ZToxNHB4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwic2hvd19QXCIgY2xhc3M9XCJ0ZXh0LWVuZFwiIHN0eWxlPVwiZm9udC1zaXplOjE0cHg7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgbXQtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJteVJhbmdlQ29sb3JcIiBjbGFzcz1cInByb2dyZXNzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJteVJhbmdlXCIgY2xhc3M9XCJwcm9ncmVzcy1iYXIgcHJvZ3Jlc3MtYmFyLXN0cmlwZWQgcHJvZ3Jlc3MtYmFyLWFuaW1hdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiIGFyaWEtdmFsdWVub3c9XCI1MFwiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIndpZHRoOiA4MCVcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwic2hvd19sXCIgY2xhc3M9XCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhbmdlclwiIHN0eWxlPVwiZm9udC1zaXplOjEwcHg7XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sIHRleHQtZGFyayB0ZXh0LWNlbnRlclwiIHN0eWxlPVwiZm9udC1zaXplOjEwcHg7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERheSBSYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJzaG93X2hcIiBjbGFzcz1cImNvbCB0ZXh0LWVuZCB0ZXh0LXN1Y2Nlc3NcIiBzdHlsZT1cImZvbnQtc2l6ZToxMHB4O1wiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgbXQtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiPlZvbHVtZSAyNEg8L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBpZD1cInNob3dfdlwiIGNsYXNzPVwiY29sIHRleHQtZW5kIHRleHQtd2FybmluZyBjbGVhcmZpeFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiY29sIHRleHQtc3RhcnQgdGV4dC1kYXJrIGNsZWFyZml4XCI+TWFya2V0IENhcDwvc21hbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGlkPVwic2hvd19tY1wiIGNsYXNzPVwiY29sIHRleHQtZW5kIHRleHQtd2FybmluZyBjbGVhcmZpeFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhcmsgY2xlYXJmaXhcIj5Ub3RhbCBTdXBwbHk8L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBpZD1cInNob3dfdHNcIiBjbGFzcz1cImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cImNvbGxhcHNlRGVwdGhcIlxuICAgICAgICAgICAgY2xhc3M9XCJjb2xsYXBzZSBjb2wtbGctNiBjb2wtbWQtMTAgY29sLXNtLTEyIGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwIFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIiBzdHlsZT1cImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJjaGFydGRpdlwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiY29sbGFwc2VPcmRlcnNcIlxuICAgICAgICAgICAgY2xhc3M9XCJjb2xsYXBzZSBjb2wtbGctNCBjb2wtbWQtNCBjb2wtc20tNiBjb2wtMTIgcG9zaXRpb24tYWJzb2x1dGUgc3RpY2t5LXRvcCBjYXJkLTExMFwiIHN0eWxlPVwibWF4LXdpZHRoOjI4MHB4O1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIiBzdHlsZT1cImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1jb250ZW50IG15LTFcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJveFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVwibWItMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwidGV4dC1zdGFydCBwcy0xIHRleHQtZGFya1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwidGV4dC1jZW50ZXIgcHMtMSB0ZXh0LWRhcmtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInRleHQtZW5kIHBlLTEgdGV4dC1kYXJrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG90YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJhc2tzXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZXdlc3RcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwiYmlkc1wiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYXBwLWNvbnRhaW5lclwiIHN0eWxlPVwibWFyZ2luLXRvcDo0MHB4O1wiPlxuICAgICAgICAgICAgPHRyYWRpbmctdnVlIDprZXk9XCJyZXNldGtleVwiIHJlZj1cInR2anNcIiA6ZGF0YT1cImRjXCIgOndpZHRoPVwid2lkdGhcIiA6aGVpZ2h0PVwiaGVpZ2h0XCIgOnRpdGxlLXR4dD1cInRpdGxlXCJcbiAgICAgICAgICAgICAgICBjb2xvci10aXRsZT1cIiNmZjlmNDNcIiA6bGVnZW5kLWJ1dHRvbnM9XCJbJ2Rpc3BsYXknLCAnc2V0dGluZ3MnLCAndXAnLCAnZG93bicsICdhZGQnLCAncmVtb3ZlJ11cIlxuICAgICAgICAgICAgICAgIDpjaGFydC1jb25maWc9XCJ7REVGQVVMVF9MRU46NjAsTUlOX1pPT006MX1cIiA6dG9vbGJhcj1cInRydWVcIiA6Y29sb3ItYmFjaz1cImNvbG9ycy5jb2xvckJhY2tcIlxuICAgICAgICAgICAgICAgIDpjb2xvci1ncmlkPVwiY29sb3JzLmNvbG9yR3JpZFwiIDpjb2xvci10ZXh0PVwiY29sb3JzLmNvbG9yVGV4dFwiIDpleHRlbnNpb25zPVwiZXh0XCIgOm92ZXJsYXlzPVwib3ZzXCJcbiAgICAgICAgICAgICAgICA6bmlnaHQ9XCJuaWdodFwiIDpyZXNldGtleT1cInJlc2V0a2V5XCIgOngtc2V0dGluZ3M9XCJ4c2V0dFwiIDp0aW1lem9uZT1cInRpbWV6b25lXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgVHJhZGluZ1Z1ZSwgRGF0YUN1YmUgfSBmcm9tICd0cmFkaW5nLXZ1ZS1qcydcbmltcG9ydCBPdmVybGF5cyBmcm9tICd0dmpzLW92ZXJsYXlzJ1xuaW1wb3J0IERhdGEgZnJvbSAnLi4vcmVzb3VyY2VzL2RhdGEvZGF0YS5qc29uJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vc3R1ZmYvdXRpbHMuanMnXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9zdHVmZi9jb25zdGFudHMuanMnXG5pbXBvcnQgU3RyZWFtIGZyb20gJy4vc3RyZWFtLmpzJ1xuaW1wb3J0IEV4dGVuc2lvbnMgZnJvbSAnLi9pbmRleF9kZXYnXG5cbi8vIEdldHRpbicgZGF0YSB0aHJvdWdoIHdlYnBlY2sgcHJveHlcbmNvbnN0IHN5bWJvbHNtID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKVszXVxuY29uc3Qgc3ltYm9sYmcgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUudG9VcHBlckNhc2UoKS5zcGxpdCgnLycpWzNdXG5jb25zdCBwYWlyc20gPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnLycpWzRdXG5jb25zdCBwYWlyYmcgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUudG9VcHBlckNhc2UoKS5zcGxpdCgnLycpWzRdXG5jb25zdCBVUkwgPSBgaHR0cHM6Ly9iaW5hbmNlLXdhdGNoLXdyYXBwZXIuaGVyb2t1YXBwLmNvbS9odHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjEva2xpbmVzP3N5bWJvbD1gXG5jb25zdCBXU1MgPSBgd3NzOi8vc3RyZWFtLmJpbmFuY2UuY29tOjk0NDMvd3MvJHtzeW1ib2xzbX0ke3BhaXJzbX1AYWdnVHJhZGVgXG5jb25zdCBkYXRhcyA9IGBkYXRhc2V0cy5iaW5hbmNlLSR7c3ltYm9sc219JHtwYWlyc219YFxuLy9jb25zdCBQT1JUID0gbG9jYXRpb24ucG9ydFxuLy9jb25zdCBVUkwgPSBgaHR0cDovL2xvY2FsaG9zdDoke1BPUlR9L2FwaS92MS9rbGluZXM/c3ltYm9sPWBcbi8vY29uc3QgV1NTID0gYHdzOi8vbG9jYWxob3N0OiR7UE9SVH0vd3MvJHtzeW1ib2xzbX1AYWdnVHJhZGVgXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnQXBwJyxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIFRyYWRpbmdWdWVcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYzogbmV3IERhdGFDdWJlKERhdGEpLFxuICAgICAgICAgICAgdGl0bGU6IHN5bWJvbGJnICsgcGFpcmJnLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBsb2dfc2NhbGU6IHRydWUsXG4gICAgICAgICAgICBzeW1ib2w6IHN5bWJvbGJnICsgcGFpcmJnLFxuICAgICAgICAgICAgaW5kZXhfYmFzZWQ6IHRydWUsXG4gICAgICAgICAgICB0aW1lem9uZTogdGhpcy50aW1lem9uZWQoKSxcbiAgICAgICAgICAgIHhzZXR0OiB7XG4gICAgICAgICAgICAgICAgJ2dyaWQtcmVzaXplJzogeyBtaW5faGVpZ2h0OiAzMCB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3ZzOiBPYmplY3QudmFsdWVzKE92ZXJsYXlzKSxcbiAgICAgICAgICAgIGV4dDogT2JqZWN0LnZhbHVlcyhFeHRlbnNpb25zKSxcbiAgICAgICAgICAgIG5pZ2h0OiB0cnVlLFxuICAgICAgICAgICAgdG9wOiA1MCxcbiAgICAgICAgICAgIHJlc2V0a2V5OiAwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbG9ycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5pZ2h0ID8ge30gOiB7XG4gICAgICAgICAgICAgICAgY29sb3JCYWNrOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgY29sb3JHcmlkOiAnI2VlZScsXG4gICAgICAgICAgICAgICAgY29sb3JUZXh0OiAnIzMzMydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUpXG4gICAgICAgIGxldCBxID0gdGhpcy53aW5fcXVlcnkoKVxuICAgICAgICBpZiAocS5ubSA9PT0gJ2ZhbHNlJykgdGhpcy5uaWdodCA9IGZhbHNlXG4gICAgICAgIGlmIChxLm92KSB0aGlzLmN1cnJlbnQgPSBxLm92XG4gICAgICAgIGlmIChxLmhlYWRlciA9PT0gJ2ZhbHNlJykgdGhpcy50b3AgPSAwXG4gICAgICAgIHRoaXMub25SZXNpemUoKSxcbiAgICAgICAgd2luZG93LmRjID0gdGhpcy5kY1xuICAgICAgICB3aW5kb3cudHYgPSB0aGlzLiRyZWZzLnR2anNcbiAgICAgICAgLy8gTG9hZCB0aGUgbGFzdCBkYXRhIGNodW5rICYgaW5pdCBEYXRhQ3ViZTpcbiAgICAgICAgbGV0IG5vdyA9IFV0aWxzLm5vdygpXG4gICAgICAgIHRoaXMubG9hZF9jaHVuayhbbm93IC0gQ29uc3QuSE9VUjQsIG5vd10pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBkYy5kYXRhLmNoYXJ0LmRhdGEgPSBkYXRhWydjaGFydC5kYXRhJ11cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIG9ucmFuZ2UgY2FsbGJhY2sgJiBBbmQgYSBzdHJlYW0gb2YgdHJhZGVzXG4gICAgICAgICAgICB0aGlzLmRjLm9ucmFuZ2UodGhpcy5sb2FkX2NodW5rKVxuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgU3RyZWFtKFdTUylcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9udHJhZGVzID0gdGhpcy5vbl90cmFkZXNcbiAgICAgICAgICAgIHdpbmRvdy5kYyA9IHRoaXMuY2hhcnQgICAgICAvLyBEZWJ1Z1xuICAgICAgICAgICAgd2luZG93LnR2ID0gdGhpcy4kcmVmcy50dmpzIC8vIERlYnVnXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSlcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB0aGlzLnN0cmVhbS5vZmYoKVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+ICc5OTInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtICh3aW5kb3cuaW5uZXJXaWR0aCAqIDAuMjEpKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+ICc3NjgnICAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8PSAnOTkyJykge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAod2luZG93LmlubmVyV2lkdGggLSAod2luZG93LmlubmVyV2lkdGggKiAwLjI2KSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIDE1KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiAwLjgwXG4gICAgICAgIH0sXG4gICAgICAgIHNwbGluZSAoKSB7XG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudHlwZSA9IFwiU3BsaW5lXCJcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50ZiA9IFwiMW1cIlxuICAgICAgICAgICAgdGhpcy4kcmVmcy50dmpzLnJlc2V0Q2hhcnQoKVxuICAgICAgICB9LFxuICAgICAgICBjYW5kbGVzICgpIHtcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50eXBlID0gXCJDYW5kbGVzXCJcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50ZiA9IFwiMW1cIlxuICAgICAgICAgICAgdGhpcy4kcmVmcy50dmpzLnJlc2V0Q2hhcnQoKVxuICAgICAgICB9LFxuICAgICAgICB4YmFycyAoKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEub3ZzID0gJ1hPaGxjQmFycydcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50ZiA9IFwiMW1cIlxuICAgICAgICAgICAgdGhpcy4kcmVmcy50dmpzLnJlc2V0Q2hhcnQoKVxuICAgICAgICB9LFxuICAgICAgICB0cmFkZSAoKSB7XG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudHlwZSA9IFwiU3BsaW5lXCJcbiAgICAgICAgfSxcbiAgICAgICAgd2luX3F1ZXJ5KCkge1xuICAgICAgICAgICAgbGV0IHFzID0gKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYSA9PSBcIlwiKSByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgdmFyIGIgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHA9YVtpXS5zcGxpdCgnPScsIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJbcFswXV0gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBiW3BbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHBbMV0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfSkod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkuc3BsaXQoJyYnKSk7XG4gICAgICAgICAgICByZXR1cm4gcXNcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoc3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBzdWIgPSBPYmplY3Qua2V5cyhzdGF0ZSkuZmlsdGVyKHggPT4gc3RhdGVbeF0pXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBzdWIubWFwKHggPT4gRXh0ZW5zaW9uc1t4XSlcbiAgICAgICAgICAgIHRoaXMucmVzZXRrZXkrK1xuICAgICAgICB9LFxuICAgICAgICBvbnNlbGVjdChpZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gaWRcbiAgICAgICAgfSxcbiAgICAgICAgdGltZXpvbmVkKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBtaW51dGVzID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBvZmZzZXQgPCAwID8gXCJcIiA6IFwiLVwiO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHByZWZpeCtob3Vycyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5ldyBkYXRhIGhhbmRsZXIuIFNob3VsZCByZXR1cm4gUHJvbWlzZSwgb3JcbiAgICAgICAgLy8gdXNlIGNhbGxiYWNrOiBsb2FkX2NodW5rKHJhbmdlLCB0ZiwgY2FsbGJhY2spXG4gICAgICAgIGFzeW5jIGxvYWRfY2h1bmsocmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBbdDEsIHQyXSA9IHJhbmdlXG4gICAgICAgICAgICBsZXQgeCA9IHN5bWJvbGJnXG4gICAgICAgICAgICBsZXQgeSA9IHBhaXJiZ1xuICAgICAgICAgICAgbGV0IHEgPSBgJHt4fSR7eX0maW50ZXJ2YWw9MW0mc3RhcnRUaW1lPSR7dDF9JmVuZFRpbWU9JHt0Mn1gXG4gICAgICAgICAgICBsZXQgciA9IGF3YWl0IGZldGNoKFVSTCArIHEpLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0aGlzLnBhcnNlX2JpbmFuY2UocikpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBhcnNlIGEgc3BlY2lmaWMgZXhjaGFuZ2UgZm9ybWF0XG4gICAgICAgIHBhcnNlX2JpbmFuY2UoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSByZXR1cm4gW11cbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcCh4ID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeFtpXSA9IHBhcnNlRmxvYXQoeFtpXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguc2xpY2UoMCw2KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0KGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2NoYXJ0LmRhdGEnOiBkYXRhLFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbl90cmFkZXModHJhZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICB0OiB0cmFkZS5ULCAgICAgLy8gRXhjaGFuZ2UgdGltZSAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgcHJpY2U6IHBhcnNlRmxvYXQodHJhZGUucCksICAgLy8gVHJhZGUgcHJpY2VcbiAgICAgICAgICAgICAgICB2b2x1bWU6IHBhcnNlRmxvYXQodHJhZGUucSksICAvLyBUcmFkZSBhbW91bnRcbiAgICAgICAgICAgICAgICBkYXRhcyA6IFsgLy8gVXBkYXRlIGRhdGFzZXRcbiAgICAgICAgICAgICAgICAgICAgdHJhZGUuVCxcbiAgICAgICAgICAgICAgICAgICAgdHJhZGUubSA/IDAgOiAxLCAgICAgICAgICAvLyBTZWxsIG9yIEJ1eVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRyYWRlLnEpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRyYWRlLnApXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyAuLi4gb3RoZXIgb25jaGFydC9vZmZjaGFydCB1cGRhdGVzXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbi5hcHAtY29udGVudCB7XG4gICAgcGFkZGluZzogY2FsYygycmVtICsgMi40NXJlbSkgMCAwIDByZW0gIWltcG9ydGFudDtcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XG59XG5AbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpe1xuICAgIGh0bWwgYm9keS5uYXZiYXItc3RpY2t5IC5hcHAtY29udGVudCB7XG4gICAgICAgIHBhZGRpbmc6IGNhbGMoMXJlbSAtIDAuOHJlbSArIDQuNDVyZW0pIDAgMCAwICFpbXBvcnRhbnQ7XG4gICAgfVxufVxuLmZsZXhlZCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGZsZXgtd3JhcDogbm93cmFwO1xufVxuXG4jYXBwLWNvbmFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgZmxleC13cmFwOiBub3dyYXA7XG59XG5cbi8qIEBtZWRpYSAobWF4LXdpZHRoOiA3NjcuOThweCl7XG4gICAgI2FwcC1jb25haW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGZsZXgtd3JhcDogbm93cmFwO1xuICAgIH1cbn0gKi9cbiN0cmFkZWJhciB7XG4gICAgY29sb3I6ICNkZGQ7XG59XG5cbiN0dmpzLWhlYWRlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgcGFkZGluZy1sZWZ0OiA3MHB4O1xuICAgIGhlaWdodDogNDBweDtcbiAgICBjb2xvcjogI2RkZDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTIxODI2O1xufVxuXG4ubmlnaHQtbW9kZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMTVweDtcbiAgICByaWdodDogMjBweDtcbn1cblxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMC1jYW52YXMsXG4jdHJhZGluZy12dWUtanMtc2lkZWJhci0wLWNhbnZhcyxcbiN0cmFkaW5nLXZ1ZS1qcy1ncmlkLTEtY2FudmFzLFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMS1jYW52YXMsXG4jdHJhZGluZy12dWUtanMtYm90YmFyLWNhbnZhcyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAgMCAwIC8gMCUpICFpbXBvcnRhbnQ7XG59XG5cbiN0cmFkaW5nLXZ1ZS10Yml0ZW0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigxOCwgMjQsIDM4KTtcbn1cblxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LWRldmljZS13aWR0aDogNDgwcHgpIHtcbiAgICAudGYtc2VsZWN0b3Ige1xuICAgICAgICB0b3A6IDUwcHg7XG4gICAgICAgIHJpZ2h0OiAxNDBweDtcbiAgICAgICAgbWF4LXdpZHRoOiAxNDBweDtcbiAgICAgICAgZm9udDogMTJweCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsXG4gICAgICAgICAgICBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLFxuICAgICAgICAgICAgRmlyYSBTYW5zLCBEcm9pZCBTYW5zLCBIZWx2ZXRpY2EgTmV1ZSxcbiAgICAgICAgICAgIHNhbnMtc2VyaWY7XG4gICAgfVxufVxuXG4uYm94IHtcbiAgICB3aWR0aDogMjgwcHg7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gICAgYm94LXNoYWRvdzogMCAxLjVweCA1cHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIHBhZGRpbmc6IDAgMTVweCAwIDE1cHg7XG59XG5cbnRhYmxlIHtcbiAgICBmb250LXNpemU6IDEzcHg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBjb2xvcjogcmdiKDE4MywgMTg5LCAxOTgpO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbnRkIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgaGVpZ2h0OiAyMHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xufVxuXG50ZC5wcmljZSB7XG4gICAgd2lkdGg6IDMwJTtcbn1cblxudGQucHJpY2Ugc3BhbiB7XG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7XG59XG5cbnRkLnF1YW50aXR5IHtcbiAgICB3aWR0aDogMzAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xufVxuXG50ZC50aW1lIHtcbiAgICB3aWR0aDogNDAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIGNvbG9yOiAjOTk5O1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbn1cblxudGQuYnRjIHtcbiAgICB3aWR0aDogNDAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbn1cblxudGQgc3BhbiB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHotaW5kZXg6IDI7XG59XG5cbnRhYmxlLmFza3MgLnBlcmNlbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ2LCA3MCwgOTQsIDAuMik7XG59XG5cbnRhYmxlLmJpZHMgLnBlcmNlbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTQsIDIwMywgMTI5LCAwLjIpO1xufVxuXG50ZCAucGVyY2VudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgcmlnaHQ6IDA7XG59XG5cbi5uZXdlc3Qge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xuICAgIG1hcmdpbjogMTVweCAtMTVweDtcbn1cblxuLmNhcmQtMTEwIHtcbiAgICB0b3A6IDExMHB4ICFpbXBvcnRhbnQ7XG4gICAgbGVmdDogNzBweDtcbn1cbi8qIFN0eWxlIHBhZ2UgY29udGVudCAtIHVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIHB1c2ggdGhlIHBhZ2UgY29udGVudCB0byB0aGUgcmlnaHQgd2hlbiB5b3Ugb3BlbiB0aGUgc2lkZSBuYXZpZ2F0aW9uICovXG4jbWFpbiB7XG4gICAgdHJhbnNpdGlvbjogbWFyZ2luLWxlZnQgLjVzO1xuICAgIC8qIElmIHlvdSB3YW50IGEgdHJhbnNpdGlvbiBlZmZlY3QgKi9cbn1cblxuLyogT24gc21hbGxlciBzY3JlZW5zLCB3aGVyZSBoZWlnaHQgaXMgbGVzcyB0aGFuIDQ1MHB4LCBjaGFuZ2UgdGhlIHN0eWxlIG9mIHRoZSBzaWRlbmF2IChsZXNzIHBhZGRpbmcgYW5kIGEgc21hbGxlciBmb250IHNpemUpICovXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogNDUwcHgpIHtcbiAgICAuc2lkZWJhcjEge1xuICAgICAgICBwYWRkaW5nLXRvcDogMTVweDtcbiAgICB9XG5cbiAgICAuc2lkZWJhcjEgYSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICB9XG59XG5cbi5idG4tY2lyY2xlIHtcbiAgICB3aWR0aDogMzBweDtcbiAgICBoZWlnaHQ6IDMwcHg7XG4gICAgcGFkZGluZzogNnB4IDBweDtcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xuICAgIGZvbnQtc2l6ZTogOHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuI2NoYXJ0ZGl2IHtcbiAgICBtaW4taGVpZ2h0OiAzMDBweDtcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcbiAgICBoZWlnaHQ6IDcwdmg7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxyXG4gICAgPHNwYW4+XHJcbiAgICAgICAgPGlucHV0XG52LWlmPVwidHlwZT09PSd0ZXh0JyB8fCAhdHlwZVwiXHJcbiAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbmNsYXNzPVwidHZqcy1zdGQtaW5wdXRcIlxuOnN0eWxlPVwic3R5bGVcIlxyXG4gICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJuYW1lXCJcclxuICAgICAgICAgICAgQGNoYW5nZT1cIiRlbWl0KCdjaGFuZ2UnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXHJcbiAgICAgICAgICAgIEBpbnB1dD1cIiRlbWl0KCdpbnB1dCcsICRldmVudC50YXJnZXQudmFsdWUpXCJcbj5cclxuICAgICAgICA8c2VsZWN0XG52LWVsc2UtaWY9XCJ0eXBlPT09J3NlbGVjdCdcIlxyXG4gICAgICAgICAgICBjbGFzcz1cInR2anMtc3RkLWlucHV0XCJcbjpzdHlsZT1cInN0eWxlXCJcclxuICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxyXG4gICAgICAgICAgICBAaW5wdXQ9XCIkZW1pdCgnaW5wdXQnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4+XHJcbiAgICAgICAgICAgIDxvcHRpb24gdi1mb3I9XCJvcHQgaW4gbGlzdFwiPnt7IG9wdCB9fTwvb3B0aW9uPlxyXG4gICAgICAgIDwvc2VsZWN0PlxyXG4gICAgPC9zcGFuPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbmFtZTogJ1N0ZElucHV0JyxcclxuICAgIHByb3BzOiBbJ3ZhbHVlJywgJ25hbWUnLCAndHlwZScsICdsaXN0JywgJ2NvbG9ycyddLFxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIHN0eWxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kOiB0aGlzLiRwcm9wcy5jb2xvcnMuYmFjayxcclxuICAgICAgICAgICAgICAgIC8vY29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy50ZXh0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge31cclxufVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuLnR2anMtc3RkLWlucHV0IHtcclxuICAgIG1hcmdpbjogNXB4O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzE2MWIyNztcclxuICAgIGJvcmRlcjogMXB4IGRvdHRlZCAjMzUzOTQwO1xyXG4gICAgaGVpZ2h0OiAyMnB4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xyXG4gICAgcGFkZGluZzogMnB4IDBweCAzcHggMTBweDtcclxuICAgIGNvbG9yOiB3aGl0ZXNtb2tlO1xyXG4gICAgZm9udC1zaXplOiAxLjJlbTtcclxuICAgIG91dGxpbmU6IG5vbmU7XHJcbiAgICB3aWR0aDogMTAwcHg7XHJcbn1cclxuXHJcbnNlbGVjdC50dmpzLXN0ZC1pbnB1dCB7XHJcbiAgICBoZWlnaHQ6IDI5cHg7XHJcbiAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XHJcblxyXG59XHJcblxyXG5zZWxlY3QudHZqcy1zdGQtaW5wdXQgIHtcclxuICAgIC8vZGlzcGxheTogbm9uZTsgLypoaWRlIG9yaWdpbmFsIFNFTEVDVCBlbGVtZW50OiAqL1xyXG59XHJcblxyXG5cclxuLnR2anMtc3RkLWlucHV0OjpwbGFjZWhvbGRlciB7XHJcbiAgICBjb2xvcjogIzhlOTA5YTtcclxuICAgIG9wYWNpdHk6IDAuMjU7XHJcbn1cclxuPC9zdHlsZT5cclxuIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdlxucmVmPVwid2luXCJcbmNsYXNzPVwidHZqcy14LXdpbmRvd1wiXG46c3R5bGU9XCJzdHlsZVwiXG4+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInR2anMteC13aW5kb3ctaGVhZFwiPlxyXG4gICAgICAgICAgICA8ZGl2XG5jbGFzcz1cInR2anMteC13aW5kb3ctdGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgQG1vdXNlZG93bj1cIm9uTW91c2VEb3duXCJcbj5cclxuICAgICAgICAgICAgICAgIHt7IHRpdGxlIH19XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2XG5jbGFzcz1cInR2anMteC13aW5kb3ctY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgQGNsaWNrPVwiJGVtaXQoJ2Nsb3NlJylcIlxuPlxyXG4gICAgICAgICAgICAgICAg4pWzXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0dmpzLXgtd2luZG93LWJvZHlcIj5cclxuICAgICAgICAgICAgPHNsb3QgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5cclxuaW1wb3J0IERyYWdnIGZyb20gJy4vZHJhZ2cuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBuYW1lOiAnV2luZG93JyxcclxuICAgIG1peGluczogW0RyYWdnXSxcclxuICAgIHByb3BzOiBbJ3RpdGxlJywgJ3R2J10sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHd3OiAwLFxyXG4gICAgICAgICAgICB3aDogMCxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIHN0eWxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiBgJHt0aGlzLnl9cHhgLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogYCR7dGhpcy54fXB4YFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0dncoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy50di53aWR0aFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHZoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcHJvcHMudHYuaGVpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoKSB7XHJcbiAgICAgICAgdGhpcy53dyA9IHRoaXMuJHJlZnMud2luLmNsaWVudFdpZHRoXHJcbiAgICAgICAgdGhpcy53aCA9IHRoaXMuJHJlZnMud2luLmNsaWVudEhlaWdodFxyXG4gICAgICAgIHRoaXMueCA9IHRoaXMudHZ3ICogMC41IC0gdGhpcy53dyAqIDAuNVxyXG4gICAgICAgIHRoaXMueSA9IHRoaXMudHZoICogMC41IC0gdGhpcy53aCAqIDAuNVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbi50dmpzLXgtd2luZG93IHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGJhY2tncm91bmQ6ICMxYjIwMmRlZjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbiAgICBwYWRkaW5nLWxlZnQ6IDdweDtcclxuICAgIHotaW5kZXg6IDEwMDtcclxuICAgIGNvbG9yOiAjZGVkZGRkO1xyXG59XHJcbi50dmpzLXgtd2luZG93LWhlYWQge1xyXG4gICAgZm9udC1zaXplOiAyZW07XHJcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xyXG4gICAgZmxleC13cmFwOiBub3dyYXA7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XHJcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgaGVpZ2h0OiAzNnB4O1xyXG4gICAgcGFkZGluZzogMTBweDtcclxuICAgIGN1cnNvcjogZ3JhYjtcclxufVxyXG5cclxuLnR2anMteC13aW5kb3ctYm9keSB7XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG4gICAgZm9udC1zaXplOiAxLjFlbTtcclxufVxyXG4udHZqcy14LXdpbmRvdy10aXRsZSB7XHJcbiAgICB3aWR0aDogMzAwcHg7XHJcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxufVxyXG4udHZqcy14LXdpbmRvdy1jbG9zZSB7XHJcbiAgICB3aWR0aDogMjZweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIG1hcmdpbjogLTFlbTtcclxuICAgIHBhZGRpbmc6IDFlbTtcclxuICAgIGZvbnQtc2l6ZTogMC43NWVtO1xyXG59XHJcbjwvc3R5bGU+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICAgIDxzcGFuXG5jbGFzcz1cImgtc3BsaXR0ZXJcIlxyXG4gICAgICAgIDpzdHlsZT1cImhzX3N0eWxlXCJcbkBtb3VzZWRvd249XCJoc19tb3VzZWRvd25cIlxuLz5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbmFtZTogJ1NwbGl0dGVyJyxcclxuICAgIHByb3BzOiBbJ2lkJywgJ21haW4nLCAnZGMnLCAndHYnLCAnZGF0YSddLFxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBoc19zdHlsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRyYWc6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuZGF0YS5ncmlkMi5vZmZzZXQgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY29sb3JzLnNwbGl0dGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoKSB7XHJcbiAgICAgICAgdGhpcy5NSU5fSEVJR0hUID0gdGhpcy5kYXRhLnNldHQubWluX2hlaWdodCB8fCAyMFxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBoc19tb3VzZWRvd24oZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHMnLFxyXG4gICAgICAgICAgICAgICAgeTogZS5jbGllbnRZLFxyXG4gICAgICAgICAgICAgICAgaDE6IHRoaXMuZGF0YS5ncmlkMS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBoMjogdGhpcy5kYXRhLmdyaWQyLmhlaWdodFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFV0aWxzLmFkZF9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcsIGBib2R5ICoge1xyXG4gICAgICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLnRyYWRpbmctdnVlLWNoYXJ0IHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgICAgICB9YClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzX21vdXNldXAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXHJcbiAgICAgICAgICAgIFV0aWxzLnJlbV9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoc19tb3VzZW1vdmUoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2ZmID0gZS5jbGllbnRZIC0gdGhpcy5kcmFnLnlcclxuICAgICAgICAgICAgICAgIGxldCBuZXdfaDEgPSB0aGlzLmRyYWcuaDEgKyBvZmZcclxuICAgICAgICAgICAgICAgIGxldCBuZXdfaDIgPSB0aGlzLmRyYWcuaDIgLSBvZmZcclxuICAgICAgICAgICAgICAgIGlmIChuZXdfaDEgPiB0aGlzLk1JTl9IRUlHSFQgJiZcclxuICAgICAgICAgICAgICAgICAgICBuZXdfaDIgPiB0aGlzLk1JTl9IRUlHSFQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZ3JpZDEuaGVpZ2h0ID0gbmV3X2gxXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmdyaWQyLmhlaWdodCA9IG5ld19oMlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNhbGNfaGVpZ2h0cygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzX21vdXNlbGVhdmUoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXHJcbiAgICAgICAgICAgIFV0aWxzLnJlbV9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGUgc2NvcGVkPlxyXG4uaC1zcGxpdHRlciB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBsZWZ0OiAwO1xyXG4gICAgaGVpZ2h0OiA1cHg7XHJcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICB6LWluZGV4OiAxO1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNlZTRhZmI1O1xyXG4gICAgb3BhY2l0eTogMDtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbn1cclxuLmgtc3BsaXR0ZXI6aG92ZXIge1xyXG4gICAgY3Vyc29yOiByb3ctcmVzaXplO1xyXG4gICAgb3BhY2l0eTogMTtcclxufVxyXG48L3N0eWxlPlxyXG4iLCI8dGVtcGxhdGU+XG4gICAgPHdpbmRvdyB0aXRsZT1cIkFkZCBJbmRpY2F0b3JcIiBjbGFzcz1cImFkZC13aW5cIiA6dHY9XCJ0dlwiIEBjbG9zZT1cIm9uX2Nsb3NlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhZGQtd2luLWxpc3RcIj5cbiAgICAgICAgICAgIDxkaXYgdi1mb3I9XCJvdiBvZiBvdnNcIiBjbGFzcz1cImFkZC13aW4taXRlbVwiIEBjbGljaz1cIm9uX2NsaWNrKG92Lm5hbWUpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4+e3sgb3YubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFkZC13aW4taXRlbS1kZXNjXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IG92Lm1ldGhvZHMubWV0YV9pbmZvKCkuZGVzYyB9fVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L3dpbmRvdz5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuXG5pbXBvcnQgV2luZG93IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvV2luZG93LnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdBZGRXaW4nLFxuICAgIGNvbXBvbmVudHM6IHsgV2luZG93IH0sXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG92czogdGhpcy50di5vdmVybGF5cy5maWx0ZXIoeCA9PiB4Lm1ldGhvZHMuY2FsYylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2V0dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm92LnNldHRpbmdzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIG9uX2Nsb3NlKCkge1xuICAgICAgICAgICAgdGhpcy4kcHJvcHMubWFpbi5yZW1vdmVfd2lkZ2V0KHRoaXMuJHByb3BzLmlkKVxuICAgICAgICB9LFxuICAgICAgICBvbl9jbGljayhuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm9uX2Nsb3NlKClcbiAgICAgICAgICAgIHRoaXMubWFpbi5hZGRfb3ZlcmxheSh7XG4gICAgICAgICAgICAgICAgc2lkZTogdGhpcy5kYXRhLnR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZGF0YS5pbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlOiBuYW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGUgc2NvcGVkPlxuLnR2anMteC13aW5kb3cuYWRkLXdpbiB7XG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xufVxuLmFkZC13aW4tbGlzdCB7XG4gICAgaGVpZ2h0OiAzMDBweDtcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBDaHJvbWUsIFNhZmFyaSBhbmQgT3BlcmEgKi9cbi5hZGQtd2luLWxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLyogSGlkZSBzY3JvbGxiYXIgZm9yIElFLCBFZGdlIGFuZCBGaXJlZm94ICovXG4uYWRkLXdpbi1saXN0IHtcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAgLyogSUUgYW5kIEVkZ2UgKi9cbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lOyAgLyogRmlyZWZveCAqL1xufVxuLmFkZC13aW4taXRlbSB7XG4gICAgY29sb3I6ICNmZmZmZmY4ODtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwYWRkaW5nOiA1cHg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuLmFkZC13aW4taXRlbTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogIzg4ODg4ODIyO1xuICAgIGNvbG9yOiAjZmZmZmZmZmY7XG59XG4uYWRkLXdpbi1pdGVtLWRlc2Mge1xuICAgIGNvbG9yOiAjZmZmZmZmMzM7XG4gICAgbWFyZ2luLWxlZnQ6IDNweDtcbn1cbi5hZGQtd2luLWl0ZW06aG92ZXIgLmFkZC13aW4taXRlbS1kZXNjIHtcbiAgICBjb2xvcjogI2ZmZmZmZjQ0O1xufVxuLmFkZC13aW4tZW1wdHkge1xuICAgIG9wYWNpdHk6IDAuNTtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPHdpbmRvdyA6dGl0bGU9XCJkYXRhLm92Lm5hbWVcIiBjbGFzcz1cInNldHQtd2luXCIgOnR2PVwidHZcIiBAY2xvc2U9XCJvbl9jbG9zZVwiPlxuICAgICAgICA8ZGl2IHYtZm9yPVwiayBpbiBzZXR0bGlzdFwiIGNsYXNzPVwic2V0dC13aW4taXRlbVwiPlxuICAgICAgICAgICAgPGxhYmVsPnt7IHMyZChrKSB9fTwvbGFiZWw+XG4gICAgICAgICAgICA8c3RkLWlucHV0IDp2YWx1ZT1cInNldHRba11cIiBAaW5wdXQ9XCJ1cGRhdGVfc2V0dChrLCAkZXZlbnQpXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxzcGFuIHYtaWY9XCIhc2V0dGxpc3QubGVuZ3RoXCIgY2xhc3M9XCJzZXR0LXdpbi1lbXB0eVwiPlxuICAgICAgICAgICAgPGk+Tm8gc2NyaXB0IHNldHRpbmdzPC9pPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC93aW5kb3c+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cblxuaW1wb3J0IFdpbmRvdyBmcm9tICcuLi8uLi9jb21wb25lbnRzL1dpbmRvdy52dWUnXG5pbXBvcnQgU3RkSW5wdXQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9TdGRJbnB1dC52dWUnXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdTZXR0aW5nc1dpbicsXG4gICAgY29tcG9uZW50czogeyBXaW5kb3csIFN0ZElucHV0IH0sXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2V0dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm92LnNldHRpbmdzXG4gICAgICAgIH0sXG4gICAgICAgIHNldHRsaXN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0dCkuZmlsdGVyKHggPT5cbiAgICAgICAgICAgICAgICB4WzBdICE9PSAnJCcgJiYgdGhpcy5zZXR0LiRwcm9wcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dC4kcHJvcHMuaW5jbHVkZXMoeCkpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHMyZChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5zZXR0MmRlc2Moc3RyKVxuICAgICAgICB9LFxuICAgICAgICBvbl9jbG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJHByb3BzLm1haW4ucmVtb3ZlX3dpZGdldCh0aGlzLiRwcm9wcy5pZClcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlX3NldHQoaywgdmFsKSB7XG4gICAgICAgICAgICBsZXQgZGNpZCA9IHRoaXMuJHByb3BzLmRhdGEub3YuaWRcblxuICAgICAgICAgICAgbGV0IHZhbE4gPSBwYXJzZUZsb2F0KHZhbClcbiAgICAgICAgICAgIGlmICh2YWxOICE9PSB2YWxOKSB2YWxOID0gdmFsXG5cbiAgICAgICAgICAgIHRoaXMuJHByb3BzLmRjLm1lcmdlKGAke2RjaWR9LnNldHRpbmdzYCxcbiAgICAgICAgICAgICAgICB7IFtrXTogdmFsTiB9XG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZSBzY29wZWQ+XG4udHZqcy14LXdpbmRvdy5zZXR0LXdpbiB7XG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xufVxuLnNldHQtd2luLWl0ZW0ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG4uc2V0dC13aW4taXRlbSBsYWJlbCB7XG4gICAgbWluLXdpZHRoOiA4MHB4O1xuICAgIGNvbG9yOiAjMzVhNzc2O1xufVxuLnNldHQtd2luLWVtcHR5IHtcbiAgICBvcGFjaXR5OiAwLjU7XG59XG48L3N0eWxlPlxuIiwiZXhwb3J0IGRlZmF1bHQgIHtcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBvbk1vdXNlRG93bihlKSB7XHJcbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudFxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICAgICAgdGhpcy5kcmFnLm9mZnNldF94ID0gZS5jbGllbnRYIC0gdGhpcy54XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZy5vZmZzZXRfeSA9IGUuY2xpZW50WSAtIHRoaXMueVxyXG4gICAgICAgICAgICBkb2N1bWVudC5vbm1vdXNldXAgPSB0aGlzLnN0b3BkcmFnXHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gdGhpcy5vbmRyYWdcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvbmRyYWcoZSkge1xyXG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnRcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgIHRoaXMueCA9IGUuY2xpZW50WCAtIHRoaXMuZHJhZy5vZmZzZXRfeFxyXG4gICAgICAgICAgICB0aGlzLnkgPSAgZS5jbGllbnRZIC0gdGhpcy5kcmFnLm9mZnNldF95XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3RvcGRyYWcoKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IG51bGxcclxuICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZHJhZzoge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0X3g6IDAsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRfeTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIlxyXG4vKiBFeGFtcGxlOlxyXG5cclxucnVsZXM6IHtcclxuICAgICcqIC0+IConOiB7fSwgICAgIC8vIEZyb20gZWFjaCB0byBlYWNoXHJcbiAgICAnKic6IHsgICAgICAgICAgICAvLyBUaGUgc2FtZSBhcyBeXHJcbiAgICAgICAgY3Vyc29yOiB0cnVlLCAvLyBib29sLCAnWCcsICdZJywgJ1hZJ1xyXG4gICAgICAgIHBvc2l0aW9uOiAnWCcsIC8vIGJvb2wsICdYJywgJ1knLCAnWFknXHJcbiAgICAgICAgdG9vbHM6IHRydWVcclxuICAgIH0sXHJcbiAgICAndHJhZGluZy12dWUtMSAtPiB0cmFkaW5nLXZ1ZS0yJzoge1xyXG4gICAgICAgIGRhdGE6IFtcclxuICAgICAgICAgICAgJ29uY2hhcnQuU01BJyxcclxuICAgICAgICAgICAgJ1JTSTRIJyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogJ2NoYXJ0LmRhdGEnLFxyXG4gICAgICAgICAgICAgICAgdG86ICdkYXRhc2V0cycsXHJcbiAgICAgICAgICAgICAgICBvYmo6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogJ3NtYWxsLXRmLWRhdGEnLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTb3VyY2VEYXRhJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgICdub25lJzoge1xyXG4gICAgICAgIHJhbmdlOiAnWCcsIC8vIGJvb2wsICdYJywgJ1knLCAnWFknXHJcbiAgICB9XHJcbn1cclxuKi9cclxuXHJcbmltcG9ydCBTaGFyZWQgZnJvbSAnLi9zaGFyZWQuanMnXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiB7XHJcblxyXG4gICAgY29uc3RydWN0b3IodHYsIGRjLCBzZXR0KSB7XHJcblxyXG4gICAgICAgIGlmIChzZXR0LnVzZV93aW5kb3cpIHtcclxuICAgICAgICAgICAgaWYgKCF3aW5kb3cueGNoYXJ0bGluayQpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy54Y2hhcnRsaW5rJCA9IHt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaGFyZWQgPSB3aW5kb3cueGNoYXJ0bGluayRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZCA9IFNoYXJlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50diA9IHR2XHJcbiAgICAgICAgdGhpcy5kYyA9IGRjXHJcbiAgICAgICAgdGhpcy5zZXR0ID0gc2V0dFxyXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IHt9XHJcblxyXG4gICAgICAgIHRoaXMub25zZXR0aW5ncyh7J2NoYXJ0LWxpbmsnOiBzZXR0fSlcclxuICAgIH1cclxuXHJcbiAgICBvbnNldHRpbmdzKGFsbCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0X2lkKVxyXG4gICAgICAgIHRoaXMuc2V0dCA9IGFsbFsnY2hhcnQtbGluayddXHJcbiAgICAgICAgaWYgKCF0aGlzLnNoYXJlZC5ydWxlcykge1xyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZC5ydWxlcyA9IHt9XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkLnJlZnMgPSB7fVxyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZC5tZXRhID0ge31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudHYuaWQpXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNldHQucnVsZXMgJiYgZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFyZWQucnVsZXNbdGhpcy50di5pZF0gPSB0aGlzLnNldHQucnVsZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcmVkLnJlZnNbdGhpcy50di5pZF0gPSB0aGlzLnR2XHJcblxyXG4gICAgICAgIHRoaXMuY29tYmluZSgpXHJcbiAgICAgICAgdGhpcy5yZXNldF9pZCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXNldCgpKVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBDb21iaW5lIHJ1bGVzIGZyb20gZGlmZmVyZW50IGluc3RhbmNlc1xyXG4gICAgY29tYmluZSgpIHtcclxuICAgICAgICB0aGlzLnNoYXJlZC5jb21iaW5lZCA9IHt9XHJcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zaGFyZWQucnVsZXMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnNoYXJlZC5ydWxlc1tpZF0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLmNvbWJpbmVkW3JdID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZC5ydWxlc1tpZF1bcl1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21waWxlIHJ1bGVzIGZvciB0aGlzIGluc3RhbmNlXHJcbiAgICBjb21waWxlKCkge1xyXG5cclxuICAgICAgICBsZXQgZ2ViY24gPSAnZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSdcclxuICAgICAgICBsZXQgZWxzID0gWy4uLmRvY3VtZW50W2dlYmNuXSgndHJhZGluZy12dWUnKV1cclxuICAgICAgICB0aGlzLnRhcmdldHMgPSB7fVxyXG5cclxuICAgICAgICBmb3IgKGxldCBlbCBvZiBlbHMpIHtcclxuICAgICAgICAgICAgaWYgKGVsLmlkID09PSB0aGlzLnR2LmlkKSBjb250aW51ZVxyXG4gICAgICAgICAgICB0aGlzLnRhcmdldHNbZWwuaWRdID0ge31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBydWxlcyA9IHRoaXMucmFuayh0aGlzLnNoYXJlZC5jb21iaW5lZClcclxuXHJcbiAgICAgICAgZm9yICh2YXIgciBvZiBydWxlcykge1xyXG4gICAgICAgICAgICBsZXQgZHN0ID0gci5wYWlyWzFdXHJcbiAgICAgICAgICAgIGlmIChkc3QgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgZHN0ID0gT2JqZWN0LmtleXModGhpcy50YXJnZXRzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRzdCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGQgb2YgZHN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZCBpbiB0aGlzLnRhcmdldHMpKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50YXJnZXRzW2RdLCByLnIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShkc3QgaW4gdGhpcy50YXJnZXRzKSkgY29udGludWVcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50YXJnZXRzW2RzdF0sIHIucilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWxlY3QsIHJhbmsgJiBzb3J0IHRoZSBydWxlc1xyXG4gICAgcmFuayhydWxlcykge1xyXG4gICAgICAgIGxldCBvdXQgPSBbXVxyXG4gICAgICAgIGZvciAodmFyIHIgaW4gcnVsZXMpIHtcclxuICAgICAgICAgICAgbGV0IHBhaXIgPSB0aGlzLnNwbGl0cihyKVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hlcyhwYWlyWzBdKSkgY29udGludWVcclxuICAgICAgICAgICAgaWYgKHBhaXJbMF0gPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmsgPSAyMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFpclswXSkgKSB7XHJcbiAgICAgICAgICAgICAgICByYW5rID0gMTBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJhbmsgPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhaXJbMV0gPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgcmFuayArPSAyXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYWlyWzFdKSApIHtcclxuICAgICAgICAgICAgICAgIHJhbmsgKz0gMVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmFuayArPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LnB1c2goe3BhaXIsIHJhbmssIHI6IHJ1bGVzW3JdfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dC5zb3J0KChhLCBiKSA9PiBiLnJhbmsgLSBhLnJhbmspXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHNvdXJjZSBvZiBhIHJ1bGUgbWF0Y2hlcyB0di5pZFxyXG4gICAgbWF0Y2hlcyhzcmMpIHtcclxuICAgICAgICByZXR1cm4gc3JjID09PSAnKicgfHwgc3JjID09PSB0aGlzLnR2LmlkIHx8XHJcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHNyYykgJiYgc3JjLmluY2x1ZGVzKHRoaXMudHYuaWQpKVxyXG4gICAgfVxyXG5cclxuICAgIHNwbGl0cihydWxlKSB7XHJcbiAgICAgICAgaWYgKHJ1bGUudHJpbSgpID09PSAnKicpIHJldHVybiBbJyonLCAnKiddXHJcbiAgICAgICAgcmV0dXJuIHJ1bGUuc3BsaXQoJy0+JykubWFwKHggPT4ge1xyXG4gICAgICAgICAgICBsZXQgdHVwID0geC5zcGxpdCgnLCcpXHJcbiAgICAgICAgICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1cC5tYXAoeSA9PiB5LnRyaW0oKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geC50cmltKClcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSBhbGwgcnVsZXMgZm9yIHRoaXMgaW5zdGFuY2VcclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY29tcGlsZSgpXHJcblxyXG4gICAgICAgIC8vIEVuYWJsZSBzb21lIGNoYXJ0IGhvb2sgZXZlbnRzXHJcbiAgICAgICAgdGhpcy50di4kcmVmcy5jaGFydC5ob29rcygneGNoYW5nZWQnKVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy50di4kd2F0Y2goeCA9PiB0aGlzLmRjLmdldCgnLicpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4LnNldHRpbmdzLiRzdGF0ZSksXHJcbiAgICAgICAgICAgIHRoaXMub250b29scy5iaW5kKHRoaXMpKVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBMaXN0ZW5pbmcgdG8gdGhlIENoYXJ0LnZ1ZSBob29rcyAmXHJcbiAgICAvLyBvdGhlciBldmVudHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoIChlLmV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJz94LWNoYW5nZWQnOlxyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUuYXJnc1swXVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5wcmV2ZW50RGVmYXVsdCkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBsZXQgbWFpbiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuX2xheW91dC5ncmlkc1tjdXJzb3IuZ3JpZF9pZF1cclxuICAgICAgICAgICAgICAgIGxldCBtYyA9IHRoaXMudHYuJHJlZnMuY2hhcnQuY3Vyc29yXHJcbiAgICAgICAgICAgICAgICBjdXJzb3IudCA9IG1jLnRcclxuICAgICAgICAgICAgICAgIGN1cnNvci4kID0gbWMueSRcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMudGFyZ2V0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByID0gdGhpcy50YXJnZXRzW2lkXS5jdXJzb3JcclxuICAgICAgICAgICAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZyA9IHR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHNbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHh4ID0gdGhpcy5pc1gocilcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHl5ID0gZy5pZCA9PT0gbWFpbi5pZCAmJiB0aGlzLmlzWShyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4eCA/IGcudDJzY3JlZW4oY3Vyc29yLnQpIDogLTEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogeXkgPyBnLiQyc2NyZWVuKGN1cnNvci4kKSA6IC0xMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRfaWQ6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0di4kcmVmcy5jaGFydC5jdXJzb3JfY2hhbmdlZCh1cGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LiRyZWZzLmNoYXJ0LmN1cnNvci50ID0geHggPyBjdXJzb3IudCA6IC0xMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0di4kcmVmcy5jaGFydC5jdXJzb3IueSQgPSB5eSA/IGN1cnNvci4kIDogLTEwXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAncmFuZ2UtY2hhbmdlZCc6XHJcbiAgICAgICAgICAgICAgICBsZXQgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKClcclxuICAgICAgICAgICAgICAgIGxldCBtZXRhID0gdGhpcy5zaGFyZWQubWV0YVt0aGlzLnR2LmlkXVxyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhLnBvc2l0aW9uLmxvY2sgPiBub3cpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZS5hcmdzWzBdXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnRhcmdldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IHRoaXMudGFyZ2V0c1tpZF0ucG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4eCA9IHRoaXMuaXNYKHIpXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHl5ID0gdGhpcy5pc1kocilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVkLm1ldGFbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdID0ge31cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgYW4gaW5maW5pdGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdLnBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NrOiBub3cgKyAxMDBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHh4KSB0di5nb3RvKHJhbmdlWzFdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb250b29scyhuLCBwKSB7XHJcbiAgICAgICAgbGV0IHJlbSA9IFV0aWxzLnJlbW92ZWQoXHJcbiAgICAgICAgICAgIG4ubWFwKHggPT4geC5zZXR0aW5ncy4kdXVpZCksXHJcbiAgICAgICAgICAgIHAubWFwKHggPT4geC5zZXR0aW5ncy4kdXVpZClcclxuICAgICAgICApXHJcbiAgICAgICAgbGV0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLnNoYXJlZC5tZXRhW3RoaXMudHYuaWRdXHJcbiAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS50b29scykge1xyXG4gICAgICAgICAgICBpZiAobWV0YS50b29scy5sb2NrID4gbm93KSByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy50YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIGxldCByID0gdGhpcy50YXJnZXRzW2lkXS50b29sc1xyXG4gICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlZC5tZXRhW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdID0ge31cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIGFuIGluZmluaXRlIGxvb3BcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdLnRvb2xzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2s6IG5vdyArIDEwMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5X3Rvb2xzKG4sIHR2KVxyXG4gICAgICAgICAgICAgICAgcmVtLmZvckVhY2gociA9PiB0di5kYXRhLmRlbChgJHtyfWApKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvcHlfdG9vbHMobiwgdHYpIHtcclxuICAgICAgICBmb3IgKHZhciB0b29sIG9mIG4pIHtcclxuICAgICAgICAgICAgaWYgKHRvb2wuaWQuaW5jbHVkZXMoJ29mZmNoYXJ0JykpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGxldCB1dWlkID0gdG9vbC5zZXR0aW5ncy4kdXVpZFxyXG4gICAgICAgICAgICBsZXQgZXhpID0gdHYuZGF0YS5nZXRfb25lKGAke3V1aWR9YClcclxuICAgICAgICAgICAgaWYgKGV4aSkge1xyXG4gICAgICAgICAgICAgICAgdHYuJHNldChleGksICdzZXR0aW5ncycsIFV0aWxzLmNvcHkoXHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbC5zZXR0aW5ncyxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZWxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZTogJ2ZpbmlzaGVkJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBhZGQgYSBwcm9wZXIgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBhY2Nlc3Npbmcgb3ZlcmxheXNcclxuICAgICAgICAgICAgICAgIGxldCBvdnMgPSB0di4kcmVmcy5jaGFydC4kcmVmcy5zZWNbMF1cclxuICAgICAgICAgICAgICAgICAgICAuJHJlZnMuZ3JpZFxyXG4gICAgICAgICAgICAgICAgICAgIC4kY2hpbGRyZW4uZmlsdGVyKHggPT4geC50b29sKVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG92IG9mIG92cykge1xyXG4gICAgICAgICAgICAgICAgICAgIG92LnBpbnMuZm9yRWFjaCh4ID0+IHgucmVfaW5pdCgpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gVXRpbHMuY29weSh0b29sKVxyXG4gICAgICAgICAgICAgICAgY29weS5zZXR0aW5ncy4kc2VsZWN0ZWQgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgY29weS5zZXR0aW5ncy4kc3RhdGUgPSAnZmluaXNoZWQnXHJcbiAgICAgICAgICAgICAgICB0di5kYXRhLmFkZCgnb25jaGFydCcsIGNvcHkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaXNYKHJ1bGUpIHtcclxuICAgICAgICByZXR1cm4gcnVsZSA9PT0gdHJ1ZSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHJ1bGUgPT09ICdzdHJpbmcnICYmIHJ1bGUuaW5jbHVkZXMoJ1gnKSlcclxuICAgIH1cclxuXHJcbiAgICBpc1kocnVsZSkge1xyXG4gICAgICAgIHJldHVybiBydWxlID09PSB0cnVlIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgcnVsZSA9PT0gJ3N0cmluZycgJiYgcnVsZS5pbmNsdWRlcygnWScpKVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuLy8gIE9iamVjdCBzaGFyZWQgYmVldHdlZW4gdHZqcyBpbnN0YW5jZXNcclxuXHJcbmNsYXNzIFNoYXJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9faWRfXyA9IE1hdGgucmFuZG9tKClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IFNoYXJlZCgpXHJcbiIsImV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgICBjb3B5KG9iaiwgbW9kKSB7XHJcbiAgICAgICAgbGV0IGNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29weSwgbW9kKVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVkKGlkcywgcHJldikge1xyXG4gICAgICAgIGxldCBsaXN0ID0gW11cclxuICAgICAgICBmb3IgKHZhciBpZCBvZiBwcmV2KSB7XHJcbiAgICAgICAgICAgIGlmICghaWRzLmluY2x1ZGVzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKGlkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0XHJcbiAgICB9XHJcbn1cclxuIiwiXG4vLyBFeHRlbnNpb24ncyBjb250cm9sbGVyXG5cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAndHJhZGluZy12dWUtanMnXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBTcGxpdHRlciBmcm9tICcuL1NwbGl0dGVyLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0diwgZGMsIHNldHQpIHtcblxuICAgICAgICB0aGlzLndpZGdldHMgPSB7fVxuICAgICAgICB0aGlzLnR2ID0gdHZcbiAgICAgICAgdGhpcy5kYyA9IGRjXG4gICAgICAgIHRoaXMuc2V0dCA9IHNldHRcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgdGhpcy50di4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAnbW91c2Vtb3ZlJywgdGhpcy5vbm1vdXNlbW92ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMudHYuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgJ21vdXNldXAnLCB0aGlzLm9ubW91c2V1cC5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMudHYuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgJ21vdXNlbGVhdmUnLCB0aGlzLm9ubW91c2VsZWF2ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMucGxhY2Vfc3BsaXR0ZXJzKClcbiAgICAgICAgICAgIHRoaXMuY2FsY19oZWlnaHRzKClcblxuICAgICAgICAgICAgLy8gVHJhY2sgY2hhbmdlcyBvZiBncmlkcyBjb3VudFxuICAgICAgICAgICAgdGhpcy50di4kd2F0Y2goeCA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZGMuZ2V0KCcuJykubWFwKHggPT4geC5pZCksXG4gICAgICAgICAgICAgICAgdGhpcy5vbmdyaWRzLmJpbmQodGhpcykpXG5cbiAgICAgICAgfSlcblxuICAgIH1cblxuICAgIC8vIExpc3RlbnMgdG8gYWxsIHR2anMgZXZlbnRzLCBjcmVhdGVzIG5ldyB3aWRnZXRzXG4gICAgdXBkYXRlKGUpIHtcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9uIHNldHRpbmdzIGhhcyBjaGFuZ2VkXG4gICAgb25zZXR0aW5ncyhzZXR0KSB7fVxuXG4gICAgb25ncmlkcygpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZV93aWRnZXRzKClcbiAgICAgICAgICAgIHRoaXMucGxhY2Vfc3BsaXR0ZXJzKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBvbm1vdXNlbW92ZShlKSB7XG4gICAgICAgIC8vIExpc3Qgb2Ygd2lkZ2V0cyBjcmVhdGVkIGJ5IHRoaXMgY29udHJvbGxlclxuICAgICAgICBsZXQgbGlzdCA9IHRoaXMudHYuJHJlZnMud2lkZ2V0cy4kY2hpbGRyZW5cbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4Lm1haW4gPT09IHRoaXMpXG5cbiAgICAgICAgZm9yICh2YXIgcyBvZiBsaXN0KSB7XG4gICAgICAgICAgICBzLmhzX21vdXNlbW92ZShlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25tb3VzZXVwKGUpIHtcbiAgICAgICAgLy8gTGlzdCBvZiB3aWRnZXRzIGNyZWF0ZWQgYnkgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy50di4kcmVmcy53aWRnZXRzLiRjaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgubWFpbiA9PT0gdGhpcylcblxuICAgICAgICBmb3IgKHZhciBzIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIHMuaHNfbW91c2V1cChlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25tb3VzZWxlYXZlKGUpIHtcbiAgICAgICAgLy8gTGlzdCBvZiB3aWRnZXRzIGNyZWF0ZWQgYnkgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy50di4kcmVmcy53aWRnZXRzLiRjaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgubWFpbiA9PT0gdGhpcylcblxuICAgICAgICBmb3IgKHZhciBzIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIHMuaHNfbW91c2VsZWF2ZShlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGxhY2Vfc3BsaXR0ZXJzKCkge1xuICAgICAgICBsZXQgZ3JpZHMgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncmlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGcxID0gZ3JpZHNbaS0xXVxuICAgICAgICAgICAgbGV0IGcyID0gZ3JpZHNbaV1cbiAgICAgICAgICAgIGxldCBpZCA9IGBTcGxpdHRlci0ke2cxLmlkfS0ke2cyLmlkfS0ke1V0aWxzLnV1aWQyKCl9YFxuICAgICAgICAgICAgVnVlLnNldCh0aGlzLndpZGdldHMsIGlkLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGNsczogU3BsaXR0ZXIsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBncmlkMTogZzEsXG4gICAgICAgICAgICAgICAgICAgIGdyaWQyOiBnMixcbiAgICAgICAgICAgICAgICAgICAgc2V0dDogdGhpcy5zZXR0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGNfaGVpZ2h0cygpIHtcbiAgICAgICAgbGV0IGhzID0gW11cbiAgICAgICAgZm9yICh2YXIgZyBvZiB0aGlzLnR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHMpIHtcbiAgICAgICAgICAgIGhzLnB1c2goZy5oZWlnaHQpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1bSA9IGhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApXG4gICAgICAgIGhzID0gaHMubWFwKGggPT4gaCAvIHN1bSlcbiAgICAgICAgdGhpcy5ncmlkX292cygpLmZvckVhY2goKG92LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW92LmdyaWQpIHtcbiAgICAgICAgICAgICAgICBWdWUuc2V0KG92LCAnZ3JpZCcsIHt9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVnVlLnNldChvdi5ncmlkLCAnaGVpZ2h0JywgaHNbaV0gfHwgMSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBHcmlkIGRlZmluaW5nIG92ZXJsYXlzXG4gICAgZ3JpZF9vdnMoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gW3RoaXMuZGMuZGF0YS5jaGFydF1cbiAgICAgICAgZm9yICh2YXIgb3Ygb2YgdGhpcy5kYy5kYXRhLm9mZmNoYXJ0KSB7XG4gICAgICAgICAgICBpZiAoIW92LmdyaWQgfHwgb3YuZ3JpZC5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKG92KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0XG4gICAgfVxuXG4gICAgcmVtb3ZlX3dpZGdldHMoKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMud2lkZ2V0cykge1xuICAgICAgICAgICAgdGhpcy50di4kZGVsZXRlKHRoaXMud2lkZ2V0cywgaWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNlbW92ZScsIHRoaXMub25tb3VzZW1vdmVcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNldXAnLCB0aGlzLm1vdXNldXBcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNlbGVhdmUnLCB0aGlzLm1vdXNlbGVhdmVcbiAgICAgICAgKVxuICAgIH1cblxufVxuIiwiZXhwb3J0IGRlZmF1bHQge1xyXG5cclxuICAgIGFkZF9zdHlsZShpZCwgc3R5bGUpIHtcclxuXHJcbiAgICAgICAgdmFyIHN0YnIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcclxuICAgICAgICBpZiAoc3Ricikge1xyXG4gICAgICAgICAgICB2YXIgc2hlZXRQYXJlbnQgPSBzdGJyLnBhcmVudE5vZGVcclxuICAgICAgICAgICAgc2hlZXRQYXJlbnQucmVtb3ZlQ2hpbGQoc3RicilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcclxuICAgICAgICBzaGVldC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZClcclxuICAgICAgICBzaGVldC5pbm5lckhUTUwgPSBzdHlsZVxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2hlZXQpXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbV9zdHlsZShpZCwgc3R5bGUpIHtcclxuICAgICAgICB2YXIgc3RiciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxyXG4gICAgICAgIGlmIChzdGJyKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGVldFBhcmVudCA9IHN0YnIucGFyZW50Tm9kZVxyXG4gICAgICAgICAgICBzaGVldFBhcmVudC5yZW1vdmVDaGlsZChzdGJyKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiXHJcbi8vIEV4dGVuc2lvbidzIGNvbnRyb2xsZXJcclxuXHJcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAndHJhZGluZy12dWUtanMnXHJcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5pbXBvcnQgQWRkV2luIGZyb20gJy4vQWRkV2luLnZ1ZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR2LCBkYywgc2V0dCkge1xyXG5cclxuICAgICAgICB0aGlzLndpZGdldHMgPSB7fVxyXG4gICAgICAgIHRoaXMudHYgPSB0dlxyXG4gICAgICAgIHRoaXMuZGMgPSBkY1xyXG4gICAgICAgIHRoaXMuc2V0dCA9IHNldHRcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlzdGVucyB0byBhbGwgdHZqcyBldmVudHMsIGNyZWF0ZXMgbmV3IHdpZGdldHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGVnZW5kLWJ1dHRvbi1jbGljayc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uYnV0dG9uKGUuYXJnc1swXSlcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25idXR0b24oZSkge1xyXG4gICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZ2V0KGUudHlwZSlbZS5kYXRhSW5kZXhdXHJcbiAgICAgICAgbGV0IG9uY2hhcnQgPSB0aGlzLmRjLmRhdGEub25jaGFydFxyXG4gICAgICAgIGxldCBvZmZjaGFydCA9IHRoaXMuZGMuZGF0YS5vZmZjaGFydFxyXG4gICAgICAgIGlmICghb3YpIHJldHVyblxyXG4gICAgICAgIHN3aXRjaChlLmJ1dHRvbikge1xyXG4gICAgICAgICAgICBjYXNlICdkaXNwbGF5JzpcclxuICAgICAgICAgICAgICAgIGlmIChvdi5zZXR0aW5ncy5kaXNwbGF5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZyA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSAhb3Yuc2V0dGluZ3MuZGlzcGxheVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50di4kc2V0KG92LnNldHRpbmdzLCAnZGlzcGxheScsIGZsYWcpXHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICBjYXNlICd1cCc6XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnb2ZmY2hhcnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YUluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZmNoYXJ0LnNwbGljZShlLmRhdGFJbmRleCwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25jaGFydC5wdXNoKG92KVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gb2ZmY2hhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkwID0gZS5kYXRhSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkxID0gZS5kYXRhSW5kZXgtMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2kwXSA9IGRhdGEuc3BsaWNlKGkxLCAxLCBkYXRhW2kwXSlbMF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAnZG93bic6XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnb25jaGFydCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaCA9IHRoaXMuYXZnX2dyaWRfaChvZmZjaGFydClcclxuICAgICAgICAgICAgICAgICAgICBvbmNoYXJ0LnNwbGljZShlLmRhdGFJbmRleCwgMSlcclxuICAgICAgICAgICAgICAgICAgICBvZmZjaGFydC51bnNoaWZ0KG92KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldChvdiwgJ2dyaWQnLCB7aGVpZ2h0OiBofSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBvZmZjaGFydC5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG9mZmNoYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YUluZGV4IDwgbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkwID0gZS5kYXRhSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkxID0gZS5kYXRhSW5kZXgrMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2kwXSA9IGRhdGEuc3BsaWNlKGkxLCAxLCBkYXRhW2kwXSlbMF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAnYWRkJzpcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gYEFkZFdpbi0ke1V0aWxzLnV1aWQyKCl9YFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZGF0YVtlLnR5cGVdW2UuZGF0YUluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0gT2JqZWN0LnZhbHVlcyh0aGlzLndpZGdldHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHggPT4geC5kYXRhLm92ID09PSBvdilcclxuICAgICAgICAgICAgICAgICAgICBpZihmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGYuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldCh0aGlzLndpZGdldHMsIGlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLCBjbHM6IEFkZFdpbiwgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Y6IG92LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGUuZGF0YUluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLmRhdGFbZS50eXBlXS5zcGxpY2UoZS5kYXRhSW5kZXgsIDEpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsbGVkIGZyb20gQWRkV2luLnZ1ZVxyXG4gICAgYWRkX292ZXJsYXkoZSkge1xyXG4gICAgICAgIGxldCBwcmVzZXQgPSB0aGlzLmdldF9wcmVzZXQoZS50eXBlKSB8fCB7fVxyXG4gICAgICAgIGlmIChwcmVzZXQuc2lkZSkgZS5zaWRlID0gcHJlc2V0LnNpZGVcclxuICAgICAgICBsZXQgb25jaGFydCA9IHRoaXMuZGMuZGF0YS5vbmNoYXJ0XHJcbiAgICAgICAgbGV0IG9mZmNoYXJ0ID0gdGhpcy5kYy5kYXRhLm9mZmNoYXJ0XHJcbiAgICAgICAgaWYgKGUuc2lkZSA9PT0gJ29uY2hhcnQnKSB7XHJcbiAgICAgICAgICAgIG9uY2hhcnQuc3BsaWNlKGUuaW5kZXgrMSwgMCwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogcHJlc2V0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBwcmVzZXQuc2V0dGluZ3MgfHwge31cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgaCA9IHRoaXMuYXZnX2dyaWRfaChvZmZjaGFydClcclxuICAgICAgICAgICAgb2ZmY2hhcnQuc3BsaWNlKGUuaW5kZXgrMSwgMCwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogcHJlc2V0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBwcmVzZXQuc2V0dGluZ3MgfHwge30sXHJcbiAgICAgICAgICAgICAgICBncmlkOiB7aGVpZ2h0OiBofVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBwcmVzZXQgKGRlZmF1bHQgc2V0dGluZ3MsIGNvbG9ycykgaWYgZGVmaW5lZFxyXG4gICAgZ2V0X3ByZXNldCh0eXBlKSB7XHJcbiAgICAgICAgbGV0IHByb3RvID0gdGhpcy50di5vdmVybGF5cy5maW5kKHggPT4geC5uYW1lID09PSB0eXBlKVxyXG4gICAgICAgIGlmIChwcm90byAmJiBwcm90by5tZXRob2RzLm1ldGFfaW5mbykge1xyXG4gICAgICAgICAgICBsZXQgbWV0YSA9IHByb3RvLm1ldGhvZHMubWV0YV9pbmZvKClcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGEucHJlc2V0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dGVuc2lvbiBzZXR0aW5ncyBoYXMgY2hhbmdlZFxyXG4gICAgb25zZXR0aW5ncyhzZXR0KSB7fVxyXG5cclxuICAgIGF2Z19ncmlkX2gob3ZzKSB7XHJcbiAgICAgICAgaWYgKCFvdnMubGVuZ3RoKSByZXR1cm4gMC4yNVxyXG4gICAgICAgIGxldCBnaCA9IDBcclxuICAgICAgICBmb3IgKHZhciBvdiBvZiBvdnMpIHtcclxuICAgICAgICAgICAgaWYgKG92LmdyaWQgJiYgdHlwZW9mIG92LmdyaWQuaGVpZ2h0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgZ2ggKz0gb3YuZ3JpZC5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2ggLyBvdnMubGVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlX3dpZGdldChpZCkge1xyXG4gICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGlkKVxyXG4gICAgfVxyXG5cclxuICAgIGRlc3Ryb3koKSB7XHJcblxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuLy8gRXh0ZW5zaW9uJ3MgY29udHJvbGxlclxyXG5cclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICd0cmFkaW5nLXZ1ZS1qcydcclxuaW1wb3J0IFNldHRpbmdzV2luIGZyb20gJy4vU2V0dGluZ3NXaW4udnVlJ1xyXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR2LCBkYykge1xyXG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IHt9XHJcbiAgICAgICAgdGhpcy50diA9IHR2XHJcbiAgICAgICAgdGhpcy5kYyA9IGRjXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlzdGVucyB0byBhbGwgdHZqcyBldmVudHMsIGNyZWF0ZXMgbmV3IHdpZGdldHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGVnZW5kLWJ1dHRvbi1jbGljayc6XHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBgU2V0dGluZ3NXaW4tJHtVdGlscy51dWlkMigpfWBcclxuICAgICAgICAgICAgICAgIGxldCBhcmdzID0gZS5hcmdzWzBdXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5idXR0b24gIT09ICdzZXR0aW5ncycpIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZGF0YVthcmdzLnR5cGVdW2FyZ3MuZGF0YUluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0gT2JqZWN0LnZhbHVlcyh0aGlzLndpZGdldHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHggPT4geC5kYXRhLm92ID09PSBvdilcclxuICAgICAgICAgICAgICAgICAgICBpZihmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGYuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldCh0aGlzLndpZGdldHMsIGlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLCBjbHM6IFNldHRpbmdzV2luLCBkYXRhOiB7IG92OiBvdiB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVfd2lkZ2V0KGlkKSB7XHJcbiAgICAgICAgdGhpcy50di4kZGVsZXRlKHRoaXMud2lkZ2V0cywgaWQpXHJcbiAgICB9XHJcblxyXG59XHJcbiIsIlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblxyXG4gICAgc2V0dDJkZXNjKHNldHQpIHtcclxuICAgICAgICBmdW5jdGlvbiBzZXRDaGFyQXQoc3RyLGluZGV4LGNocikge1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IHN0ci5sZW5ndGgtMSkgcmV0dXJuIHN0clxyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLGluZGV4KSArIGNociArIHN0ci5zdWJzdHJpbmcoaW5kZXgrMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLyhbXkEtWl0pKFtBLVpdKS9nLCAnJDEgJDInKVxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLy18Xy9nLCAnICcpXHJcbiAgICAgICAgbGV0IHR1cGxlID0gc2V0dC5zcGxpdCgnICcpXHJcbiAgICAgICAgdHVwbGUgPSB0dXBsZVxyXG4gICAgICAgICAgICAuZmlsdGVyKHggPT4geC5sZW5ndGgpXHJcbiAgICAgICAgICAgIC5tYXAoeCA9PiBzZXRDaGFyQXQoeCwgMCwgeFswXS50b1VwcGVyQ2FzZSgpKSlcclxuICAgICAgICByZXR1cm4gdHVwbGUuam9pbignICcpXHJcbiAgICB9XHJcbiAgICBcclxufVxyXG4iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBDaGFydExpbmsgZnJvbSAnLi4vYnVpbGQvY2hhcnQtbGluay9jaGFydC1saW5rLWRldi5qcydcbmltcG9ydCBHcmlkUmVzaXplIGZyb20gJy4uL2J1aWxkL2dyaWQtcmVzaXplL2dyaWQtcmVzaXplLWRldi5qcydcbmltcG9ydCBMZWdlbmRCdXR0b25zIGZyb20gJy4uL2J1aWxkL2xlZ2VuZC1idXR0b25zL2xlZ2VuZC1idXR0b25zLWRldi5qcydcbmltcG9ydCBTZXR0aW5nc1dpbiBmcm9tICcuLi9idWlsZC9zZXR0aW5ncy13aW4vc2V0dGluZ3Mtd2luLWRldi5qcydcblxuXG5cbmNvbnN0IFBhY2sgPSB7XG4gICAgJ2NoYXJ0LWxpbmsnOiBDaGFydExpbmssXG4gICAgJ2dyaWQtcmVzaXplJzogR3JpZFJlc2l6ZSxcbiAgICAnbGVnZW5kLWJ1dHRvbnMnOiBMZWdlbmRCdXR0b25zLFxuICAgICdzZXR0aW5ncy13aW4nOiBTZXR0aW5nc1dpblxufVxuXG5leHBvcnQgZGVmYXVsdCBQYWNrXG5cbmV4cG9ydCB7XG4gICAgXG59IiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgQXBwIGZyb20gJy4vTWFpbi52dWUnXG5cbm5ldyBWdWUoe1xuICAgIGVsOiAnI2FwcCcsXG4gICAgcmVuZGVyOiBoID0+IGgoQXBwKVxufSlcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0cmVhbSh1cmwpIHtcclxuXHJcbiAgICB2YXIgd3MgPSBuZXcgV2ViU29ja2V0KHVybClcclxuICAgIHZhciBjYiA9ICgpID0+IHt9XHJcblxyXG5cclxuICAgIHdzLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXZWJzb2NrZXQgaXMgb3BlbmVkJylcclxuICAgIH1cclxuXHJcbiAgICB3cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YS5kYXRhKVxyXG4gICAgICAgICAgICBjYihkYXRhKVxyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNldCBvbnRyYWRlcyh2YWwpIHsgY2IgPSB2YWwgfSxcclxuICAgICAgICBvZmYoKSB7IHdzLmNsb3NlKDEwMDApIH1cclxuICAgIH1cclxufVxyXG4iLCJcclxuY29uc3QgU0VDT05EID0gMTAwMFxyXG5jb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MFxyXG5jb25zdCBNSU5VVEUzID0gTUlOVVRFICogM1xyXG5jb25zdCBNSU5VVEU1ID0gTUlOVVRFICogNVxyXG5jb25zdCBNSU5VVEUxNSA9IE1JTlVURSAqIDE1XHJcbmNvbnN0IE1JTlVURTMwID0gTUlOVVRFICogMzBcclxuY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwXHJcbmNvbnN0IEhPVVI0ID0gSE9VUiAqIDRcclxuY29uc3QgSE9VUjEyID0gSE9VUiAqIDEyXHJcbmNvbnN0IERBWSA9IEhPVVIgKiAyNFxyXG5jb25zdCBXRUVLID0gREFZICogN1xyXG5jb25zdCBNT05USCA9IFdFRUsgKiA0XHJcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjVcclxuXHJcbmNvbnN0IE1PTlRITUFQID0gW1xyXG4gICAgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIixcclxuICAgIFwiTWF5XCIsIFwiSnVuXCIsXCJKdWxcIiwgXCJBdWdcIixcclxuICAgIFwiU2VwXCIsIFwiT2N0XCIsXCJOb3ZcIiwgXCJEZWNcIlxyXG5dXHJcblxyXG4vLyBHcmlkIHRpbWUgc3RlcHNcclxuY29uc3QgVElNRVNDQUxFUyA9IFtcclxuICAgIFlFQVIgKiAxMCwgWUVBUiAqIDUsIFlFQVIgKiAzLCBZRUFSICogMiwgWUVBUixcclxuICAgIE1PTlRIICogNiwgTU9OVEggKiA0LCBNT05USCAqIDMsIE1PTlRIICogMiwgTU9OVEgsXHJcbiAgICBEQVkgKiAxNSwgREFZICogMTAsIERBWSAqIDcsIERBWSAqIDUsIERBWSAqIDMsIERBWSAqIDIsIERBWSxcclxuICAgIEhPVVIgKiAxMiwgSE9VUiAqIDYsIEhPVVIgKiAzLCBIT1VSICogMS41LCBIT1VSLFxyXG4gICAgTUlOVVRFMzAsIE1JTlVURTE1LCBNSU5VVEUgKiAxMCwgTUlOVVRFNSwgTUlOVVRFICogMiwgTUlOVVRFXHJcbl1cclxuXHJcbi8vIEdyaWQgJCBzdGVwc1xyXG5jb25zdCAkU0NBTEVTID0gWzAuMDUsIDAuMSwgMC4yLCAwLjI1LCAwLjUsIDAuOCwgMSwgMiwgNV1cclxuXHJcbmNvbnN0IENoYXJ0Q29uZmlnID0ge1xyXG4gICAgU0JNSU46IDYwLCAgICAgICAvLyBNaW5pbWFsIHNpZGViYXIgcHhcclxuICAgIFNCTUFYOiBJbmZpbml0eSwgLy8gTWF4IHNpZGViYXIsIHB4XHJcbiAgICBUT09MQkFSOiA1NywgICAgIC8vIFRvb2xiYXIgd2lkdGggcHhcclxuICAgIFRCX0lDT046IDI1LCAgICAgLy8gVG9vbGJhciBpY29uIHNpemUgcHhcclxuICAgIFRCX0lURU1fTTogNiwgICAgLy8gVG9vbGJhciBpdGVtIG1hcmdpbiBweFxyXG4gICAgVEJfSUNPTl9CUkk6IDEsICAvLyBUb29sYmFyIGljb24gYnJpZ2h0bmVzc1xyXG4gICAgVEJfSUNPTl9IT0xEOiA0MjAsIC8vIG1zLCB3YWl0IHRvIGV4cGFuZFxyXG4gICAgVEJfQk9SREVSOiAxLCAgICAvLyBUb29sYmFyIGJvcmRlciBweFxyXG4gICAgVEJfQl9TVFlMRTogJ2RvdHRlZCcsIC8vIFRvb2xiYXIgYm9yZGVyIHN0eWxlXHJcbiAgICBUT09MX0NPTEw6IDcsICAgIC8vIFRvb2wgY29sbGlzaW9uIHRocmVzaG9sZFxyXG4gICAgRVhQQU5EOiAwLjE1LCAgICAvLyAlLzEwMCBvZiByYW5nZVxyXG4gICAgQ0FORExFVzogMC42LCAgICAvLyAlLzEwMCBvZiBzdGVwXHJcbiAgICBHUklEWDogMTAwLCAgICAgIC8vIHB4XHJcbiAgICBHUklEWTogNDcsICAgICAgIC8vIHB4XHJcbiAgICBCT1RCQVI6IDI4LCAgICAgIC8vIHB4XHJcbiAgICBQQU5IRUlHSFQ6IDIyLCAgIC8vIHB4XHJcbiAgICBERUZBVUxUX0xFTjogNTAsIC8vIGNhbmRsZXNcclxuICAgIE1JTklNVU1fTEVOOiA1LCAgLy8gY2FuZGxlcyxcclxuICAgIE1JTl9aT09NOiAyNSwgICAgLy8gY2FuZGxlc1xyXG4gICAgTUFYX1pPT006IDEwMDAsICAvLyBjYW5kbGVzLFxyXG4gICAgVk9MU0NBTEU6IDAuMTUsICAvLyAlLzEwMCBvZiBoZWlnaHRcclxuICAgIFVYX09QQUNJVFk6IDAuOSwgLy8gVXggYmFja2dyb3VuZCBvcGFjaXR5XHJcbiAgICBaT09NX01PREU6ICd0dicsIC8vICd0dicgb3IgJ3RsJ1xyXG4gICAgTF9CVE5fU0laRTogMjEsICAvLyBMZWdlbmQgQnV0dG9uIHNpemUsIHB4XHJcbiAgICBMX0JUTl9NQVJHSU46ICctNnB4IDAgLTZweCAwJywgLy8gY3NzIG1hcmdpblxyXG4gICAgU0NST0xMX1dIRUVMOiAncHJldmVudCcsIC8vICdwYXNzJywgJ2NsaWNrJ1xyXG59XHJcblxyXG5DaGFydENvbmZpZy5GT05UID1cclxuICAgIGAxMXB4IC1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFxyXG4gICAgU2Vnb2UgVUksUm9ib3RvLE94eWdlbixVYnVudHUsQ2FudGFyZWxsLFxyXG4gICAgRmlyYSBTYW5zLERyb2lkIFNhbnMsSGVsdmV0aWNhIE5ldWUsXHJcbiAgICBzYW5zLXNlcmlmYFxyXG5cclxuY29uc3QgSUJfVEZfV0FSTiA9XHJcbiAgICBgV2hlbiB1c2luZyBJQiBtb2RlIHlvdSBzaG91bGQgc3BlY2lmeSBgICtcclxuICAgIGB0aW1lZnJhbWUgKCd0ZicgZmlsZWQgaW4gJ2NoYXJ0JyBvYmplY3QpLGAgK1xyXG4gICAgYG90aGVyd2lzZSB5b3UgY2FuIGdldCBhbiB1bmV4cGVjdGVkIGJlaGF2aW91cmBcclxuXHJcbmNvbnN0IE1BUF9VTklUID0ge1xyXG4gIFwiMXNcIjogU0VDT05ELFxyXG4gIFwiNXNcIjogU0VDT05EICogNSxcclxuICBcIjEwc1wiOiBTRUNPTkQgKiAxMCxcclxuICBcIjIwc1wiOiBTRUNPTkQgKiAyMCxcclxuICBcIjMwc1wiOiBTRUNPTkQgKiAzMCxcclxuICBcIjFtXCI6IE1JTlVURSxcclxuICBcIjNtXCI6IE1JTlVURTMsXHJcbiAgXCI1bVwiOiBNSU5VVEU1LFxyXG4gIFwiMTVtXCI6IE1JTlVURTE1LFxyXG4gIFwiMzBtXCI6IE1JTlVURTMwLFxyXG4gIFwiMUhcIjogSE9VUixcclxuICBcIjJIXCI6IEhPVVIgKiAyLFxyXG4gIFwiM0hcIjogSE9VUiAqIDMsXHJcbiAgXCI0SFwiOiBIT1VSNCxcclxuICBcIjEySFwiOiBIT1VSMTIsXHJcbiAgXCIxRFwiOiBEQVksXHJcbiAgXCIxV1wiOiBXRUVLLFxyXG4gIFwiMU1cIjogTU9OVEgsXHJcbiAgXCIxWVwiOiBZRUFSXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIFNFQ09ORDogU0VDT05ELFxyXG4gICAgTUlOVVRFOiBNSU5VVEUsXHJcbiAgICBNSU5VVEU1OiBNSU5VVEU1LFxyXG4gICAgTUlOVVRFMTU6IE1JTlVURTE1LFxyXG4gICAgTUlOVVRFMzA6IE1JTlVURTMwLFxyXG4gICAgSE9VUjogSE9VUixcclxuICAgIEhPVVI0OiBIT1VSNCxcclxuICAgIERBWTogREFZLFxyXG4gICAgV0VFSzogV0VFSyxcclxuICAgIE1PTlRIOiBNT05USCxcclxuICAgIFlFQVI6IFlFQVIsXHJcbiAgICBNT05USE1BUDogTU9OVEhNQVAsXHJcbiAgICBUSU1FU0NBTEVTOiBUSU1FU0NBTEVTLFxyXG4gICAgJFNDQUxFUzogJFNDQUxFUyxcclxuICAgIENoYXJ0Q29uZmlnOiBDaGFydENvbmZpZyxcclxuICAgIG1hcF91bml0OiBNQVBfVU5JVCxcclxuICAgIElCX1RGX1dBUk5cclxufVxyXG4iLCJpbXBvcnQgSW5kZXhlZEFycmF5IGZyb20gJ2FycmF5c2xpY2VyJ1xyXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdGFudHMuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblxyXG4gICAgbmFtZTJOYW1lKHNldHQpIHtcclxuICAgICAgICBmdW5jdGlvbiBzZXRDaGFyQXQoc3RyLGluZGV4LGNocikge1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IHN0ci5sZW5ndGgtMSkgcmV0dXJuIHN0clxyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLGluZGV4KSArIGNociArIHN0ci5zdWJzdHJpbmcoaW5kZXgrMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLyhbXkEtWl0pKFtBLVpdKS9nLCAnJDEgJDInKVxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLy18Xy9nLCAnICcpXHJcbiAgICAgICAgbGV0IHR1cGxlID0gc2V0dC5zcGxpdCgnICcpXHJcbiAgICAgICAgdHVwbGUgPSB0dXBsZVxyXG4gICAgICAgICAgICAuZmlsdGVyKHggPT4geC5sZW5ndGgpXHJcbiAgICAgICAgICAgIC5tYXAoeCA9PiBzZXRDaGFyQXQoeCwgMCwgeFswXS50b1VwcGVyQ2FzZSgpKSlcclxuICAgICAgICByZXR1cm4gdHVwbGUuam9pbignJylcclxuICAgIH0sXHJcblxyXG4gICAgY2xhbXAobnVtLCBtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBudW0gPD0gbWluID8gbWluIDogbnVtID49IG1heCA/IG1heCA6IG51bVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRfemVybyhpKSB7XHJcbiAgICAgICAgaWYgKGkgPCAxMCkge1xyXG4gICAgICAgICAgICBpID0gXCIwXCIgKyBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTdGFydCBvZiB0aGUgZGF5ICh6ZXJvIG1pbGxpc2Vjb25kKVxyXG4gICAgZGF5X3N0YXJ0KHQpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBuZXcgRGF0ZSh0KVxyXG4gICAgICAgIHJldHVybiBzdGFydC5zZXRVVENIb3VycygwLDAsMCwwKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTdGFydCBvZiB0aGUgbW9udGhcclxuICAgIG1vbnRoX3N0YXJ0KHQpIHtcclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHQpXHJcbiAgICAgICAgcmV0dXJuIERhdGUuVVRDKFxyXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0TW9udGgoKSwgMVxyXG4gICAgICAgIClcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU3RhcnQgb2YgdGhlIHllYXJcclxuICAgIHllYXJfc3RhcnQodCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLlVUQyhuZXcgRGF0ZSh0KS5nZXRGdWxsWWVhcigpKVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRfeWVhcih0KSB7XHJcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHQpLmdldFVUQ0Z1bGxZZWFyKClcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0X21vbnRoKHQpIHtcclxuICAgICAgICBpZiAoIXQpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUodCkuZ2V0VVRDTW9udGgoKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBOZWFyZXN0IGluIGFycmF5XHJcbiAgICBuZWFyZXN0X2EoeCwgYXJyYXkpIHtcclxuICAgICAgICBsZXQgZGlzdCA9IEluZmluaXR5XHJcbiAgICAgICAgbGV0IHZhbCA9IG51bGxcclxuICAgICAgICBsZXQgaW5kZXggPSAtMVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHhpID0gYXJyYXlbaV1cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHhpIC0geCkgPCBkaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5hYnMoeGkgLSB4KVxyXG4gICAgICAgICAgICAgICAgdmFsID0geGlcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbaW5kZXgsIHZhbF1cclxuICAgIH0sXHJcblxyXG4gICAgcm91bmQobnVtLCBkZWNpbWFscyA9IDgpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0udG9GaXhlZChkZWNpbWFscykpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFN0cmlwPyBObywgaXQncyB1Z2x5IGZsb2F0cyBpbiBqc1xyXG4gICAgc3RyaXAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoXHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQobnVtYmVyKS50b1ByZWNpc2lvbigxMilcclxuICAgICAgICApXHJcbiAgICB9LFxyXG5cclxuICAgIGdldF9kYXkodCkge1xyXG4gICAgICAgIHJldHVybiB0ID8gbmV3IERhdGUodCkuZ2V0RGF0ZSgpIDogbnVsbFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBVcGRhdGUgYXJyYXkga2VlcGluZyB0aGUgc2FtZSByZWZlcmVuY2VcclxuICAgIG92ZXJ3cml0ZShhcnIsIG5ld19hcnIpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgsIC4uLm5ld19hcnIpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENvcHkgbGF5b3V0IGluIHJlYWN0aXZlIHdheVxyXG4gICAgY29weV9sYXlvdXQob2JqLCBuZXdfb2JqKSB7XHJcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gKHNvbWUgb2ZmY2hhcnQgaW5kaWNhdG9ycyBhcmUgYWRkZWQvcmVtb3ZlZClcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIGxheW91dCBpbiBhIHJlYWN0aXZlIHdheVxyXG4gICAgICAgICAgICAgICAgaWYgKG9ialtrXS5sZW5ndGggIT09IG5ld19vYmpba10ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdmVyd3JpdGUob2JqW2tdLCBuZXdfb2JqW2tdKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIG9ialtrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2JqW2tdW21dLCBuZXdfb2JqW2tdW21dKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvYmpba10sIG5ld19vYmpba10pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERldGVjdHMgY2FuZGxlcyBpbnRlcnZhbFxyXG4gICAgZGV0ZWN0X2ludGVydmFsKG9obGN2KSB7XHJcbiAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKG9obGN2Lmxlbmd0aCAtIDEsIDk5KVxyXG4gICAgICAgIGxldCBtaW4gPSBJbmZpbml0eVxyXG4gICAgICAgIG9obGN2LnNsaWNlKDAsIGxlbikuZm9yRWFjaCgoeCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZCA9IG9obGN2W2krMV1bMF0gLSB4WzBdXHJcbiAgICAgICAgICAgIGlmIChkID09PSBkICYmIGQgPCBtaW4pIG1pbiA9IGRcclxuICAgICAgICB9KVxyXG4gICAgICAgIC8vIFRoaXMgc2F2ZXMgbW9udGhseSBjaGFydCBmcm9tIGJlaW5nIGF3a3dhcmRcclxuICAgICAgICBpZiAobWluID49IENvbnN0Lk1PTlRIICYmIG1pbiA8PSBDb25zdC5EQVkgKiAzMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3QuREFZICogMzFcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXRzIG51bWJlcmljIHBhcnQgb2Ygb3ZlcmxheSBpZCAoZS5nICdFTUFfMScgPSA+IDEpXHJcbiAgICBnZXRfbnVtX2lkKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlkLnNwbGl0KCdfJykucG9wKCkpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZhc3QgZmlsdGVyLiBSZWFsbHkgZmFzdCwgbGlrZSAxMFhcclxuICAgIGZhc3RfZmlsdGVyKGFyciwgdDEsIHQyKSB7XHJcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSByZXR1cm4gW2FyciwgdW5kZWZpbmVkXVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBpYSA9IG5ldyBJbmRleGVkQXJyYXkoYXJyLCBcIjBcIilcclxuICAgICAgICAgICAgbGV0IHJlcyA9IGlhLmdldFJhbmdlKHQxLCB0MilcclxuICAgICAgICAgICAgbGV0IGkwID0gaWEudmFscG9zW3QxXS5uZXh0XHJcbiAgICAgICAgICAgIHJldHVybiBbcmVzLCBpMF1cclxuICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdyb25nIHdpdGggZmFuY3kgc2xpY2UgbGliXHJcbiAgICAgICAgICAgIC8vIEZhc3QgZml4OiBmYWxsYmFjayB0byBmaWx0ZXJcclxuICAgICAgICAgICAgcmV0dXJuIFthcnIuZmlsdGVyKHggPT5cclxuICAgICAgICAgICAgICAgIHhbMF0gPj0gdDEgJiYgeFswXSA8PSB0MlxyXG4gICAgICAgICAgICApLCAwXVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gRmFzdCBmaWx0ZXIgKGluZGV4LWJhc2VkKVxyXG4gICAgZmFzdF9maWx0ZXJfaShhcnIsIHQxLCB0Mikge1xyXG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuIFthcnIsIHVuZGVmaW5lZF1cclxuICAgICAgICBsZXQgaTEgPSAgTWF0aC5mbG9vcih0MSlcclxuICAgICAgICBpZiAoaTEgPCAwKSBpMSA9IDBcclxuICAgICAgICBsZXQgaTIgPSAgTWF0aC5mbG9vcih0MiArIDEpXHJcbiAgICAgICAgbGV0IHJlcyA9IGFyci5zbGljZShpMSwgaTIpXHJcbiAgICAgICAgcmV0dXJuIFtyZXMsIGkxXVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBOZWFyZXN0IGluZGV4ZXMgKGxlZnQgYW5kIHJpZ2h0KVxyXG4gICAgZmFzdF9uZWFyZXN0KGFyciwgdDEpIHtcclxuICAgICAgICBsZXQgaWEgPSBuZXcgSW5kZXhlZEFycmF5KGFyciwgXCIwXCIpXHJcbiAgICAgICAgaWEuZmV0Y2godDEpXHJcbiAgICAgICAgcmV0dXJuIFtpYS5uZXh0bG93LCBpYS5uZXh0aGlnaF1cclxuICAgIH0sXHJcblxyXG4gICAgbm93KCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSB9LFxyXG5cclxuICAgIHBhdXNlKGRlbGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChycywgcmopID0+IHNldFRpbWVvdXQocnMsIGRlbGF5KSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gTGltaXQgY3Jhenkgd2hlZWwgZGVsdGEgdmFsdWVzXHJcbiAgICBzbWFydF93aGVlbChkZWx0YSkge1xyXG4gICAgICAgIGxldCBhYnMgPSBNYXRoLmFicyhkZWx0YSlcclxuICAgICAgICBpZiAoYWJzID4gNTAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoMjAwICsgTWF0aC5sb2coYWJzKSkgKiBNYXRoLnNpZ24oZGVsdGEpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWx0YVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBQYXJzZSB0aGUgb3JpZ2luYWwgbW91c2UgZXZlbnQgdG8gZmluZCBkZWx0YVhcclxuICAgIGdldF9kZWx0YVgoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVggLyAxMlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBQYXJzZSB0aGUgb3JpZ2luYWwgbW91c2UgZXZlbnQgdG8gZmluZCBkZWx0YVlcclxuICAgIGdldF9kZWx0YVkoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVkgLyAxMlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBBcHBseSBvcGFjaXR5IHRvIGEgaGV4IGNvbG9yXHJcbiAgICBhcHBseV9vcGFjaXR5KGMsIG9wKSB7XHJcbiAgICAgICAgaWYgKGMubGVuZ3RoID09PSA3KSB7XHJcbiAgICAgICAgICAgIGxldCBuID0gTWF0aC5mbG9vcihvcCAqIDI1NSlcclxuICAgICAgICAgICAgbiA9IHRoaXMuY2xhbXAobiwgMCwgMjU1KVxyXG4gICAgICAgICAgICBjICs9IG4udG9TdHJpbmcoMTYpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFBhcnNlIHRpbWVmcmFtZSBvciByZXR1cm4gdmFsdWUgaW4gbXNcclxuICAgIHBhcnNlX3RmKHNtdGgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNtdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb25zdC5tYXBfdW5pdFtzbXRoXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbXRoXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBEZXRlY3QgaW5kZXggc2hpZnQgYmV0d2VlbiB0aGUgbWFpbiBkYXRhIHN1YlxyXG4gICAgLy8gYW5kIHRoZSBvdmVybGF5J3Mgc3ViIChmb3IgSUItbW9kZSlcclxuICAgIGluZGV4X3NoaWZ0KHN1YiwgZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBGaW5kIHRoZSBzZWNvbmQgdGltZXN0YW1wIChieSB2YWx1ZSlcclxuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm4gMFxyXG4gICAgICAgIGxldCBmaXJzdCA9IGRhdGFbMF1bMF1cclxuICAgICAgICBsZXQgc2Vjb25kXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZGF0YVtpXVswXSAhPT0gZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgIHNlY29uZCA9IGRhdGFbaV1bMF1cclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJbal1bMF0gPT09IHNlY29uZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGogLSBpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAwXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZhbGxiYWNrIGZpeCBmb3IgQnJhdmUgYnJvd3NlclxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JyYXZlL2JyYXZlLWJyb3dzZXIvaXNzdWVzLzE3MzhcclxuICAgIG1lYXN1cmVUZXh0KGN0eCwgdGV4dCwgdHZfaWQpIHtcclxuICAgICAgICBsZXQgbSA9IGN0eC5tZWFzdXJlVGV4dE9yZyh0ZXh0KVxyXG4gICAgICAgIGlmIChtLndpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gJ3R2anMtbWVhc3VyZS10ZXh0J1xyXG4gICAgICAgICAgICBsZXQgZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpXHJcbiAgICAgICAgICAgIGlmICghZWwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gZG9jLmdldEVsZW1lbnRCeUlkKHR2X2lkKVxyXG4gICAgICAgICAgICAgICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG4gICAgICAgICAgICAgICAgZWwuaWQgPSBpZFxyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS50b3AgPSAnLTEwMDBweCdcclxuICAgICAgICAgICAgICAgIGJhc2UuYXBwZW5kQ2hpbGQoZWwpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoY3R4LmZvbnQpIGVsLnN0eWxlLmZvbnQgPSBjdHguZm9udFxyXG4gICAgICAgICAgICBlbC5pbm5lclRleHQgPSB0ZXh0LnJlcGxhY2UoLyAvZywgJy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IGVsLm9mZnNldFdpZHRoIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXVpZCh0ZW1wID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcpIHtcclxuICAgICAgICByZXR1cm4gdGVtcFxyXG4gICAgICAgICAgICAucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcclxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSAneCcgP1xyXG4gICAgICAgICAgICAgICAgciA6XHJcbiAgICAgICAgICAgICAgICAociAmIDB4MyB8IDB4OClcclxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgdXVpZDIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXVpZCgneHh4eHh4eHh4eHh4JylcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGVsYXllZCB3YXJuaW5nLCBmID0gY29uZGl0aW9uIGxhbWJkYSBmblxyXG4gICAgd2FybihmLCB0ZXh0LCBkZWxheSA9IDApIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGYoKSkgY29uc29sZS53YXJuKHRleHQpXHJcbiAgICAgICAgfSwgZGVsYXkpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENoZWNrcyBpZiBzY3JpcHQgcHJvcHMgdXBkYXRlZFxyXG4gICAgLy8gKGFuZCBub3Qgc3R5bGUgc2V0dGluZ3Mgb3Igc29tZXRoaW5nIGVsc2UpXHJcbiAgICBpc19zY3JfcHJvcHNfdXBkKG4sIHByZXYpIHtcclxuICAgICAgICBsZXQgcCA9IHByZXYuZmluZCh4ID0+IHgudi4kdXVpZCA9PT0gbi52LiR1dWlkKVxyXG4gICAgICAgIGlmICghcCkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgICAgIGxldCBwcm9wcyA9IG4ucC5zZXR0aW5ncy4kcHJvcHNcclxuICAgICAgICBpZiAoIXByb3BzKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3BzLnNvbWUoeCA9PiBuLnZbeF0gIT09IHAudlt4XSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hlY2tzIGlmIGl0J3MgdGltZSB0byBtYWtlIGEgc2NyaXB0IHVwZGF0ZVxyXG4gICAgLy8gKGJhc2VkIG9uIGV4ZWNJbnRlcnZhbCBpbiBtcylcclxuICAgIGRlbGF5ZWRfZXhlYyh2KSB7XHJcbiAgICAgICAgaWYgKCF2LnNjcmlwdCB8fCAhdi5zY3JpcHQuZXhlY0ludGVydmFsKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGxldCB0ID0gdGhpcy5ub3coKVxyXG4gICAgICAgIGxldCBkdCA9IHYuc2NyaXB0LmV4ZWNJbnRlcnZhbFxyXG4gICAgICAgIGlmICghdi5zZXR0aW5ncy4kbGFzdF9leGVjIHx8XHJcbiAgICAgICAgICAgIHQgPiB2LnNldHRpbmdzLiRsYXN0X2V4ZWMgKyBkdCkge1xyXG4gICAgICAgICAgICB2LnNldHRpbmdzLiRsYXN0X2V4ZWMgPSB0XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGb3JtYXQgbmFtZXMgc3VjaCAnUlNJLCAkbGVuZ3RoJywgd2hlcmVcclxuICAgIC8vIGxlbmd0aCAtIGlzIG9uZSBvZiB0aGUgc2V0dGluZ3NcclxuICAgIGZvcm1hdF9uYW1lKG92KSB7XHJcbiAgICAgICAgaWYgKCFvdi5uYW1lKSByZXR1cm4gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIGxldCBuYW1lID0gb3YubmFtZVxyXG5cclxuICAgICAgICBmb3IgKHZhciBrIGluIG92LnNldHRpbmdzIHx8IHt9KSB7XHJcbiAgICAgICAgICAgIGxldCB2YWwgPSBvdi5zZXR0aW5nc1trXVxyXG4gICAgICAgICAgICBsZXQgcmVnID0gbmV3IFJlZ0V4cChgXFxcXCQke2t9YCwgJ2cnKVxyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHJlZywgdmFsKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWVcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGVmYXVsdCBjdXJzb3IgbW9kZVxyXG4gICAgeG1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNfbW9iaWxlID8gJ2V4cGxvcmUnIDogJ2RlZmF1bHQnXHJcbiAgICB9LFxyXG5cclxuICAgIGRlZmF1bHRfcHJldmVudGVkKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC5vcmlnaW5hbC5kZWZhdWx0UHJldmVudGVkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFdURiB3aXRoIG1vZGVybiB3ZWIgZGV2ZWxvcG1lbnRcclxuICAgIGlzX21vYmlsZTogKHcgPT4gJ29ub3JpZW50YXRpb25jaGFuZ2UnIGluIHcgJiZcclxuICAgICAgICghIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fFxyXG4gICAgICAgICEhbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgfHxcclxuICAgICAgICAoJ29udG91Y2hzdGFydCcgaW4gdyB8fFxyXG4gICAgICAgICh3LkRvY3VtZW50VG91Y2ggJiZcclxuICAgICAgICBkb2N1bWVudCBpbnN0YW5jZW9mIHcuRG9jdW1lbnRUb3VjaCkpKSlcclxuICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn1cclxuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5hcHAtY29udGVudCB7XFxuICAgIHBhZGRpbmc6IGNhbGMoMnJlbSArIDIuNDVyZW0pIDAgMCAwcmVtICFpbXBvcnRhbnQ7XFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuQG1lZGlhIChtYXgtd2lkdGg6IDc2Ny45OHB4KXtcXG5odG1sIGJvZHkubmF2YmFyLXN0aWNreSAuYXBwLWNvbnRlbnQge1xcbiAgICAgICAgcGFkZGluZzogY2FsYygxcmVtIC0gMC44cmVtICsgNC40NXJlbSkgMCAwIDAgIWltcG9ydGFudDtcXG59XFxufVxcbi5mbGV4ZWQge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG59XFxuI2FwcC1jb25haW5lciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbn1cXG5cXG4vKiBAbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpe1xcbiAgICAjYXBwLWNvbmFpbmVyIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIH1cXG59ICovXFxuI3RyYWRlYmFyIHtcXG4gICAgY29sb3I6ICNkZGQ7XFxufVxcbiN0dmpzLWhlYWRlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDcwcHg7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgY29sb3I6ICNkZGQ7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTIxODI2O1xcbn1cXG4ubmlnaHQtbW9kZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAxNXB4O1xcbiAgICByaWdodDogMjBweDtcXG59XFxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMC1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMC1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMS1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMS1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLWJvdGJhci1jYW52YXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyAwJSkgIWltcG9ydGFudDtcXG59XFxuI3RyYWRpbmctdnVlLXRiaXRlbSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigxOCwgMjQsIDM4KTtcXG59XFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LWRldmljZS13aWR0aDogNDgwcHgpIHtcXG4udGYtc2VsZWN0b3Ige1xcbiAgICAgICAgdG9wOiA1MHB4O1xcbiAgICAgICAgcmlnaHQ6IDE0MHB4O1xcbiAgICAgICAgbWF4LXdpZHRoOiAxNDBweDtcXG4gICAgICAgIGZvbnQ6IDEycHggLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LFxcbiAgICAgICAgICAgIFNlZ29lIFVJLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsXFxuICAgICAgICAgICAgRmlyYSBTYW5zLCBEcm9pZCBTYW5zLCBIZWx2ZXRpY2EgTmV1ZSxcXG4gICAgICAgICAgICBzYW5zLXNlcmlmO1xcbn1cXG59XFxuLmJveCB7XFxuICAgIHdpZHRoOiAyODBweDtcXG4gICAgbWFyZ2luOiAwIGF1dG87XFxuICAgIGJveC1zaGFkb3c6IDAgMS41cHggNXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHBhZGRpbmc6IDAgMTVweCAwIDE1cHg7XFxufVxcbnRhYmxlIHtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogcmdiKDE4MywgMTg5LCAxOTgpO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxudGQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbnRkLnByaWNlIHtcXG4gICAgd2lkdGg6IDMwJTtcXG59XFxudGQucHJpY2Ugc3BhbiB7XFxuICAgIHBhZGRpbmctbGVmdDogNXB4O1xcbn1cXG50ZC5xdWFudGl0eSB7XFxuICAgIHdpZHRoOiAzMCU7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG50ZC50aW1lIHtcXG4gICAgd2lkdGg6IDQwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcbnRkLmJ0YyB7XFxuICAgIHdpZHRoOiA0MCU7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcbnRkIHNwYW4ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHotaW5kZXg6IDI7XFxufVxcbnRhYmxlLmFza3MgLnBlcmNlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0NiwgNzAsIDk0LCAwLjIpO1xcbn1cXG50YWJsZS5iaWRzIC5wZXJjZW50IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNCwgMjAzLCAxMjksIDAuMik7XFxufVxcbnRkIC5wZXJjZW50IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgcmlnaHQ6IDA7XFxufVxcbi5uZXdlc3Qge1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG4gICAgbWFyZ2luOiAxNXB4IC0xNXB4O1xcbn1cXG4uY2FyZC0xMTAge1xcbiAgICB0b3A6IDExMHB4ICFpbXBvcnRhbnQ7XFxuICAgIGxlZnQ6IDcwcHg7XFxufVxcbi8qIFN0eWxlIHBhZ2UgY29udGVudCAtIHVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIHB1c2ggdGhlIHBhZ2UgY29udGVudCB0byB0aGUgcmlnaHQgd2hlbiB5b3Ugb3BlbiB0aGUgc2lkZSBuYXZpZ2F0aW9uICovXFxuI21haW4ge1xcbiAgICB0cmFuc2l0aW9uOiBtYXJnaW4tbGVmdCAuNXM7XFxuICAgIC8qIElmIHlvdSB3YW50IGEgdHJhbnNpdGlvbiBlZmZlY3QgKi9cXG59XFxuXFxuLyogT24gc21hbGxlciBzY3JlZW5zLCB3aGVyZSBoZWlnaHQgaXMgbGVzcyB0aGFuIDQ1MHB4LCBjaGFuZ2UgdGhlIHN0eWxlIG9mIHRoZSBzaWRlbmF2IChsZXNzIHBhZGRpbmcgYW5kIGEgc21hbGxlciBmb250IHNpemUpICovXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1oZWlnaHQ6IDQ1MHB4KSB7XFxuLnNpZGViYXIxIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAxNXB4O1xcbn1cXG4uc2lkZWJhcjEgYSB7XFxuICAgICAgICBmb250LXNpemU6IDE4cHg7XFxufVxcbn1cXG4uYnRuLWNpcmNsZSB7XFxuICAgIHdpZHRoOiAzMHB4O1xcbiAgICBoZWlnaHQ6IDMwcHg7XFxuICAgIHBhZGRpbmc6IDZweCAwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbiNjaGFydGRpdiB7XFxuICAgIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcXG4gICAgaGVpZ2h0OiA3MHZoO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvTWFpbi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQW1UQTtJQUNBLGlEQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUNBO0FBQ0E7UUFDQSx1REFBQTtBQUNBO0FBQ0E7QUFDQTtJQUNBLGFBQUE7SUFDQSxzQkFBQTtJQUNBLG1CQUFBO0lBQ0EsdUJBQUE7SUFDQSxxQkFBQTtJQUNBLGlCQUFBO0FBQ0E7QUFFQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtJQUNBLDhCQUFBO0lBQ0EsNEJBQUE7SUFDQSx1QkFBQTtJQUNBLGlCQUFBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztHQVNBO0FBQ0E7SUFDQSxXQUFBO0FBQ0E7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsYUFBQTtJQUNBLHFCQUFBO0lBQ0EsbUJBQUE7SUFDQSxpQkFBQTtJQUNBLDJCQUFBO0lBQ0EsbUJBQUE7SUFDQSxrQkFBQTtJQUNBLFlBQUE7SUFDQSxXQUFBO0lBQ0EsV0FBQTtJQUNBLHlCQUFBO0FBQ0E7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsU0FBQTtJQUNBLFdBQUE7QUFDQTtBQUVBOzs7OztJQUtBLDRDQUFBO0FBQ0E7QUFFQTtJQUNBLGlDQUFBO0FBQ0E7QUFFQTtBQUNBO1FBQ0EsU0FBQTtRQUNBLFlBQUE7UUFDQSxnQkFBQTtRQUNBOzs7c0JBR0E7QUFDQTtBQUNBO0FBRUE7SUFDQSxZQUFBO0lBQ0EsY0FBQTtJQUNBLCtDQUFBO0lBQ0Esa0JBQUE7SUFDQSxzQkFBQTtBQUNBO0FBRUE7SUFDQSxlQUFBO0lBQ0EsZ0JBQUE7SUFDQSx5QkFBQTtJQUNBLGdCQUFBO0lBQ0EsV0FBQTtBQUNBO0FBRUE7SUFDQSxrQkFBQTtJQUNBLFlBQUE7SUFDQSxpQkFBQTtBQUNBO0FBRUE7SUFDQSxVQUFBO0FBQ0E7QUFFQTtJQUNBLGlCQUFBO0FBQ0E7QUFFQTtJQUNBLFVBQUE7SUFDQSxpQkFBQTtBQUNBO0FBRUE7SUFDQSxVQUFBO0lBQ0EsaUJBQUE7SUFDQSxXQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUVBO0lBQ0EsVUFBQTtJQUNBLGlCQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUVBO0lBQ0Esa0JBQUE7SUFDQSxVQUFBO0FBQ0E7QUFFQTtJQUNBLHdDQUFBO0FBQ0E7QUFFQTtJQUNBLHlDQUFBO0FBQ0E7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsTUFBQTtJQUNBLFNBQUE7SUFDQSxRQUFBO0FBQ0E7QUFFQTtJQUNBLDZCQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUVBO0lBQ0EscUJBQUE7SUFDQSxVQUFBO0FBQ0E7QUFDQSxzSEFBQTtBQUNBO0lBQ0EsMkJBQUE7SUFDQSxvQ0FBQTtBQUNBOztBQUVBLGdJQUFBO0FBQ0E7QUFDQTtRQUNBLGlCQUFBO0FBQ0E7QUFFQTtRQUNBLGVBQUE7QUFDQTtBQUNBO0FBRUE7SUFDQSxXQUFBO0lBQ0EsWUFBQTtJQUNBLGdCQUFBO0lBQ0EsbUJBQUE7SUFDQSxjQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUVBO0lBQ0EsaUJBQUE7SUFDQSxpQkFBQTtJQUNBLFlBQUE7QUFDQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZsZXgtc3RhcnQgY29sLTEwIGNvbC14bGwtMTAgY29sLXhsLTEwIGNvbC1sZy0xMCBjb2wtbWQtOSBjb2wtc20tMTJcXFwiPlxcbiAgICAgICAgPGRpdiBpZD1cXFwidHZqcy1oZWFkZXJcXFwiPlxcbiAgICAgICAgICAgIDxhPjxzcGFuIGlkPVxcXCJ0b2dnbGVDb250cmFjdHNcXFwiIGNsYXNzPVxcXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LWluZm9cXFwiIGRhdGEtYnMtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVxcXCIjY29sbGFwc2VDb250cmFjdHNcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCJjb2xsYXBzZUNvbnRyYWN0c1xcXCI+PGlcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiYmkgYmktYnJpZWZjYXNlXFxcIiAvPjxkaXYgY2xhc3M9XFxcImQtbWQtaW5saW5lIGQtbm9uZVxcXCI+IENvbnRyYWN0czwvZGl2Pjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgPGE+PHNwYW4gdi1vbjpjbGljaz1cXFwiY2FuZGxlc1xcXCIgY2xhc3M9XFxcIm1lLTEgYmFkZ2UgYmctbGlnaHQtc2Vjb25kYXJ5XFxcIj48aSBjbGFzcz1cXFwiYmkgYmktYmFyLWNoYXJ0XFxcIiAvPjxkaXYgY2xhc3M9XFxcImQtbWQtaW5saW5lIGQtbm9uZVxcXCI+ICBDYW5kbGVzPC9kaXY+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICA8YT48c3BhbiB2LW9uOmNsaWNrPVxcXCJzcGxpbmVcXFwiIGNsYXNzPVxcXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXNlY29uZGFyeVxcXCI+PGkgY2xhc3M9XFxcImJpIGJpLWdyYXBoLXVwXFxcIiAvPjxkaXYgY2xhc3M9XFxcImQtbWQtaW5saW5lIGQtbm9uZVxcXCI+ICBTcGxpbmU8L2Rpdj48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgIDxhPjxzcGFuIGlkPVxcXCJ0b2dnbGVJbmZvXFxcIiBjbGFzcz1cXFwibWUtMSBiYWRnZSBiZy1saWdodC1pbmZvXFxcIiBkYXRhLWJzLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXFxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cXFwiI2NvbGxhcHNlSW5mb3NcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCJjb2xsYXBzZUluZm9zXFxcIj48aVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJiaSBiaS1pbmZvLWNpcmNsZVxcXCIgLz48ZGl2IGNsYXNzPVxcXCJkLW1kLWlubGluZSBkLW5vbmVcXFwiPiAgSW5mbzwvZGl2Pjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgPGE+PHNwYW4gaWQ9XFxcInRvZ2dsZURlcHRoXFxcIiBjbGFzcz1cXFwibWUtMSBiYWRnZSBiZy1saWdodC1wcmltYXJ5IFxcXCIgZGF0YS1icy10b2dnbGU9XFxcImNvbGxhcHNlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1icy10YXJnZXQ9XFxcIiNjb2xsYXBzZURlcHRoXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgYXJpYS1jb250cm9scz1cXFwiY29sbGFwc2VEZXB0aFxcXCI+PGlcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiYmkgYmkta2FuYmFuXFxcIiAvPjxkaXYgY2xhc3M9XFxcImQtbWQtaW5saW5lIGQtbm9uZVxcXCI+ICBEZXB0aCBWaWV3PC9kaXY+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cXFwidG9nZ2xlT3JkZXJzXFxcIiBjbGFzcz1cXFwibWUtMSBiYWRnZSBiZy1saWdodC13YXJuaW5nIFxcXCIgZGF0YS1icy10b2dnbGU9XFxcImNvbGxhcHNlXFxcIlxcbiAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVxcXCIjY29sbGFwc2VPcmRlcnNcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCJjb2xsYXBzZU9yZGVyc1xcXCI+PGlcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiYmkgYmktZmlsZS1iYXItZ3JhcGhcXFwiIC8+PGRpdiBjbGFzcz1cXFwiZC1tZC1pbmxpbmUgZC1ub25lXFxcIj4gIE9yZGVyIEJvb2s8L2Rpdj48L3NwYW4+PC9hPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJjb2xsYXBzZUluZm9zXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJjb2xsYXBzZSBjb2wtbGctNCBjb2wtbWQtNSBjb2wtc20tNiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwIFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZFxcXCIgc3R5bGU9XFxcImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLWhlYWRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVxcXCJjYXJkLXRpdGxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgc3ltYm9sIH19XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9oND5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtYm9keVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLThcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwic2hvd19iXFxcIiBjbGFzcz1cXFwidGV4dC1zdGFydCBmcy0xXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLTRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwic2hvd19wXFxcIiBjbGFzcz1cXFwidGV4dC1lbmRcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6MTRweDtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJzaG93X1BcXFwiIGNsYXNzPVxcXCJ0ZXh0LWVuZFxcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZToxNHB4O1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IG10LTFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJteVJhbmdlQ29sb3JcXFwiIGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJteVJhbmdlXFxcIiBjbGFzcz1cXFwicHJvZ3Jlc3MtYmFyIHByb2dyZXNzLWJhci1zdHJpcGVkIHByb2dyZXNzLWJhci1hbmltYXRlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW5vdz1cXFwiNTBcXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcIjEwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cXFwid2lkdGg6IDgwJVxcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJzaG93X2xcXFwiIGNsYXNzPVxcXCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhbmdlclxcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZToxMHB4O1xcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHRleHQtZGFyayB0ZXh0LWNlbnRlclxcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZToxMHB4O1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXkgUmFuZ2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcInNob3dfaFxcXCIgY2xhc3M9XFxcImNvbCB0ZXh0LWVuZCB0ZXh0LXN1Y2Nlc3NcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6MTBweDtcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IG10LTFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFxcXCI+Vm9sdW1lIDI0SDwvc21hbGw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBpZD1cXFwic2hvd192XFxcIiBjbGFzcz1cXFwiY29sIHRleHQtZW5kIHRleHQtd2FybmluZyBjbGVhcmZpeFxcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cXFwiY29sIHRleHQtc3RhcnQgdGV4dC1kYXJrIGNsZWFyZml4XFxcIj5NYXJrZXQgQ2FwPC9zbWFsbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGlkPVxcXCJzaG93X21jXFxcIiBjbGFzcz1cXFwiY29sIHRleHQtZW5kIHRleHQtd2FybmluZyBjbGVhcmZpeFxcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cXFwiY29sIHRleHQtc3RhcnQgdGV4dC1kYXJrIGNsZWFyZml4XFxcIj5Ub3RhbCBTdXBwbHk8L3NtYWxsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgaWQ9XFxcInNob3dfdHNcXFwiIGNsYXNzPVxcXCJjb2wgdGV4dC1lbmQgdGV4dC13YXJuaW5nIGNsZWFyZml4XFxcIiAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcImNvbGxhcHNlRGVwdGhcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImNvbGxhcHNlIGNvbC1sZy02IGNvbC1tZC0xMCBjb2wtc20tMTIgY29sLTEyIHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTAgXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZDojMTMxNzIyZTYhaW1wb3J0YW50O2JveC1zaGFkb3c6IDAgNHB4IDI0cHggMCByZ2IoMCAwIDAgLyAzMCUpO1xcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJjaGFydGRpdlxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJjb2xsYXBzZU9yZGVyc1xcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiY29sbGFwc2UgY29sLWxnLTQgY29sLW1kLTQgY29sLXNtLTYgY29sLTEyIHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTBcXFwiIHN0eWxlPVxcXCJtYXgtd2lkdGg6MjgwcHg7XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZDojMTMxNzIyZTYhaW1wb3J0YW50O2JveC1zaGFkb3c6IDAgNHB4IDI0cHggMCByZ2IoMCAwIDAgLyAzMCUpO1xcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGVudCBteS0xXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJveFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcIm1iLTFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cXFwidGV4dC1zdGFydCBwcy0xIHRleHQtZGFya1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByaWNlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcInRleHQtY2VudGVyIHBzLTEgdGV4dC1kYXJrXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVhbnRpdHlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cXFwidGV4dC1lbmQgcGUtMSB0ZXh0LWRhcmtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb3RhbFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJhc2tzXFxcIiAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5ld2VzdFxcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XFxcImJpZHNcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImFwcC1jb250YWluZXJcXFwiIHN0eWxlPVxcXCJtYXJnaW4tdG9wOjQwcHg7XFxcIj5cXG4gICAgICAgICAgICA8dHJhZGluZy12dWUgOmtleT1cXFwicmVzZXRrZXlcXFwiIHJlZj1cXFwidHZqc1xcXCIgOmRhdGE9XFxcImRjXFxcIiA6d2lkdGg9XFxcIndpZHRoXFxcIiA6aGVpZ2h0PVxcXCJoZWlnaHRcXFwiIDp0aXRsZS10eHQ9XFxcInRpdGxlXFxcIlxcbiAgICAgICAgICAgICAgICBjb2xvci10aXRsZT1cXFwiI2ZmOWY0M1xcXCIgOmxlZ2VuZC1idXR0b25zPVxcXCJbJ2Rpc3BsYXknLCAnc2V0dGluZ3MnLCAndXAnLCAnZG93bicsICdhZGQnLCAncmVtb3ZlJ11cXFwiXFxuICAgICAgICAgICAgICAgIDpjaGFydC1jb25maWc9XFxcIntERUZBVUxUX0xFTjo2MCxNSU5fWk9PTToxfVxcXCIgOnRvb2xiYXI9XFxcInRydWVcXFwiIDpjb2xvci1iYWNrPVxcXCJjb2xvcnMuY29sb3JCYWNrXFxcIlxcbiAgICAgICAgICAgICAgICA6Y29sb3ItZ3JpZD1cXFwiY29sb3JzLmNvbG9yR3JpZFxcXCIgOmNvbG9yLXRleHQ9XFxcImNvbG9ycy5jb2xvclRleHRcXFwiIDpleHRlbnNpb25zPVxcXCJleHRcXFwiIDpvdmVybGF5cz1cXFwib3ZzXFxcIlxcbiAgICAgICAgICAgICAgICA6bmlnaHQ9XFxcIm5pZ2h0XFxcIiA6cmVzZXRrZXk9XFxcInJlc2V0a2V5XFxcIiA6eC1zZXR0aW5ncz1cXFwieHNldHRcXFwiIDp0aW1lem9uZT1cXFwidGltZXpvbmVcXFwiIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmltcG9ydCB7IFRyYWRpbmdWdWUsIERhdGFDdWJlIH0gZnJvbSAndHJhZGluZy12dWUtanMnXFxuaW1wb3J0IE92ZXJsYXlzIGZyb20gJ3R2anMtb3ZlcmxheXMnXFxuaW1wb3J0IERhdGEgZnJvbSAnLi4vcmVzb3VyY2VzL2RhdGEvZGF0YS5qc29uJ1xcbmltcG9ydCBVdGlscyBmcm9tICcuL3N0dWZmL3V0aWxzLmpzJ1xcbmltcG9ydCBDb25zdCBmcm9tICcuL3N0dWZmL2NvbnN0YW50cy5qcydcXG5pbXBvcnQgU3RyZWFtIGZyb20gJy4vc3RyZWFtLmpzJ1xcbmltcG9ydCBFeHRlbnNpb25zIGZyb20gJy4vaW5kZXhfZGV2J1xcblxcbi8vIEdldHRpbicgZGF0YSB0aHJvdWdoIHdlYnBlY2sgcHJveHlcXG5jb25zdCBzeW1ib2xzbSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJylbM11cXG5jb25zdCBzeW1ib2xiZyA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS50b1VwcGVyQ2FzZSgpLnNwbGl0KCcvJylbM11cXG5jb25zdCBwYWlyc20gPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnLycpWzRdXFxuY29uc3QgcGFpcmJnID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvVXBwZXJDYXNlKCkuc3BsaXQoJy8nKVs0XVxcbmNvbnN0IFVSTCA9IGBodHRwczovL2JpbmFuY2Utd2F0Y2gtd3JhcHBlci5oZXJva3VhcHAuY29tL2h0dHBzOi8vYXBpLmJpbmFuY2UuY29tL2FwaS92MS9rbGluZXM/c3ltYm9sPWBcXG5jb25zdCBXU1MgPSBgd3NzOi8vc3RyZWFtLmJpbmFuY2UuY29tOjk0NDMvd3MvJHtzeW1ib2xzbX0ke3BhaXJzbX1AYWdnVHJhZGVgXFxuY29uc3QgZGF0YXMgPSBgZGF0YXNldHMuYmluYW5jZS0ke3N5bWJvbHNtfSR7cGFpcnNtfWBcXG4vL2NvbnN0IFBPUlQgPSBsb2NhdGlvbi5wb3J0XFxuLy9jb25zdCBVUkwgPSBgaHR0cDovL2xvY2FsaG9zdDoke1BPUlR9L2FwaS92MS9rbGluZXM/c3ltYm9sPWBcXG4vL2NvbnN0IFdTUyA9IGB3czovL2xvY2FsaG9zdDoke1BPUlR9L3dzLyR7c3ltYm9sc219QGFnZ1RyYWRlYFxcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gICAgbmFtZTogJ0FwcCcsXFxuICAgIGNvbXBvbmVudHM6IHtcXG4gICAgICAgIFRyYWRpbmdWdWVcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgZGM6IG5ldyBEYXRhQ3ViZShEYXRhKSxcXG4gICAgICAgICAgICB0aXRsZTogc3ltYm9sYmcgKyBwYWlyYmcsXFxuICAgICAgICAgICAgd2lkdGg6IDAsXFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxcbiAgICAgICAgICAgIGxvZ19zY2FsZTogdHJ1ZSxcXG4gICAgICAgICAgICBzeW1ib2w6IHN5bWJvbGJnICsgcGFpcmJnLFxcbiAgICAgICAgICAgIGluZGV4X2Jhc2VkOiB0cnVlLFxcbiAgICAgICAgICAgIHRpbWV6b25lOiB0aGlzLnRpbWV6b25lZCgpLFxcbiAgICAgICAgICAgIHhzZXR0OiB7XFxuICAgICAgICAgICAgICAgICdncmlkLXJlc2l6ZSc6IHsgbWluX2hlaWdodDogMzAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgb3ZzOiBPYmplY3QudmFsdWVzKE92ZXJsYXlzKSxcXG4gICAgICAgICAgICBleHQ6IE9iamVjdC52YWx1ZXMoRXh0ZW5zaW9ucyksXFxuICAgICAgICAgICAgbmlnaHQ6IHRydWUsXFxuICAgICAgICAgICAgdG9wOiA1MCxcXG4gICAgICAgICAgICByZXNldGtleTogMFxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgICAgY29sb3JzKCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5pZ2h0ID8ge30gOiB7XFxuICAgICAgICAgICAgICAgIGNvbG9yQmFjazogJyNmZmYnLFxcbiAgICAgICAgICAgICAgICBjb2xvckdyaWQ6ICcjZWVlJyxcXG4gICAgICAgICAgICAgICAgY29sb3JUZXh0OiAnIzMzMydcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIG1vdW50ZWQoKSB7XFxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSlcXG4gICAgICAgIGxldCBxID0gdGhpcy53aW5fcXVlcnkoKVxcbiAgICAgICAgaWYgKHEubm0gPT09ICdmYWxzZScpIHRoaXMubmlnaHQgPSBmYWxzZVxcbiAgICAgICAgaWYgKHEub3YpIHRoaXMuY3VycmVudCA9IHEub3ZcXG4gICAgICAgIGlmIChxLmhlYWRlciA9PT0gJ2ZhbHNlJykgdGhpcy50b3AgPSAwXFxuICAgICAgICB0aGlzLm9uUmVzaXplKCksXFxuICAgICAgICB3aW5kb3cuZGMgPSB0aGlzLmRjXFxuICAgICAgICB3aW5kb3cudHYgPSB0aGlzLiRyZWZzLnR2anNcXG4gICAgICAgIC8vIExvYWQgdGhlIGxhc3QgZGF0YSBjaHVuayAmIGluaXQgRGF0YUN1YmU6XFxuICAgICAgICBsZXQgbm93ID0gVXRpbHMubm93KClcXG4gICAgICAgIHRoaXMubG9hZF9jaHVuayhbbm93IC0gQ29uc3QuSE9VUjQsIG5vd10pLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgZGMuZGF0YS5jaGFydC5kYXRhID0gZGF0YVsnY2hhcnQuZGF0YSddXFxuICAgICAgICAgICAgLy8gUmVnaXN0ZXIgb25yYW5nZSBjYWxsYmFjayAmIEFuZCBhIHN0cmVhbSBvZiB0cmFkZXNcXG4gICAgICAgICAgICB0aGlzLmRjLm9ucmFuZ2UodGhpcy5sb2FkX2NodW5rKVxcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IFN0cmVhbShXU1MpXFxuICAgICAgICAgICAgdGhpcy5zdHJlYW0ub250cmFkZXMgPSB0aGlzLm9uX3RyYWRlc1xcbiAgICAgICAgICAgIHdpbmRvdy5kYyA9IHRoaXMuY2hhcnQgICAgICAvLyBEZWJ1Z1xcbiAgICAgICAgICAgIHdpbmRvdy50diA9IHRoaXMuJHJlZnMudHZqcyAvLyBEZWJ1Z1xcbiAgICAgICAgfSlcXG4gICAgfSxcXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplKVxcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB0aGlzLnN0cmVhbS5vZmYoKVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBvblJlc2l6ZSgpIHtcXG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPiAnOTkyJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gKHdpbmRvdy5pbm5lcldpZHRoICogMC4yMSkpXFxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+ICc3NjgnICAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8PSAnOTkyJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gKHdpbmRvdy5pbm5lcldpZHRoICogMC4yNikpXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIDE1KVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuODBcXG4gICAgICAgIH0sXFxuICAgICAgICBzcGxpbmUgKCkge1xcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50eXBlID0gXFxcIlNwbGluZVxcXCJcXG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudGYgPSBcXFwiMW1cXFwiXFxuICAgICAgICAgICAgdGhpcy4kcmVmcy50dmpzLnJlc2V0Q2hhcnQoKVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNhbmRsZXMgKCkge1xcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50eXBlID0gXFxcIkNhbmRsZXNcXFwiXFxuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnRmID0gXFxcIjFtXFxcIlxcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudHZqcy5yZXNldENoYXJ0KClcXG4gICAgICAgIH0sXFxuICAgICAgICB4YmFycyAoKSB7XFxuICAgICAgICAgICAgdGhpcy5kYXRhLm92cyA9ICdYT2hsY0JhcnMnXFxuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnRmID0gXFxcIjFtXFxcIlxcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudHZqcy5yZXNldENoYXJ0KClcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFkZSAoKSB7XFxuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnR5cGUgPSBcXFwiU3BsaW5lXFxcIlxcbiAgICAgICAgfSxcXG4gICAgICAgIHdpbl9xdWVyeSgpIHtcXG4gICAgICAgICAgICBsZXQgcXMgPSAoZnVuY3Rpb24oYSkge1xcbiAgICAgICAgICAgICAgICBpZiAoYSA9PSBcXFwiXFxcIikgcmV0dXJuIHt9O1xcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHt9O1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBwPWFbaV0uc3BsaXQoJz0nLCAyKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA9PSAxKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJbcFswXV0gPSBcXFwiXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICBiW3BbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHBbMV0ucmVwbGFjZSgvXFxcXCsvZywgXFxcIiBcXFwiKSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XFxuICAgICAgICAgICAgfSkod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkuc3BsaXQoJyYnKSk7XFxuICAgICAgICAgICAgcmV0dXJuIHFzXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVzZXQoc3RhdGUpIHtcXG4gICAgICAgICAgICBsZXQgc3ViID0gT2JqZWN0LmtleXMoc3RhdGUpLmZpbHRlcih4ID0+IHN0YXRlW3hdKVxcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHN1Yi5tYXAoeCA9PiBFeHRlbnNpb25zW3hdKVxcbiAgICAgICAgICAgIHRoaXMucmVzZXRrZXkrK1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9uc2VsZWN0KGlkKSB7XFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gaWRcXG4gICAgICAgIH0sXFxuICAgICAgICB0aW1lem9uZWQoKSB7XFxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcXG4gICAgICAgICAgICB2YXIgbWludXRlcyA9IE1hdGguYWJzKG9mZnNldCk7XFxuICAgICAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gNjApO1xcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBvZmZzZXQgPCAwID8gXFxcIlxcXCIgOiBcXFwiLVxcXCI7XFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHByZWZpeCtob3Vycyk7XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gTmV3IGRhdGEgaGFuZGxlci4gU2hvdWxkIHJldHVybiBQcm9taXNlLCBvclxcbiAgICAgICAgLy8gdXNlIGNhbGxiYWNrOiBsb2FkX2NodW5rKHJhbmdlLCB0ZiwgY2FsbGJhY2spXFxuICAgICAgICBhc3luYyBsb2FkX2NodW5rKHJhbmdlKSB7XFxuICAgICAgICAgICAgbGV0IFt0MSwgdDJdID0gcmFuZ2VcXG4gICAgICAgICAgICBsZXQgeCA9IHN5bWJvbGJnXFxuICAgICAgICAgICAgbGV0IHkgPSBwYWlyYmdcXG4gICAgICAgICAgICBsZXQgcSA9IGAke3h9JHt5fSZpbnRlcnZhbD0xbSZzdGFydFRpbWU9JHt0MX0mZW5kVGltZT0ke3QyfWBcXG4gICAgICAgICAgICBsZXQgciA9IGF3YWl0IGZldGNoKFVSTCArIHEpLnRoZW4ociA9PiByLmpzb24oKSlcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQodGhpcy5wYXJzZV9iaW5hbmNlKHIpKVxcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIFBhcnNlIGEgc3BlY2lmaWMgZXhjaGFuZ2UgZm9ybWF0XFxuICAgICAgICBwYXJzZV9iaW5hbmNlKGRhdGEpIHtcXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHJldHVybiBbXVxcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcCh4ID0+IHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICB4W2ldID0gcGFyc2VGbG9hdCh4W2ldKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiB4LnNsaWNlKDAsNilcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSxcXG4gICAgICAgIGZvcm1hdChkYXRhKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgJ2NoYXJ0LmRhdGEnOiBkYXRhLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBvbl90cmFkZXModHJhZGUpIHtcXG4gICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZSh7XFxuICAgICAgICAgICAgICAgIHQ6IHRyYWRlLlQsICAgICAvLyBFeGNoYW5nZSB0aW1lIChvcHRpb25hbClcXG4gICAgICAgICAgICAgICAgcHJpY2U6IHBhcnNlRmxvYXQodHJhZGUucCksICAgLy8gVHJhZGUgcHJpY2VcXG4gICAgICAgICAgICAgICAgdm9sdW1lOiBwYXJzZUZsb2F0KHRyYWRlLnEpLCAgLy8gVHJhZGUgYW1vdW50XFxuICAgICAgICAgICAgICAgIGRhdGFzIDogWyAvLyBVcGRhdGUgZGF0YXNldFxcbiAgICAgICAgICAgICAgICAgICAgdHJhZGUuVCxcXG4gICAgICAgICAgICAgICAgICAgIHRyYWRlLm0gPyAwIDogMSwgICAgICAgICAgLy8gU2VsbCBvciBCdXlcXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodHJhZGUucSksXFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRyYWRlLnApXFxuICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlciBvbmNoYXJ0L29mZmNoYXJ0IHVwZGF0ZXNcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcblxcbjxzdHlsZT5cXG4uYXBwLWNvbnRlbnQge1xcbiAgICBwYWRkaW5nOiBjYWxjKDJyZW0gKyAyLjQ1cmVtKSAwIDAgMHJlbSAhaW1wb3J0YW50O1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxufVxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjcuOThweCl7XFxuICAgIGh0bWwgYm9keS5uYXZiYXItc3RpY2t5IC5hcHAtY29udGVudCB7XFxuICAgICAgICBwYWRkaW5nOiBjYWxjKDFyZW0gLSAwLjhyZW0gKyA0LjQ1cmVtKSAwIDAgMCAhaW1wb3J0YW50O1xcbiAgICB9XFxufVxcbi5mbGV4ZWQge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG59XFxuXFxuI2FwcC1jb25haW5lciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbn1cXG5cXG4vKiBAbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpe1xcbiAgICAjYXBwLWNvbmFpbmVyIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIH1cXG59ICovXFxuI3RyYWRlYmFyIHtcXG4gICAgY29sb3I6ICNkZGQ7XFxufVxcblxcbiN0dmpzLWhlYWRlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDcwcHg7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgY29sb3I6ICNkZGQ7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTIxODI2O1xcbn1cXG5cXG4ubmlnaHQtbW9kZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAxNXB4O1xcbiAgICByaWdodDogMjBweDtcXG59XFxuXFxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMC1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMC1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMS1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMS1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLWJvdGJhci1jYW52YXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyAwJSkgIWltcG9ydGFudDtcXG59XFxuXFxuI3RyYWRpbmctdnVlLXRiaXRlbSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigxOCwgMjQsIDM4KTtcXG59XFxuXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LWRldmljZS13aWR0aDogNDgwcHgpIHtcXG4gICAgLnRmLXNlbGVjdG9yIHtcXG4gICAgICAgIHRvcDogNTBweDtcXG4gICAgICAgIHJpZ2h0OiAxNDBweDtcXG4gICAgICAgIG1heC13aWR0aDogMTQwcHg7XFxuICAgICAgICBmb250OiAxMnB4IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCxcXG4gICAgICAgICAgICBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLFxcbiAgICAgICAgICAgIEZpcmEgU2FucywgRHJvaWQgU2FucywgSGVsdmV0aWNhIE5ldWUsXFxuICAgICAgICAgICAgc2Fucy1zZXJpZjtcXG4gICAgfVxcbn1cXG5cXG4uYm94IHtcXG4gICAgd2lkdGg6IDI4MHB4O1xcbiAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgYm94LXNoYWRvdzogMCAxLjVweCA1cHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgcGFkZGluZzogMCAxNXB4IDAgMTVweDtcXG59XFxuXFxudGFibGUge1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgIGNvbG9yOiByZ2IoMTgzLCAxODksIDE5OCk7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG50ZCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgaGVpZ2h0OiAyMHB4O1xcbiAgICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxuXFxudGQucHJpY2Uge1xcbiAgICB3aWR0aDogMzAlO1xcbn1cXG5cXG50ZC5wcmljZSBzcGFuIHtcXG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7XFxufVxcblxcbnRkLnF1YW50aXR5IHtcXG4gICAgd2lkdGg6IDMwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcblxcbnRkLnRpbWUge1xcbiAgICB3aWR0aDogNDAlO1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXG4gICAgY29sb3I6ICM5OTk7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcXG59XFxuXFxudGQuYnRjIHtcXG4gICAgd2lkdGg6IDQwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcXG59XFxuXFxudGQgc3BhbiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgei1pbmRleDogMjtcXG59XFxuXFxudGFibGUuYXNrcyAucGVyY2VudCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ2LCA3MCwgOTQsIDAuMik7XFxufVxcblxcbnRhYmxlLmJpZHMgLnBlcmNlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE0LCAyMDMsIDEyOSwgMC4yKTtcXG59XFxuXFxudGQgLnBlcmNlbnQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICByaWdodDogMDtcXG59XFxuXFxuLm5ld2VzdCB7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbiAgICBtYXJnaW46IDE1cHggLTE1cHg7XFxufVxcblxcbi5jYXJkLTExMCB7XFxuICAgIHRvcDogMTEwcHggIWltcG9ydGFudDtcXG4gICAgbGVmdDogNzBweDtcXG59XFxuLyogU3R5bGUgcGFnZSBjb250ZW50IC0gdXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gcHVzaCB0aGUgcGFnZSBjb250ZW50IHRvIHRoZSByaWdodCB3aGVuIHlvdSBvcGVuIHRoZSBzaWRlIG5hdmlnYXRpb24gKi9cXG4jbWFpbiB7XFxuICAgIHRyYW5zaXRpb246IG1hcmdpbi1sZWZ0IC41cztcXG4gICAgLyogSWYgeW91IHdhbnQgYSB0cmFuc2l0aW9uIGVmZmVjdCAqL1xcbn1cXG5cXG4vKiBPbiBzbWFsbGVyIHNjcmVlbnMsIHdoZXJlIGhlaWdodCBpcyBsZXNzIHRoYW4gNDUwcHgsIGNoYW5nZSB0aGUgc3R5bGUgb2YgdGhlIHNpZGVuYXYgKGxlc3MgcGFkZGluZyBhbmQgYSBzbWFsbGVyIGZvbnQgc2l6ZSkgKi9cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogNDUwcHgpIHtcXG4gICAgLnNpZGViYXIxIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAxNXB4O1xcbiAgICB9XFxuXFxuICAgIC5zaWRlYmFyMSBhIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgfVxcbn1cXG5cXG4uYnRuLWNpcmNsZSB7XFxuICAgIHdpZHRoOiAzMHB4O1xcbiAgICBoZWlnaHQ6IDMwcHg7XFxuICAgIHBhZGRpbmc6IDZweCAwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbiNjaGFydGRpdiB7XFxuICAgIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcXG4gICAgaGVpZ2h0OiA3MHZoO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnR2anMtc3RkLWlucHV0IHtcXHJcXG4gICAgbWFyZ2luOiA1cHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxNjFiMjc7XFxyXFxuICAgIGJvcmRlcjogMXB4IGRvdHRlZCAjMzUzOTQwO1xcclxcbiAgICBoZWlnaHQ6IDIycHg7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXHJcXG4gICAgcGFkZGluZzogMnB4IDBweCAzcHggMTBweDtcXHJcXG4gICAgY29sb3I6IHdoaXRlc21va2U7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS4yZW07XFxyXFxuICAgIG91dGxpbmU6IG5vbmU7XFxyXFxuICAgIHdpZHRoOiAxMDBweDtcXG59XFxuc2VsZWN0LnR2anMtc3RkLWlucHV0IHtcXHJcXG4gICAgaGVpZ2h0OiAyOXB4O1xcclxcbiAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbnNlbGVjdC50dmpzLXN0ZC1pbnB1dCAge1xcclxcbiAgICAvL2Rpc3BsYXk6IG5vbmU7IC8qaGlkZSBvcmlnaW5hbCBTRUxFQ1QgZWxlbWVudDogKi9cXG59XFxuLnR2anMtc3RkLWlucHV0OjotbW96LXBsYWNlaG9sZGVyIHtcXHJcXG4gICAgY29sb3I6ICM4ZTkwOWE7XFxyXFxuICAgIG9wYWNpdHk6IDAuMjU7XFxufVxcbi50dmpzLXN0ZC1pbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXIge1xcclxcbiAgICBjb2xvcjogIzhlOTA5YTtcXHJcXG4gICAgb3BhY2l0eTogMC4yNTtcXG59XFxuLnR2anMtc3RkLWlucHV0OjpwbGFjZWhvbGRlciB7XFxyXFxuICAgIGNvbG9yOiAjOGU5MDlhO1xcclxcbiAgICBvcGFjaXR5OiAwLjI1O1xcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQTRDQTtJQUNBLFdBQUE7SUFDQSx5QkFBQTtJQUNBLDBCQUFBO0lBQ0EsWUFBQTtJQUNBLGtCQUFBO0lBQ0EseUJBQUE7SUFDQSxpQkFBQTtJQUNBLGdCQUFBO0lBQ0EsYUFBQTtJQUNBLFlBQUE7QUFDQTtBQUVBO0lBQ0EsWUFBQTtJQUNBLHFCQUFBO0FBRUE7QUFFQTtJQUNBLGVBQUEsRUFBQSxpQ0FBQTtBQUNBO0FBR0E7SUFDQSxjQUFBO0lBQ0EsYUFBQTtBQUNBO0FBSEE7SUFDQSxjQUFBO0lBQ0EsYUFBQTtBQUNBO0FBSEE7SUFDQSxjQUFBO0lBQ0EsYUFBQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG4gICAgPHNwYW4+XFxyXFxuICAgICAgICA8aW5wdXRcXG52LWlmPVxcXCJ0eXBlPT09J3RleHQnIHx8ICF0eXBlXFxcIlxcclxcbiAgICAgICAgICAgIDp2YWx1ZT1cXFwidmFsdWVcXFwiXFxuY2xhc3M9XFxcInR2anMtc3RkLWlucHV0XFxcIlxcbjpzdHlsZT1cXFwic3R5bGVcXFwiXFxyXFxuICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVxcXCJuYW1lXFxcIlxcclxcbiAgICAgICAgICAgIEBjaGFuZ2U9XFxcIiRlbWl0KCdjaGFuZ2UnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxcXCJcXHJcXG4gICAgICAgICAgICBAaW5wdXQ9XFxcIiRlbWl0KCdpbnB1dCcsICRldmVudC50YXJnZXQudmFsdWUpXFxcIlxcbj5cXHJcXG4gICAgICAgIDxzZWxlY3RcXG52LWVsc2UtaWY9XFxcInR5cGU9PT0nc2VsZWN0J1xcXCJcXHJcXG4gICAgICAgICAgICBjbGFzcz1cXFwidHZqcy1zdGQtaW5wdXRcXFwiXFxuOnN0eWxlPVxcXCJzdHlsZVxcXCJcXHJcXG4gICAgICAgICAgICA6dmFsdWU9XFxcInZhbHVlXFxcIlxcclxcbiAgICAgICAgICAgIEBpbnB1dD1cXFwiJGVtaXQoJ2lucHV0JywgJGV2ZW50LnRhcmdldC52YWx1ZSlcXFwiXFxuPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdi1mb3I9XFxcIm9wdCBpbiBsaXN0XFxcIj57eyBvcHQgfX08L29wdGlvbj5cXHJcXG4gICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICA8L3NwYW4+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgbmFtZTogJ1N0ZElucHV0JyxcXHJcXG4gICAgcHJvcHM6IFsndmFsdWUnLCAnbmFtZScsICd0eXBlJywgJ2xpc3QnLCAnY29sb3JzJ10sXFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgc3R5bGUoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kOiB0aGlzLiRwcm9wcy5jb2xvcnMuYmFjayxcXHJcXG4gICAgICAgICAgICAgICAgLy9jb2xvcjogdGhpcy4kcHJvcHMuY29sb3JzLnRleHRcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6IHt9XFxyXFxufVxcclxcbjwvc2NyaXB0PlxcclxcblxcclxcbjxzdHlsZT5cXHJcXG4udHZqcy1zdGQtaW5wdXQge1xcclxcbiAgICBtYXJnaW46IDVweDtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzE2MWIyNztcXHJcXG4gICAgYm9yZGVyOiAxcHggZG90dGVkICMzNTM5NDA7XFxyXFxuICAgIGhlaWdodDogMjJweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgICBwYWRkaW5nOiAycHggMHB4IDNweCAxMHB4O1xcclxcbiAgICBjb2xvcjogd2hpdGVzbW9rZTtcXHJcXG4gICAgZm9udC1zaXplOiAxLjJlbTtcXHJcXG4gICAgb3V0bGluZTogbm9uZTtcXHJcXG4gICAgd2lkdGg6IDEwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5zZWxlY3QudHZqcy1zdGQtaW5wdXQge1xcclxcbiAgICBoZWlnaHQ6IDI5cHg7XFxyXFxuICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuc2VsZWN0LnR2anMtc3RkLWlucHV0ICB7XFxyXFxuICAgIC8vZGlzcGxheTogbm9uZTsgLypoaWRlIG9yaWdpbmFsIFNFTEVDVCBlbGVtZW50OiAqL1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4udHZqcy1zdGQtaW5wdXQ6OnBsYWNlaG9sZGVyIHtcXHJcXG4gICAgY29sb3I6ICM4ZTkwOWE7XFxyXFxuICAgIG9wYWNpdHk6IDAuMjU7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy14LXdpbmRvdyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgYmFja2dyb3VuZDogIzFiMjAyZGVmO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogN3B4O1xcclxcbiAgICB6LWluZGV4OiAxMDA7XFxyXFxuICAgIGNvbG9yOiAjZGVkZGRkO1xcbn1cXG4udHZqcy14LXdpbmRvdy1oZWFkIHtcXHJcXG4gICAgZm9udC1zaXplOiAyZW07XFxyXFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxyXFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gICAgaGVpZ2h0OiAzNnB4O1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgICBjdXJzb3I6IC13ZWJraXQtZ3JhYjtcXHJcXG4gICAgY3Vyc29yOiBncmFiO1xcbn1cXG4udHZqcy14LXdpbmRvdy1ib2R5IHtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgZm9udC1zaXplOiAxLjFlbTtcXG59XFxuLnR2anMteC13aW5kb3ctdGl0bGUge1xcclxcbiAgICB3aWR0aDogMzAwcHg7XFxyXFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi50dmpzLXgtd2luZG93LWNsb3NlIHtcXHJcXG4gICAgd2lkdGg6IDI2cHg7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgbWFyZ2luOiAtMWVtO1xcclxcbiAgICBwYWRkaW5nOiAxZW07XFxyXFxuICAgIGZvbnQtc2l6ZTogMC43NWVtO1xcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFnRUE7SUFDQSxrQkFBQTtJQUNBLHFCQUFBO0lBQ0Esa0JBQUE7SUFDQSxtQkFBQTtJQUNBLGlCQUFBO0lBQ0EsWUFBQTtJQUNBLGNBQUE7QUFDQTtBQUNBO0lBQ0EsY0FBQTtJQUNBLHlCQUFBO09BQUEsc0JBQUE7UUFBQSxxQkFBQTtZQUFBLGlCQUFBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0lBQ0EsaUJBQUE7SUFDQSwyQkFBQTtJQUNBLHFCQUFBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLG9CQUFBO0lBQUEsWUFBQTtBQUNBO0FBRUE7SUFDQSxhQUFBO0lBQ0EsZ0JBQUE7QUFDQTtBQUNBO0lBQ0EsWUFBQTtJQUNBLHlCQUFBO09BQUEsc0JBQUE7UUFBQSxxQkFBQTtZQUFBLGlCQUFBO0FBQ0E7QUFDQTtJQUNBLFdBQUE7SUFDQSxlQUFBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxpQkFBQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG4gICAgPGRpdlxcbnJlZj1cXFwid2luXFxcIlxcbmNsYXNzPVxcXCJ0dmpzLXgtd2luZG93XFxcIlxcbjpzdHlsZT1cXFwic3R5bGVcXFwiXFxuPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHZqcy14LXdpbmRvdy1oZWFkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2XFxuY2xhc3M9XFxcInR2anMteC13aW5kb3ctdGl0bGVcXFwiXFxyXFxuICAgICAgICAgICAgICAgIEBtb3VzZWRvd249XFxcIm9uTW91c2VEb3duXFxcIlxcbj5cXHJcXG4gICAgICAgICAgICAgICAge3sgdGl0bGUgfX1cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2XFxuY2xhc3M9XFxcInR2anMteC13aW5kb3ctY2xvc2VcXFwiXFxyXFxuICAgICAgICAgICAgICAgIEBjbGljaz1cXFwiJGVtaXQoJ2Nsb3NlJylcXFwiXFxuPlxcclxcbiAgICAgICAgICAgICAgICDilbNcXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHZqcy14LXdpbmRvdy1ib2R5XFxcIj5cXHJcXG4gICAgICAgICAgICA8c2xvdCAvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5cXHJcXG5pbXBvcnQgRHJhZ2cgZnJvbSAnLi9kcmFnZy5qcydcXHJcXG5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIG5hbWU6ICdXaW5kb3cnLFxcclxcbiAgICBtaXhpbnM6IFtEcmFnZ10sXFxyXFxuICAgIHByb3BzOiBbJ3RpdGxlJywgJ3R2J10sXFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIHd3OiAwLFxcclxcbiAgICAgICAgICAgIHdoOiAwLFxcclxcbiAgICAgICAgICAgIHg6IDAsXFxyXFxuICAgICAgICAgICAgeTogMFxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgc3R5bGUoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgdG9wOiBgJHt0aGlzLnl9cHhgLFxcclxcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHt0aGlzLnh9cHhgXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHR2dygpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcHJvcHMudHYud2lkdGhcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB0dmgoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnR2LmhlaWdodFxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtb3VudGVkKCkge1xcclxcbiAgICAgICAgdGhpcy53dyA9IHRoaXMuJHJlZnMud2luLmNsaWVudFdpZHRoXFxyXFxuICAgICAgICB0aGlzLndoID0gdGhpcy4kcmVmcy53aW4uY2xpZW50SGVpZ2h0XFxyXFxuICAgICAgICB0aGlzLnggPSB0aGlzLnR2dyAqIDAuNSAtIHRoaXMud3cgKiAwLjVcXHJcXG4gICAgICAgIHRoaXMueSA9IHRoaXMudHZoICogMC41IC0gdGhpcy53aCAqIDAuNVxcclxcbiAgICB9XFxyXFxufVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG4udHZqcy14LXdpbmRvdyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgYmFja2dyb3VuZDogIzFiMjAyZGVmO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogN3B4O1xcclxcbiAgICB6LWluZGV4OiAxMDA7XFxyXFxuICAgIGNvbG9yOiAjZGVkZGRkO1xcclxcbn1cXHJcXG4udHZqcy14LXdpbmRvdy1oZWFkIHtcXHJcXG4gICAgZm9udC1zaXplOiAyZW07XFxyXFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcclxcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIGhlaWdodDogMzZweDtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgY3Vyc29yOiBncmFiO1xcclxcbn1cXHJcXG5cXHJcXG4udHZqcy14LXdpbmRvdy1ib2R5IHtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgZm9udC1zaXplOiAxLjFlbTtcXHJcXG59XFxyXFxuLnR2anMteC13aW5kb3ctdGl0bGUge1xcclxcbiAgICB3aWR0aDogMzAwcHg7XFxyXFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcbn1cXHJcXG4udHZqcy14LXdpbmRvdy1jbG9zZSB7XFxyXFxuICAgIHdpZHRoOiAyNnB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIG1hcmdpbjogLTFlbTtcXHJcXG4gICAgcGFkZGluZzogMWVtO1xcclxcbiAgICBmb250LXNpemU6IDAuNzVlbTtcXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5oLXNwbGl0dGVyW2RhdGEtdi0xODlmY2NhZF0ge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIGhlaWdodDogNXB4O1xcclxcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgei1pbmRleDogMTtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNlZTRhZmI1O1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbn1cXG4uaC1zcGxpdHRlcltkYXRhLXYtMTg5ZmNjYWRdOmhvdmVyIHtcXHJcXG4gICAgY3Vyc29yOiByb3ctcmVzaXplO1xcclxcbiAgICBvcGFjaXR5OiAxO1xcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS9TcGxpdHRlci52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQWtFQTtJQUNBLGtCQUFBO0lBQ0EsT0FBQTtJQUNBLFdBQUE7SUFDQSxnQkFBQTtJQUNBLFdBQUE7SUFDQSxVQUFBO0lBQ0EsMkJBQUE7SUFDQSxVQUFBO0lBQ0EsbUJBQUE7QUFDQTtBQUNBO0lBQ0Esa0JBQUE7SUFDQSxVQUFBO0FBQ0FcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgICA8c3BhblxcbmNsYXNzPVxcXCJoLXNwbGl0dGVyXFxcIlxcclxcbiAgICAgICAgOnN0eWxlPVxcXCJoc19zdHlsZVxcXCJcXG5AbW91c2Vkb3duPVxcXCJoc19tb3VzZWRvd25cXFwiXFxuLz5cXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuXFxyXFxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMuanMnXFxyXFxuXFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICBuYW1lOiAnU3BsaXR0ZXInLFxcclxcbiAgICBwcm9wczogWydpZCcsICdtYWluJywgJ2RjJywgJ3R2JywgJ2RhdGEnXSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgIGhzX3N0eWxlKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIGRyYWc6IG51bGwsXFxyXFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5kYXRhLmdyaWQyLm9mZnNldCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIC8vYmFja2dyb3VuZENvbG9yOiB0aGlzLmNvbG9ycy5zcGxpdHRlclxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgIH0sXFxyXFxuICAgIG1vdW50ZWQoKSB7XFxyXFxuICAgICAgICB0aGlzLk1JTl9IRUlHSFQgPSB0aGlzLmRhdGEuc2V0dC5taW5faGVpZ2h0IHx8IDIwXFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6IHtcXHJcXG4gICAgICAgIGhzX21vdXNlZG93bihlKSB7XFxyXFxuICAgICAgICAgICAgdGhpcy5kcmFnID0ge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHMnLFxcclxcbiAgICAgICAgICAgICAgICB5OiBlLmNsaWVudFksXFxyXFxuICAgICAgICAgICAgICAgIGgxOiB0aGlzLmRhdGEuZ3JpZDEuaGVpZ2h0LFxcclxcbiAgICAgICAgICAgICAgICBoMjogdGhpcy5kYXRhLmdyaWQyLmhlaWdodFxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBVdGlscy5hZGRfc3R5bGUoJ2Rpc2FibGUtdXNlci1zZWxlY3QnLCBgYm9keSAqIHtcXHJcXG4gICAgICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC50cmFkaW5nLXZ1ZS1jaGFydCB7XFxyXFxuICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgICAgICAgICAgIH1gKVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGhzX21vdXNldXAoZSkge1xcclxcbiAgICAgICAgICAgIHRoaXMuZHJhZyA9IG51bGxcXHJcXG4gICAgICAgICAgICBVdGlscy5yZW1fc3R5bGUoJ2Rpc2FibGUtdXNlci1zZWxlY3QnKVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGhzX21vdXNlbW92ZShlKSB7XFxyXFxuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZykge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgb2ZmID0gZS5jbGllbnRZIC0gdGhpcy5kcmFnLnlcXHJcXG4gICAgICAgICAgICAgICAgbGV0IG5ld19oMSA9IHRoaXMuZHJhZy5oMSArIG9mZlxcclxcbiAgICAgICAgICAgICAgICBsZXQgbmV3X2gyID0gdGhpcy5kcmFnLmgyIC0gb2ZmXFxyXFxuICAgICAgICAgICAgICAgIGlmIChuZXdfaDEgPiB0aGlzLk1JTl9IRUlHSFQgJiZcXHJcXG4gICAgICAgICAgICAgICAgICAgIG5ld19oMiA+IHRoaXMuTUlOX0hFSUdIVCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmdyaWQxLmhlaWdodCA9IG5ld19oMVxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmdyaWQyLmhlaWdodCA9IG5ld19oMlxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jYWxjX2hlaWdodHMoKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBoc19tb3VzZWxlYXZlKGUpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXFxyXFxuICAgICAgICAgICAgVXRpbHMucmVtX3N0eWxlKCdkaXNhYmxlLXVzZXItc2VsZWN0JylcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGUgc2NvcGVkPlxcclxcbi5oLXNwbGl0dGVyIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICBoZWlnaHQ6IDVweDtcXHJcXG4gICAgbWFyZ2luLXRvcDogLTJweDtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHotaW5kZXg6IDE7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzZWU0YWZiNTtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXHJcXG59XFxyXFxuLmgtc3BsaXR0ZXI6aG92ZXIge1xcclxcbiAgICBjdXJzb3I6IHJvdy1yZXNpemU7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy14LXdpbmRvdy5hZGQtd2luW2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzBweDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xcbn1cXG4uYWRkLXdpbi1saXN0W2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBoZWlnaHQ6IDMwMHB4O1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBDaHJvbWUsIFNhZmFyaSBhbmQgT3BlcmEgKi9cXG4uYWRkLXdpbi1saXN0W2RhdGEtdi01MzQwOGFjN106Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBJRSwgRWRnZSBhbmQgRmlyZWZveCAqL1xcbi5hZGQtd2luLWxpc3RbZGF0YS12LTUzNDA4YWM3XSB7XFxuICAtbXMtb3ZlcmZsb3ctc3R5bGU6IG5vbmU7ICAvKiBJRSBhbmQgRWRnZSAqL1xcbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lOyAgLyogRmlyZWZveCAqL1xcbn1cXG4uYWRkLXdpbi1pdGVtW2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBjb2xvcjogI2ZmZmZmZjg4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5hZGQtd2luLWl0ZW1bZGF0YS12LTUzNDA4YWM3XTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQ6ICM4ODg4ODgyMjtcXG4gICAgY29sb3I6ICNmZmZmZmZmZjtcXG59XFxuLmFkZC13aW4taXRlbS1kZXNjW2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBjb2xvcjogI2ZmZmZmZjMzO1xcbiAgICBtYXJnaW4tbGVmdDogM3B4O1xcbn1cXG4uYWRkLXdpbi1pdGVtOmhvdmVyIC5hZGQtd2luLWl0ZW0tZGVzY1tkYXRhLXYtNTM0MDhhYzddIHtcXG4gICAgY29sb3I6ICNmZmZmZmY0NDtcXG59XFxuLmFkZC13aW4tZW1wdHlbZGF0YS12LTUzNDA4YWM3XSB7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBZ0RBO0lBQ0Esb0JBQUE7SUFDQSwyQkFBQTtBQUNBO0FBQ0E7SUFDQSxhQUFBO0lBQ0Esa0JBQUE7SUFDQSxnQkFBQTtJQUNBLHlCQUFBO09BQUEsc0JBQUE7UUFBQSxxQkFBQTtZQUFBLGlCQUFBO0FBQ0E7QUFDQSxnREFBQTtBQUNBO0VBQ0EsYUFBQTtBQUNBOztBQUVBLDRDQUFBO0FBQ0E7RUFDQSx3QkFBQSxHQUFBLGdCQUFBO0VBQ0EscUJBQUEsR0FBQSxZQUFBO0FBQ0E7QUFDQTtJQUNBLGdCQUFBO0lBQ0EsV0FBQTtJQUNBLFlBQUE7SUFDQSxlQUFBO0FBQ0E7QUFDQTtJQUNBLHFCQUFBO0lBQ0EsZ0JBQUE7QUFDQTtBQUNBO0lBQ0EsZ0JBQUE7SUFDQSxnQkFBQTtBQUNBO0FBQ0E7SUFDQSxnQkFBQTtBQUNBO0FBQ0E7SUFDQSxZQUFBO0FBQ0FcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgICA8d2luZG93IHRpdGxlPVxcXCJBZGQgSW5kaWNhdG9yXFxcIiBjbGFzcz1cXFwiYWRkLXdpblxcXCIgOnR2PVxcXCJ0dlxcXCIgQGNsb3NlPVxcXCJvbl9jbG9zZVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhZGQtd2luLWxpc3RcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgdi1mb3I9XFxcIm92IG9mIG92c1xcXCIgY2xhc3M9XFxcImFkZC13aW4taXRlbVxcXCIgQGNsaWNrPVxcXCJvbl9jbGljayhvdi5uYW1lKVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuPnt7IG92Lm5hbWUgfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJhZGQtd2luLWl0ZW0tZGVzY1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICB7eyBvdi5tZXRob2RzLm1ldGFfaW5mbygpLmRlc2MgfX1cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvd2luZG93PlxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5cXG5pbXBvcnQgV2luZG93IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvV2luZG93LnZ1ZSdcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIG5hbWU6ICdBZGRXaW4nLFxcbiAgICBjb21wb25lbnRzOiB7IFdpbmRvdyB9LFxcbiAgICBwcm9wczogWydpZCcsICdtYWluJywgJ2RjJywgJ3R2JywgJ2RhdGEnXSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgb3ZzOiB0aGlzLnR2Lm92ZXJsYXlzLmZpbHRlcih4ID0+IHgubWV0aG9kcy5jYWxjKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgICAgc2V0dCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcHJvcHMuZGF0YS5vdi5zZXR0aW5nc1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtb3VudGVkKCkge1xcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBvbl9jbG9zZSgpIHtcXG4gICAgICAgICAgICB0aGlzLiRwcm9wcy5tYWluLnJlbW92ZV93aWRnZXQodGhpcy4kcHJvcHMuaWQpXFxuICAgICAgICB9LFxcbiAgICAgICAgb25fY2xpY2sobmFtZSkge1xcbiAgICAgICAgICAgIHRoaXMub25fY2xvc2UoKVxcbiAgICAgICAgICAgIHRoaXMubWFpbi5hZGRfb3ZlcmxheSh7XFxuICAgICAgICAgICAgICAgIHNpZGU6IHRoaXMuZGF0YS50eXBlLFxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5kYXRhLmluZGV4LFxcbiAgICAgICAgICAgICAgICB0eXBlOiBuYW1lXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGUgc2NvcGVkPlxcbi50dmpzLXgtd2luZG93LmFkZC13aW4ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzBweDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xcbn1cXG4uYWRkLXdpbi1saXN0IHtcXG4gICAgaGVpZ2h0OiAzMDBweDtcXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuLyogSGlkZSBzY3JvbGxiYXIgZm9yIENocm9tZSwgU2FmYXJpIGFuZCBPcGVyYSAqL1xcbi5hZGQtd2luLWxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBJRSwgRWRnZSBhbmQgRmlyZWZveCAqL1xcbi5hZGQtd2luLWxpc3Qge1xcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAgLyogSUUgYW5kIEVkZ2UgKi9cXG4gIHNjcm9sbGJhci13aWR0aDogbm9uZTsgIC8qIEZpcmVmb3ggKi9cXG59XFxuLmFkZC13aW4taXRlbSB7XFxuICAgIGNvbG9yOiAjZmZmZmZmODg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmFkZC13aW4taXRlbTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQ6ICM4ODg4ODgyMjtcXG4gICAgY29sb3I6ICNmZmZmZmZmZjtcXG59XFxuLmFkZC13aW4taXRlbS1kZXNjIHtcXG4gICAgY29sb3I6ICNmZmZmZmYzMztcXG4gICAgbWFyZ2luLWxlZnQ6IDNweDtcXG59XFxuLmFkZC13aW4taXRlbTpob3ZlciAuYWRkLXdpbi1pdGVtLWRlc2Mge1xcbiAgICBjb2xvcjogI2ZmZmZmZjQ0O1xcbn1cXG4uYWRkLXdpbi1lbXB0eSB7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50dmpzLXgtd2luZG93LnNldHQtd2luW2RhdGEtdi01ZDIyM2IwZV0ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzBweDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xcbn1cXG4uc2V0dC13aW4taXRlbVtkYXRhLXYtNWQyMjNiMGVdIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4uc2V0dC13aW4taXRlbSBsYWJlbFtkYXRhLXYtNWQyMjNiMGVdIHtcXG4gICAgbWluLXdpZHRoOiA4MHB4O1xcbiAgICBjb2xvcjogIzM1YTc3NjtcXG59XFxuLnNldHQtd2luLWVtcHR5W2RhdGEtdi01ZDIyM2IwZV0ge1xcbiAgICBvcGFjaXR5OiAwLjU7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXNEQTtJQUNBLG9CQUFBO0lBQ0EsMkJBQUE7QUFDQTtBQUNBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0lBQ0EsaUJBQUE7SUFDQSwyQkFBQTtJQUNBLHFCQUFBO0lBQ0EsbUJBQUE7QUFDQTtBQUNBO0lBQ0EsZUFBQTtJQUNBLGNBQUE7QUFDQTtBQUNBO0lBQ0EsWUFBQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gICAgPHdpbmRvdyA6dGl0bGU9XFxcImRhdGEub3YubmFtZVxcXCIgY2xhc3M9XFxcInNldHQtd2luXFxcIiA6dHY9XFxcInR2XFxcIiBAY2xvc2U9XFxcIm9uX2Nsb3NlXFxcIj5cXG4gICAgICAgIDxkaXYgdi1mb3I9XFxcImsgaW4gc2V0dGxpc3RcXFwiIGNsYXNzPVxcXCJzZXR0LXdpbi1pdGVtXFxcIj5cXG4gICAgICAgICAgICA8bGFiZWw+e3sgczJkKGspIH19PC9sYWJlbD5cXG4gICAgICAgICAgICA8c3RkLWlucHV0IDp2YWx1ZT1cXFwic2V0dFtrXVxcXCIgQGlucHV0PVxcXCJ1cGRhdGVfc2V0dChrLCAkZXZlbnQpXFxcIiAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8c3BhbiB2LWlmPVxcXCIhc2V0dGxpc3QubGVuZ3RoXFxcIiBjbGFzcz1cXFwic2V0dC13aW4tZW1wdHlcXFwiPlxcbiAgICAgICAgICAgIDxpPk5vIHNjcmlwdCBzZXR0aW5nczwvaT5cXG4gICAgICAgIDwvc3Bhbj5cXG4gICAgPC93aW5kb3c+XFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcblxcbmltcG9ydCBXaW5kb3cgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9XaW5kb3cudnVlJ1xcbmltcG9ydCBTdGRJbnB1dCBmcm9tICcuLi8uLi9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZSdcXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy5qcydcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIG5hbWU6ICdTZXR0aW5nc1dpbicsXFxuICAgIGNvbXBvbmVudHM6IHsgV2luZG93LCBTdGRJbnB1dCB9LFxcbiAgICBwcm9wczogWydpZCcsICdtYWluJywgJ2RjJywgJ3R2JywgJ2RhdGEnXSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIHNldHQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmRhdGEub3Yuc2V0dGluZ3NcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXR0bGlzdCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXR0KS5maWx0ZXIoeCA9PlxcbiAgICAgICAgICAgICAgICB4WzBdICE9PSAnJCcgJiYgdGhpcy5zZXR0LiRwcm9wcyAmJlxcbiAgICAgICAgICAgICAgICB0aGlzLnNldHQuJHByb3BzLmluY2x1ZGVzKHgpKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtb3VudGVkKCkge1xcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBzMmQoc3RyKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnNldHQyZGVzYyhzdHIpXFxuICAgICAgICB9LFxcbiAgICAgICAgb25fY2xvc2UoKSB7XFxuICAgICAgICAgICAgdGhpcy4kcHJvcHMubWFpbi5yZW1vdmVfd2lkZ2V0KHRoaXMuJHByb3BzLmlkKVxcbiAgICAgICAgfSxcXG4gICAgICAgIHVwZGF0ZV9zZXR0KGssIHZhbCkge1xcbiAgICAgICAgICAgIGxldCBkY2lkID0gdGhpcy4kcHJvcHMuZGF0YS5vdi5pZFxcblxcbiAgICAgICAgICAgIGxldCB2YWxOID0gcGFyc2VGbG9hdCh2YWwpXFxuICAgICAgICAgICAgaWYgKHZhbE4gIT09IHZhbE4pIHZhbE4gPSB2YWxcXG5cXG4gICAgICAgICAgICB0aGlzLiRwcm9wcy5kYy5tZXJnZShgJHtkY2lkfS5zZXR0aW5nc2AsXFxuICAgICAgICAgICAgICAgIHsgW2tdOiB2YWxOIH1cXG4gICAgICAgICAgICApXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlIHNjb3BlZD5cXG4udHZqcy14LXdpbmRvdy5zZXR0LXdpbiB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAzMHB4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjODA4MDgwMTE7XFxufVxcbi5zZXR0LXdpbi1pdGVtIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4uc2V0dC13aW4taXRlbSBsYWJlbCB7XFxuICAgIG1pbi13aWR0aDogODBweDtcXG4gICAgY29sb3I6ICMzNWE3NzY7XFxufVxcbi5zZXR0LXdpbi1lbXB0eSB7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyICYmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl0pOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSkge1xuICB2YXIgX2l0ZW0gPSBfc2xpY2VkVG9BcnJheShpdGVtLCA0KSxcbiAgICAgIGNvbnRlbnQgPSBfaXRlbVsxXSxcbiAgICAgIGNzc01hcHBpbmcgPSBfaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMl0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NYWluLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vV2luZG93LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xODlmY2NhZCZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjlbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQWRkV2luLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTUzNDA4YWM3JnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TZXR0aW5nc1dpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01ZDIyM2IwZSZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIi8qIVxuICogVHJhZGluZ1Z1ZS5KUyAtIHYxLjAuMiAtIFRodSBNYXIgMTggMjAyMVxuICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS90dmpzeC90cmFkaW5nLXZ1ZS1qc1xuICogICAgIENvcHlyaWdodCAoYykgMjAxOSBDNDUxIENvZGUncyBBbGwgUmlnaHQ7XG4gKiAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlRyYWRpbmdWdWVKc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJUcmFkaW5nVnVlSnNcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNzU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjY2KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTQ2OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLyoqXG4gKiBVdGlsaXR5IGNvbXBhcmUgZnVuY3Rpb25zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IDEgaWYgYSA+IGIsIDAgaWYgYSA9IGIsIC0xIGlmIGEgPCBiXG4gICAgICovXG4gICAgbnVtY21wOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAxIGlmIGEgPiBiLCAwIGlmIGEgPSBiLCAtMSBpZiBhIDwgYlxuICAgICAqL1xuICAgIHN0cmNtcDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH1cblxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjc4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKipcbiAqIEluZGV4ZWQgQXJyYXkgQmluYXJ5IFNlYXJjaCBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTAwKSxcbiAgICBjbXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0NiksXG4gICAgYmluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG4vKipcbiAqIE1vZHVsZSBpbnRlcmZhY2UgZGVmaW5pdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWRBcnJheTtcblxuLyoqXG4gKiBJbmRleGVkIEFycmF5IGNvbnN0cnVjdG9yXG4gKlxuICogSXQgbG9hZHMgdGhlIGFycmF5IGRhdGEsIGRlZmluZXMgdGhlIGluZGV4IGZpZWxkIGFuZCB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICogdG8gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIGlzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbmRleCBpcyB0aGUgb2JqZWN0J3MgcHJvcGVydHkgdXNlZCB0byBzZWFyY2ggdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRBcnJheShkYXRhLCBpbmRleCkge1xuXG4gICAgLy8gaXMgZGF0YSBzb3J0YWJsZSBhcnJheSBvciBhcnJheS1saWtlIG9iamVjdD9cbiAgICBpZiAoIXV0aWwuaXNTb3J0YWJsZUFycmF5TGlrZShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhXCIpO1xuXG4gICAgLy8gaXMgaW5kZXggYSB2YWxpZCBwcm9wZXJ0eT9cbiAgICBpZiAoIWluZGV4IHx8IGRhdGEubGVuZ3RoID4gMCAmJiAhKGluZGV4IGluIGRhdGFbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGV4XCIpO1xuXG4gICAgLy8gZGF0YSBhcnJheVxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBuYW1lIG9mIHRoZSBpbmRleCBwcm9wZXJ0eVxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcblxuICAgIC8vIHNldCBpbmRleCBib3VuZGFyeSB2YWx1ZXNcbiAgICB0aGlzLnNldEJvdW5kYXJpZXMoKTtcblxuICAgIC8vIGRlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgIHRoaXMuY29tcGFyZSA9IHR5cGVvZiB0aGlzLm1pbnYgPT09IFwibnVtYmVyXCIgPyBjbXAubnVtY21wIDogY21wLnN0cmNtcDtcblxuICAgIC8vIGRlZmF1bHQgc2VhcmNoIGZ1bmN0aW9uXG4gICAgdGhpcy5zZWFyY2ggPSBiaW4uc2VhcmNoO1xuXG4gICAgLy8gY2FjaGUgb2YgaW5kZXggdmFsdWVzIHRvIGFycmF5IHBvc2l0aW9uc1xuICAgIC8vIGVhY2ggdmFsdWUgc3RvcmVzIGFuIG9iamVjdCBhcyB7IGZvdW5kOiB0cnVlfGZhbHNlLCBpbmRleDogYXJyYXktaW5kZXggfVxuICAgIHRoaXMudmFscG9zID0ge307XG5cbiAgICAvLyBjdXJzb3IgYW5kIGFkamFjZW50IHBvc2l0aW9uc1xuICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgIHRoaXMubmV4dGhpZ2ggPSBudWxsO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRvIGNvbXBhcmUgaW5kZXggdmFsdWVzIHRoYXQgcmV0dXJuZXMgMSwgMCwgLTFcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zZXRDb21wYXJlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuXG4gICAgdGhpcy5jb21wYXJlID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc2VhcmNoIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gc2VhcmNoIGluZGV4IHZhbHVlcyBpbiB0aGUgYXJyYXkgb2Ygb2JqZWN0c1xuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLnNldFNlYXJjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcblxuICAgIHRoaXMuc2VhcmNoID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvcnQgdGhlIGRhdGEgYXJyYXkgYnkgaXRzIGluZGV4IHByb3BlcnR5XG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgIC8vIHNvcnQgdGhlIGFycmF5XG4gICAgdGhpcy5kYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY29tcGFyZShhW2luZGV4XSwgYltpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgYm91bmRhcnkgdmFsdWVzXG4gICAgdGhpcy5zZXRCb3VuZGFyaWVzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5zcGVjdCBhbmQgc2V0IHRoZSBib3VuZGFyaWVzIG9mIHRoZSBpbnRlcm5hbCBkYXRhIGFycmF5XG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuc2V0Qm91bmRhcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgdGhpcy5taW52ID0gZGF0YS5sZW5ndGggJiYgZGF0YVswXVtpbmRleF07XG4gICAgdGhpcy5tYXh2ID0gZGF0YS5sZW5ndGggJiYgZGF0YVtkYXRhLmxlbmd0aCAtIDFdW2luZGV4XTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhcbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGluZGV4IGlzIHRoZSBpZCBvZiB0aGUgcmVxdWVzdGVkIG9iamVjdFxuICogQHJldHVybnMge051bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5XG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBjaGVjayBkYXRhIGhhcyBvYmplY3RzXG4gICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRoaWdoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGhlIHJlcXVlc3QgaXMgd2l0aGluIHJhbmdlXG4gICAgaWYgKHRoaXMuY29tcGFyZSh2YWx1ZSwgdGhpcy5taW52KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRoaWdoID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbXBhcmUodmFsdWUsIHRoaXMubWF4dikgPT09IDEpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRsb3cgPSB0aGlzLmRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB2YWxwb3MgPSB0aGlzLnZhbHBvcyxcbiAgICAgICAgcG9zID0gdmFscG9zW3ZhbHVlXTtcblxuICAgIC8vIGlmIHRoZSByZXF1ZXN0IGlzIG1lbW9yaXplZCwganVzdCBnaXZlIGl0IGJhY2tcbiAgICBpZiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MuZm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gcG9zLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5uZXh0bG93ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmV4dGhpZ2ggPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZXh0bG93ID0gcG9zLnByZXY7XG4gICAgICAgICAgICB0aGlzLm5leHRoaWdoID0gcG9zLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gaWYgbm90LCBkbyB0aGUgc2VhcmNoXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuc2VhcmNoLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIHRoaXMuY3Vyc29yID0gcmVzdWx0LmluZGV4O1xuICAgIHRoaXMubmV4dGxvdyA9IHJlc3VsdC5wcmV2O1xuICAgIHRoaXMubmV4dGhpZ2ggPSByZXN1bHQubmV4dDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhcbiAqXG4gKiBXaGVuIG5vIHZhbHVlIGlzIGdpdmVuLCB0aGUgZnVuY3Rpb24gd2lsbCBkZWZhdWx0IHRvIHRoZSBsYXN0IGZldGNoZWQgaXRlbS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcHRpb25hbF0gaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgZm91bmQgb2JqZWN0IG9yIG51bGxcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpXG4gICAgICAgIHRoaXMuZmV0Y2godmFsdWUpO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMuY3Vyc29yO1xuICAgIHJldHVybiBwb3MgIT09IG51bGwgPyB0aGlzLmRhdGFbcG9zXSA6IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBhbiBzbGljZSBvZiB0aGUgZGF0YSBhcnJheVxuICpcbiAqIEJvdW5kYXJpZXMgaGF2ZSB0byBiZSBpbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJlZ2luIGluZGV4IGlzIHRoZSBpZCBvZiB0aGUgcmVxdWVzdGVkIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBlbmQgaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgc2xpY2Ugb2YgZGF0YSBhcnJheSBvciBbXVxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLmdldFJhbmdlID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQpIHtcbiAgICAvLyBjaGVjayBpZiBib3VuZGFyaWVzIGFyZSBpbiBvcmRlclxuICAgIGlmICh0aGlzLmNvbXBhcmUoYmVnaW4sIGVuZCkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIGZldGNoIHN0YXJ0IGFuZCBkZWZhdWx0IHRvIHRoZSBuZXh0IGluZGV4IGFib3ZlXG4gICAgdGhpcy5mZXRjaChiZWdpbik7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5jdXJzb3IgfHwgdGhpcy5uZXh0aGlnaDtcblxuICAgIC8vIGZldGNoIGZpbmlzaCBhbmQgZGVmYXVsdCB0byB0aGUgbmV4dCBpbmRleCBiZWxvd1xuICAgIHRoaXMuZmV0Y2goZW5kKTtcbiAgICB2YXIgZmluaXNoID0gdGhpcy5jdXJzb3IgfHwgdGhpcy5uZXh0bG93O1xuXG4gICAgLy8gaWYgYW55IGJvdW5kYXJ5IGlzIG5vdCBzZXQsIHJldHVybiBubyByYW5nZVxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBmaW5pc2ggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIHJldHVybiByYW5nZVxuICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2Uoc3RhcnQsIGZpbmlzaCArIDEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTAxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBNYWluIHNlYXJjaCByZWN1cnNpdmUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gbG9vcChkYXRhLCBtaW4sIG1heCwgaW5kZXgsIHZhbHBvcykge1xuXG4gICAgLy8gc2V0IGN1cnJlbnQgcG9zaXRpb24gYXMgdGhlIG1pZGRsZSBwb2ludCBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgdmFyIGN1cnIgPSAobWF4ICsgbWluKSA+Pj4gMTtcblxuICAgIC8vIGNvbXBhcmUgY3VycmVudCBpbmRleCB2YWx1ZSB3aXRoIHRoZSBvbmUgd2UgYXJlIGxvb2tpbmcgZm9yXG4gICAgdmFyIGRpZmYgPSB0aGlzLmNvbXBhcmUoZGF0YVtjdXJyXVt0aGlzLmluZGV4XSwgaW5kZXgpO1xuXG4gICAgLy8gZm91bmQ/XG4gICAgaWYgKCFkaWZmKSB7XG4gICAgICAgIHJldHVybiB2YWxwb3NbaW5kZXhdID0ge1xuICAgICAgICAgICAgXCJmb3VuZFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJpbmRleFwiOiBjdXJyLFxuICAgICAgICAgICAgXCJwcmV2XCI6IG51bGwsXG4gICAgICAgICAgICBcIm5leHRcIjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgcG9zaXRpb25zIGF2YWlsYWJsZT9cbiAgICBpZiAobWluID49IG1heCkge1xuICAgICAgICByZXR1cm4gdmFscG9zW2luZGV4XSA9IHtcbiAgICAgICAgICAgIFwiZm91bmRcIjogZmFsc2UsXG4gICAgICAgICAgICBcImluZGV4XCI6IG51bGwsXG4gICAgICAgICAgICBcInByZXZcIjogKGRpZmYgPCAwKSA/IG1heCA6IG1heCAtIDEsXG4gICAgICAgICAgICBcIm5leHRcIjogKGRpZmYgPCAwKSA/IG1heCArIDEgOiBtYXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBjb250aW51ZSBsb29raW5nIGZvciBpbmRleCBpbiBvbmUgb2YgdGhlIHJlbWFpbmluZyBhcnJheSBoYWx2ZXNcbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGNhbiBiZSBza2VwdCBhcyBpbmRleCBpcyBub3QgdGhlcmUuLi5cbiAgICBpZiAoZGlmZiA+IDApXG4gICAgICAgIHJldHVybiBsb29wLmNhbGwodGhpcywgZGF0YSwgbWluLCBjdXJyIC0gMSwgaW5kZXgsIHZhbHBvcyk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gbG9vcC5jYWxsKHRoaXMsIGRhdGEsIGN1cnIgKyAxLCBtYXgsIGluZGV4LCB2YWxwb3MpO1xufVxuXG4vKipcbiAqIFNlYXJjaCBib290c3RyYXBcbiAqIFRoZSBmdW5jdGlvbiBoYXMgdG8gYmUgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIEluZGV4ZWRBcnJheSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc2VhcmNoKGluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgcmV0dXJuIGxvb3AuY2FsbCh0aGlzLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCAtIDEsIGluZGV4LCB0aGlzLnZhbHBvcyk7XG59XG5cbi8qKlxuICogRXhwb3J0IHNlYXJjaCBmdW5jdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5zZWFyY2ggPSBzZWFyY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwMDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8qKlxuICogVXRpbHMgbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gYXJyYXktbGlrZSBvYmplY3RcbiAqXG4gKiBAY3JlZGl0IEphdmFzY3JpcHQ6IFRoZSBEZWZpbml0aXZlIEd1aWRlLCBPJ1JlaWxseSwgMjAxMVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZShvKSB7XG4gICAgaWYgKG8gJiYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvIGlzIG5vdCBudWxsLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgICAgICAgICAgICAgLy8gbyBpcyBhbiBvYmplY3RcbiAgICAgICAgaXNGaW5pdGUoby5sZW5ndGgpICYmICAgICAgICAgICAgICAgIC8vIG8ubGVuZ3RoIGlzIGEgZmluaXRlIG51bWJlclxuICAgICAgICBvLmxlbmd0aCA+PSAwICYmICAgICAgICAgICAgICAgICAgICAgLy8gby5sZW5ndGggaXMgbm9uLW5lZ2F0aXZlXG4gICAgICAgIG8ubGVuZ3RoID09PSBNYXRoLmZsb29yKG8ubGVuZ3RoKSAmJiAvLyBvLmxlbmd0aCBpcyBhbiBpbnRlZ2VyXG4gICAgICAgIG8ubGVuZ3RoIDwgNDI5NDk2NzI5NikgICAgICAgICAgICAgICAvLyBvLmxlbmd0aCA8IDJeMzJcbiAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gbyBpcyBhcnJheS1saWtlXG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IGlzIG5vdFxufVxuXG4vKipcbiAqIENoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHRoZSBzb3J0IGZ1bmN0aW9uIGluIHRoZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaXNTb3J0YWJsZShvKSB7XG4gICAgaWYgKG8gJiYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvIGlzIG5vdCBudWxsLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgICAgICAgICAgICAgLy8gbyBpcyBhbiBvYmplY3RcbiAgICAgICAgdHlwZW9mIG8uc29ydCA9PT0gXCJmdW5jdGlvblwiKSAgICAgICAgLy8gby5zb3J0IGlzIGEgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gbyBpcyBhcnJheS1saWtlXG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IGlzIG5vdFxufVxuXG4vKipcbiAqIENoZWNrIGZvciBzb3J0YWJsZS1hcnJheS1saWtlIG9iamVjdHNcbiAqL1xubW9kdWxlLmV4cG9ydHMuaXNTb3J0YWJsZUFycmF5TGlrZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG8pICYmIGlzU29ydGFibGUobyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwiQ2FuZGxlXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDYW5kbGVFeHQpLFxuICBcIkNvbnN0YW50c1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gY29uc3RhbnRzKSxcbiAgXCJEYXRhQ3ViZVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGF0YUN1YmUpLFxuICBcIkludGVyZmFjZVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gbWl4aW5zX2ludGVyZmFjZSksXG4gIFwiT3ZlcmxheVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gb3ZlcmxheSksXG4gIFwiVG9vbFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdG9vbCksXG4gIFwiVHJhZGluZ1Z1ZVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVHJhZGluZ1Z1ZSksXG4gIFwiVXRpbHNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHV0aWxzKSxcbiAgXCJWb2xiYXJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFZvbGJhckV4dCksXG4gIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzcmMpLFxuICBcImxheW91dF9jbnZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGxheW91dF9jbnYpLFxuICBcImxheW91dF92b2xcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGxheW91dF92b2wpLFxuICBcInByaW1pdGl2ZXNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcHJpbWl0aXZlcylcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvVHJhZGluZ1Z1ZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjM1YzBhZGUmXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWVcIixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNoYXJ0X3Byb3BzLmNvbG9ycy50ZXh0LFxuICAgICAgICBmb250OiB0aGlzLmZvbnRfY29tcCxcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggKyBcInB4XCIsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQgKyBcInB4XCJcbiAgICAgIH0sXG4gICAgICBhdHRyczogeyBpZDogX3ZtLmlkIH0sXG4gICAgICBvbjogeyBtb3VzZWRvd246IF92bS5tb3VzZWRvd24sIG1vdXNlbGVhdmU6IF92bS5tb3VzZWxlYXZlIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF92bS50b29sYmFyXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcInRvb2xiYXJcIixcbiAgICAgICAgICAgIF92bS5fYihcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlZjogXCJ0b29sYmFyXCIsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgY29uZmlnOiBfdm0uY2hhcnRfY29uZmlnIH0sXG4gICAgICAgICAgICAgICAgb246IHsgXCJjdXN0b20tZXZlbnRcIjogX3ZtLmN1c3RvbV9ldmVudCB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwidG9vbGJhclwiLFxuICAgICAgICAgICAgICBfdm0uY2hhcnRfcHJvcHMsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5jb250cm9sbGVycy5sZW5ndGhcbiAgICAgICAgPyBfYyhcIndpZGdldHNcIiwge1xuICAgICAgICAgICAgcmVmOiBcIndpZGdldHNcIixcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIG1hcDogX3ZtLndzLFxuICAgICAgICAgICAgICB3aWR0aDogX3ZtLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IF92bS5oZWlnaHQsXG4gICAgICAgICAgICAgIHR2OiB0aGlzLFxuICAgICAgICAgICAgICBkYzogX3ZtLmRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImNoYXJ0XCIsXG4gICAgICAgIF92bS5fYihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IF92bS5yZXNldCxcbiAgICAgICAgICAgIHJlZjogXCJjaGFydFwiLFxuICAgICAgICAgICAgYXR0cnM6IHsgdHZfaWQ6IF92bS5pZCwgY29uZmlnOiBfdm0uY2hhcnRfY29uZmlnIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBcImN1c3RvbS1ldmVudFwiOiBfdm0uY3VzdG9tX2V2ZW50LFxuICAgICAgICAgICAgICBcInJhbmdlLWNoYW5nZWRcIjogX3ZtLnJhbmdlX2NoYW5nZWQsXG4gICAgICAgICAgICAgIFwibGVnZW5kLWJ1dHRvbi1jbGlja1wiOiBfdm0ubGVnZW5kX2J1dHRvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjaGFydFwiLFxuICAgICAgICAgIF92bS5jaGFydF9wcm9wcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcInRyYW5zaXRpb25cIixcbiAgICAgICAgeyBhdHRyczogeyBuYW1lOiBcInR2anMtZHJpZnRcIiB9IH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfdm0udGlwXG4gICAgICAgICAgICA/IF9jKFwidGhlLXRpcFwiLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgZGF0YTogX3ZtLnRpcCB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICBcInJlbW92ZS1tZVwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLnRpcCA9IG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgIClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvVHJhZGluZ1Z1ZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjM1YzBhZGUmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXMuanNcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanNcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanNcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanNcblxuXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0dWZmL2NvbnN0YW50cy5qc1xudmFyIFNFQ09ORCA9IDEwMDA7XG52YXIgTUlOVVRFID0gU0VDT05EICogNjA7XG52YXIgTUlOVVRFMyA9IE1JTlVURSAqIDM7XG52YXIgTUlOVVRFNSA9IE1JTlVURSAqIDU7XG52YXIgTUlOVVRFMTUgPSBNSU5VVEUgKiAxNTtcbnZhciBNSU5VVEUzMCA9IE1JTlVURSAqIDMwO1xudmFyIEhPVVIgPSBNSU5VVEUgKiA2MDtcbnZhciBIT1VSNCA9IEhPVVIgKiA0O1xudmFyIEhPVVIxMiA9IEhPVVIgKiAxMjtcbnZhciBEQVkgPSBIT1VSICogMjQ7XG52YXIgV0VFSyA9IERBWSAqIDc7XG52YXIgTU9OVEggPSBXRUVLICogNDtcbnZhciBZRUFSID0gREFZICogMzY1O1xudmFyIE1PTlRITUFQID0gW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdOyAvLyBHcmlkIHRpbWUgc3RlcHNcblxudmFyIFRJTUVTQ0FMRVMgPSBbWUVBUiAqIDEwLCBZRUFSICogNSwgWUVBUiAqIDMsIFlFQVIgKiAyLCBZRUFSLCBNT05USCAqIDYsIE1PTlRIICogNCwgTU9OVEggKiAzLCBNT05USCAqIDIsIE1PTlRILCBEQVkgKiAxNSwgREFZICogMTAsIERBWSAqIDcsIERBWSAqIDUsIERBWSAqIDMsIERBWSAqIDIsIERBWSwgSE9VUiAqIDEyLCBIT1VSICogNiwgSE9VUiAqIDMsIEhPVVIgKiAxLjUsIEhPVVIsIE1JTlVURTMwLCBNSU5VVEUxNSwgTUlOVVRFICogMTAsIE1JTlVURTUsIE1JTlVURSAqIDIsIE1JTlVURV07IC8vIEdyaWQgJCBzdGVwc1xuXG52YXIgJFNDQUxFUyA9IFswLjA1LCAwLjEsIDAuMiwgMC4yNSwgMC41LCAwLjgsIDEsIDIsIDVdO1xudmFyIENoYXJ0Q29uZmlnID0ge1xuICBTQk1JTjogNjAsXG4gIC8vIE1pbmltYWwgc2lkZWJhciBweFxuICBTQk1BWDogSW5maW5pdHksXG4gIC8vIE1heCBzaWRlYmFyLCBweFxuICBUT09MQkFSOiA1NyxcbiAgLy8gVG9vbGJhciB3aWR0aCBweFxuICBUQl9JQ09OOiAyNSxcbiAgLy8gVG9vbGJhciBpY29uIHNpemUgcHhcbiAgVEJfSVRFTV9NOiA2LFxuICAvLyBUb29sYmFyIGl0ZW0gbWFyZ2luIHB4XG4gIFRCX0lDT05fQlJJOiAxLFxuICAvLyBUb29sYmFyIGljb24gYnJpZ2h0bmVzc1xuICBUQl9JQ09OX0hPTEQ6IDQyMCxcbiAgLy8gbXMsIHdhaXQgdG8gZXhwYW5kXG4gIFRCX0JPUkRFUjogMSxcbiAgLy8gVG9vbGJhciBib3JkZXIgcHhcbiAgVEJfQl9TVFlMRTogJ2RvdHRlZCcsXG4gIC8vIFRvb2xiYXIgYm9yZGVyIHN0eWxlXG4gIFRPT0xfQ09MTDogNyxcbiAgLy8gVG9vbCBjb2xsaXNpb24gdGhyZXNob2xkXG4gIEVYUEFORDogMC4xNSxcbiAgLy8gJS8xMDAgb2YgcmFuZ2VcbiAgQ0FORExFVzogMC42LFxuICAvLyAlLzEwMCBvZiBzdGVwXG4gIEdSSURYOiAxMDAsXG4gIC8vIHB4XG4gIEdSSURZOiA0NyxcbiAgLy8gcHhcbiAgQk9UQkFSOiAyOCxcbiAgLy8gcHhcbiAgUEFOSEVJR0hUOiAyMixcbiAgLy8gcHhcbiAgREVGQVVMVF9MRU46IDUwLFxuICAvLyBjYW5kbGVzXG4gIE1JTklNVU1fTEVOOiA1LFxuICAvLyBjYW5kbGVzLFxuICBNSU5fWk9PTTogMjUsXG4gIC8vIGNhbmRsZXNcbiAgTUFYX1pPT006IDEwMDAsXG4gIC8vIGNhbmRsZXMsXG4gIFZPTFNDQUxFOiAwLjE1LFxuICAvLyAlLzEwMCBvZiBoZWlnaHRcbiAgVVhfT1BBQ0lUWTogMC45LFxuICAvLyBVeCBiYWNrZ3JvdW5kIG9wYWNpdHlcbiAgWk9PTV9NT0RFOiAndHYnLFxuICAvLyAndHYnIG9yICd0bCdcbiAgTF9CVE5fU0laRTogMjEsXG4gIC8vIExlZ2VuZCBCdXR0b24gc2l6ZSwgcHhcbiAgTF9CVE5fTUFSR0lOOiAnLTZweCAwIC02cHggMCcsXG4gIC8vIGNzcyBtYXJnaW5cbiAgU0NST0xMX1dIRUVMOiAncHJldmVudCcgLy8gJ3Bhc3MnLCAnY2xpY2snXG5cbn07XG5DaGFydENvbmZpZy5GT05UID0gXCIxMXB4IC1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFxcbiAgICBTZWdvZSBVSSxSb2JvdG8sT3h5Z2VuLFVidW50dSxDYW50YXJlbGwsXFxuICAgIEZpcmEgU2FucyxEcm9pZCBTYW5zLEhlbHZldGljYSBOZXVlLFxcbiAgICBzYW5zLXNlcmlmXCI7XG52YXIgSUJfVEZfV0FSTiA9IFwiV2hlbiB1c2luZyBJQiBtb2RlIHlvdSBzaG91bGQgc3BlY2lmeSBcIiArIFwidGltZWZyYW1lICgndGYnIGZpbGVkIGluICdjaGFydCcgb2JqZWN0KSxcIiArIFwib3RoZXJ3aXNlIHlvdSBjYW4gZ2V0IGFuIHVuZXhwZWN0ZWQgYmVoYXZpb3VyXCI7XG52YXIgTUFQX1VOSVQgPSB7XG4gIFwiMXNcIjogU0VDT05ELFxuICBcIjVzXCI6IFNFQ09ORCAqIDUsXG4gIFwiMTBzXCI6IFNFQ09ORCAqIDEwLFxuICBcIjIwc1wiOiBTRUNPTkQgKiAyMCxcbiAgXCIzMHNcIjogU0VDT05EICogMzAsXG4gIFwiMW1cIjogTUlOVVRFLFxuICBcIjNtXCI6IE1JTlVURTMsXG4gIFwiNW1cIjogTUlOVVRFNSxcbiAgXCIxNW1cIjogTUlOVVRFMTUsXG4gIFwiMzBtXCI6IE1JTlVURTMwLFxuICBcIjFIXCI6IEhPVVIsXG4gIFwiMkhcIjogSE9VUiAqIDIsXG4gIFwiM0hcIjogSE9VUiAqIDMsXG4gIFwiNEhcIjogSE9VUjQsXG4gIFwiMTJIXCI6IEhPVVIxMixcbiAgXCIxRFwiOiBEQVksXG4gIFwiMVdcIjogV0VFSyxcbiAgXCIxTVwiOiBNT05USCxcbiAgXCIxWVwiOiBZRUFSXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb25zdGFudHMgPSAoe1xuICBTRUNPTkQ6IFNFQ09ORCxcbiAgTUlOVVRFOiBNSU5VVEUsXG4gIE1JTlVURTU6IE1JTlVURTUsXG4gIE1JTlVURTE1OiBNSU5VVEUxNSxcbiAgTUlOVVRFMzA6IE1JTlVURTMwLFxuICBIT1VSOiBIT1VSLFxuICBIT1VSNDogSE9VUjQsXG4gIERBWTogREFZLFxuICBXRUVLOiBXRUVLLFxuICBNT05USDogTU9OVEgsXG4gIFlFQVI6IFlFQVIsXG4gIE1PTlRITUFQOiBNT05USE1BUCxcbiAgVElNRVNDQUxFUzogVElNRVNDQUxFUyxcbiAgJFNDQUxFUzogJFNDQUxFUyxcbiAgQ2hhcnRDb25maWc6IENoYXJ0Q29uZmlnLFxuICBtYXBfdW5pdDogTUFQX1VOSVQsXG4gIElCX1RGX1dBUk46IElCX1RGX1dBUk5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQ2hhcnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTRkMDZhNGRlJlxudmFyIENoYXJ0dnVlX3R5cGVfdGVtcGxhdGVfaWRfNGQwNmE0ZGVfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS1jaGFydFwiLCBzdHlsZTogX3ZtLnN0eWxlcyB9LFxuICAgIFtcbiAgICAgIF9jKFwia2V5Ym9hcmRcIiwgeyByZWY6IFwia2V5Ym9hcmRcIiB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uX2wodGhpcy5fbGF5b3V0LmdyaWRzLCBmdW5jdGlvbihncmlkLCBpKSB7XG4gICAgICAgIHJldHVybiBfYyhcImdyaWQtc2VjdGlvblwiLCB7XG4gICAgICAgICAga2V5OiBncmlkLmlkLFxuICAgICAgICAgIHJlZjogXCJzZWNcIixcbiAgICAgICAgICByZWZJbkZvcjogdHJ1ZSxcbiAgICAgICAgICBhdHRyczogeyBjb21tb246IF92bS5zZWN0aW9uX3Byb3BzKGkpLCBncmlkX2lkOiBpIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwicmVnaXN0ZXIta2ItbGlzdGVuZXJcIjogX3ZtLnJlZ2lzdGVyX2tiLFxuICAgICAgICAgICAgXCJyZW1vdmUta2ItbGlzdGVuZXJcIjogX3ZtLnJlbW92ZV9rYixcbiAgICAgICAgICAgIFwicmFuZ2UtY2hhbmdlZFwiOiBfdm0ucmFuZ2VfY2hhbmdlZCxcbiAgICAgICAgICAgIFwiY3Vyc29yLWNoYW5nZWRcIjogX3ZtLmN1cnNvcl9jaGFuZ2VkLFxuICAgICAgICAgICAgXCJjdXJzb3ItbG9ja2VkXCI6IF92bS5jdXJzb3JfbG9ja2VkLFxuICAgICAgICAgICAgXCJzaWRlYmFyLXRyYW5zZm9ybVwiOiBfdm0uc2V0X3l0cmFuc2Zvcm0sXG4gICAgICAgICAgICBcImxheWVyLW1ldGEtcHJvcHNcIjogX3ZtLmxheWVyX21ldGFfcHJvcHMsXG4gICAgICAgICAgICBcImN1c3RvbS1ldmVudFwiOiBfdm0uZW1pdF9jdXN0b21fZXZlbnQsXG4gICAgICAgICAgICBcImxlZ2VuZC1idXR0b24tY2xpY2tcIjogX3ZtLmxlZ2VuZF9idXR0b25fY2xpY2tcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJib3RiYXJcIixcbiAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgIHsgYXR0cnM6IHsgc2hhZGVyczogX3ZtLnNoYWRlcnMsIHRpbWV6b25lOiBfdm0udGltZXpvbmUgfSB9LFxuICAgICAgICAgIFwiYm90YmFyXCIsXG4gICAgICAgICAgX3ZtLmJvdGJhcl9wcm9wcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgICApXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBDaGFydHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRkMDZhNGRlX3N0YXRpY1JlbmRlckZucyA9IFtdXG5DaGFydHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRkMDZhNGRlX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NoYXJ0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00ZDA2YTRkZSZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanNcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVJlc3QuanNcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qc1xuXG5cblxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHVmZi9jb250ZXh0LmpzXG4vLyBDYW52YXMgY29udGV4dCBmb3IgdGV4dCBtZWFzdXJtZW50c1xuZnVuY3Rpb24gQ29udGV4dCgkcCkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgdmFyIGN0eCA9IGVsLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY3R4LmZvbnQgPSAkcC5mb250O1xuICByZXR1cm4gY3R4O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbnRleHQgPSAoQ29udGV4dCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2FycmF5c2xpY2VyL2xpYi9pbmRleC5qc1xudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oNjc4KTtcbnZhciBsaWJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obGliKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHVmZi91dGlscy5qc1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB1dGlscyA9ICh7XG4gIGNsYW1wOiBmdW5jdGlvbiBjbGFtcChudW0sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIG51bSA8PSBtaW4gPyBtaW4gOiBudW0gPj0gbWF4ID8gbWF4IDogbnVtO1xuICB9LFxuICBhZGRfemVybzogZnVuY3Rpb24gYWRkX3plcm8oaSkge1xuICAgIGlmIChpIDwgMTApIHtcbiAgICAgIGkgPSBcIjBcIiArIGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGk7XG4gIH0sXG4gIC8vIFN0YXJ0IG9mIHRoZSBkYXkgKHplcm8gbWlsbGlzZWNvbmQpXG4gIGRheV9zdGFydDogZnVuY3Rpb24gZGF5X3N0YXJ0KHQpIHtcbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSh0KTtcbiAgICByZXR1cm4gc3RhcnQuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sXG4gIC8vIFN0YXJ0IG9mIHRoZSBtb250aFxuICBtb250aF9zdGFydDogZnVuY3Rpb24gbW9udGhfc3RhcnQodCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUodCk7XG4gICAgcmV0dXJuIERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKTtcbiAgfSxcbiAgLy8gU3RhcnQgb2YgdGhlIHllYXJcbiAgeWVhcl9zdGFydDogZnVuY3Rpb24geWVhcl9zdGFydCh0KSB7XG4gICAgcmV0dXJuIERhdGUuVVRDKG5ldyBEYXRlKHQpLmdldEZ1bGxZZWFyKCkpO1xuICB9LFxuICBnZXRfeWVhcjogZnVuY3Rpb24gZ2V0X3llYXIodCkge1xuICAgIGlmICghdCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IERhdGUodCkuZ2V0VVRDRnVsbFllYXIoKTtcbiAgfSxcbiAgZ2V0X21vbnRoOiBmdW5jdGlvbiBnZXRfbW9udGgodCkge1xuICAgIGlmICghdCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IERhdGUodCkuZ2V0VVRDTW9udGgoKTtcbiAgfSxcbiAgLy8gTmVhcmVzdCBpbiBhcnJheVxuICBuZWFyZXN0X2E6IGZ1bmN0aW9uIG5lYXJlc3RfYSh4LCBhcnJheSkge1xuICAgIHZhciBkaXN0ID0gSW5maW5pdHk7XG4gICAgdmFyIHZhbCA9IG51bGw7XG4gICAgdmFyIGluZGV4ID0gLTE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgeGkgPSBhcnJheVtpXTtcblxuICAgICAgaWYgKE1hdGguYWJzKHhpIC0geCkgPCBkaXN0KSB7XG4gICAgICAgIGRpc3QgPSBNYXRoLmFicyh4aSAtIHgpO1xuICAgICAgICB2YWwgPSB4aTtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbaW5kZXgsIHZhbF07XG4gIH0sXG4gIHJvdW5kOiBmdW5jdGlvbiByb3VuZChudW0sIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09PSB2b2lkIDApIHtcbiAgICAgIGRlY2ltYWxzID0gODtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChudW0udG9GaXhlZChkZWNpbWFscykpO1xuICB9LFxuICAvLyBTdHJpcD8gTm8sIGl0J3MgdWdseSBmbG9hdHMgaW4ganNcbiAgc3RyaXA6IGZ1bmN0aW9uIHN0cmlwKG51bWJlcikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnNlRmxvYXQobnVtYmVyKS50b1ByZWNpc2lvbigxMikpO1xuICB9LFxuICBnZXRfZGF5OiBmdW5jdGlvbiBnZXRfZGF5KHQpIHtcbiAgICByZXR1cm4gdCA/IG5ldyBEYXRlKHQpLmdldERhdGUoKSA6IG51bGw7XG4gIH0sXG4gIC8vIFVwZGF0ZSBhcnJheSBrZWVwaW5nIHRoZSBzYW1lIHJlZmVyZW5jZVxuICBvdmVyd3JpdGU6IGZ1bmN0aW9uIG92ZXJ3cml0ZShhcnIsIG5ld19hcnIpIHtcbiAgICBhcnIuc3BsaWNlLmFwcGx5KGFyciwgWzAsIGFyci5sZW5ndGhdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobmV3X2FycikpKTtcbiAgfSxcbiAgLy8gQ29weSBsYXlvdXQgaW4gcmVhY3RpdmUgd2F5XG4gIGNvcHlfbGF5b3V0OiBmdW5jdGlvbiBjb3B5X2xheW91dChvYmosIG5ld19vYmopIHtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICAvLyAoc29tZSBvZmZjaGFydCBpbmRpY2F0b3JzIGFyZSBhZGRlZC9yZW1vdmVkKVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSBsYXlvdXQgaW4gYSByZWFjdGl2ZSB3YXlcbiAgICAgICAgaWYgKG9ialtrXS5sZW5ndGggIT09IG5ld19vYmpba10ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5vdmVyd3JpdGUob2JqW2tdLCBuZXdfb2JqW2tdKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIG0gaW4gb2JqW2tdKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihvYmpba11bbV0sIG5ld19vYmpba11bbV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9ialtrXSwgbmV3X29ialtrXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBEZXRlY3RzIGNhbmRsZXMgaW50ZXJ2YWxcbiAgZGV0ZWN0X2ludGVydmFsOiBmdW5jdGlvbiBkZXRlY3RfaW50ZXJ2YWwob2hsY3YpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4ob2hsY3YubGVuZ3RoIC0gMSwgOTkpO1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICBvaGxjdi5zbGljZSgwLCBsZW4pLmZvckVhY2goZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgIHZhciBkID0gb2hsY3ZbaSArIDFdWzBdIC0geFswXTtcbiAgICAgIGlmIChkID09PSBkICYmIGQgPCBtaW4pIG1pbiA9IGQ7XG4gICAgfSk7IC8vIFRoaXMgc2F2ZXMgbW9udGhseSBjaGFydCBmcm9tIGJlaW5nIGF3a3dhcmRcblxuICAgIGlmIChtaW4gPj0gY29uc3RhbnRzLk1PTlRIICYmIG1pbiA8PSBjb25zdGFudHMuREFZICogMzApIHtcbiAgICAgIHJldHVybiBjb25zdGFudHMuREFZICogMzE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbiAgfSxcbiAgLy8gR2V0cyBudW1iZXJpYyBwYXJ0IG9mIG92ZXJsYXkgaWQgKGUuZyAnRU1BXzEnID0gPiAxKVxuICBnZXRfbnVtX2lkOiBmdW5jdGlvbiBnZXRfbnVtX2lkKGlkKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGlkLnNwbGl0KCdfJykucG9wKCkpO1xuICB9LFxuICAvLyBGYXN0IGZpbHRlci4gUmVhbGx5IGZhc3QsIGxpa2UgMTBYXG4gIGZhc3RfZmlsdGVyOiBmdW5jdGlvbiBmYXN0X2ZpbHRlcihhcnIsIHQxLCB0Mikge1xuICAgIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuIFthcnIsIHVuZGVmaW5lZF07XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGlhID0gbmV3IChsaWJfZGVmYXVsdCgpKShhcnIsIFwiMFwiKTtcbiAgICAgIHZhciByZXMgPSBpYS5nZXRSYW5nZSh0MSwgdDIpO1xuICAgICAgdmFyIGkwID0gaWEudmFscG9zW3QxXS5uZXh0O1xuICAgICAgcmV0dXJuIFtyZXMsIGkwXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBTb21ldGhpbmcgd3Jvbmcgd2l0aCBmYW5jeSBzbGljZSBsaWJcbiAgICAgIC8vIEZhc3QgZml4OiBmYWxsYmFjayB0byBmaWx0ZXJcbiAgICAgIHJldHVybiBbYXJyLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFswXSA+PSB0MSAmJiB4WzBdIDw9IHQyO1xuICAgICAgfSksIDBdO1xuICAgIH1cbiAgfSxcbiAgLy8gRmFzdCBmaWx0ZXIgKGluZGV4LWJhc2VkKVxuICBmYXN0X2ZpbHRlcl9pOiBmdW5jdGlvbiBmYXN0X2ZpbHRlcl9pKGFyciwgdDEsIHQyKSB7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSByZXR1cm4gW2FyciwgdW5kZWZpbmVkXTtcbiAgICB2YXIgaTEgPSBNYXRoLmZsb29yKHQxKTtcbiAgICBpZiAoaTEgPCAwKSBpMSA9IDA7XG4gICAgdmFyIGkyID0gTWF0aC5mbG9vcih0MiArIDEpO1xuICAgIHZhciByZXMgPSBhcnIuc2xpY2UoaTEsIGkyKTtcbiAgICByZXR1cm4gW3JlcywgaTFdO1xuICB9LFxuICAvLyBOZWFyZXN0IGluZGV4ZXMgKGxlZnQgYW5kIHJpZ2h0KVxuICBmYXN0X25lYXJlc3Q6IGZ1bmN0aW9uIGZhc3RfbmVhcmVzdChhcnIsIHQxKSB7XG4gICAgdmFyIGlhID0gbmV3IChsaWJfZGVmYXVsdCgpKShhcnIsIFwiMFwiKTtcbiAgICBpYS5mZXRjaCh0MSk7XG4gICAgcmV0dXJuIFtpYS5uZXh0bG93LCBpYS5uZXh0aGlnaF07XG4gIH0sXG4gIG5vdzogZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKGRlbGF5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChycywgcmopIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJzLCBkZWxheSk7XG4gICAgfSk7XG4gIH0sXG4gIC8vIExpbWl0IGNyYXp5IHdoZWVsIGRlbHRhIHZhbHVlc1xuICBzbWFydF93aGVlbDogZnVuY3Rpb24gc21hcnRfd2hlZWwoZGVsdGEpIHtcbiAgICB2YXIgYWJzID0gTWF0aC5hYnMoZGVsdGEpO1xuXG4gICAgaWYgKGFicyA+IDUwMCkge1xuICAgICAgcmV0dXJuICgyMDAgKyBNYXRoLmxvZyhhYnMpKSAqIE1hdGguc2lnbihkZWx0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbHRhO1xuICB9LFxuICAvLyBQYXJzZSB0aGUgb3JpZ2luYWwgbW91c2UgZXZlbnQgdG8gZmluZCBkZWx0YVhcbiAgZ2V0X2RlbHRhWDogZnVuY3Rpb24gZ2V0X2RlbHRhWChldmVudCkge1xuICAgIHJldHVybiBldmVudC5vcmlnaW5hbEV2ZW50LmRlbHRhWCAvIDEyO1xuICB9LFxuICAvLyBQYXJzZSB0aGUgb3JpZ2luYWwgbW91c2UgZXZlbnQgdG8gZmluZCBkZWx0YVlcbiAgZ2V0X2RlbHRhWTogZnVuY3Rpb24gZ2V0X2RlbHRhWShldmVudCkge1xuICAgIHJldHVybiBldmVudC5vcmlnaW5hbEV2ZW50LmRlbHRhWSAvIDEyO1xuICB9LFxuICAvLyBBcHBseSBvcGFjaXR5IHRvIGEgaGV4IGNvbG9yXG4gIGFwcGx5X29wYWNpdHk6IGZ1bmN0aW9uIGFwcGx5X29wYWNpdHkoYywgb3ApIHtcbiAgICBpZiAoYy5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBuID0gTWF0aC5mbG9vcihvcCAqIDI1NSk7XG4gICAgICBuID0gdGhpcy5jbGFtcChuLCAwLCAyNTUpO1xuICAgICAgYyArPSBuLnRvU3RyaW5nKDE2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcbiAgLy8gUGFyc2UgdGltZWZyYW1lIG9yIHJldHVybiB2YWx1ZSBpbiBtc1xuICBwYXJzZV90ZjogZnVuY3Rpb24gcGFyc2VfdGYoc210aCkge1xuICAgIGlmICh0eXBlb2Ygc210aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb25zdGFudHMubWFwX3VuaXRbc210aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzbXRoO1xuICAgIH1cbiAgfSxcbiAgLy8gRGV0ZWN0IGluZGV4IHNoaWZ0IGJldHdlZW4gdGhlIG1haW4gZGF0YSBzdWJcbiAgLy8gYW5kIHRoZSBvdmVybGF5J3Mgc3ViIChmb3IgSUItbW9kZSlcbiAgaW5kZXhfc2hpZnQ6IGZ1bmN0aW9uIGluZGV4X3NoaWZ0KHN1YiwgZGF0YSkge1xuICAgIC8vIEZpbmQgdGhlIHNlY29uZCB0aW1lc3RhbXAgKGJ5IHZhbHVlKVxuICAgIGlmICghZGF0YS5sZW5ndGgpIHJldHVybiAwO1xuICAgIHZhciBmaXJzdCA9IGRhdGFbMF1bMF07XG4gICAgdmFyIHNlY29uZDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRhdGFbaV1bMF0gIT09IGZpcnN0KSB7XG4gICAgICAgIHNlY29uZCA9IGRhdGFbaV1bMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoc3ViW2pdWzBdID09PSBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIGogLSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICAvLyBGYWxsYmFjayBmaXggZm9yIEJyYXZlIGJyb3dzZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JyYXZlL2JyYXZlLWJyb3dzZXIvaXNzdWVzLzE3MzhcbiAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uIG1lYXN1cmVUZXh0KGN0eCwgdGV4dCwgdHZfaWQpIHtcbiAgICB2YXIgbSA9IGN0eC5tZWFzdXJlVGV4dE9yZyh0ZXh0KTtcblxuICAgIGlmIChtLndpZHRoID09PSAwKSB7XG4gICAgICB2YXIgZG9jID0gZG9jdW1lbnQ7XG4gICAgICB2YXIgaWQgPSAndHZqcy1tZWFzdXJlLXRleHQnO1xuICAgICAgdmFyIGVsID0gZG9jLmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICB2YXIgYmFzZSA9IGRvYy5nZXRFbGVtZW50QnlJZCh0dl9pZCk7XG4gICAgICAgIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsLmlkID0gaWQ7XG4gICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZWwuc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgICAgICBiYXNlLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0eC5mb250KSBlbC5zdHlsZS5mb250ID0gY3R4LmZvbnQ7XG4gICAgICBlbC5pbm5lclRleHQgPSB0ZXh0LnJlcGxhY2UoLyAvZywgJy4nKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBlbC5vZmZzZXRXaWR0aFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG07XG4gICAgfVxuICB9LFxuICB1dWlkOiBmdW5jdGlvbiB1dWlkKHRlbXApIHtcbiAgICBpZiAodGVtcCA9PT0gdm9pZCAwKSB7XG4gICAgICB0ZW1wID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXAucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLFxuICAgICAgICAgIHYgPSBjID09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuICB9LFxuICB1dWlkMjogZnVuY3Rpb24gdXVpZDIoKSB7XG4gICAgcmV0dXJuIHRoaXMudXVpZCgneHh4eHh4eHh4eHh4Jyk7XG4gIH0sXG4gIC8vIERlbGF5ZWQgd2FybmluZywgZiA9IGNvbmRpdGlvbiBsYW1iZGEgZm5cbiAgd2FybjogZnVuY3Rpb24gd2FybihmLCB0ZXh0LCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZigpKSBjb25zb2xlLndhcm4odGV4dCk7XG4gICAgfSwgZGVsYXkpO1xuICB9LFxuICAvLyBDaGVja3MgaWYgc2NyaXB0IHByb3BzIHVwZGF0ZWRcbiAgLy8gKGFuZCBub3Qgc3R5bGUgc2V0dGluZ3Mgb3Igc29tZXRoaW5nIGVsc2UpXG4gIGlzX3Njcl9wcm9wc191cGQ6IGZ1bmN0aW9uIGlzX3Njcl9wcm9wc191cGQobiwgcHJldikge1xuICAgIHZhciBwID0gcHJldi5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC52LiR1dWlkID09PSBuLnYuJHV1aWQ7XG4gICAgfSk7XG4gICAgaWYgKCFwKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHByb3BzID0gbi5wLnNldHRpbmdzLiRwcm9wcztcbiAgICBpZiAoIXByb3BzKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHByb3BzLnNvbWUoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuLnZbeF0gIT09IHAudlt4XTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gQ2hlY2tzIGlmIGl0J3MgdGltZSB0byBtYWtlIGEgc2NyaXB0IHVwZGF0ZVxuICAvLyAoYmFzZWQgb24gZXhlY0ludGVydmFsIGluIG1zKVxuICBkZWxheWVkX2V4ZWM6IGZ1bmN0aW9uIGRlbGF5ZWRfZXhlYyh2KSB7XG4gICAgaWYgKCF2LnNjcmlwdCB8fCAhdi5zY3JpcHQuZXhlY0ludGVydmFsKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgdCA9IHRoaXMubm93KCk7XG4gICAgdmFyIGR0ID0gdi5zY3JpcHQuZXhlY0ludGVydmFsO1xuXG4gICAgaWYgKCF2LnNldHRpbmdzLiRsYXN0X2V4ZWMgfHwgdCA+IHYuc2V0dGluZ3MuJGxhc3RfZXhlYyArIGR0KSB7XG4gICAgICB2LnNldHRpbmdzLiRsYXN0X2V4ZWMgPSB0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICAvLyBGb3JtYXQgbmFtZXMgc3VjaCAnUlNJLCAkbGVuZ3RoJywgd2hlcmVcbiAgLy8gbGVuZ3RoIC0gaXMgb25lIG9mIHRoZSBzZXR0aW5nc1xuICBmb3JtYXRfbmFtZTogZnVuY3Rpb24gZm9ybWF0X25hbWUob3YpIHtcbiAgICBpZiAoIW92Lm5hbWUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIG5hbWUgPSBvdi5uYW1lO1xuXG4gICAgZm9yICh2YXIgayBpbiBvdi5zZXR0aW5ncyB8fCB7fSkge1xuICAgICAgdmFyIHZhbCA9IG92LnNldHRpbmdzW2tdO1xuICAgICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCJcXFxcJFwiLmNvbmNhdChrKSwgJ2cnKTtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UocmVnLCB2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9LFxuICAvLyBEZWZhdWx0IGN1cnNvciBtb2RlXG4gIHhtb2RlOiBmdW5jdGlvbiB4bW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc19tb2JpbGUgPyAnZXhwbG9yZScgOiAnZGVmYXVsdCc7XG4gIH0sXG4gIGRlZmF1bHRfcHJldmVudGVkOiBmdW5jdGlvbiBkZWZhdWx0X3ByZXZlbnRlZChldmVudCkge1xuICAgIGlmIChldmVudC5vcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGV2ZW50Lm9yaWdpbmFsLmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gIH0sXG4gIC8vIFdURiB3aXRoIG1vZGVybiB3ZWIgZGV2ZWxvcG1lbnRcbiAgaXNfbW9iaWxlOiBmdW5jdGlvbiAodykge1xuICAgIHJldHVybiAnb25vcmllbnRhdGlvbmNoYW5nZScgaW4gdyAmJiAoISFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgISFuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyB8fCAnb250b3VjaHN0YXJ0JyBpbiB3IHx8IHcuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHcuRG9jdW1lbnRUb3VjaCk7XG4gIH0odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fSlcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0dWZmL21hdGguanNcbi8vIE1hdGgvR2VvbWV0cnlcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbWF0aCA9ICh7XG4gIC8vIERpc3RhbmNlIGZyb20gcG9pbnQgdG8gbGluZVxuICAvLyBwMSA9IHBvaW50LCAocDIsIHAzKSA9IGxpbmVcbiAgcG9pbnQybGluZTogZnVuY3Rpb24gcG9pbnQybGluZShwMSwgcDIsIHAzKSB7XG4gICAgdmFyIF90aGlzJHRyaSA9IHRoaXMudHJpKHAxLCBwMiwgcDMpLFxuICAgICAgICBhcmVhID0gX3RoaXMkdHJpLmFyZWEsXG4gICAgICAgIGJhc2UgPSBfdGhpcyR0cmkuYmFzZTtcblxuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnRyaV9oKGFyZWEsIGJhc2UpKTtcbiAgfSxcbiAgLy8gRGlzdGFuY2UgZnJvbSBwb2ludCB0byBzZWdtZW50XG4gIC8vIHAxID0gcG9pbnQsIChwMiwgcDMpID0gc2VnbWVudFxuICBwb2ludDJzZWc6IGZ1bmN0aW9uIHBvaW50MnNlZyhwMSwgcDIsIHAzKSB7XG4gICAgdmFyIF90aGlzJHRyaTIgPSB0aGlzLnRyaShwMSwgcDIsIHAzKSxcbiAgICAgICAgYXJlYSA9IF90aGlzJHRyaTIuYXJlYSxcbiAgICAgICAgYmFzZSA9IF90aGlzJHRyaTIuYmFzZTsgLy8gVmVjdG9yIHByb2plY3Rpb25cblxuXG4gICAgdmFyIHByb2ogPSB0aGlzLmRvdF9wcm9kKHAxLCBwMiwgcDMpIC8gYmFzZTsgLy8gRGlzdGFuY2UgZnJvbSBsZWZ0IHBpblxuXG4gICAgdmFyIGwxID0gTWF0aC5tYXgoLXByb2osIDApOyAvLyBEaXN0YW5jZSBmcm9tIHJpZ2h0IHBpblxuXG4gICAgdmFyIGwyID0gTWF0aC5tYXgocHJvaiAtIGJhc2UsIDApOyAvLyBOb3JtYWxcblxuICAgIHZhciBoID0gTWF0aC5hYnModGhpcy50cmlfaChhcmVhLCBiYXNlKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGgsIGwxLCBsMik7XG4gIH0sXG4gIC8vIERpc3RhbmNlIGZyb20gcG9pbnQgdG8gcmF5XG4gIC8vIHAxID0gcG9pbnQsIChwMiwgcDMpID0gcmF5XG4gIHBvaW50MnJheTogZnVuY3Rpb24gcG9pbnQycmF5KHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgX3RoaXMkdHJpMyA9IHRoaXMudHJpKHAxLCBwMiwgcDMpLFxuICAgICAgICBhcmVhID0gX3RoaXMkdHJpMy5hcmVhLFxuICAgICAgICBiYXNlID0gX3RoaXMkdHJpMy5iYXNlOyAvLyBWZWN0b3IgcHJvamVjdGlvblxuXG5cbiAgICB2YXIgcHJvaiA9IHRoaXMuZG90X3Byb2QocDEsIHAyLCBwMykgLyBiYXNlOyAvLyBEaXN0YW5jZSBmcm9tIGxlZnQgcGluXG5cbiAgICB2YXIgbDEgPSBNYXRoLm1heCgtcHJvaiwgMCk7IC8vIE5vcm1hbFxuXG4gICAgdmFyIGggPSBNYXRoLmFicyh0aGlzLnRyaV9oKGFyZWEsIGJhc2UpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoaCwgbDEpO1xuICB9LFxuICB0cmk6IGZ1bmN0aW9uIHRyaShwMSwgcDIsIHAzKSB7XG4gICAgdmFyIGFyZWEgPSB0aGlzLmFyZWEocDEsIHAyLCBwMyk7XG4gICAgdmFyIGR4ID0gcDNbMF0gLSBwMlswXTtcbiAgICB2YXIgZHkgPSBwM1sxXSAtIHAyWzFdO1xuICAgIHZhciBiYXNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgYXJlYTogYXJlYSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuXG4gIC8qIEFyZWEgb2YgdHJpYW5nbGU6XG4gICAgICAgICAgcDFcbiAgICAgICAgLyAgICBcXFxuICAgICAgcDIgIF8gIHAzXG4gICovXG4gIGFyZWE6IGZ1bmN0aW9uIGFyZWEocDEsIHAyLCBwMykge1xuICAgIHJldHVybiBwMVswXSAqIChwMlsxXSAtIHAzWzFdKSArIHAyWzBdICogKHAzWzFdIC0gcDFbMV0pICsgcDNbMF0gKiAocDFbMV0gLSBwMlsxXSk7XG4gIH0sXG4gIC8vIFRyaWFuZ2xlIGhlaWdodFxuICB0cmlfaDogZnVuY3Rpb24gdHJpX2goYXJlYSwgYmFzZSkge1xuICAgIHJldHVybiBhcmVhIC8gYmFzZTtcbiAgfSxcbiAgLy8gRG90IHByb2R1Y3Qgb2YgKHAyLCBwMykgYW5kIChwMiwgcDEpXG4gIGRvdF9wcm9kOiBmdW5jdGlvbiBkb3RfcHJvZChwMSwgcDIsIHAzKSB7XG4gICAgdmFyIHYxID0gW3AzWzBdIC0gcDJbMF0sIHAzWzFdIC0gcDJbMV1dO1xuICAgIHZhciB2MiA9IFtwMVswXSAtIHAyWzBdLCBwMVsxXSAtIHAyWzFdXTtcbiAgICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG4gIH0sXG4gIC8vIFN5bW1ldHJpY2FsIGxvZ1xuICBsb2c6IGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgLy8gVE9ETzogbG9nIGZvciBzbWFsbCB2YWx1ZXNcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5sb2coTWF0aC5hYnMoeCkgKyAxKTtcbiAgfSxcbiAgLy8gU3ltbWV0cmljYWwgZXhwXG4gIGV4cDogZnVuY3Rpb24gZXhwKHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogKE1hdGguZXhwKE1hdGguYWJzKHgpKSAtIDEpO1xuICB9LFxuICAvLyBNaWRkbGUgbGluZSBvbiBsb2cgc2NhbGUgYmFzZWQgb24gcmFuZ2UgJiBweCBoZWlnaHRcbiAgbG9nX21pZDogZnVuY3Rpb24gbG9nX21pZChyLCBoKSB7XG4gICAgdmFyIGxvZ19oaSA9IHRoaXMubG9nKHJbMF0pO1xuICAgIHZhciBsb2dfbG8gPSB0aGlzLmxvZyhyWzFdKTtcbiAgICB2YXIgcHggPSBoIC8gMjtcbiAgICB2YXIgZ3ggPSBsb2dfaGkgLSBweCAqIChsb2dfaGkgLSBsb2dfbG8pIC8gaDtcbiAgICByZXR1cm4gdGhpcy5leHAoZ3gpO1xuICB9LFxuICAvLyBSZXR1cm4gbmV3IGFkanVzdGVkIHJhbmdlLCBiYXNlZCBvbiB0aGUgcHJldmlvdXNcbiAgLy8gcmFuZ2UsIG5ldyAkX2hpLCB0YXJnZXQgbWlkZGxlIGxpbmVcbiAgcmVfcmFuZ2U6IGZ1bmN0aW9uIHJlX3JhbmdlKHIxLCBoaTIsIG1pZCkge1xuICAgIHZhciBsb2dfaGkxID0gdGhpcy5sb2cocjFbMF0pO1xuICAgIHZhciBsb2dfbG8xID0gdGhpcy5sb2cocjFbMV0pO1xuICAgIHZhciBsb2dfaGkyID0gdGhpcy5sb2coaGkyKTtcbiAgICB2YXIgbG9nXyQgPSB0aGlzLmxvZyhtaWQpO1xuICAgIHZhciBXID0gKGxvZ19oaTIgLSBsb2dfJCkgKiAobG9nX2hpMSAtIGxvZ19sbzEpIC8gKGxvZ19oaTEgLSBsb2dfJCk7XG4gICAgcmV0dXJuIHRoaXMuZXhwKGxvZ19oaTIgLSBXKTtcbiAgfSAvLyBSZXR1cm4gbmV3IGFkanVzdGVkIHJhbmdlLCBiYXNlZCBvbiB0aGUgcHJldmlvdXNcbiAgLy8gcmFuZ2UsIG5ldyAkX2hpLCB0YXJnZXQgbWlkZGxlIGxpbmUgKyBkeSAoc2hpZnQpXG4gIC8vIFdBU1RFXG5cbiAgLypyYW5nZV9zaGlmdChyMSwgaGkyLCBtaWQsIGR5LCBoKSB7XG4gICAgICBsZXQgbG9nX2hpMSA9IHRoaXMubG9nKHIxWzBdKVxuICAgICAgbGV0IGxvZ19sbzEgPSB0aGlzLmxvZyhyMVsxXSlcbiAgICAgIGxldCBsb2dfaGkyID0gdGhpcy5sb2coaGkyKVxuICAgICAgbGV0IGxvZ18kID0gdGhpcy5sb2cobWlkKVxuICAgICAgIGxldCBXID0gaCAqIChsb2dfaGkyIC0gbG9nXyQpIC9cbiAgICAgICAgICAgICAgKGggKiAobG9nX2hpMSAtIGxvZ18kKSAvIChsb2dfaGkxIC0gbG9nX2xvMSkgKyBkeSlcbiAgICAgICByZXR1cm4gdGhpcy5leHAobG9nX2hpMiAtIFcpXG4gICB9Ki9cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9sYXlvdXRfZm4uanNcbi8vIExheW91dCBmdW5jdGlvbmFsIGludGVyZmFjZVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gZnVuY3Rpb24gbGF5b3V0X2ZuKHNlbGYsIHJhbmdlKSB7XG4gIHZhciBpYiA9IHNlbGYudGlfbWFwLmliO1xuICB2YXIgZHQgPSByYW5nZVsxXSAtIHJhbmdlWzBdO1xuICB2YXIgciA9IHNlbGYuc3BhY2V4IC8gZHQ7XG4gIHZhciBscyA9IHNlbGYuZ3JpZC5sb2dTY2FsZSB8fCBmYWxzZTtcbiAgT2JqZWN0LmFzc2lnbihzZWxmLCB7XG4gICAgLy8gVGltZSB0byBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICB0MnNjcmVlbjogZnVuY3Rpb24gdDJzY3JlZW4odCkge1xuICAgICAgaWYgKGliKSB0ID0gc2VsZi50aV9tYXAuc210aDJpKHQpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHQgLSByYW5nZVswXSkgKiByKSAtIDAuNTtcbiAgICB9LFxuICAgIC8vICQgdG8gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgJDJzY3JlZW46IGZ1bmN0aW9uICQyc2NyZWVuKHkpIHtcbiAgICAgIGlmIChscykgeSA9IG1hdGgubG9nKHkpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoeSAqIHNlbGYuQSArIHNlbGYuQikgLSAwLjU7XG4gICAgfSxcbiAgICAvLyBUaW1lLWF4aXMgbmVhcmVzdCBzdGVwXG4gICAgdF9tYWduZXQ6IGZ1bmN0aW9uIHRfbWFnbmV0KHQpIHtcbiAgICAgIGlmIChpYikgdCA9IHNlbGYudGlfbWFwLnNtdGgyaSh0KTtcbiAgICAgIHZhciBjbiA9IHNlbGYuY2FuZGxlcyB8fCBzZWxmLm1hc3Rlcl9ncmlkLmNhbmRsZXM7XG4gICAgICB2YXIgYXJyID0gY24ubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnJhd1swXTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGkgPSB1dGlscy5uZWFyZXN0X2EodCwgYXJyKVswXTtcbiAgICAgIGlmICghY25baV0pIHJldHVybjtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNuW2ldLngpIC0gMC41O1xuICAgIH0sXG4gICAgLy8gU2NyZWVuLVkgdG8gZG9sbGFyIHZhbHVlIChvciB3aGF0ZXZlcilcbiAgICBzY3JlZW4yJDogZnVuY3Rpb24gc2NyZWVuMiQoeSkge1xuICAgICAgaWYgKGxzKSByZXR1cm4gbWF0aC5leHAoKHkgLSBzZWxmLkIpIC8gc2VsZi5BKTtcbiAgICAgIHJldHVybiAoeSAtIHNlbGYuQikgLyBzZWxmLkE7XG4gICAgfSxcbiAgICAvLyBTY3JlZW4tWCB0byB0aW1lc3RhbXBcbiAgICBzY3JlZW4ydDogZnVuY3Rpb24gc2NyZWVuMnQoeCkge1xuICAgICAgLy8gVE9ETzogbW9zdCBsaWtlbHkgTWF0aC5mbG9vciBub3QgbmVlZGVkXG4gICAgICAvLyByZXR1cm4gTWF0aC5mbG9vcihyYW5nZVswXSArIHggLyByKVxuICAgICAgcmV0dXJuIHJhbmdlWzBdICsgeCAvIHI7XG4gICAgfSxcbiAgICAvLyAkLWF4aXMgbmVhcmVzdCBzdGVwXG4gICAgJF9tYWduZXQ6IGZ1bmN0aW9uICRfbWFnbmV0KHByaWNlKSB7fSxcbiAgICAvLyBOZWFyZXN0IGNhbmRsZXN0aWNrXG4gICAgY19tYWduZXQ6IGZ1bmN0aW9uIGNfbWFnbmV0KHQpIHtcbiAgICAgIHZhciBjbiA9IHNlbGYuY2FuZGxlcyB8fCBzZWxmLm1hc3Rlcl9ncmlkLmNhbmRsZXM7XG4gICAgICB2YXIgYXJyID0gY24ubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnJhd1swXTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGkgPSB1dGlscy5uZWFyZXN0X2EodCwgYXJyKVswXTtcbiAgICAgIHJldHVybiBjbltpXTtcbiAgICB9LFxuICAgIC8vIE5lYXJlc3QgZGF0YSBwb2ludHNcbiAgICBkYXRhX21hZ25ldDogZnVuY3Rpb24gZGF0YV9tYWduZXQodCkge1xuICAgICAgLyogVE9ETzogaW1wbGVtZW50ICovXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlbGY7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9sb2dfc2NhbGUuanNcbi8vIExvZy1zY2FsZSBtb2RlIGhlbHBlcnNcbi8vIFRPRE86IGFsbC1uZWdhdGl2ZSBudW1iZXJzIChzb21ldGltZXMgd3Jvbmcgc2NhbGluZylcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBsb2dfc2NhbGUgPSAoe1xuICBjYW5kbGU6IGZ1bmN0aW9uIGNhbmRsZShzZWxmLCBtaWQsIHAsICRwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG1pZCxcbiAgICAgIHc6IHNlbGYucHhfc3RlcCAqICRwLmNvbmZpZy5DQU5ETEVXLFxuICAgICAgbzogTWF0aC5mbG9vcihtYXRoLmxvZyhwWzFdKSAqIHNlbGYuQSArIHNlbGYuQiksXG4gICAgICBoOiBNYXRoLmZsb29yKG1hdGgubG9nKHBbMl0pICogc2VsZi5BICsgc2VsZi5CKSxcbiAgICAgIGw6IE1hdGguZmxvb3IobWF0aC5sb2cocFszXSkgKiBzZWxmLkEgKyBzZWxmLkIpLFxuICAgICAgYzogTWF0aC5mbG9vcihtYXRoLmxvZyhwWzRdKSAqIHNlbGYuQSArIHNlbGYuQiksXG4gICAgICByYXc6IHBcbiAgICB9O1xuICB9LFxuICBleHBhbmQ6IGZ1bmN0aW9uIGV4cGFuZChzZWxmLCBoZWlnaHQpIHtcbiAgICAvLyBleHBhbmQgbG9nIHNjYWxlXG4gICAgdmFyIEEgPSAtaGVpZ2h0IC8gKG1hdGgubG9nKHNlbGYuJF9oaSkgLSBtYXRoLmxvZyhzZWxmLiRfbG8pKTtcbiAgICB2YXIgQiA9IC1tYXRoLmxvZyhzZWxmLiRfaGkpICogQTtcbiAgICB2YXIgdG9wID0gLWhlaWdodCAqIDAuMTtcbiAgICB2YXIgYm90ID0gaGVpZ2h0ICogMS4xO1xuICAgIHNlbGYuJF9oaSA9IG1hdGguZXhwKCh0b3AgLSBCKSAvIEEpO1xuICAgIHNlbGYuJF9sbyA9IG1hdGguZXhwKChib3QgLSBCKSAvIEEpO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL2dyaWRfbWFrZXIuanNcblxuXG5cblxuXG5cbnZhciBncmlkX21ha2VyX1RJTUVTQ0FMRVMgPSBjb25zdGFudHMuVElNRVNDQUxFUyxcbiAgICBncmlkX21ha2VyXyRTQ0FMRVMgPSBjb25zdGFudHMuJFNDQUxFUyxcbiAgICBncmlkX21ha2VyX1dFRUsgPSBjb25zdGFudHMuV0VFSyxcbiAgICBncmlkX21ha2VyX01PTlRIID0gY29uc3RhbnRzLk1PTlRILFxuICAgIGdyaWRfbWFrZXJfWUVBUiA9IGNvbnN0YW50cy5ZRUFSLFxuICAgIGdyaWRfbWFrZXJfSE9VUiA9IGNvbnN0YW50cy5IT1VSLFxuICAgIGdyaWRfbWFrZXJfREFZID0gY29uc3RhbnRzLkRBWTtcbnZhciBNQVhfSU5UID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7IC8vIG1hc3Rlcl9ncmlkIC0gcmVmIHRvIHRoZSBtYXN0ZXIgZ3JpZFxuXG5mdW5jdGlvbiBHcmlkTWFrZXIoaWQsIHBhcmFtcywgbWFzdGVyX2dyaWQpIHtcbiAgaWYgKG1hc3Rlcl9ncmlkID09PSB2b2lkIDApIHtcbiAgICBtYXN0ZXJfZ3JpZCA9IG51bGw7XG4gIH1cblxuICB2YXIgc3ViID0gcGFyYW1zLnN1YixcbiAgICAgIGludGVydmFsID0gcGFyYW1zLmludGVydmFsLFxuICAgICAgcmFuZ2UgPSBwYXJhbXMucmFuZ2UsXG4gICAgICBjdHggPSBwYXJhbXMuY3R4LFxuICAgICAgJHAgPSBwYXJhbXMuJHAsXG4gICAgICBsYXllcnNfbWV0YSA9IHBhcmFtcy5sYXllcnNfbWV0YSxcbiAgICAgIGhlaWdodCA9IHBhcmFtcy5oZWlnaHQsXG4gICAgICB5X3QgPSBwYXJhbXMueV90LFxuICAgICAgdGlfbWFwID0gcGFyYW1zLnRpX21hcCxcbiAgICAgIGdyaWQgPSBwYXJhbXMuZ3JpZCxcbiAgICAgIHRpbWV6b25lID0gcGFyYW1zLnRpbWV6b25lO1xuICB2YXIgc2VsZiA9IHtcbiAgICB0aV9tYXA6IHRpX21hcFxuICB9O1xuICB2YXIgbG0gPSBsYXllcnNfbWV0YVtpZF07XG4gIHZhciB5X3JhbmdlX2ZuID0gbnVsbDtcbiAgdmFyIGxzID0gZ3JpZC5sb2dTY2FsZTtcblxuICBpZiAobG0gJiYgT2JqZWN0LmtleXMobG0pLmxlbmd0aCkge1xuICAgIC8vIEdldHMgbGFzdCB5X3JhbmdlIGZuKClcbiAgICB2YXIgeXJzID0gT2JqZWN0LnZhbHVlcyhsbSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC55X3JhbmdlO1xuICAgIH0pOyAvLyBUaGUgZmlyc3QgeV9yYW5nZSgpIGRldGVybWluZXMgdGhlIHJhbmdlXG5cbiAgICBpZiAoeXJzLmxlbmd0aCkgeV9yYW5nZV9mbiA9IHlyc1swXS55X3JhbmdlO1xuICB9IC8vIENhbGMgdmVydGljYWwgKCQv4oK/KSByYW5nZVxuXG5cbiAgZnVuY3Rpb24gY2FsY18kcmFuZ2UoKSB7XG4gICAgaWYgKCFtYXN0ZXJfZ3JpZCkge1xuICAgICAgLy8gJCBjYW5kbGVzdGljayByYW5nZVxuICAgICAgaWYgKHlfcmFuZ2VfZm4pIHtcbiAgICAgICAgdmFyIF95X3JhbmdlX2ZuID0geV9yYW5nZV9mbihoaSwgbG8pLFxuICAgICAgICAgICAgX3lfcmFuZ2VfZm4yID0gX3NsaWNlZFRvQXJyYXkoX3lfcmFuZ2VfZm4sIDIpLFxuICAgICAgICAgICAgaGkgPSBfeV9yYW5nZV9mbjJbMF0sXG4gICAgICAgICAgICBsbyA9IF95X3JhbmdlX2ZuMlsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpID0gLUluZmluaXR5LCBsbyA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc3ViLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHZhciB4ID0gc3ViW2ldO1xuICAgICAgICAgIGlmICh4WzJdID4gaGkpIGhpID0geFsyXTtcbiAgICAgICAgICBpZiAoeFszXSA8IGxvKSBsbyA9IHhbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2ZmY2hhcnQgaW5kaWNhdG9yIHJhbmdlXG4gICAgICBoaSA9IC1JbmZpbml0eSwgbG8gPSBJbmZpbml0eTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBzdWJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgdiA9IHN1YltpXVtqXTtcbiAgICAgICAgICBpZiAodiA+IGhpKSBoaSA9IHY7XG4gICAgICAgICAgaWYgKHYgPCBsbykgbG8gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh5X3JhbmdlX2ZuKSB7XG4gICAgICAgIHZhciBfeV9yYW5nZV9mbjMgPSB5X3JhbmdlX2ZuKGhpLCBsbyksXG4gICAgICAgICAgICBfeV9yYW5nZV9mbjQgPSBfc2xpY2VkVG9BcnJheShfeV9yYW5nZV9mbjMsIDMpLFxuICAgICAgICAgICAgaGkgPSBfeV9yYW5nZV9mbjRbMF0sXG4gICAgICAgICAgICBsbyA9IF95X3JhbmdlX2ZuNFsxXSxcbiAgICAgICAgICAgIGV4cCA9IF95X3JhbmdlX2ZuNFsyXTtcbiAgICAgIH1cbiAgICB9IC8vIEZpeGVkIHktcmFuZ2UgaW4gbm9uLWF1dG8gbW9kZVxuXG5cbiAgICBpZiAoeV90ICYmICF5X3QuYXV0byAmJiB5X3QucmFuZ2UpIHtcbiAgICAgIHNlbGYuJF9oaSA9IHlfdC5yYW5nZVswXTtcbiAgICAgIHNlbGYuJF9sbyA9IHlfdC5yYW5nZVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFscykge1xuICAgICAgICBleHAgPSBleHAgPT09IGZhbHNlID8gMCA6IDE7XG4gICAgICAgIHNlbGYuJF9oaSA9IGhpICsgKGhpIC0gbG8pICogJHAuY29uZmlnLkVYUEFORCAqIGV4cDtcbiAgICAgICAgc2VsZi4kX2xvID0gbG8gLSAoaGkgLSBsbykgKiAkcC5jb25maWcuRVhQQU5EICogZXhwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi4kX2hpID0gaGk7XG4gICAgICAgIHNlbGYuJF9sbyA9IGxvO1xuICAgICAgICBsb2dfc2NhbGUuZXhwYW5kKHNlbGYsIGhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLiRfaGkgPT09IHNlbGYuJF9sbykge1xuICAgICAgICBpZiAoIWxzKSB7XG4gICAgICAgICAgc2VsZi4kX2hpICo9IDEuMDU7IC8vIEV4cGFuZCBpZiBoZWlnaHQgcmFuZ2UgPT09IDBcblxuICAgICAgICAgIHNlbGYuJF9sbyAqPSAwLjk1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ19zY2FsZS5leHBhbmQoc2VsZiwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNfc2lkZWJhcigpIHtcbiAgICBpZiAoc3ViLmxlbmd0aCA8IDIpIHtcbiAgICAgIHNlbGYucHJlYyA9IDA7XG4gICAgICBzZWxmLnNiID0gJHAuY29uZmlnLlNCTUlOO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVE9ETzogaW1wcm92ZSBzaWRlYmFyIHdpZHRoIGNhbGN1bGF0aW9uXG4gICAgLy8gYXQgdHJhbnNpdGlvbiBwb2ludCwgd2hlbiBvbmUgcHJlY2lzaW9uIGlzXG4gICAgLy8gcmVwbGFjZWQgd2l0aCBhbm90aGVyXG4gICAgLy8gR2V0cyBmb3JtYXRlZCBsZXZlbHMgKHRoZWlyIGxlbmd0aHMpLFxuICAgIC8vIGNhbGN1bGF0ZXMgbWF4IGFuZCBtZWFzdXJlcyB0aGUgc2lkZWJhciBsZW5ndGhcbiAgICAvLyBmcm9tIGl0OlxuICAgIC8vIFRPRE86IGFkZCBjdXN0b20gZm9ybWF0dGVyIGYoKVxuXG5cbiAgICBzZWxmLnByZWMgPSBjYWxjX3ByZWNpc2lvbihzdWIpO1xuICAgIHZhciBsZW5zID0gW107XG4gICAgbGVucy5wdXNoKHNlbGYuJF9oaS50b0ZpeGVkKHNlbGYucHJlYykubGVuZ3RoKTtcbiAgICBsZW5zLnB1c2goc2VsZi4kX2xvLnRvRml4ZWQoc2VsZi5wcmVjKS5sZW5ndGgpO1xuICAgIHZhciBzdHIgPSAnMCcucmVwZWF0KE1hdGgubWF4LmFwcGx5KE1hdGgsIGxlbnMpKSArICcgICAgJztcbiAgICBzZWxmLnNiID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGg7XG4gICAgc2VsZi5zYiA9IE1hdGgubWF4KE1hdGguZmxvb3Ioc2VsZi5zYiksICRwLmNvbmZpZy5TQk1JTik7XG4gICAgc2VsZi5zYiA9IE1hdGgubWluKHNlbGYuc2IsICRwLmNvbmZpZy5TQk1BWCk7XG4gIH0gLy8gQ2FsY3VsYXRlICQgcHJlY2lzaW9uIGZvciB0aGUgWS1heGlzXG5cblxuICBmdW5jdGlvbiBjYWxjX3ByZWNpc2lvbihkYXRhKSB7XG4gICAgdmFyIG1heF9yID0gMCxcbiAgICAgICAgbWF4X2wgPSAwO1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5OyAvLyBTcGVlZCBVUFxuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIHggPSBkYXRhW2ldO1xuICAgICAgaWYgKHhbMV0gPiBtYXgpIG1heCA9IHhbMV07ZWxzZSBpZiAoeFsxXSA8IG1pbikgbWluID0geFsxXTtcbiAgICB9IC8vIEdldCBtYXggbGVuZ3RocyBvZiBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIHBhcnRzXG5cblxuICAgIFttaW4sIG1heF0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gRml4IHVuZGVmaW5lZCBidWdcbiAgICAgIHZhciBzdHIgPSB4ICE9IG51bGwgPyB4LnRvU3RyaW5nKCkgOiAnJztcblxuICAgICAgaWYgKHggPCAwLjAwMDAwMSkge1xuICAgICAgICAvLyBQYXJzaW5nIHRoZSBleHBvbmVudGlhbCBmb3JtLiBHb3NoIHRoaXNcbiAgICAgICAgLy8gc21lbGxzIHRyaWNraWx5XG4gICAgICAgIHZhciBfc3RyJHNwbGl0ID0gc3RyLnNwbGl0KCdlLScpLFxuICAgICAgICAgICAgX3N0ciRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfc3RyJHNwbGl0LCAyKSxcbiAgICAgICAgICAgIGxzID0gX3N0ciRzcGxpdDJbMF0sXG4gICAgICAgICAgICBycyA9IF9zdHIkc3BsaXQyWzFdO1xuXG4gICAgICAgIHZhciBfbHMkc3BsaXQgPSBscy5zcGxpdCgnLicpLFxuICAgICAgICAgICAgX2xzJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9scyRzcGxpdCwgMiksXG4gICAgICAgICAgICBsID0gX2xzJHNwbGl0MlswXSxcbiAgICAgICAgICAgIHIgPSBfbHMkc3BsaXQyWzFdO1xuXG4gICAgICAgIGlmICghcikgciA9ICcnO1xuICAgICAgICByID0ge1xuICAgICAgICAgIGxlbmd0aDogci5sZW5ndGggKyBwYXJzZUludChycykgfHwgMFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9zdHIkc3BsaXQzID0gc3RyLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBfc3RyJHNwbGl0NCA9IF9zbGljZWRUb0FycmF5KF9zdHIkc3BsaXQzLCAyKSxcbiAgICAgICAgICAgIGwgPSBfc3RyJHNwbGl0NFswXSxcbiAgICAgICAgICAgIHIgPSBfc3RyJHNwbGl0NFsxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIgJiYgci5sZW5ndGggPiBtYXhfcikge1xuICAgICAgICBtYXhfciA9IHIubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAobCAmJiBsLmxlbmd0aCA+IG1heF9sKSB7XG4gICAgICAgIG1heF9sID0gbC5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7IC8vIFNlbGVjdCBwcmVjaXNpb24gc2NoZW1lIGRlcGVuZGluZ1xuICAgIC8vIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0IGxlbmd0aHNcbiAgICAvL1xuXG4gICAgdmFyIGV2ZW4gPSBtYXhfciAtIG1heF9yICUgMiArIDI7XG5cbiAgICBpZiAobWF4X2wgPT09IDEpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbig4LCBNYXRoLm1heCgyLCBldmVuKSk7XG4gICAgfVxuXG4gICAgaWYgKG1heF9sIDw9IDIpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbig0LCBNYXRoLm1heCgyLCBldmVuKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjX3Bvc2l0aW9ucygpIHtcbiAgICBpZiAoc3ViLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICB2YXIgZHQgPSByYW5nZVsxXSAtIHJhbmdlWzBdOyAvLyBBIHBpeGVsIHNwYWNlIGF2YWlsYWJsZSB0byBkcmF3IG9uICh4LWF4aXMpXG5cbiAgICBzZWxmLnNwYWNleCA9ICRwLndpZHRoIC0gc2VsZi5zYjsgLy8gQ2FuZGxlIGNhcGFjaXR5XG5cbiAgICB2YXIgY2FwYWNpdHkgPSBkdCAvIGludGVydmFsO1xuICAgIHNlbGYucHhfc3RlcCA9IHNlbGYuc3BhY2V4IC8gY2FwYWNpdHk7IC8vIHB4IC8gdGltZSByYXRpb1xuXG4gICAgdmFyIHIgPSBzZWxmLnNwYWNleCAvIGR0O1xuICAgIHNlbGYuc3RhcnR4ID0gKHN1YlswXVswXSAtIHJhbmdlWzBdKSAqIHI7IC8vIENhbmRsZSBZLXRyYW5zZm9ybTogKEEgPSBzY2FsZSwgQiA9IHNoaWZ0KVxuXG4gICAgaWYgKCFncmlkLmxvZ1NjYWxlKSB7XG4gICAgICBzZWxmLkEgPSAtaGVpZ2h0IC8gKHNlbGYuJF9oaSAtIHNlbGYuJF9sbyk7XG4gICAgICBzZWxmLkIgPSAtc2VsZi4kX2hpICogc2VsZi5BO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLkEgPSAtaGVpZ2h0IC8gKG1hdGgubG9nKHNlbGYuJF9oaSkgLSBtYXRoLmxvZyhzZWxmLiRfbG8pKTtcbiAgICAgIHNlbGYuQiA9IC1tYXRoLmxvZyhzZWxmLiRfaGkpICogc2VsZi5BO1xuICAgIH1cbiAgfSAvLyBTZWxlY3QgbmVhcmVzdCBnb29kLWxva2luZyB0IHN0ZXAgKG0gaXMgdGFyZ2V0IHNjYWxlKVxuXG5cbiAgZnVuY3Rpb24gdGltZV9zdGVwKCkge1xuICAgIHZhciBrID0gdGlfbWFwLmliID8gNjAwMDAgOiAxO1xuICAgIHZhciB4cmFuZ2UgPSAocmFuZ2VbMV0gLSByYW5nZVswXSkgKiBrO1xuICAgIHZhciBtID0geHJhbmdlICogKCRwLmNvbmZpZy5HUklEWCAvICRwLndpZHRoKTtcbiAgICB2YXIgcyA9IGdyaWRfbWFrZXJfVElNRVNDQUxFUztcbiAgICByZXR1cm4gdXRpbHMubmVhcmVzdF9hKG0sIHMpWzFdIC8gaztcbiAgfSAvLyBTZWxlY3QgbmVhcmVzdCBnb29kLWxva2luZyAkIHN0ZXAgKG0gaXMgdGFyZ2V0IHNjYWxlKVxuXG5cbiAgZnVuY3Rpb24gZG9sbGFyX3N0ZXAoKSB7XG4gICAgdmFyIHlyYW5nZSA9IHNlbGYuJF9oaSAtIHNlbGYuJF9sbztcbiAgICB2YXIgbSA9IHlyYW5nZSAqICgkcC5jb25maWcuR1JJRFkgLyBoZWlnaHQpO1xuICAgIHZhciBwID0gcGFyc2VJbnQoeXJhbmdlLnRvRXhwb25lbnRpYWwoKS5zcGxpdCgnZScpWzFdKTtcbiAgICB2YXIgZCA9IE1hdGgucG93KDEwLCBwKTtcbiAgICB2YXIgcyA9IGdyaWRfbWFrZXJfJFNDQUxFUy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4ICogZDtcbiAgICB9KTsgLy8gVE9ETzogY2VudGVyIHRoZSByYW5nZSAobG9vayBhdCBSU0kgZm9yIGV4YW1wbGUsXG4gICAgLy8gaXQgbG9va3MgdWdseSB3aGVuIFwiODBcIiBpcyBuZWFyIHRoZSB0b3ApXG5cbiAgICByZXR1cm4gdXRpbHMuc3RyaXAodXRpbHMubmVhcmVzdF9hKG0sIHMpWzFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbGxhcl9tdWx0KCkge1xuICAgIHZhciBtdWx0X2hpID0gZG9sbGFyX211bHRfaGkoKTtcbiAgICB2YXIgbXVsdF9sbyA9IGRvbGxhcl9tdWx0X2xvKCk7XG4gICAgcmV0dXJuIE1hdGgubWF4KG11bHRfaGksIG11bHRfbG8pO1xuICB9IC8vIFByaWNlIHN0ZXAgbXVsdGlwbGllciAoZm9yIHRoZSBsb2ctc2NhbGUgbW9kZSlcblxuXG4gIGZ1bmN0aW9uIGRvbGxhcl9tdWx0X2hpKCkge1xuICAgIHZhciBoID0gTWF0aC5taW4oc2VsZi5CLCBoZWlnaHQpO1xuICAgIGlmIChoIDwgJHAuY29uZmlnLkdSSURZKSByZXR1cm4gMTtcbiAgICB2YXIgbiA9IGggLyAkcC5jb25maWcuR1JJRFk7IC8vIHRhcmdldCBncmlkIE5cblxuICAgIHZhciB5cmFuZ2UgPSBzZWxmLiRfaGk7XG5cbiAgICBpZiAoc2VsZi4kX2xvID4gMCkge1xuICAgICAgdmFyIHlyYXRpbyA9IHNlbGYuJF9oaSAvIHNlbGYuJF9sbztcbiAgICB9IGVsc2Uge1xuICAgICAgeXJhdGlvID0gc2VsZi4kX2hpIC8gMTsgLy8gVE9ETzogc21hbGwgdmFsdWVzXG4gICAgfVxuXG4gICAgdmFyIG0gPSB5cmFuZ2UgKiAoJHAuY29uZmlnLkdSSURZIC8gaCk7XG4gICAgdmFyIHAgPSBwYXJzZUludCh5cmFuZ2UudG9FeHBvbmVudGlhbCgpLnNwbGl0KCdlJylbMV0pO1xuICAgIHJldHVybiBNYXRoLnBvdyh5cmF0aW8sIDEgLyBuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbGxhcl9tdWx0X2xvKCkge1xuICAgIHZhciBoID0gTWF0aC5taW4oaGVpZ2h0IC0gc2VsZi5CLCBoZWlnaHQpO1xuICAgIGlmIChoIDwgJHAuY29uZmlnLkdSSURZKSByZXR1cm4gMTtcbiAgICB2YXIgbiA9IGggLyAkcC5jb25maWcuR1JJRFk7IC8vIHRhcmdldCBncmlkIE5cblxuICAgIHZhciB5cmFuZ2UgPSBNYXRoLmFicyhzZWxmLiRfbG8pO1xuXG4gICAgaWYgKHNlbGYuJF9oaSA8IDAgJiYgc2VsZi4kX2xvIDwgMCkge1xuICAgICAgdmFyIHlyYXRpbyA9IE1hdGguYWJzKHNlbGYuJF9sbyAvIHNlbGYuJF9oaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlyYXRpbyA9IE1hdGguYWJzKHNlbGYuJF9sbykgLyAxO1xuICAgIH1cblxuICAgIHZhciBtID0geXJhbmdlICogKCRwLmNvbmZpZy5HUklEWSAvIGgpO1xuICAgIHZhciBwID0gcGFyc2VJbnQoeXJhbmdlLnRvRXhwb25lbnRpYWwoKS5zcGxpdCgnZScpWzFdKTtcbiAgICByZXR1cm4gTWF0aC5wb3coeXJhdGlvLCAxIC8gbik7XG4gIH1cblxuICBmdW5jdGlvbiBncmlkX3goKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIHN1YmdyaWQsIG5vIG5lZWQgdG8gY2FsYyBhIHRpbWVsaW5lLFxuICAgIC8vIHdlIGp1c3QgYm9ycm93IGl0IGZyb20gdGhlIG1hc3Rlcl9ncmlkXG4gICAgaWYgKCFtYXN0ZXJfZ3JpZCkge1xuICAgICAgc2VsZi50X3N0ZXAgPSB0aW1lX3N0ZXAoKTtcbiAgICAgIHNlbGYueHMgPSBbXTtcbiAgICAgIHZhciBkdCA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gICAgICB2YXIgciA9IHNlbGYuc3BhY2V4IC8gZHQ7XG4gICAgICAvKiBUT0RPOiByZW1vdmUgdGhlIGxlZnQtc2lkZSBnbGl0Y2hcbiAgICAgICBsZXQgeWVhcl8wID0gVXRpbHMuZ2V0X3llYXIoc3ViWzBdWzBdKVxuICAgICAgZm9yICh2YXIgdDAgPSB5ZWFyXzA7IHQwIDwgcmFuZ2VbMF07IHQwICs9IHNlbGYudF9zdGVwKSB7fVxuICAgICAgIGxldCBtMCA9IFV0aWxzLmdldF9tb250aCh0MCkqL1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHN1YltpXTtcbiAgICAgICAgdmFyIHByZXYgPSBzdWJbaSAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcHJldl94cyA9IHNlbGYueHNbc2VsZi54cy5sZW5ndGggLSAxXSB8fCBbMCwgW11dO1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoKHBbMF0gLSByYW5nZVswXSkgKiByKTtcbiAgICAgICAgaW5zZXJ0X2xpbmUocHJldiwgcCwgeCk7IC8vIEZpbHRlcmluZyBsaW5lcyB0aGF0IGFyZSB0b28gbmVhclxuXG4gICAgICAgIHZhciB4cyA9IHNlbGYueHNbc2VsZi54cy5sZW5ndGggLSAxXSB8fCBbMCwgW11dO1xuICAgICAgICBpZiAocHJldl94cyA9PT0geHMpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICh4c1sxXVswXSAtIHByZXZfeHNbMV1bMF0gPCBzZWxmLnRfc3RlcCAqIDAuOCkge1xuICAgICAgICAgIC8vIHByZXZfeHMgaXMgYSBoaWdoZXIgXCJyYW5rXCIgbGFiZWxcbiAgICAgICAgICBpZiAoeHNbMl0gPD0gcHJldl94c1syXSkge1xuICAgICAgICAgICAgc2VsZi54cy5wb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlXG4gICAgICAgICAgICBzZWxmLnhzLnNwbGljZShzZWxmLnhzLmxlbmd0aCAtIDIsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBUT0RPOiBmaXggZ3JpZCBleHRlbnNpb24gZm9yIGJpZ2dlciB0aW1lZnJhbWVzXG5cblxuICAgICAgaWYgKGludGVydmFsIDwgZ3JpZF9tYWtlcl9XRUVLICYmIHIgPiAwKSB7XG4gICAgICAgIGV4dGVuZF9sZWZ0KGR0LCByKTtcbiAgICAgICAgZXh0ZW5kX3JpZ2h0KGR0LCByKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi50X3N0ZXAgPSBtYXN0ZXJfZ3JpZC50X3N0ZXA7XG4gICAgICBzZWxmLnB4X3N0ZXAgPSBtYXN0ZXJfZ3JpZC5weF9zdGVwO1xuICAgICAgc2VsZi5zdGFydHggPSBtYXN0ZXJfZ3JpZC5zdGFydHg7XG4gICAgICBzZWxmLnhzID0gbWFzdGVyX2dyaWQueHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0X2xpbmUocHJldiwgcCwgeCwgbTApIHtcbiAgICB2YXIgcHJldl90ID0gdGlfbWFwLmliID8gdGlfbWFwLmkydChwcmV2WzBdKSA6IHByZXZbMF07XG4gICAgdmFyIHBfdCA9IHRpX21hcC5pYiA/IHRpX21hcC5pMnQocFswXSkgOiBwWzBdO1xuXG4gICAgaWYgKHRpX21hcC50ZiA8IGdyaWRfbWFrZXJfREFZKSB7XG4gICAgICBwcmV2X3QgKz0gdGltZXpvbmUgKiBncmlkX21ha2VyX0hPVVI7XG4gICAgICBwX3QgKz0gdGltZXpvbmUgKiBncmlkX21ha2VyX0hPVVI7XG4gICAgfVxuXG4gICAgdmFyIGQgPSB0aW1lem9uZSAqIGdyaWRfbWFrZXJfSE9VUjsgLy8gVE9ETzogdGFrZSB0aGlzIGJsb2NrID09PT09PT09PT4gKHNlZSBiZWxvdylcblxuICAgIGlmICgocHJldlswXSB8fCBpbnRlcnZhbCA9PT0gZ3JpZF9tYWtlcl9ZRUFSKSAmJiB1dGlscy5nZXRfeWVhcihwX3QpICE9PSB1dGlscy5nZXRfeWVhcihwcmV2X3QpKSB7XG4gICAgICBzZWxmLnhzLnB1c2goW3gsIHAsIGdyaWRfbWFrZXJfWUVBUl0pOyAvLyBbcHgsIFsuLi5dLCByYW5rXVxuICAgIH0gZWxzZSBpZiAocHJldlswXSAmJiB1dGlscy5nZXRfbW9udGgocF90KSAhPT0gdXRpbHMuZ2V0X21vbnRoKHByZXZfdCkpIHtcbiAgICAgIHNlbGYueHMucHVzaChbeCwgcCwgZ3JpZF9tYWtlcl9NT05USF0pO1xuICAgIH0gLy8gVE9ETzogc2hvdWxkIGJlIGFkZGVkIGlmIHRoaXMgZGF5ICE9PSBwcmV2IGRheVxuICAgIC8vIEFuZCB0aGUgc2FtZSBmb3IgJ2JvdGJhci5qcycsIFRPRE8oKilcbiAgICBlbHNlIGlmICh1dGlscy5kYXlfc3RhcnQocF90KSA9PT0gcF90KSB7XG4gICAgICAgIHNlbGYueHMucHVzaChbeCwgcCwgZ3JpZF9tYWtlcl9EQVldKTtcbiAgICAgIH0gZWxzZSBpZiAocFswXSAlIHNlbGYudF9zdGVwID09PSAwKSB7XG4gICAgICAgIHNlbGYueHMucHVzaChbeCwgcCwgaW50ZXJ2YWxdKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZF9sZWZ0KGR0LCByKSB7XG4gICAgaWYgKCFzZWxmLnhzLmxlbmd0aCB8fCAhaXNGaW5pdGUocikpIHJldHVybjtcbiAgICB2YXIgdCA9IHNlbGYueHNbMF1bMV1bMF07XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdCAtPSBzZWxmLnRfc3RlcDtcbiAgICAgIHZhciB4ID0gTWF0aC5mbG9vcigodCAtIHJhbmdlWzBdKSAqIHIpO1xuICAgICAgaWYgKHggPCAwKSBicmVhazsgLy8gVE9ETzogPT09PT09PT09PT4gQW5kIGluc2VydCBpdCBoZXJlIHNvbWVob3dcblxuICAgICAgaWYgKHQgJSBpbnRlcnZhbCA9PT0gMCkge1xuICAgICAgICBzZWxmLnhzLnVuc2hpZnQoW3gsIFt0XSwgaW50ZXJ2YWxdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRfcmlnaHQoZHQsIHIpIHtcbiAgICBpZiAoIXNlbGYueHMubGVuZ3RoIHx8ICFpc0Zpbml0ZShyKSkgcmV0dXJuO1xuICAgIHZhciB0ID0gc2VsZi54c1tzZWxmLnhzLmxlbmd0aCAtIDFdWzFdWzBdO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHQgKz0gc2VsZi50X3N0ZXA7XG4gICAgICB2YXIgeCA9IE1hdGguZmxvb3IoKHQgLSByYW5nZVswXSkgKiByKTtcbiAgICAgIGlmICh4ID4gc2VsZi5zcGFjZXgpIGJyZWFrO1xuXG4gICAgICBpZiAodCAlIGludGVydmFsID09PSAwKSB7XG4gICAgICAgIHNlbGYueHMucHVzaChbeCwgW3RdLCBpbnRlcnZhbF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdyaWRfeSgpIHtcbiAgICAvLyBQcmV2ZW50IGR1cGxpY2F0ZSBsZXZlbHNcbiAgICB2YXIgbSA9IE1hdGgucG93KDEwLCAtc2VsZi5wcmVjKTtcbiAgICBzZWxmLiRfc3RlcCA9IE1hdGgubWF4KG0sIGRvbGxhcl9zdGVwKCkpO1xuICAgIHNlbGYueXMgPSBbXTtcbiAgICB2YXIgeTEgPSBzZWxmLiRfbG8gLSBzZWxmLiRfbG8gJSBzZWxmLiRfc3RlcDtcblxuICAgIGZvciAodmFyIHkkID0geTE7IHkkIDw9IHNlbGYuJF9oaTsgeSQgKz0gc2VsZi4kX3N0ZXApIHtcbiAgICAgIHZhciB5ID0gTWF0aC5mbG9vcih5JCAqIHNlbGYuQSArIHNlbGYuQik7XG4gICAgICBpZiAoeSA+IGhlaWdodCkgY29udGludWU7XG4gICAgICBzZWxmLnlzLnB1c2goW3ksIHV0aWxzLnN0cmlwKHkkKV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdyaWRfeV9sb2coKSB7XG4gICAgLy8gVE9ETzogUHJldmVudCBkdXBsaWNhdGUgbGV2ZWxzLCBpcyB0aGlzIGV2ZW5cbiAgICAvLyBhIHByb2JsZW0gaGVyZSA/XG4gICAgc2VsZi4kX211bHQgPSBkb2xsYXJfbXVsdCgpO1xuICAgIHNlbGYueXMgPSBbXTtcbiAgICBpZiAoIXN1Yi5sZW5ndGgpIHJldHVybjtcbiAgICB2YXIgdiA9IE1hdGguYWJzKHN1YltzdWIubGVuZ3RoIC0gMV1bMV0gfHwgMSk7XG4gICAgdmFyIHkxID0gc2VhcmNoX3N0YXJ0X3Bvcyh2KTtcbiAgICB2YXIgeTIgPSBzZWFyY2hfc3RhcnRfbmVnKC12KTtcbiAgICB2YXIgeXAgPSAtSW5maW5pdHk7IC8vIFByZXZpb3VzIHkgdmFsdWVcblxuICAgIHZhciBuID0gaGVpZ2h0IC8gJHAuY29uZmlnLkdSSURZOyAvLyB0YXJnZXQgZ3JpZCBOXG5cbiAgICB2YXIgcSA9IDEgKyAoc2VsZi4kX211bHQgLSAxKSAvIDI7IC8vIE92ZXIgMFxuXG4gICAgZm9yICh2YXIgeSQgPSB5MTsgeSQgPiAwOyB5JCAvPSBzZWxmLiRfbXVsdCkge1xuICAgICAgeSQgPSBsb2dfcm91bmRlcih5JCwgcSk7XG4gICAgICB2YXIgeSA9IE1hdGguZmxvb3IobWF0aC5sb2coeSQpICogc2VsZi5BICsgc2VsZi5CKTtcbiAgICAgIHNlbGYueXMucHVzaChbeSwgdXRpbHMuc3RyaXAoeSQpXSk7XG4gICAgICBpZiAoeSA+IGhlaWdodCkgYnJlYWs7XG4gICAgICBpZiAoeSAtIHlwIDwgJHAuY29uZmlnLkdSSURZICogMC43KSBicmVhaztcbiAgICAgIGlmIChzZWxmLnlzLmxlbmd0aCA+IG4gKyAxKSBicmVhaztcbiAgICAgIHlwID0geTtcbiAgICB9IC8vIFVuZGVyIDBcblxuXG4gICAgeXAgPSBJbmZpbml0eTtcblxuICAgIGZvciAodmFyIHkkID0geTI7IHkkIDwgMDsgeSQgLz0gc2VsZi4kX211bHQpIHtcbiAgICAgIHkkID0gbG9nX3JvdW5kZXIoeSQsIHEpO1xuXG4gICAgICB2YXIgX3kgPSBNYXRoLmZsb29yKG1hdGgubG9nKHkkKSAqIHNlbGYuQSArIHNlbGYuQik7XG5cbiAgICAgIGlmICh5cCAtIF95IDwgJHAuY29uZmlnLkdSSURZICogMC43KSBicmVhaztcbiAgICAgIHNlbGYueXMucHVzaChbX3ksIHV0aWxzLnN0cmlwKHkkKV0pO1xuICAgICAgaWYgKF95IDwgMCkgYnJlYWs7XG4gICAgICBpZiAoc2VsZi55cy5sZW5ndGggPiBuICogMyArIDEpIGJyZWFrO1xuICAgICAgeXAgPSBfeTtcbiAgICB9IC8vIFRPRE86IHJlbW92ZSBsaW5lcyBuZWFyIHRvIDBcblxuICB9IC8vIFNlYXJjaCBhIHN0YXJ0IGZvciB0aGUgdG9wIGdyaWQgc28gdGhhdFxuICAvLyB0aGUgZml4ZWQgdmFsdWUgYWx3YXlzIGluY2x1ZGVkXG5cblxuICBmdW5jdGlvbiBzZWFyY2hfc3RhcnRfcG9zKHZhbHVlKSB7XG4gICAgdmFyIE4gPSBoZWlnaHQgLyAkcC5jb25maWcuR1JJRFk7IC8vIHRhcmdldCBncmlkIE5cblxuICAgIHZhciB5ID0gSW5maW5pdHksXG4gICAgICAgIHkkID0gdmFsdWUsXG4gICAgICAgIGNvdW50ID0gMDtcblxuICAgIHdoaWxlICh5ID4gMCkge1xuICAgICAgeSA9IE1hdGguZmxvb3IobWF0aC5sb2coeSQpICogc2VsZi5BICsgc2VsZi5CKTtcbiAgICAgIHkkICo9IHNlbGYuJF9tdWx0O1xuICAgICAgaWYgKGNvdW50KysgPiBOICogMykgcmV0dXJuIDA7IC8vIFByZXZlbnRzIGRlYWRsb29wc1xuICAgIH1cblxuICAgIHJldHVybiB5JDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaF9zdGFydF9uZWcodmFsdWUpIHtcbiAgICB2YXIgTiA9IGhlaWdodCAvICRwLmNvbmZpZy5HUklEWTsgLy8gdGFyZ2V0IGdyaWQgTlxuXG4gICAgdmFyIHkgPSAtSW5maW5pdHksXG4gICAgICAgIHkkID0gdmFsdWUsXG4gICAgICAgIGNvdW50ID0gMDtcblxuICAgIHdoaWxlICh5IDwgaGVpZ2h0KSB7XG4gICAgICB5ID0gTWF0aC5mbG9vcihtYXRoLmxvZyh5JCkgKiBzZWxmLkEgKyBzZWxmLkIpO1xuICAgICAgeSQgKj0gc2VsZi4kX211bHQ7XG4gICAgICBpZiAoY291bnQrKyA+IE4gKiAzKSBicmVhazsgLy8gUHJldmVudHMgZGVhZGxvb3BzXG4gICAgfVxuXG4gICAgcmV0dXJuIHkkO1xuICB9IC8vIE1ha2UgbG9nIHNjYWxlIGxldmVscyBsb29rIGdyZWF0IGFnYWluXG5cblxuICBmdW5jdGlvbiBsb2dfcm91bmRlcih4LCBxdWFsaXR5KSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpZ24oeCk7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuXG4gICAgaWYgKHggPiAxMCkge1xuICAgICAgZm9yICh2YXIgZGl2ID0gMTA7IGRpdiA8IE1BWF9JTlQ7IGRpdiAqPSAxMCkge1xuICAgICAgICB2YXIgbmljZSA9IE1hdGguZmxvb3IoeCAvIGRpdikgKiBkaXY7XG5cbiAgICAgICAgaWYgKHggLyBuaWNlID4gcXVhbGl0eSkge1xuICAgICAgICAgIC8vIE1vcmUgdGhhbiAxMCUgb2ZmXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGl2IC89IDEwO1xuICAgICAgcmV0dXJuIHMgKiBNYXRoLmZsb29yKHggLyBkaXYpICogZGl2O1xuICAgIH0gZWxzZSBpZiAoeCA8IDEpIHtcbiAgICAgIGZvciAodmFyIHJvID0gMTA7IHJvID49IDE7IHJvLS0pIHtcbiAgICAgICAgdmFyIF9uaWNlID0gdXRpbHMucm91bmQoeCwgcm8pO1xuXG4gICAgICAgIGlmICh4IC8gX25pY2UgPiBxdWFsaXR5KSB7XG4gICAgICAgICAgLy8gTW9yZSB0aGFuIDEwJSBvZmZcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcyAqIHV0aWxzLnJvdW5kKHgsIHJvICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzICogTWF0aC5mbG9vcih4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseV9zaXplcygpIHtcbiAgICBzZWxmLndpZHRoID0gJHAud2lkdGggLSBzZWxmLnNiO1xuICAgIHNlbGYuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgY2FsY18kcmFuZ2UoKTtcbiAgY2FsY19zaWRlYmFyKCk7XG4gIHJldHVybiB7XG4gICAgLy8gRmlyc3Qgd2UgbmVlZCB0byBjYWxjdWxhdGUgbWF4IHNpZGViYXIgd2lkdGhcbiAgICAvLyAoYW1vbmcgYWxsIGdyaWRzKS4gVGhlbiB3ZSBjYW4gYWN0dWFsbHkgbWFrZVxuICAgIC8vIHRoZW1cbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIGNhbGNfcG9zaXRpb25zKCk7XG4gICAgICBncmlkX3goKTtcblxuICAgICAgaWYgKGdyaWQubG9nU2NhbGUpIHtcbiAgICAgICAgZ3JpZF95X2xvZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZF95KCk7XG4gICAgICB9XG5cbiAgICAgIGFwcGx5X3NpemVzKCk7IC8vIExpbmsgdG8gdGhlIG1hc3RlciBncmlkIChjYW5kbGVzdGlja3MpXG5cbiAgICAgIGlmIChtYXN0ZXJfZ3JpZCkge1xuICAgICAgICBzZWxmLm1hc3Rlcl9ncmlkID0gbWFzdGVyX2dyaWQ7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZ3JpZCA9IGdyaWQ7IC8vIEdyaWQgcGFyYW1zXG4gICAgICAvLyBIZXJlIHdlIGFkZCBzb21lIGhlbHBmdWwgZnVuY3Rpb25zIGZvclxuICAgICAgLy8gcGx1Z2luIGNyZWF0b3JzXG5cbiAgICAgIHJldHVybiBsYXlvdXRfZm4oc2VsZiwgcmFuZ2UpO1xuICAgIH0sXG4gICAgZ2V0X2xheW91dDogZnVuY3Rpb24gZ2V0X2xheW91dCgpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgc2V0X3NpZGViYXI6IGZ1bmN0aW9uIHNldF9zaWRlYmFyKHYpIHtcbiAgICAgIHJldHVybiBzZWxmLnNiID0gdjtcbiAgICB9LFxuICAgIGdldF9zaWRlYmFyOiBmdW5jdGlvbiBnZXRfc2lkZWJhcigpIHtcbiAgICAgIHJldHVybiBzZWxmLnNiO1xuICAgIH1cbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBncmlkX21ha2VyID0gKEdyaWRNYWtlcik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9sYXlvdXQuanNcblxuXG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gbGF5b3V0X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBsYXlvdXRfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBsYXlvdXRfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGxheW91dF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gbGF5b3V0X2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIENhbGN1bGF0ZXMgYWxsIG5lY2Vzc2FyeSBzKml0IHRvIGJ1aWxkIHRoZSBjaGFydFxuLy8gSGVpZ2h0cywgd2lkdGhzLCB0cmFuc2Zvcm1zLCAuLi4gPSBldmVyeXRoaW5nXG4vLyBXaHkgc3VjaCBhIG1lc3MgeW91IGFzaz8gV2VsbCwgdGhhdCdzIGJlY2F1c2Vcbi8vIG9uZSBjb21wb25lbnRzIHNpemUgY2FuIGRlcGVuZCBvbiBvdGhlciBjb21wb25lbnRcbi8vIGRhdGEgZm9ybWF0dGluZyAoZS5nLiBncmlkIHdpZHRoIGRlcGVuZHMgb24gc2lkZWJhciBwcmVjaXNpb24pXG4vLyBTbyBpdCdzIGJldHRlciB0byBjYWxjIGFsbCBpbiBvbmUgcGxhY2UuXG5cblxuXG5cblxuZnVuY3Rpb24gTGF5b3V0KHBhcmFtcykge1xuICB2YXIgY2hhcnQgPSBwYXJhbXMuY2hhcnQsXG4gICAgICBzdWIgPSBwYXJhbXMuc3ViLFxuICAgICAgb2Zmc3ViID0gcGFyYW1zLm9mZnN1YixcbiAgICAgIGludGVydmFsID0gcGFyYW1zLmludGVydmFsLFxuICAgICAgcmFuZ2UgPSBwYXJhbXMucmFuZ2UsXG4gICAgICBjdHggPSBwYXJhbXMuY3R4LFxuICAgICAgbGF5ZXJzX21ldGEgPSBwYXJhbXMubGF5ZXJzX21ldGEsXG4gICAgICB0aV9tYXAgPSBwYXJhbXMudGlfbWFwLFxuICAgICAgJHAgPSBwYXJhbXMuJHByb3BzLFxuICAgICAgeV90cyA9IHBhcmFtcy55X3RyYW5zZm9ybXM7XG4gIHZhciBtZ3JpZCA9IGNoYXJ0LmdyaWQgfHwge307XG4gIG9mZnN1YiA9IG9mZnN1Yi5maWx0ZXIoZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAvLyBTa2lwIG9mZmNoYXJ0IG92ZXJsYXlzIHdpdGggY3VzdG9tIGdyaWQgaWQsXG4gICAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgbWVyZ3JlZCB3aXRoIHRoZSBleGlzdGluZyBncmlkc1xuICAgIHJldHVybiAhKHguZ3JpZCAmJiB4LmdyaWQuaWQpO1xuICB9KTsgLy8gU3BsaXRzIHNwYWNlIGJldHdlZW4gbWFpbiBjaGFydFxuICAvLyBhbmQgb2ZmY2hhcnQgaW5kaWNhdG9yIGdyaWRzXG5cbiAgZnVuY3Rpb24gZ3JpZF9ocygpIHtcbiAgICB2YXIgaGVpZ2h0ID0gJHAuaGVpZ2h0IC0gJHAuY29uZmlnLkJPVEJBUjsgLy8gV2hlbiBhdCBsZWFzdCBvbmUgaGVpZ2h0IGRlZmluZWQgKGRlZmF1bHQgPSAxKSxcbiAgICAvLyBQeHMgY2FsY3VsYXRlZCBhczogKHN1bSBvZiB3ZWlnaHRzKSAvIG51bWJlclxuXG4gICAgaWYgKG1ncmlkLmhlaWdodCB8fCBvZmZzdWIuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguZ3JpZC5oZWlnaHQ7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiB3ZWlnaHRlZF9ocyhtZ3JpZCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgbiA9IG9mZnN1Yi5sZW5ndGg7XG4gICAgdmFyIG9mZl9oID0gMiAqIE1hdGguc3FydChuKSAvIDcgLyAobiB8fCAxKTsgLy8gT2ZmY2hhcnQgZ3JpZCBoZWlnaHRcblxuICAgIHZhciBweCA9IE1hdGguZmxvb3IoaGVpZ2h0ICogb2ZmX2gpOyAvLyBNYWluIGdyaWQgaGVpZ2h0XG5cbiAgICB2YXIgbSA9IGhlaWdodCAtIHB4ICogbjtcbiAgICByZXR1cm4gW21dLmNvbmNhdChBcnJheShuKS5maWxsKHB4KSk7XG4gIH1cblxuICBmdW5jdGlvbiB3ZWlnaHRlZF9ocyhncmlkLCBoZWlnaHQpIHtcbiAgICB2YXIgaHMgPSBbe1xuICAgICAgZ3JpZDogZ3JpZFxuICAgIH1dLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkob2Zmc3ViKSkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5ncmlkLmhlaWdodCB8fCAxO1xuICAgIH0pO1xuICAgIHZhciBzdW0gPSBocy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICsgYjtcbiAgICB9LCAwKTtcbiAgICBocyA9IGhzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoeCAvIHN1bSAqIGhlaWdodCk7XG4gICAgfSk7IC8vIFJlZmluZSB0aGUgaGVpZ2h0IGlmIE1hdGguZmxvb3IgZGVjcmVhc2VkIHB4IHN1bVxuXG4gICAgc3VtID0gaHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSArIGI7XG4gICAgfSwgMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlaWdodCAtIHN1bTsgaSsrKSB7XG4gICAgICBoc1tpICUgaHMubGVuZ3RoXSsrO1xuICAgIH1cblxuICAgIHJldHVybiBocztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmRsZXNfbl92b2woKSB7XG4gICAgc2VsZi5jYW5kbGVzID0gW107XG4gICAgc2VsZi52b2x1bWUgPSBbXTtcbiAgICB2YXIgbWF4diA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShzdWIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geFs1XTtcbiAgICB9KSkpO1xuICAgIHZhciB2cyA9ICRwLmNvbmZpZy5WT0xTQ0FMRSAqICRwLmhlaWdodCAvIG1heHY7XG4gICAgdmFyIHgxLFxuICAgICAgICB4MixcbiAgICAgICAgbWlkLFxuICAgICAgICBwcmV2ID0gdW5kZWZpbmVkO1xuICAgIHZhciBzcGxpdHRlciA9IHNlbGYucHhfc3RlcCA+IDUgPyAxIDogMDtcbiAgICB2YXIgaGZfcHhfc3RlcCA9IHNlbGYucHhfc3RlcCAqIDAuNTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHN1YltpXTtcbiAgICAgIG1pZCA9IHNlbGYudDJzY3JlZW4ocFswXSkgKyAwLjU7XG4gICAgICBzZWxmLmNhbmRsZXMucHVzaChtZ3JpZC5sb2dTY2FsZSA/IGxvZ19zY2FsZS5jYW5kbGUoc2VsZiwgbWlkLCBwLCAkcCkgOiB7XG4gICAgICAgIHg6IG1pZCxcbiAgICAgICAgdzogc2VsZi5weF9zdGVwICogJHAuY29uZmlnLkNBTkRMRVcsXG4gICAgICAgIG86IE1hdGguZmxvb3IocFsxXSAqIHNlbGYuQSArIHNlbGYuQiksXG4gICAgICAgIGg6IE1hdGguZmxvb3IocFsyXSAqIHNlbGYuQSArIHNlbGYuQiksXG4gICAgICAgIGw6IE1hdGguZmxvb3IocFszXSAqIHNlbGYuQSArIHNlbGYuQiksXG4gICAgICAgIGM6IE1hdGguZmxvb3IocFs0XSAqIHNlbGYuQSArIHNlbGYuQiksXG4gICAgICAgIHJhdzogcFxuICAgICAgfSk7IC8vIENsZWFyIHZvbHVtZSBiYXIgaWYgdGhlcmUgaXMgYSB0aW1lIGdhcFxuXG4gICAgICBpZiAoc3ViW2kgLSAxXSAmJiBwWzBdIC0gc3ViW2kgLSAxXVswXSA+IGludGVydmFsKSB7XG4gICAgICAgIHByZXYgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB4MSA9IHByZXYgfHwgTWF0aC5mbG9vcihtaWQgLSBoZl9weF9zdGVwKTtcbiAgICAgIHgyID0gTWF0aC5mbG9vcihtaWQgKyBoZl9weF9zdGVwKSAtIDAuNTtcbiAgICAgIHNlbGYudm9sdW1lLnB1c2goe1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgaDogcFs1XSAqIHZzLFxuICAgICAgICBncmVlbjogcFs0XSA+PSBwWzFdLFxuICAgICAgICByYXc6IHBcbiAgICAgIH0pO1xuICAgICAgcHJldiA9IHgyICsgc3BsaXR0ZXI7XG4gICAgfVxuICB9IC8vIE1haW4gZ3JpZFxuXG5cbiAgdmFyIGhzID0gZ3JpZF9ocygpO1xuICB2YXIgc3BlY3MgPSB7XG4gICAgc3ViOiBzdWIsXG4gICAgaW50ZXJ2YWw6IGludGVydmFsLFxuICAgIHJhbmdlOiByYW5nZSxcbiAgICBjdHg6IGN0eCxcbiAgICAkcDogJHAsXG4gICAgbGF5ZXJzX21ldGE6IGxheWVyc19tZXRhLFxuICAgIHRpX21hcDogdGlfbWFwLFxuICAgIGhlaWdodDogaHNbMF0sXG4gICAgeV90OiB5X3RzWzBdLFxuICAgIGdyaWQ6IG1ncmlkLFxuICAgIHRpbWV6b25lOiAkcC50aW1lem9uZVxuICB9O1xuICB2YXIgZ21zID0gW25ldyBncmlkX21ha2VyKDAsIHNwZWNzKV07IC8vIFN1YiBncmlkc1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvZmZzdWIuZW50cmllcygpKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICBpID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgX3N0ZXAkdmFsdWUkID0gX3N0ZXAkdmFsdWVbMV0sXG4gICAgICAgICAgZGF0YSA9IF9zdGVwJHZhbHVlJC5kYXRhLFxuICAgICAgICAgIGdyaWQgPSBfc3RlcCR2YWx1ZSQuZ3JpZDtcblxuICAgICAgc3BlY3Muc3ViID0gZGF0YTtcbiAgICAgIHNwZWNzLmhlaWdodCA9IGhzW2kgKyAxXTtcbiAgICAgIHNwZWNzLnlfdCA9IHlfdHNbaSArIDFdO1xuICAgICAgc3BlY3MuZ3JpZCA9IGdyaWQgfHwge307XG4gICAgICBnbXMucHVzaChuZXcgZ3JpZF9tYWtlcihpICsgMSwgc3BlY3MsIGdtc1swXS5nZXRfbGF5b3V0KCkpKTtcbiAgICB9IC8vIE1heCBzaWRlYmFyIGFtb25nIGFsbCBncmluZHNcblxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICB2YXIgc2IgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoZ21zLm1hcChmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4LmdldF9zaWRlYmFyKCk7XG4gIH0pKSk7XG4gIHZhciBncmlkcyA9IFtdLFxuICAgICAgb2Zmc2V0ID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgZ21zLmxlbmd0aDsgaSsrKSB7XG4gICAgZ21zW2ldLnNldF9zaWRlYmFyKHNiKTtcbiAgICBncmlkcy5wdXNoKGdtc1tpXS5jcmVhdGUoKSk7XG4gICAgZ3JpZHNbaV0uaWQgPSBpO1xuICAgIGdyaWRzW2ldLm9mZnNldCA9IG9mZnNldDtcbiAgICBvZmZzZXQgKz0gZ3JpZHNbaV0uaGVpZ2h0O1xuICB9XG5cbiAgdmFyIHNlbGYgPSBncmlkc1swXTtcbiAgY2FuZGxlc19uX3ZvbCgpO1xuICByZXR1cm4ge1xuICAgIGdyaWRzOiBncmlkcyxcbiAgICBib3RiYXI6IHtcbiAgICAgIHdpZHRoOiAkcC53aWR0aCxcbiAgICAgIGhlaWdodDogJHAuY29uZmlnLkJPVEJBUixcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgeHM6IGdyaWRzWzBdID8gZ3JpZHNbMF0ueHMgOiBbXVxuICAgIH1cbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBsYXlvdXQgPSAoTGF5b3V0KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qc1xuZnVuY3Rpb24gY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL3VwZGF0ZXIuanNcblxuXG5cblxuZnVuY3Rpb24gdXBkYXRlcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gdXBkYXRlcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gdXBkYXRlcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHVwZGF0ZXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHVwZGF0ZXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIHVwZGF0ZXJfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gQ3Vyc29yIHVwZGF0ZXI6IGNhbGN1bGF0ZXMgY3VycmVudCB2YWx1ZXMgZm9yXG4vLyBPSExDViBhbmQgYWxsIG90aGVyIGluZGljYXRvcnNcblxuXG52YXIgQ3Vyc29yVXBkYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1cnNvclVwZGF0ZXIoY29tcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnNvclVwZGF0ZXIpO1xuXG4gICAgdGhpcy5jb21wID0gY29tcCwgdGhpcy5ncmlkcyA9IGNvbXAuX2xheW91dC5ncmlkcywgdGhpcy5jdXJzb3IgPSBjb21wLmN1cnNvcjtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKEN1cnNvclVwZGF0ZXIsIFt7XG4gICAga2V5OiBcInN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3luYyhlKSB7XG4gICAgICAvLyBUT0RPOiB2YWx1ZXMgbm90IGRpc3BsYXlpbmcgaWYgYSBjdXN0b20gZ3JpZCBpZCBpcyBzZXQ6XG4gICAgICAvLyBncmlkOiB7IGlkOiBOIH1cbiAgICAgIHRoaXMuY3Vyc29yLmdyaWRfaWQgPSBlLmdyaWRfaWQ7XG4gICAgICB2YXIgb25jZSA9IHRydWU7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSB1cGRhdGVyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5ncmlkcyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGdyaWQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuY3Vyc29yX2RhdGEoZ3JpZCwgZSk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuY3Vyc29yLmxvY2tlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBmaXggdG8gaW52aXNpYmxlIGN1cnNvciBwcm9iXG4gICAgICAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgICAgICB0aGlzLmN1cnNvci50ID0gdGhpcy5jdXJzb3JfdGltZShncmlkLCBlLCBjKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yLnQpIG9uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMudmFsdWVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcC4kc2V0KHRoaXMuY3Vyc29yLnZhbHVlcywgZ3JpZC5pZCwgYy52YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChncmlkLmlkICE9PSBlLmdyaWRfaWQpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMuY3Vyc29yLnggPSBncmlkLnQyc2NyZWVuKHRoaXMuY3Vyc29yLnQpO1xuICAgICAgICAgIHRoaXMuY3Vyc29yLnkgPSBjLnk7XG4gICAgICAgICAgdGhpcy5jdXJzb3IueSQgPSBjLnkkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJsYXlfZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVybGF5X2RhdGEoZ3JpZCwgZSkge1xuICAgICAgdmFyIHMgPSBncmlkLmlkID09PSAwID8gJ21haW5fc2VjdGlvbicgOiAnc3ViX3NlY3Rpb24nO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmNvbXBbc10uZGF0YTsgLy8gU3BsaXQgb2ZmY2hhcnQgZGF0YSBiZXR3ZWVuIG9mZmNoYXJ0IGdyaWRzXG5cbiAgICAgIGlmIChncmlkLmlkID4gMCkge1xuICAgICAgICAvLyBTZXF1ZW50aWFsIGdyaWRzXG4gICAgICAgIHZhciBfZCA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHguZ3JpZC5pZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9KTsgLy8gZ3JpZHMgd2l0aCBjdXN0b20gaWRzIChmb3IgbWVyZ2luZylcblxuXG4gICAgICAgIHZhciBtID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5ncmlkLmlkID09PSBncmlkLmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgZGF0YSA9IFtfZFtncmlkLmlkIC0gMV1dLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdCA9IGdyaWQuc2NyZWVuMnQoZS54KTtcbiAgICAgIHZhciBpZHMgPSB7fSxcbiAgICAgICAgICByZXMgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSB1cGRhdGVyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIHZhciB0cyA9IGQuZGF0YS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4WzBdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpID0gdXRpbHMubmVhcmVzdF9hKHQsIHRzKVswXTtcbiAgICAgICAgICBkLnR5cGUgaW4gaWRzID8gaWRzW2QudHlwZV0rKyA6IGlkc1tkLnR5cGVdID0gMDtcbiAgICAgICAgICByZXNbXCJcIi5jb25jYXQoZC50eXBlLCBcIl9cIikuY29uY2F0KGlkc1tkLnR5cGVdKV0gPSBkLmRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gTmVhcmVzdCBkYXRhcG9pbnRzXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXJzb3JfZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJzb3JfZGF0YShncmlkLCBlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuY29tcC5tYWluX3NlY3Rpb24uc3ViO1xuICAgICAgdmFyIHhzID0gZGF0YS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQudDJzY3JlZW4oeFswXSkgKyAwLjU7XG4gICAgICB9KTtcbiAgICAgIHZhciBpID0gdXRpbHMubmVhcmVzdF9hKGUueCwgeHMpWzBdO1xuICAgICAgaWYgKCF4c1tpXSkgcmV0dXJuIHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5mbG9vcih4c1tpXSkgLSAwLjUsXG4gICAgICAgIHk6IE1hdGguZmxvb3IoZS55IC0gMikgLSAwLjUgLSBncmlkLm9mZnNldCxcbiAgICAgICAgeSQ6IGdyaWQuc2NyZWVuMiQoZS55IC0gMiAtIGdyaWQub2Zmc2V0KSxcbiAgICAgICAgdDogKGRhdGFbaV0gfHwgW10pWzBdLFxuICAgICAgICB2YWx1ZXM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIG9obGN2OiBncmlkLmlkID09PSAwID8gZGF0YVtpXSA6IHVuZGVmaW5lZFxuICAgICAgICB9LCB0aGlzLm92ZXJsYXlfZGF0YShncmlkLCBlKSlcbiAgICAgIH07XG4gICAgfSAvLyBHZXQgY3Vyc29yIHQtcG9zaXRpb24gKGV4dGVuZGVkKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3Vyc29yX3RpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3Vyc29yX3RpbWUoZ3JpZCwgbW91c2UsIGNhbmRsZSkge1xuICAgICAgdmFyIHQgPSBncmlkLnNjcmVlbjJ0KG1vdXNlLngpO1xuICAgICAgdmFyIHIgPSBNYXRoLmFicygodCAtIGNhbmRsZS50KSAvIHRoaXMuY29tcC5pbnRlcnZhbCk7XG4gICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbih0IC0gY2FuZGxlLnQpO1xuXG4gICAgICBpZiAociA+PSAwLjUpIHtcbiAgICAgICAgLy8gT3V0c2lkZSB0aGUgZGF0YSByYW5nZVxuICAgICAgICB2YXIgbiA9IE1hdGgucm91bmQocik7XG4gICAgICAgIHJldHVybiBjYW5kbGUudCArIG4gKiB0aGlzLmNvbXAuaW50ZXJ2YWwgKiBzaWduO1xuICAgICAgfSAvLyBJbnNpZGUgdGhlIGRhdGEgcmFuZ2VcblxuXG4gICAgICByZXR1cm4gY2FuZGxlLnQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1cnNvclVwZGF0ZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgdXBkYXRlciA9IChDdXJzb3JVcGRhdGVyKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1NlY3Rpb24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPThmYmU5MzM2JlxudmFyIFNlY3Rpb252dWVfdHlwZV90ZW1wbGF0ZV9pZF84ZmJlOTMzNl9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLXNlY3Rpb25cIiB9LFxuICAgIFtcbiAgICAgIF9jKFwiY2hhcnQtbGVnZW5kXCIsIHtcbiAgICAgICAgcmVmOiBcImxlZ2VuZFwiLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHZhbHVlczogX3ZtLnNlY3Rpb25fdmFsdWVzLFxuICAgICAgICAgIGdyaWRfaWQ6IF92bS5ncmlkX2lkLFxuICAgICAgICAgIGNvbW1vbjogX3ZtLmxlZ2VuZF9wcm9wcyxcbiAgICAgICAgICBtZXRhX3Byb3BzOiBfdm0uZ2V0X21ldGFfcHJvcHNcbiAgICAgICAgfSxcbiAgICAgICAgb246IHsgXCJsZWdlbmQtYnV0dG9uLWNsaWNrXCI6IF92bS5idXR0b25fY2xpY2sgfVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwiZ3JpZFwiLFxuICAgICAgICBfdm0uX2IoXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVmOiBcImdyaWRcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGdyaWRfaWQ6IF92bS5ncmlkX2lkIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBcInJlZ2lzdGVyLWtiLWxpc3RlbmVyXCI6IF92bS5yZWdpc3Rlcl9rYixcbiAgICAgICAgICAgICAgXCJyZW1vdmUta2ItbGlzdGVuZXJcIjogX3ZtLnJlbW92ZV9rYixcbiAgICAgICAgICAgICAgXCJyYW5nZS1jaGFuZ2VkXCI6IF92bS5yYW5nZV9jaGFuZ2VkLFxuICAgICAgICAgICAgICBcImN1cnNvci1jaGFuZ2VkXCI6IF92bS5jdXJzb3JfY2hhbmdlZCxcbiAgICAgICAgICAgICAgXCJjdXJzb3ItbG9ja2VkXCI6IF92bS5jdXJzb3JfbG9ja2VkLFxuICAgICAgICAgICAgICBcImxheWVyLW1ldGEtcHJvcHNcIjogX3ZtLmVtaXRfbWV0YV9wcm9wcyxcbiAgICAgICAgICAgICAgXCJjdXN0b20tZXZlbnRcIjogX3ZtLmVtaXRfY3VzdG9tX2V2ZW50LFxuICAgICAgICAgICAgICBcInNpZGViYXItdHJhbnNmb3JtXCI6IF92bS5zaWRlYmFyX3RyYW5zZm9ybSxcbiAgICAgICAgICAgICAgXCJyZXpvb20tcmFuZ2VcIjogX3ZtLnJlem9vbV9yYW5nZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJncmlkXCIsXG4gICAgICAgICAgX3ZtLmdyaWRfcHJvcHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJzaWRlYmFyXCIsXG4gICAgICAgIF92bS5fYihcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZWY6IFwic2ItXCIgKyBfdm0uZ3JpZF9pZCxcbiAgICAgICAgICAgIGF0dHJzOiB7IGdyaWRfaWQ6IF92bS5ncmlkX2lkLCByZXJlbmRlcjogX3ZtLnJlcmVuZGVyIH0sXG4gICAgICAgICAgICBvbjogeyBcInNpZGViYXItdHJhbnNmb3JtXCI6IF92bS5zaWRlYmFyX3RyYW5zZm9ybSB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNpZGViYXJcIixcbiAgICAgICAgICBfdm0uc2lkZWJhcl9wcm9wcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBTZWN0aW9udnVlX3R5cGVfdGVtcGxhdGVfaWRfOGZiZTkzMzZfc3RhdGljUmVuZGVyRm5zID0gW11cblNlY3Rpb252dWVfdHlwZV90ZW1wbGF0ZV9pZF84ZmJlOTMzNl9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TZWN0aW9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD04ZmJlOTMzNiZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0dWZmL2ZyYW1lLmpzXG5cblxuLy8gQW5uaW1hdGlvbiBmcmFtZSB3aXRoIGEgZmFsbGJhY2sgZm9yXG4vLyBzbG93ZXIgZGV2aWNlc1xuXG5cbnZhciBGcmFtZUFuaW1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZyYW1lQW5pbWF0aW9uKGNiKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZyYW1lQW5pbWF0aW9uKTtcblxuICAgIHRoaXMudDAgPSB0aGlzLnQgPSB1dGlscy5ub3coKTtcbiAgICB0aGlzLmlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVGhlIHByZXYgZnJhbWUgdG9vayB0b28gbG9uZ1xuICAgICAgaWYgKHV0aWxzLm5vdygpIC0gX3RoaXMudCA+IDEwMCkgcmV0dXJuO1xuXG4gICAgICBpZiAodXRpbHMubm93KCkgLSBfdGhpcy50MCA+IDEyMDApIHtcbiAgICAgICAgX3RoaXMuc3RvcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuaWQpIGNiKF90aGlzKTtcbiAgICAgIF90aGlzLnQgPSB1dGlscy5ub3coKTtcbiAgICB9LCAxNik7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhGcmFtZUFuaW1hdGlvbiwgW3tcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmlkKTtcbiAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmFtZUFuaW1hdGlvbjtcbn0oKTtcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qc1xudmFyIGhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oODQwKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvaGFtc3RlcmpzL2hhbXN0ZXIuanNcbnZhciBoYW1zdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODEpO1xudmFyIGhhbXN0ZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaGFtc3Rlcik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9ncmlkLmpzXG5cblxuXG5cblxuZnVuY3Rpb24gZ3JpZF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gZ3JpZF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gZ3JpZF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGdyaWRfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGdyaWRfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGdyaWRfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gR3JpZC5qcyBsaXN0ZW5zIHRvIHZhcmlvdXMgdXNlci1nZW5lcmF0ZWQgZXZlbnRzLFxuLy8gZW1pdHMgVnVlLWV2ZW50cyBpZiBzb21ldGhpbmcgaGFzIGNoYW5nZWQgKGUuZy4gcmFuZ2UpXG4vLyBUaGluayBvZiBpdCBhcyBhbiBJL08gc3lzdGVtIGZvciBHcmlkLnZ1ZVxuXG5cblxuXG4gLy8gR3JpZCBpcyBnb29kLlxuXG52YXIgR3JpZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdyaWQoY2FudmFzLCBjb21wKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JpZCk7XG5cbiAgICB0aGlzLk1JTl9aT09NID0gY29tcC5jb25maWcuTUlOX1pPT007XG4gICAgdGhpcy5NQVhfWk9PTSA9IGNvbXAuY29uZmlnLk1BWF9aT09NO1xuICAgIGlmICh1dGlscy5pc19tb2JpbGUpIHRoaXMuTUlOX1pPT00gKj0gMC41O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5jb21wID0gY29tcDtcbiAgICB0aGlzLiRwID0gY29tcC4kcHJvcHM7XG4gICAgdGhpcy5kYXRhID0gdGhpcy4kcC5zdWI7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuJHAucmFuZ2U7XG4gICAgdGhpcy5pZCA9IHRoaXMuJHAuZ3JpZF9pZDtcbiAgICB0aGlzLmxheW91dCA9IHRoaXMuJHAubGF5b3V0LmdyaWRzW3RoaXMuaWRdO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSB0aGlzLiRwLmludGVydmFsO1xuICAgIHRoaXMuY3Vyc29yID0gY29tcC4kcHJvcHMuY3Vyc29yO1xuICAgIHRoaXMub2Zmc2V0X3ggPSAwO1xuICAgIHRoaXMub2Zmc2V0X3kgPSAwO1xuICAgIHRoaXMuZGVsdGFzID0gMDsgLy8gV2hlZWwgZGVsdGEgZXZlbnRzXG5cbiAgICB0aGlzLndtb2RlID0gdGhpcy4kcC5jb25maWcuU0NST0xMX1dIRUVMO1xuICAgIHRoaXMubGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vdmVybGF5cyA9IFtdO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoR3JpZCwgW3tcbiAgICBrZXk6IFwibGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuaG0gPSBoYW1zdGVyX2RlZmF1bHQoKSh0aGlzLmNhbnZhcyk7XG4gICAgICB0aGlzLmhtLndoZWVsKGZ1bmN0aW9uIChldmVudCwgZGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm1vdXNlem9vbSgtZGVsdGEgKiA1MCwgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbWMgPSB0aGlzLm1jID0gbmV3IGhhbW1lci5NYW5hZ2VyKHRoaXMuY2FudmFzKTtcbiAgICAgIHZhciBUID0gdXRpbHMuaXNfbW9iaWxlID8gMTAgOiAwO1xuICAgICAgbWMuYWRkKG5ldyBoYW1tZXIuUGFuKHtcbiAgICAgICAgdGhyZXNob2xkOiBUXG4gICAgICB9KSk7XG4gICAgICBtYy5hZGQobmV3IGhhbW1lci5UYXAoKSk7XG4gICAgICBtYy5hZGQobmV3IGhhbW1lci5QaW5jaCh7XG4gICAgICAgIHRocmVzaG9sZDogMFxuICAgICAgfSkpO1xuICAgICAgbWMuZ2V0KCdwaW5jaCcpLnNldCh7XG4gICAgICAgIGVuYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSBtYy5hZGQobmV3IGhhbW1lci5QcmVzcygpKTtcbiAgICAgIG1jLm9uKCdwYW5zdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMuY3Vyc29yLnNjcm9sbF9sb2NrKSByZXR1cm47XG5cbiAgICAgICAgaWYgKF90aGlzLmN1cnNvci5tb2RlID09PSAnYWltJykge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0X2N1cnNvcl9jb29yZChldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGZybSA9IF90aGlzLiRwLnlfdHJhbnNmb3JtO1xuICAgICAgICBfdGhpcy5kcnVnID0ge1xuICAgICAgICAgIHg6IGV2ZW50LmNlbnRlci54ICsgX3RoaXMub2Zmc2V0X3gsXG4gICAgICAgICAgeTogZXZlbnQuY2VudGVyLnkgKyBfdGhpcy5vZmZzZXRfeSxcbiAgICAgICAgICByOiBfdGhpcy5yYW5nZS5zbGljZSgpLFxuICAgICAgICAgIHQ6IF90aGlzLnJhbmdlWzFdIC0gX3RoaXMucmFuZ2VbMF0sXG4gICAgICAgICAgbzogdGZybSA/IHRmcm0ub2Zmc2V0IHx8IDAgOiAwLFxuICAgICAgICAgIHlfcjogdGZybSAmJiB0ZnJtLnJhbmdlID8gdGZybS5yYW5nZS5zbGljZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIEI6IF90aGlzLmxheW91dC5CLFxuICAgICAgICAgIHQwOiB1dGlscy5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1jaGFuZ2VkJywge1xuICAgICAgICAgIGdyaWRfaWQ6IF90aGlzLmlkLFxuICAgICAgICAgIHg6IGV2ZW50LmNlbnRlci54ICsgX3RoaXMub2Zmc2V0X3gsXG4gICAgICAgICAgeTogZXZlbnQuY2VudGVyLnkgKyBfdGhpcy5vZmZzZXRfeVxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItbG9ja2VkJywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdwYW5tb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh1dGlscy5pc19tb2JpbGUpIHtcbiAgICAgICAgICBfdGhpcy5jYWxjX29mZnNldCgpO1xuXG4gICAgICAgICAgX3RoaXMucHJvcGFnYXRlKCdtb3VzZW1vdmUnLCBfdGhpcy50b3VjaDJtb3VzZShldmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLmRydWcpIHtcbiAgICAgICAgICBfdGhpcy5tb3VzZWRyYWcoX3RoaXMuZHJ1Zy54ICsgZXZlbnQuZGVsdGFYLCBfdGhpcy5kcnVnLnkgKyBldmVudC5kZWx0YVkpO1xuXG4gICAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBncmlkX2lkOiBfdGhpcy5pZCxcbiAgICAgICAgICAgIHg6IGV2ZW50LmNlbnRlci54ICsgX3RoaXMub2Zmc2V0X3gsXG4gICAgICAgICAgICB5OiBldmVudC5jZW50ZXIueSArIF90aGlzLm9mZnNldF95XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuY3Vyc29yLm1vZGUgPT09ICdhaW0nKSB7XG4gICAgICAgICAgX3RoaXMuZW1pdF9jdXJzb3JfY29vcmQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdwYW5lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzX21vYmlsZSAmJiBfdGhpcy5kcnVnKSB7XG4gICAgICAgICAgX3RoaXMucGFuX2ZhZGUoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZHJ1ZyA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWxvY2tlZCcsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXV0aWxzLmlzX21vYmlsZSkgcmV0dXJuO1xuXG4gICAgICAgIF90aGlzLnNpbV9tb3VzZWRvd24oZXZlbnQpO1xuXG4gICAgICAgIGlmIChfdGhpcy5mYWRlKSBfdGhpcy5mYWRlLnN0b3AoKTtcblxuICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItY2hhbmdlZCcsIHt9KTtcblxuICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItY2hhbmdlZCcsIHtcbiAgICAgICAgICAvKmdyaWRfaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgeDogdW5kZWZpbmVkLC8vZXZlbnQuY2VudGVyLnggKyB0aGlzLm9mZnNldF94LFxuICAgICAgICAgIHk6IHVuZGVmaW5lZCwvL2V2ZW50LmNlbnRlci55ICsgdGhpcy5vZmZzZXRfeSwqL1xuICAgICAgICAgIG1vZGU6ICdleHBsb3JlJ1xuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy51cGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3BpbmNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRydWcgPSBudWxsO1xuICAgICAgICBfdGhpcy5waW5jaCA9IHtcbiAgICAgICAgICB0OiBfdGhpcy5yYW5nZVsxXSAtIF90aGlzLnJhbmdlWzBdLFxuICAgICAgICAgIHI6IF90aGlzLnJhbmdlLnNsaWNlKClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3BpbmNoZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5waW5jaCA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdwaW5jaCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMucGluY2gpIF90aGlzLnBpbmNoem9vbShldmVudC5zY2FsZSk7XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdwcmVzcycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXV0aWxzLmlzX21vYmlsZSkgcmV0dXJuO1xuICAgICAgICBpZiAoX3RoaXMuZmFkZSkgX3RoaXMuZmFkZS5zdG9wKCk7XG5cbiAgICAgICAgX3RoaXMuY2FsY19vZmZzZXQoKTtcblxuICAgICAgICBfdGhpcy5lbWl0X2N1cnNvcl9jb29yZChldmVudCwge1xuICAgICAgICAgIG1vZGU6ICdhaW0nXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuc2ltX21vdXNlZG93bihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBhZGQgPSBhZGRFdmVudExpc3RlbmVyO1xuICAgICAgYWRkKFwiZ2VzdHVyZXN0YXJ0XCIsIHRoaXMuZ2VzdHVyZXN0YXJ0KTtcbiAgICAgIGFkZChcImdlc3R1cmVjaGFuZ2VcIiwgdGhpcy5nZXN0dXJlY2hhbmdlKTtcbiAgICAgIGFkZChcImdlc3R1cmVlbmRcIiwgdGhpcy5nZXN0dXJlZW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VzdHVyZXN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlc3R1cmVzdGFydChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VzdHVyZWNoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXN0dXJlY2hhbmdlKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXN0dXJlZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlc3R1cmVlbmQoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZW1vdmUoZXZlbnQpIHtcbiAgICAgIGlmICh1dGlscy5pc19tb2JpbGUpIHJldHVybjtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWNoYW5nZWQnLCB7XG4gICAgICAgIGdyaWRfaWQ6IHRoaXMuaWQsXG4gICAgICAgIHg6IGV2ZW50LmxheWVyWCxcbiAgICAgICAgeTogZXZlbnQubGF5ZXJZICsgdGhpcy5sYXlvdXQub2Zmc2V0XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FsY19vZmZzZXQoKTtcbiAgICAgIHRoaXMucHJvcGFnYXRlKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlb3V0KGV2ZW50KSB7XG4gICAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSByZXR1cm47XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1jaGFuZ2VkJywge30pO1xuICAgICAgdGhpcy5wcm9wYWdhdGUoJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZXVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNldXAoZXZlbnQpIHtcbiAgICAgIHRoaXMuZHJ1ZyA9IG51bGw7XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1sb2NrZWQnLCBmYWxzZSk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZSgnbW91c2V1cCcsIGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2Vkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlZG93bihldmVudCkge1xuICAgICAgaWYgKHV0aWxzLmlzX21vYmlsZSkgcmV0dXJuO1xuICAgICAgdGhpcy5wcm9wYWdhdGUoJ21vdXNlZG93bicsIGV2ZW50KTtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWxvY2tlZCcsIHRydWUpO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogJ2dyaWQtbW91c2Vkb3duJyxcbiAgICAgICAgYXJnczogW3RoaXMuaWQsIGV2ZW50XVxuICAgICAgfSk7XG4gICAgfSAvLyBTaW11bGF0ZWQgbW91c2Vkb3duIChmb3IgbW9iaWxlKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwic2ltX21vdXNlZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW1fbW91c2Vkb3duKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKGV2ZW50LnNyY0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogJ2dyaWQtbW91c2Vkb3duJyxcbiAgICAgICAgYXJnczogW3RoaXMuaWQsIGV2ZW50XVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZSgnbW91c2Vtb3ZlJywgdGhpcy50b3VjaDJtb3VzZShldmVudCkpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMucHJvcGFnYXRlKCdtb3VzZWRvd24nLCB0aGlzLnRvdWNoMm1vdXNlKGV2ZW50KSk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnByb3BhZ2F0ZSgnY2xpY2snLCBfdGhpczIudG91Y2gybW91c2UoZXZlbnQpKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gQ29udmVydCB0b3VjaCB0byBcIm1vdXNlXCIgZXZlbnRcblxuICB9LCB7XG4gICAga2V5OiBcInRvdWNoMm1vdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvdWNoMm1vdXNlKGUpIHtcbiAgICAgIHRoaXMuY2FsY19vZmZzZXQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsOiBlLnNyY0V2ZW50LFxuICAgICAgICBsYXllclg6IGUuY2VudGVyLnggKyB0aGlzLm9mZnNldF94LFxuICAgICAgICBsYXllclk6IGUuY2VudGVyLnkgKyB0aGlzLm9mZnNldF95LFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGljayhldmVudCkge1xuICAgICAgdGhpcy5wcm9wYWdhdGUoJ2NsaWNrJywgZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbWl0X2N1cnNvcl9jb29yZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0X2N1cnNvcl9jb29yZChldmVudCwgYWRkKSB7XG4gICAgICBpZiAoYWRkID09PSB2b2lkIDApIHtcbiAgICAgICAgYWRkID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWNoYW5nZWQnLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgZ3JpZF9pZDogdGhpcy5pZCxcbiAgICAgICAgeDogZXZlbnQuY2VudGVyLnggKyB0aGlzLm9mZnNldF94LFxuICAgICAgICB5OiBldmVudC5jZW50ZXIueSArIHRoaXMub2Zmc2V0X3kgKyB0aGlzLmxheW91dC5vZmZzZXRcbiAgICAgIH0sIGFkZCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5fZmFkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW5fZmFkZShldmVudCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBkdCA9IHV0aWxzLm5vdygpIC0gdGhpcy5kcnVnLnQwO1xuICAgICAgdmFyIGR4ID0gdGhpcy5yYW5nZVsxXSAtIHRoaXMuZHJ1Zy5yWzFdO1xuICAgICAgdmFyIHYgPSA0MiAqIGR4IC8gZHQ7XG4gICAgICB2YXIgdjAgPSBNYXRoLmFicyh2ICogMC4wMSk7XG4gICAgICBpZiAoZHQgPiA1MDApIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmZhZGUpIHRoaXMuZmFkZS5zdG9wKCk7XG4gICAgICB0aGlzLmZhZGUgPSBuZXcgRnJhbWVBbmltYXRpb24oZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgdiAqPSAwLjg1O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyh2KSA8IHYwKSB7XG4gICAgICAgICAgc2VsZi5zdG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczMucmFuZ2VbMF0gKz0gdjtcbiAgICAgICAgX3RoaXMzLnJhbmdlWzFdICs9IHY7XG5cbiAgICAgICAgX3RoaXMzLmNoYW5nZV9yYW5nZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGNfb2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfb2Zmc2V0KCkge1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMub2Zmc2V0X3ggPSAtcmVjdC54O1xuICAgICAgdGhpcy5vZmZzZXRfeSA9IC1yZWN0Lnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5ld19sYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdfbGF5ZXIobGF5ZXIpIHtcbiAgICAgIGlmIChsYXllci5uYW1lID09PSAnY3Jvc3NoYWlyJykge1xuICAgICAgICB0aGlzLmNyb3NzaGFpciA9IGxheWVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdmVybGF5cy5wdXNoKGxheWVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsX2xheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbF9sYXllcihpZCkge1xuICAgICAgdGhpcy5vdmVybGF5cyA9IHRoaXMub3ZlcmxheXMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LmlkICE9PSBpZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd19oaWRlX2xheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dfaGlkZV9sYXllcihldmVudCkge1xuICAgICAgdmFyIGwgPSB0aGlzLm92ZXJsYXlzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5pZCA9PT0gZXZlbnQuaWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChsLmxlbmd0aCkgbFswXS5kaXNwbGF5ID0gZXZlbnQuZGlzcGxheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAvLyBVcGRhdGUgcmVmZXJlbmNlIHRvIHRoZSBncmlkXG4gICAgICAvLyBUT0RPOiBjaGVjayB3aGF0IGhhcHBlbnMgaWYgZGF0YSBjaGFuZ2VzIGludGVydmFsXG4gICAgICB0aGlzLmxheW91dCA9IHRoaXMuJHAubGF5b3V0LmdyaWRzW3RoaXMuaWRdO1xuICAgICAgdGhpcy5pbnRlcnZhbCA9IHRoaXMuJHAuaW50ZXJ2YWw7XG4gICAgICBpZiAoIXRoaXMubGF5b3V0KSByZXR1cm47XG4gICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICBpZiAodGhpcy4kcC5zaGFkZXJzLmxlbmd0aCkgdGhpcy5hcHBseV9zaGFkZXJzKCk7XG4gICAgICB0aGlzLmdyaWQoKTtcbiAgICAgIHZhciBvdmVybGF5cyA9IFtdO1xuICAgICAgb3ZlcmxheXMucHVzaC5hcHBseShvdmVybGF5cywgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMub3ZlcmxheXMpKTsgLy8gei1pbmRleCBzb3J0aW5nXG5cbiAgICAgIG92ZXJsYXlzLnNvcnQoZnVuY3Rpb24gKGwxLCBsMikge1xuICAgICAgICByZXR1cm4gbDEueiAtIGwyLno7XG4gICAgICB9KTtcbiAgICAgIG92ZXJsYXlzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgaWYgKCFsLmRpc3BsYXkpIHJldHVybjtcblxuICAgICAgICBfdGhpczQuY3R4LnNhdmUoKTtcblxuICAgICAgICB2YXIgciA9IGwucmVuZGVyZXI7XG4gICAgICAgIGlmIChyLnByZV9kcmF3KSByLnByZV9kcmF3KF90aGlzNC5jdHgpO1xuICAgICAgICByLmRyYXcoX3RoaXM0LmN0eCk7XG4gICAgICAgIGlmIChyLnBvc3RfZHJhdykgci5wb3N0X2RyYXcoX3RoaXM0LmN0eCk7XG5cbiAgICAgICAgX3RoaXM0LmN0eC5yZXN0b3JlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuY3Jvc3NoYWlyKSB7XG4gICAgICAgIHRoaXMuY3Jvc3NoYWlyLnJlbmRlcmVyLmRyYXcodGhpcy5jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseV9zaGFkZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5X3NoYWRlcnMoKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQuZ3JpZHNbdGhpcy5pZF07XG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICByYW5nZTogdGhpcy5yYW5nZSxcbiAgICAgICAgaW50ZXJ2YWw6IHRoaXMuaW50ZXJ2YWwsXG4gICAgICAgIHRmOiBsYXlvdXQudGlfbWFwLnRmLFxuICAgICAgICBjdXJzb3I6IHRoaXMuY3Vyc29yLFxuICAgICAgICBjb2xvcnM6IHRoaXMuJHAuY29sb3JzLFxuICAgICAgICBzdWI6IHRoaXMuZGF0YSxcbiAgICAgICAgZm9udDogdGhpcy4kcC5mb250LFxuICAgICAgICBjb25maWc6IHRoaXMuJHAuY29uZmlnLFxuICAgICAgICBtZXRhOiB0aGlzLiRwLm1ldGFcbiAgICAgIH07XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBncmlkX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcC5zaGFkZXJzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICBzLmRyYXcodGhpcy5jdHgsIHByb3BzKTtcbiAgICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9IC8vIEFjdHVhbGx5IGRyYXdzIHRoZSBncmlkIChmb3IgcmVhbClcblxuICB9LCB7XG4gICAga2V5OiBcImdyaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JpZCgpIHtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy4kcC5jb2xvcnMuZ3JpZDtcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdmFyIHltYXggPSB0aGlzLmxheW91dC5oZWlnaHQ7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gZ3JpZF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMubGF5b3V0LnhzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIHggPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIHAgPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeCAtIDAuNSwgMCk7XG4gICAgICAgICAgdGhpcy5jdHgubGluZVRvKHggLSAwLjUsIHltYXgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBncmlkX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5sYXlvdXQueXMpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgeSA9IF9zdGVwMyR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgeSQgPSBfc3RlcDMkdmFsdWVbMV07XG5cbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgeSAtIDAuNSk7XG4gICAgICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMubGF5b3V0LndpZHRoLCB5IC0gMC41KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgaWYgKHRoaXMuJHAuZ3JpZF9pZCkgdGhpcy51cHBlcl9ib3JkZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBwZXJfYm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwcGVyX2JvcmRlcigpIHtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy4kcC5jb2xvcnMuc2NhbGU7XG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCAwLjUpO1xuICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMubGF5b3V0LndpZHRoLCAwLjUpO1xuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZXpvb20oZGVsdGEsIGV2ZW50KSB7XG4gICAgICAvLyBUT0RPOiBmb3IgbW9iaWxlXG4gICAgICBpZiAodGhpcy53bW9kZSAhPT0gJ3Bhc3MnKSB7XG4gICAgICAgIGlmICh0aGlzLndtb2RlID09PSAnY2xpY2snICYmICF0aGlzLiRwLm1ldGEuYWN0aXZhdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5kZWx0YVggPSBldmVudC5kZWx0YVggfHwgdXRpbHMuZ2V0X2RlbHRhWChldmVudCk7XG4gICAgICBldmVudC5kZWx0YVkgPSBldmVudC5kZWx0YVkgfHwgdXRpbHMuZ2V0X2RlbHRhWShldmVudCk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhldmVudC5kZWx0YVgpID4gMCkge1xuICAgICAgICB0aGlzLnRyYWNrcGFkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZXZlbnQuZGVsdGFYKSA+PSBNYXRoLmFicyhldmVudC5kZWx0YVkpKSB7XG4gICAgICAgICAgZGVsdGEgKj0gMC4xO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFja3BhZF9zY3JvbGwoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50cmFja3BhZCkgZGVsdGEgKj0gMC4wMzI7XG4gICAgICBkZWx0YSA9IHV0aWxzLnNtYXJ0X3doZWVsKGRlbHRhKTsgLy8gVE9ETzogbW91c2Ugem9vbWluZyBpcyBhIGxpdHRsZSBqZXJreSxcbiAgICAgIC8vIG5lZWRzIHRvIGZvbGxvdyBmKG1vdXNlX3doZWVsX3NwZWVkKSBhbmRcbiAgICAgIC8vIGlmIHNwZWVkIGlzIGxvdywgc2Nyb2xsIHNob3VkIGJlIHNsb3dlclxuXG4gICAgICBpZiAoZGVsdGEgPCAwICYmIHRoaXMuZGF0YS5sZW5ndGggPD0gdGhpcy5NSU5fWk9PTSkgcmV0dXJuO1xuICAgICAgaWYgKGRlbHRhID4gMCAmJiB0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5NQVhfWk9PTSkgcmV0dXJuO1xuICAgICAgdmFyIGsgPSB0aGlzLmludGVydmFsIC8gMTAwMDtcbiAgICAgIHZhciBkaWZmID0gZGVsdGEgKiBrICogdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgIHZhciB0bCA9IHRoaXMuY29tcC5jb25maWcuWk9PTV9NT0RFID09PSAndGwnO1xuXG4gICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5jdHJsS2V5IHx8IHRsKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBldmVudC5vcmlnaW5hbEV2ZW50Lm9mZnNldFg7XG4gICAgICAgIHZhciBkaWZmMSA9IG9mZnNldCAvICh0aGlzLmNhbnZhcy53aWR0aCAtIDEpICogZGlmZjtcbiAgICAgICAgdmFyIGRpZmYyID0gZGlmZiAtIGRpZmYxO1xuICAgICAgICB0aGlzLnJhbmdlWzBdIC09IGRpZmYxO1xuICAgICAgICB0aGlzLnJhbmdlWzFdICs9IGRpZmYyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYW5nZVswXSAtPSBkaWZmO1xuICAgICAgfVxuXG4gICAgICBpZiAodGwpIHtcbiAgICAgICAgdmFyIF9vZmZzZXQgPSBldmVudC5vcmlnaW5hbEV2ZW50Lm9mZnNldFk7XG5cbiAgICAgICAgdmFyIF9kaWZmID0gX29mZnNldCAvICh0aGlzLmNhbnZhcy5oZWlnaHQgLSAxKSAqIDI7XG5cbiAgICAgICAgdmFyIF9kaWZmMiA9IDIgLSBfZGlmZjtcblxuICAgICAgICB2YXIgeiA9IGRpZmYgLyAodGhpcy5yYW5nZVsxXSAtIHRoaXMucmFuZ2VbMF0pOyAvL3Jlem9vbV9yYW5nZSh6LCBkaWZmX3gsIGRpZmZfeSlcblxuICAgICAgICB0aGlzLmNvbXAuJGVtaXQoJ3Jlem9vbS1yYW5nZScsIHtcbiAgICAgICAgICBncmlkX2lkOiB0aGlzLmlkLFxuICAgICAgICAgIHo6IHosXG4gICAgICAgICAgZGlmZjE6IF9kaWZmLFxuICAgICAgICAgIGRpZmYyOiBfZGlmZjJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hhbmdlX3JhbmdlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlZHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZWRyYWcoeCwgeSkge1xuICAgICAgdmFyIGR0ID0gdGhpcy5kcnVnLnQgKiAodGhpcy5kcnVnLnggLSB4KSAvIHRoaXMubGF5b3V0LndpZHRoO1xuICAgICAgdmFyIGQkID0gdGhpcy5sYXlvdXQuJF9oaSAtIHRoaXMubGF5b3V0LiRfbG87XG4gICAgICBkJCAqPSAodGhpcy5kcnVnLnkgLSB5KSAvIHRoaXMubGF5b3V0LmhlaWdodDtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmRydWcubyArIGQkO1xuICAgICAgdmFyIGxzID0gdGhpcy5sYXlvdXQuZ3JpZC5sb2dTY2FsZTtcblxuICAgICAgaWYgKGxzICYmIHRoaXMuZHJ1Zy55X3IpIHtcbiAgICAgICAgdmFyIGR5ID0gdGhpcy5kcnVnLnkgLSB5O1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmRydWcueV9yLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlWzBdID0gbWF0aC5leHAoKDAgLSB0aGlzLmRydWcuQiArIGR5KSAvIHRoaXMubGF5b3V0LkEpO1xuICAgICAgICByYW5nZVsxXSA9IG1hdGguZXhwKCh0aGlzLmxheW91dC5oZWlnaHQgLSB0aGlzLmRydWcuQiArIGR5KSAvIHRoaXMubGF5b3V0LkEpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kcnVnLnlfciAmJiB0aGlzLiRwLnlfdHJhbnNmb3JtICYmICF0aGlzLiRwLnlfdHJhbnNmb3JtLmF1dG8pIHtcbiAgICAgICAgdGhpcy5jb21wLiRlbWl0KCdzaWRlYmFyLXRyYW5zZm9ybScsIHtcbiAgICAgICAgICBncmlkX2lkOiB0aGlzLmlkLFxuICAgICAgICAgIHJhbmdlOiBscyA/IHJhbmdlIHx8IHRoaXMuZHJ1Zy55X3IgOiBbdGhpcy5kcnVnLnlfclswXSAtIG9mZnNldCwgdGhpcy5kcnVnLnlfclsxXSAtIG9mZnNldF1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmFuZ2VbMF0gPSB0aGlzLmRydWcuclswXSArIGR0O1xuICAgICAgdGhpcy5yYW5nZVsxXSA9IHRoaXMuZHJ1Zy5yWzFdICsgZHQ7XG4gICAgICB0aGlzLmNoYW5nZV9yYW5nZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwaW5jaHpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGluY2h6b29tKHNjYWxlKSB7XG4gICAgICBpZiAoc2NhbGUgPiAxICYmIHRoaXMuZGF0YS5sZW5ndGggPD0gdGhpcy5NSU5fWk9PTSkgcmV0dXJuO1xuICAgICAgaWYgKHNjYWxlIDwgMSAmJiB0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5NQVhfWk9PTSkgcmV0dXJuO1xuICAgICAgdmFyIHQgPSB0aGlzLnBpbmNoLnQ7XG4gICAgICB2YXIgbnQgPSB0ICogMSAvIHNjYWxlO1xuICAgICAgdGhpcy5yYW5nZVswXSA9IHRoaXMucGluY2guclswXSAtIChudCAtIHQpICogMC41O1xuICAgICAgdGhpcy5yYW5nZVsxXSA9IHRoaXMucGluY2guclsxXSArIChudCAtIHQpICogMC41O1xuICAgICAgdGhpcy5jaGFuZ2VfcmFuZ2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhY2twYWRfc2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWNrcGFkX3Njcm9sbChldmVudCkge1xuICAgICAgdmFyIGR0ID0gdGhpcy5yYW5nZVsxXSAtIHRoaXMucmFuZ2VbMF07XG4gICAgICB0aGlzLnJhbmdlWzBdICs9IGV2ZW50LmRlbHRhWCAqIGR0ICogMC4wMTE7XG4gICAgICB0aGlzLnJhbmdlWzFdICs9IGV2ZW50LmRlbHRhWCAqIGR0ICogMC4wMTE7XG4gICAgICB0aGlzLmNoYW5nZV9yYW5nZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGFuZ2VfcmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlX3JhbmdlKCkge1xuICAgICAgLy8gVE9ETzogYmV0dGVyIHdheSB0byBsaW1pdCB0aGUgdmlldy4gUHJvYmxlbTpcbiAgICAgIC8vIHdoZW4geW91IGFyZSBhdCB0aGUgZGVhZCBlbmQgb2YgdGhlIGRhdGEsXG4gICAgICAvLyBhbmQga2VlcCBzY3JvbGxpbmcsXG4gICAgICAvLyB0aGUgY2hhcnQgY29udGludWVzIHRvIHNjYWxlIGRvd24gYSBsaXR0bGUuXG4gICAgICAvLyBTb2x1dGlvbjogSSBkb24ndCBrbm93IHlldFxuICAgICAgaWYgKCF0aGlzLnJhbmdlLmxlbmd0aCB8fCB0aGlzLmRhdGEubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgICAgdmFyIGwgPSB0aGlzLmRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgIHJhbmdlWzBdID0gdXRpbHMuY2xhbXAocmFuZ2VbMF0sIC1JbmZpbml0eSwgZGF0YVtsXVswXSAtIHRoaXMuaW50ZXJ2YWwgKiA1LjUpO1xuICAgICAgcmFuZ2VbMV0gPSB1dGlscy5jbGFtcChyYW5nZVsxXSwgZGF0YVswXVswXSArIHRoaXMuaW50ZXJ2YWwgKiA1LjUsIEluZmluaXR5KTsgLy8gVE9ETzogSU1QT1JUQU5UIHNjcm9sbGluZyBpcyBqZXJreSBUaGUgUHJvYmxlbSBjYXVzZWRcbiAgICAgIC8vIGJ5IHRoZSBsb25nIHJvdW5kIHRyaXAgb2YgJ3JhbmdlLWNoYW5nZWQnIGV2ZW50LlxuICAgICAgLy8gRmlyc3QgaXQgcHJvcGFnYXRlcyB1cCB0byB1cGRhdGUgbGF5b3V0IGluIENoYXJ0LnZ1ZSxcbiAgICAgIC8vIHRoZW4gaXQgbW92ZXMgYmFjayBhcyB3YXRjaCgpIHVwZGF0ZS4gSXQgdGFrZXMgMS01IG1zLlxuICAgICAgLy8gQW5kIGJlY2F1c2UgdGhlIGRlbGF5IGlzIGRpZmZlcmVudCBlYWNoIHRpbWUgd2Ugc2VlXG4gICAgICAvLyB0aGUgbGFnLiBObyBzbW9vdGggbW92ZW1lbnQgYW5kIGl0J3MgYW5ub3lpbmcuXG4gICAgICAvLyBTb2x1dGlvbjogd2UgY291bGQgdHJ5IHRvIGNhbGMgdGhlIGxheW91dCBpbW1lZGlhdGx5XG4gICAgICAvLyBzb21ld2hlcmUgaGVyZS4gU3RpbGwgd2lsbCBodXJ0IHRoZSBzaWRlYmFyICYgYm90dG9tYmFyXG5cbiAgICAgIHRoaXMuY29tcC4kZW1pdCgncmFuZ2UtY2hhbmdlZCcsIHJhbmdlKTtcbiAgICB9IC8vIFByb3BhZ2F0ZSBtb3VzZSBldmVudCB0byBvdmVybGF5c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvcGFnYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3BhZ2F0ZShuYW1lLCBldmVudCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjQgPSBncmlkX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5vdmVybGF5cyksXG4gICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBsYXllciA9IF9zdGVwNC52YWx1ZTtcblxuICAgICAgICAgIGlmIChsYXllci5yZW5kZXJlcltuYW1lXSkge1xuICAgICAgICAgICAgbGF5ZXIucmVuZGVyZXJbbmFtZV0oZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtb3VzZSA9IGxheWVyLnJlbmRlcmVyLm1vdXNlO1xuICAgICAgICAgIHZhciBrZXlzID0gbGF5ZXIucmVuZGVyZXIua2V5cztcblxuICAgICAgICAgIGlmIChtb3VzZS5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIG1vdXNlLmVtaXQobmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBrZXlzLmVtaXQobmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBybSA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgICBybShcImdlc3R1cmVzdGFydFwiLCB0aGlzLmdlc3R1cmVzdGFydCk7XG4gICAgICBybShcImdlc3R1cmVjaGFuZ2VcIiwgdGhpcy5nZXN0dXJlY2hhbmdlKTtcbiAgICAgIHJtKFwiZ2VzdHVyZWVuZFwiLCB0aGlzLmdlc3R1cmVlbmQpO1xuICAgICAgaWYgKHRoaXMubWMpIHRoaXMubWMuZGVzdHJveSgpO1xuICAgICAgaWYgKHRoaXMuaG0pIHRoaXMuaG0udW53aGVlbCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHcmlkO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvY2FudmFzLmpzXG4vLyBJbnRlcmFjdGl2ZSBjYW52YXMtYmFzZWQgY29tcG9uZW50XG4vLyBTaG91bGQgaW1wbGVtZW50OiBtb3VzZW1vdmUsIG1vdXNlb3V0LCBtb3VzZXVwLCBtb3VzZWRvd24sIGNsaWNrXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY2FudmFzID0gKHtcbiAgbWV0aG9kczoge1xuICAgIHNldHVwOiBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBpZCA9IFwiXCIuY29uY2F0KHRoaXMuJHByb3BzLnR2X2lkLCBcIi1cIikuY29uY2F0KHRoaXMuX2lkLCBcIi1jYW52YXNcIik7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgdmFyIGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdCh0aGlzLl9hdHRycy53aWR0aCwgXCJweFwiKTtcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdCh0aGlzLl9hdHRycy5oZWlnaHQsIFwicHhcIik7XG4gICAgICBpZiAoZHByIDwgMSkgZHByID0gMTsgLy8gUmVhbHkgPyBUaGF0J3MgaXQ/IElzc3VlICM2M1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjYW52YXMud2lkdGggPSByZWN0LndpZHRoICogZHByO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiBkcHI7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7Ly8gVE9ETzogdGVzdCB0aGUgYm9vc3Q6XG4gICAgICAgICAgLy9hbHBoYTogZmFsc2UsXG4gICAgICAgICAgLy9kZXN5bmNocm9uaXplZDogdHJ1ZSxcbiAgICAgICAgICAvL3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG5cbiAgICAgICAgX3RoaXMucmVkcmF3KCk7IC8vIEZhbGxiYWNrIGZpeCBmb3IgQnJhdmUgYnJvd3NlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnJhdmUvYnJhdmUtYnJvd3Nlci9pc3N1ZXMvMTczOFxuXG5cbiAgICAgICAgaWYgKCFjdHgubWVhc3VyZVRleHRPcmcpIHtcbiAgICAgICAgICBjdHgubWVhc3VyZVRleHRPcmcgPSBjdHgubWVhc3VyZVRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgIHJldHVybiB1dGlscy5tZWFzdXJlVGV4dChjdHgsIHRleHQsIF90aGlzLiRwcm9wcy50dl9pZCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNyZWF0ZV9jYW52YXM6IGZ1bmN0aW9uIGNyZWF0ZV9jYW52YXMoaCwgaWQsIHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgIHRoaXMuX2F0dHJzID0gcHJvcHMuYXR0cnM7XG4gICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICBcImNsYXNzXCI6IFwidHJhZGluZy12dWUtXCIuY29uY2F0KGlkKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBsZWZ0OiBwcm9wcy5wb3NpdGlvbi54ICsgJ3B4JyxcbiAgICAgICAgICB0b3A6IHByb3BzLnBvc2l0aW9uLnkgKyAncHgnLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICAgIH1cbiAgICAgIH0sIFtoKCdjYW52YXMnLCB7XG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiBtb3VzZW1vdmUoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXJlci5tb3VzZW1vdmUoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24gbW91c2VvdXQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXJlci5tb3VzZW91dChlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vdXNldXA6IGZ1bmN0aW9uIG1vdXNldXAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXJlci5tb3VzZXVwKGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiBtb3VzZWRvd24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXJlci5tb3VzZWRvd24oZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhdHRyczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgaWQ6IFwiXCIuY29uY2F0KHRoaXMuJHByb3BzLnR2X2lkLCBcIi1cIikuY29uY2F0KGlkLCBcIi1jYW52YXNcIilcbiAgICAgICAgfSwgcHJvcHMuYXR0cnMpLFxuICAgICAgICByZWY6ICdjYW52YXMnLFxuICAgICAgICBzdHlsZTogcHJvcHMuc3R5bGVcbiAgICAgIH0pXS5jb25jYXQocHJvcHMuaHMgfHwgW10pKTtcbiAgICB9LFxuICAgIHJlZHJhdzogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyKSByZXR1cm47XG4gICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgodmFsKSB7XG4gICAgICB0aGlzLl9hdHRycy53aWR0aCA9IHZhbDtcbiAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICB9LFxuICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KHZhbCkge1xuICAgICAgdGhpcy5fYXR0cnMuaGVpZ2h0ID0gdmFsO1xuICAgICAgdGhpcy5zZXR1cCgpO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL3V4bGlzdC5qc1xuLy8gTWFuYWdlciBmb3IgSW50ZWVyZmFjZSBvYmplY3RzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHV4bGlzdCA9ICh7XG4gIG1ldGhvZHM6IHtcbiAgICBvbl91eF9ldmVudDogZnVuY3Rpb24gb25fdXhfZXZlbnQoZCwgdGFyZ2V0KSB7XG4gICAgICBpZiAoZC5ldmVudCA9PT0gJ25ldy1pbnRlcmZhY2UnKSB7XG4gICAgICAgIGlmIChkLmFyZ3NbMF0udGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAgICAgICBkLmFyZ3NbMF0udmFycyA9IGQuYXJnc1swXS52YXJzIHx8IHt9O1xuICAgICAgICAgIGQuYXJnc1swXS5ncmlkX2lkID0gZC5hcmdzWzFdO1xuICAgICAgICAgIGQuYXJnc1swXS5vdmVybGF5X2lkID0gZC5hcmdzWzJdO1xuICAgICAgICAgIHRoaXMudXhzLnB1c2goZC5hcmdzWzBdKTsgLy8gdGhpcy5yZXJlbmRlcisrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZC5ldmVudCA9PT0gJ2Nsb3NlLWludGVyZmFjZScpIHtcbiAgICAgICAgdGhpcy51eHMgPSB0aGlzLnV4cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC51dWlkICE9PSBkLmFyZ3NbMF07XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChkLmV2ZW50ID09PSAnbW9kaWZ5LWludGVyZmFjZScpIHtcbiAgICAgICAgdmFyIHV4ID0gdGhpcy51eHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHgudXVpZCA9PT0gZC5hcmdzWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXgubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5tb2RpZnkodXhbMF0sIGQuYXJnc1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZC5ldmVudCA9PT0gJ2hpZGUtaW50ZXJmYWNlJykge1xuICAgICAgICB2YXIgX3V4ID0gdGhpcy51eHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHgudXVpZCA9PT0gZC5hcmdzWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoX3V4Lmxlbmd0aCkge1xuICAgICAgICAgIF91eFswXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMubW9kaWZ5KF91eFswXSwge1xuICAgICAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZC5ldmVudCA9PT0gJ3Nob3ctaW50ZXJmYWNlJykge1xuICAgICAgICB2YXIgX3V4MiA9IHRoaXMudXhzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LnV1aWQgPT09IGQuYXJnc1swXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKF91eDIubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5tb2RpZnkoX3V4MlswXSwge1xuICAgICAgICAgICAgaGlkZGVuOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vZGlmeTogZnVuY3Rpb24gbW9kaWZ5KHV4LCBvYmopIHtcbiAgICAgIGlmIChvYmogPT09IHZvaWQgMCkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGsgaW4gdXgpIHtcbiAgICAgICAgICB0aGlzLiRzZXQodXgsIGssIG9ialtrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFJlbW92ZSBhbGwgVVhzIGZvciBhIGdpdmVuIG92ZXJsYXkgaWRcbiAgICByZW1vdmVfYWxsX3V4OiBmdW5jdGlvbiByZW1vdmVfYWxsX3V4KGlkKSB7XG4gICAgICB0aGlzLnV4cyA9IHRoaXMudXhzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5vdmVybGF5LmlkICE9PSBpZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXhzOiBbXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvY3Jvc3NoYWlyLmpzXG5cblxuXG52YXIgQ3Jvc3NoYWlyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3Jvc3NoYWlyKGNvbXApIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBDcm9zc2hhaXIpO1xuXG4gICAgdGhpcy5jb21wID0gY29tcDtcbiAgICB0aGlzLiRwID0gY29tcC4kcHJvcHM7XG4gICAgdGhpcy5kYXRhID0gdGhpcy4kcC5zdWI7XG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5sYXlvdXQgPSB0aGlzLiRwLmxheW91dDtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKENyb3NzaGFpciwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgLy8gVXBkYXRlIHJlZmVyZW5jZSB0byB0aGUgZ3JpZFxuICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLiRwLmxheW91dDtcbiAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmNvbXAuJHByb3BzLmN1cnNvcjtcbiAgICAgIGlmICghdGhpcy52aXNpYmxlICYmIGN1cnNvci5tb2RlID09PSAnZXhwbG9yZScpIHJldHVybjtcbiAgICAgIHRoaXMueCA9IHRoaXMuJHAuY3Vyc29yLng7XG4gICAgICB0aGlzLnkgPSB0aGlzLiRwLmN1cnNvci55O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuJHAuY29sb3JzLmNyb3NzO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFs1XSk7IC8vIEhcblxuICAgICAgaWYgKHRoaXMuJHAuY3Vyc29yLmdyaWRfaWQgPT09IHRoaXMubGF5b3V0LmlkKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgdGhpcy55KTtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmxheW91dC53aWR0aCAtIDAuNSwgdGhpcy55KTtcbiAgICAgIH0gLy8gVlxuXG5cbiAgICAgIGN0eC5tb3ZlVG8odGhpcy54LCAwKTtcbiAgICAgIGN0eC5saW5lVG8odGhpcy54LCB0aGlzLmxheW91dC5oZWlnaHQpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpc2libGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICB0aGlzLl92aXNpYmxlID0gdmFsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDcm9zc2hhaXI7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0Nyb3NzaGFpci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDcm9zc2hhaXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ3Jvc3NoYWlyJyxcbiAgcHJvcHM6IFsnY3Vyc29yJywgJ2NvbG9ycycsICdsYXlvdXQnLCAnc3ViJ10sXG4gIG1ldGhvZHM6IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuY2ggPSBuZXcgQ3Jvc3NoYWlyKHRoaXMpOyAvLyBOZXcgZ3JpZCBvdmVybGF5LXJlbmRlcmVyIGRlc2NyaXB0b3IuXG4gICAgICAvLyBTaG91bGQgaW1wbGVtZW50IGRyYXcoKSAoc2VlIFNwbGluZS52dWUpXG5cbiAgICAgIHRoaXMuJGVtaXQoJ25ldy1ncmlkLWxheWVyJywge1xuICAgICAgICBuYW1lOiAnY3Jvc3NoYWlyJyxcbiAgICAgICAgcmVuZGVyZXI6IHRoaXMuY2hcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBjdXJzb3I6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5jaCkgdGhpcy5jcmVhdGUoKTsgLy8gRXhwbG9yZSA9IGRlZmF1bHQgbW9kZSBvbiBtb2JpbGVcblxuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy4kcHJvcHMuY3Vyc29yO1xuICAgICAgICB2YXIgZXhwbG9yZSA9IGN1cnNvci5tb2RlID09PSAnZXhwbG9yZSc7XG5cbiAgICAgICAgaWYgKCFjdXJzb3IueCB8fCAhY3Vyc29yLnkpIHtcbiAgICAgICAgICB0aGlzLmNoLmhpZGUoKTtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdyZWRyYXctZ3JpZCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2gudmlzaWJsZSA9ICFleHBsb3JlO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICByZXR1cm4gaCgpO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0Nyb3NzaGFpci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0Nyb3NzaGFpcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDcm9zc2hhaXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcbi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0Nyb3NzaGFpci52dWVcbnZhciBDcm9zc2hhaXJfcmVuZGVyLCBDcm9zc2hhaXJfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0Nyb3NzaGFpcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQ3Jvc3NoYWlyX3JlbmRlcixcbiAgQ3Jvc3NoYWlyX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgYXBpOyB9XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0Nyb3NzaGFpci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0Nyb3NzaGFpciA9IChjb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvS2V5Ym9hcmRMaXN0ZW5lci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLZXlib2FyZExpc3RlbmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0tleWJvYXJkTGlzdGVuZXInLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoKTtcbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLiRlbWl0KCdyZWdpc3Rlci1rYi1saXN0ZW5lcicsIHtcbiAgICAgIGlkOiB0aGlzLl91aWQsXG4gICAgICBrZXlkb3duOiB0aGlzLmtleWRvd24sXG4gICAgICBrZXl1cDogdGhpcy5rZXl1cCxcbiAgICAgIGtleXByZXNzOiB0aGlzLmtleXByZXNzXG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy4kZW1pdCgncmVtb3ZlLWtiLWxpc3RlbmVyJywge1xuICAgICAgaWQ6IHRoaXMuX3VpZFxuICAgIH0pO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAga2V5ZG93bjogZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgna2V5ZG93bicsIGV2ZW50KTtcbiAgICB9LFxuICAgIGtleXVwOiBmdW5jdGlvbiBrZXl1cChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgna2V5dXAnLCBldmVudCk7XG4gICAgfSxcbiAgICBrZXlwcmVzczogZnVuY3Rpb24ga2V5cHJlc3MoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2tleXByZXNzJywgZXZlbnQpO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9LZXlib2FyZExpc3RlbmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfS2V5Ym9hcmRMaXN0ZW5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChLZXlib2FyZExpc3RlbmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9LZXlib2FyZExpc3RlbmVyLnZ1ZVxudmFyIEtleWJvYXJkTGlzdGVuZXJfcmVuZGVyLCBLZXlib2FyZExpc3RlbmVyX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEtleWJvYXJkTGlzdGVuZXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0tleWJvYXJkTGlzdGVuZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEtleWJvYXJkTGlzdGVuZXJfcmVuZGVyLFxuICBLZXlib2FyZExpc3RlbmVyX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgS2V5Ym9hcmRMaXN0ZW5lcl9hcGk7IH1cbktleWJvYXJkTGlzdGVuZXJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9LZXlib2FyZExpc3RlbmVyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtleWJvYXJkTGlzdGVuZXIgPSAoS2V5Ym9hcmRMaXN0ZW5lcl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9VeExheWVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zOTBjY2Y2ZSZcbnZhciBVeExheWVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzkwY2NmNmVfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwic3BhblwiLFxuICAgIHsgY2xhc3M6IFwidHJhZGluZy12dWUtZ3JpZC11eC1cIiArIF92bS5pZCwgc3R5bGU6IF92bS5zdHlsZSB9LFxuICAgIF92bS5fbChfdm0udXhzLCBmdW5jdGlvbih1eCkge1xuICAgICAgcmV0dXJuIF9jKFwidXgtd3JhcHBlclwiLCB7XG4gICAgICAgIGtleTogdXgudXVpZCxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB1eDogdXgsXG4gICAgICAgICAgdXBkYXRlcjogX3ZtLnVwZGF0ZXIsXG4gICAgICAgICAgY29sb3JzOiBfdm0uY29sb3JzLFxuICAgICAgICAgIGNvbmZpZzogX3ZtLmNvbmZpZ1xuICAgICAgICB9LFxuICAgICAgICBvbjogeyBcImN1c3RvbS1ldmVudFwiOiBfdm0ub25fY3VzdG9tX2V2ZW50IH1cbiAgICAgIH0pXG4gICAgfSksXG4gICAgMVxuICApXG59XG52YXIgVXhMYXllcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5MGNjZjZlX3N0YXRpY1JlbmRlckZucyA9IFtdXG5VeExheWVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzkwY2NmNmVfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVXhMYXllci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzkwY2NmNmUmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1V4V3JhcHBlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NGJjMzIwNzAmXG52YXIgVXhXcmFwcGVydnVlX3R5cGVfdGVtcGxhdGVfaWRfNGJjMzIwNzBfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS52aXNpYmxlXG4gICAgPyBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLXV4LXdyYXBwZXJcIixcbiAgICAgICAgICBzdHlsZTogX3ZtLnN0eWxlLFxuICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInR2anMtdXgtd3JhcHBlci1cIiArIF92bS51eC51dWlkIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKF92bS51eC5jb21wb25lbnQsIHtcbiAgICAgICAgICAgIHRhZzogXCJjb21wb25lbnRcIixcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHV4OiBfdm0udXgsXG4gICAgICAgICAgICAgIHVwZGF0ZXI6IF92bS51cGRhdGVyLFxuICAgICAgICAgICAgICB3cmFwcGVyOiBfdm0ud3JhcHBlcixcbiAgICAgICAgICAgICAgY29sb3JzOiBfdm0uY29sb3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHsgXCJjdXN0b20tZXZlbnRcIjogX3ZtLm9uX2N1c3RvbV9ldmVudCB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfdm0udXguc2hvd19waW5cbiAgICAgICAgICAgID8gX2MoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMtdXgtd3JhcHBlci1waW5cIixcbiAgICAgICAgICAgICAgICBzdHlsZTogX3ZtLnBpbl9zdHlsZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF92bS51eC53aW5faGVhZGVyICE9PSBmYWxzZVxuICAgICAgICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInR2anMtdXgtd3JhcHBlci1oZWFkXCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidHZqcy11eC13cmFwcGVyLWNsb3NlXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBfdm0uYnRuX3N0eWxlLFxuICAgICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLmNsb3NlIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbX3ZtLl92KFwiw5dcIildXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICBdLFxuICAgICAgICAxXG4gICAgICApXG4gICAgOiBfdm0uX2UoKVxufVxudmFyIFV4V3JhcHBlcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRiYzMyMDcwX3N0YXRpY1JlbmRlckZucyA9IFtdXG5VeFdyYXBwZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF80YmMzMjA3MF9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9VeFdyYXBwZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTRiYzMyMDcwJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVXhXcmFwcGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFV4V3JhcHBlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdVeFdyYXBwZXInLFxuICBwcm9wczogWyd1eCcsICd1cGRhdGVyJywgJ2NvbG9ycycsICdjb25maWcnXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLnNlbGYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnV1aWQpO1xuICAgIHRoaXMudyA9IHRoaXMuc2VsZi5vZmZzZXRXaWR0aDsgLy8gVE9ETzogPT4gd2lkdGg6IFwiY29udGVudFwiXG5cbiAgICB0aGlzLmggPSB0aGlzLnNlbGYub2Zmc2V0SGVpZ2h0OyAvLyBUT0RPOiA9PiBoZWlnaHQ6IFwiY29udGVudFwiXG5cbiAgICB0aGlzLnVwZGF0ZV9wb3NpdGlvbigpO1xuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMubW91c2Uub24oJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZW91dCcsIHRoaXMubW91c2VvdXQpO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMubW91c2Uub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgdGhpcy5tb3VzZS5vZmYoJ21vdXNlb3V0JywgdGhpcy5tb3VzZW91dCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB1cGRhdGVfcG9zaXRpb246IGZ1bmN0aW9uIHVwZGF0ZV9wb3NpdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnV4ci5oaWRkZW4pIHJldHVybjtcbiAgICAgIHZhciBsdyA9IHRoaXMubGF5b3V0LndpZHRoO1xuICAgICAgdmFyIGxoID0gdGhpcy5sYXlvdXQuaGVpZ2h0O1xuICAgICAgdmFyIHBpbiA9IHRoaXMudXhyLnBpbjtcblxuICAgICAgc3dpdGNoIChwaW5bMF0pIHtcbiAgICAgICAgY2FzZSAnY3Vyc29yJzpcbiAgICAgICAgICB2YXIgeCA9IHRoaXMudXhyLm92ZXJsYXkuY3Vyc29yLng7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW91c2UnOlxuICAgICAgICAgIHggPSB0aGlzLm1vdXNlLng7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodHlwZW9mIHBpblswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLnBhcnNlX2Nvb3JkKHBpblswXSwgbHcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5sYXlvdXQudDJzY3JlZW4ocGluWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwaW5bMV0pIHtcbiAgICAgICAgY2FzZSAnY3Vyc29yJzpcbiAgICAgICAgICB2YXIgeSA9IHRoaXMudXhyLm92ZXJsYXkuY3Vyc29yLnk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW91c2UnOlxuICAgICAgICAgIHkgPSB0aGlzLm1vdXNlLnk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodHlwZW9mIHBpblsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLnBhcnNlX2Nvb3JkKHBpblsxXSwgbGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5sYXlvdXQuJDJzY3JlZW4ocGluWzFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy54ID0geCArIHRoaXMub3g7XG4gICAgICB0aGlzLnkgPSB5ICsgdGhpcy5veTtcbiAgICB9LFxuICAgIHBhcnNlX2Nvb3JkOiBmdW5jdGlvbiBwYXJzZV9jb29yZChzdHIsIHNjYWxlKSB7XG4gICAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgICAgaWYgKHN0ciA9PT0gJzAnIHx8IHN0ciA9PT0gJycpIHJldHVybiAwO1xuICAgICAgdmFyIHBsdXMgPSBzdHIuc3BsaXQoJysnKTtcblxuICAgICAgaWYgKHBsdXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Nvb3JkKHBsdXNbMF0sIHNjYWxlKSArIHRoaXMucGFyc2VfY29vcmQocGx1c1sxXSwgc2NhbGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWludXMgPSBzdHIuc3BsaXQoJy0nKTtcblxuICAgICAgaWYgKG1pbnVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9jb29yZChtaW51c1swXSwgc2NhbGUpIC0gdGhpcy5wYXJzZV9jb29yZChtaW51c1sxXSwgc2NhbGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGVyID0gc3RyLnNwbGl0KCclJyk7XG5cbiAgICAgIGlmIChwZXIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBzY2FsZSAqIHBhcnNlSW50KHBlclswXSkgLyAxMDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBweCA9IHN0ci5zcGxpdCgncHgnKTtcblxuICAgICAgaWYgKHB4Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocHhbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiBtb3VzZW1vdmUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZV9wb3NpdGlvbigpO1xuICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB9LFxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbiBtb3VzZW91dCgpIHtcbiAgICAgIGlmICh0aGlzLnV4ci5waW4uaW5jbHVkZXMoJ2N1cnNvcicpIHx8IHRoaXMudXhyLnBpbi5pbmNsdWRlcygnbW91c2UnKSkgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgfSxcbiAgICBvbl9jdXN0b21fZXZlbnQ6IGZ1bmN0aW9uIG9uX2N1c3RvbV9ldmVudChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50JywgZXZlbnQpO1xuXG4gICAgICBpZiAoZXZlbnQuZXZlbnQgPT09ICdtb2RpZnktaW50ZXJmYWNlJykge1xuICAgICAgICBpZiAodGhpcy5zZWxmKSB7XG4gICAgICAgICAgdGhpcy53ID0gdGhpcy5zZWxmLm9mZnNldFdpZHRoO1xuICAgICAgICAgIHRoaXMuaCA9IHRoaXMuc2VsZi5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZV9wb3NpdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogJ2Nsb3NlLWludGVyZmFjZScsXG4gICAgICAgIGFyZ3M6IFt0aGlzLiRwcm9wcy51eC51dWlkXVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHV4cjogZnVuY3Rpb24gdXhyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnV4OyAvLyBqdXN0IGEgcmVmXG4gICAgfSxcbiAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy51eC5vdmVybGF5LmxheW91dDtcbiAgICB9LFxuICAgIHNldHRpbmdzOiBmdW5jdGlvbiBzZXR0aW5ncygpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy51eC5vdmVybGF5LnNldHRpbmdzO1xuICAgIH0sXG4gICAgdXVpZDogZnVuY3Rpb24gdXVpZCgpIHtcbiAgICAgIHJldHVybiBcInR2anMtdXgtd3JhcHBlci1cIi5jb25jYXQodGhpcy51eHIudXVpZCk7XG4gICAgfSxcbiAgICBtb3VzZTogZnVuY3Rpb24gbW91c2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy51eHIub3ZlcmxheS5tb3VzZTtcbiAgICB9LFxuICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZSgpIHtcbiAgICAgIHZhciBzdCA9IHtcbiAgICAgICAgJ2Rpc3BsYXknOiB0aGlzLnV4ci5oaWRkZW4gPyAnbm9uZScgOiB1bmRlZmluZWQsXG4gICAgICAgICdsZWZ0JzogXCJcIi5jb25jYXQodGhpcy54LCBcInB4XCIpLFxuICAgICAgICAndG9wJzogXCJcIi5jb25jYXQodGhpcy55LCBcInB4XCIpLFxuICAgICAgICAncG9pbnRlci1ldmVudHMnOiB0aGlzLnV4ci5wb2ludGVyX2V2ZW50cyB8fCAnYWxsJyxcbiAgICAgICAgJ3otaW5kZXgnOiB0aGlzLnpfaW5kZXhcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy51eHIud2luX3N0eWxpbmcgIT09IGZhbHNlKSBzdCA9IE9iamVjdC5hc3NpZ24oc3QsIHtcbiAgICAgICAgJ2JvcmRlcic6IFwiMXB4IHNvbGlkIFwiLmNvbmNhdCh0aGlzLiRwcm9wcy5jb2xvcnMuZ3JpZCksXG4gICAgICAgICdib3JkZXItcmFkaXVzJzogJzNweCcsXG4gICAgICAgICdiYWNrZ3JvdW5kJzogXCJcIi5jb25jYXQodGhpcy5iYWNrZ3JvdW5kKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3Q7XG4gICAgfSxcbiAgICBwaW5fc3R5bGU6IGZ1bmN0aW9uIHBpbl9zdHlsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdsZWZ0JzogXCJcIi5jb25jYXQoLXRoaXMub3gsIFwicHhcIiksXG4gICAgICAgICd0b3AnOiBcIlwiLmNvbmNhdCgtdGhpcy5veSwgXCJweFwiKSxcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiB0aGlzLnV4ci5waW5fY29sb3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBidG5fc3R5bGU6IGZ1bmN0aW9uIGJ0bl9zdHlsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdiYWNrZ3JvdW5kJzogXCJcIi5jb25jYXQodGhpcy5pbmFjdGl2ZV9idG5fY29sb3IpLFxuICAgICAgICAnY29sb3InOiBcIlwiLmNvbmNhdCh0aGlzLmluYWN0aXZlX2J0bl9jb2xvcilcbiAgICAgIH07XG4gICAgfSxcbiAgICBwaW5fcG9zOiBmdW5jdGlvbiBwaW5fcG9zKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXhyLnBpbl9wb3NpdGlvbiA/IHRoaXMudXhyLnBpbl9wb3NpdGlvbi5zcGxpdCgnLCcpIDogWycwJywgJzAnXTtcbiAgICB9LFxuICAgIC8vIE9mZnNldCB4XG4gICAgb3g6IGZ1bmN0aW9uIG94KCkge1xuICAgICAgaWYgKHRoaXMucGluX3Bvcy5sZW5ndGggIT09IDIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgeCA9IHRoaXMucGFyc2VfY29vcmQodGhpcy5waW5fcG9zWzBdLCB0aGlzLncpO1xuICAgICAgcmV0dXJuIC14O1xuICAgIH0sXG4gICAgLy8gT2Zmc2V0IHlcbiAgICBveTogZnVuY3Rpb24gb3koKSB7XG4gICAgICBpZiAodGhpcy5waW5fcG9zLmxlbmd0aCAhPT0gMikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciB5ID0gdGhpcy5wYXJzZV9jb29yZCh0aGlzLnBpbl9wb3NbMV0sIHRoaXMuaCk7XG4gICAgICByZXR1cm4gLXk7XG4gICAgfSxcbiAgICB6X2luZGV4OiBmdW5jdGlvbiB6X2luZGV4KCkge1xuICAgICAgdmFyIGJhc2VfaW5kZXggPSB0aGlzLnNldHRpbmdzWyd6LWluZGV4J10gfHwgdGhpcy5zZXR0aW5nc1snekluZGV4J10gfHwgMDtcbiAgICAgIHZhciB1eF9pbmRleCA9IHRoaXMudXhyWyd6X2luZGV4J10gfHwgMDtcbiAgICAgIHJldHVybiBiYXNlX2luZGV4ICsgdXhfaW5kZXg7XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiBmdW5jdGlvbiBiYWNrZ3JvdW5kKCkge1xuICAgICAgdmFyIGMgPSB0aGlzLnV4ci5iYWNrZ3JvdW5kIHx8IHRoaXMuJHByb3BzLmNvbG9ycy5iYWNrO1xuICAgICAgcmV0dXJuIHV0aWxzLmFwcGx5X29wYWNpdHkoYywgdGhpcy51eHIuYmFja2dyb3VuZF9vcGFjaXR5IHx8IHRoaXMuJHByb3BzLmNvbmZpZy5VWF9PUEFDSVRZKTtcbiAgICB9LFxuICAgIGluYWN0aXZlX2J0bl9jb2xvcjogZnVuY3Rpb24gaW5hY3RpdmVfYnRuX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXhyLmluYWN0aXZlX2J0bl9jb2xvciB8fCB0aGlzLiRwcm9wcy5jb2xvcnMuZ3JpZDtcbiAgICB9LFxuICAgIHdyYXBwZXI6IGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgcGluX3g6IHRoaXMueCAtIHRoaXMub3gsXG4gICAgICAgIHBpbl95OiB0aGlzLnkgLSB0aGlzLm95XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB1cGRhdGVyOiBmdW5jdGlvbiB1cGRhdGVyKCkge1xuICAgICAgdGhpcy51cGRhdGVfcG9zaXRpb24oKTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgdzogMCxcbiAgICAgIGg6IDAsXG4gICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9VeFdyYXBwZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19VeFdyYXBwZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVXhXcmFwcGVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVXhXcmFwcGVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIFV4V3JhcHBlcnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjUpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVXhXcmFwcGVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9VeFdyYXBwZXIudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgVXhXcmFwcGVyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19VeFdyYXBwZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFV4V3JhcHBlcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRiYzMyMDcwX3JlbmRlcixcbiAgVXhXcmFwcGVydnVlX3R5cGVfdGVtcGxhdGVfaWRfNGJjMzIwNzBfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBVeFdyYXBwZXJfYXBpOyB9XG5VeFdyYXBwZXJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9VeFdyYXBwZXIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVXhXcmFwcGVyID0gKFV4V3JhcHBlcl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVXhMYXllci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFV4TGF5ZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVXhMYXllcicsXG4gIHByb3BzOiBbJ3R2X2lkJywgJ2lkJywgJ3V4cycsICd1cGRhdGVyJywgJ2NvbG9ycycsICdjb25maWcnXSxcbiAgY29tcG9uZW50czoge1xuICAgIFV4V3JhcHBlcjogVXhXcmFwcGVyXG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7fSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHt9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge30sXG4gIG1ldGhvZHM6IHtcbiAgICBvbl9jdXN0b21fZXZlbnQ6IGZ1bmN0aW9uIG9uX2N1c3RvbV9ldmVudChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50JywgZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAndG9wJzogdGhpcy4kcHJvcHMuaWQgIT09IDAgPyAnMXB4JyA6IDAsXG4gICAgICAgICdsZWZ0JzogMCxcbiAgICAgICAgJ3dpZHRoJzogJzEwMCUnLFxuICAgICAgICAnaGVpZ2h0JzogJ2NhbGMoMTAwJSAtIDJweCknLFxuICAgICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICAgICAgICAnei1pbmRleCc6ICcxJyxcbiAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJ1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVXhMYXllci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1V4TGF5ZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVXhMYXllcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVXhMYXllci52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgVXhMYXllcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfVXhMYXllcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVXhMYXllcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5MGNjZjZlX3JlbmRlcixcbiAgVXhMYXllcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5MGNjZjZlX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVXhMYXllcl9hcGk7IH1cblV4TGF5ZXJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9VeExheWVyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFV4TGF5ZXIgPSAoVXhMYXllcl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3R1ZmYvbW91c2UuanNcblxuXG5cbmZ1bmN0aW9uIG1vdXNlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBtb3VzZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gbW91c2VfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBtb3VzZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gbW91c2VfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIG1vdXNlX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIE1vdXNlIGV2ZW50IGhhbmRsZXIgZm9yIG92ZXJsYXlcbnZhciBNb3VzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vdXNlKGNvbXApIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBNb3VzZSk7XG5cbiAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAwO1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMueCA9IGNvbXAuJHByb3BzLmN1cnNvci54O1xuICAgIHRoaXMueSA9IGNvbXAuJHByb3BzLmN1cnNvci55O1xuICAgIHRoaXMudCA9IGNvbXAuJHByb3BzLmN1cnNvci50O1xuICAgIHRoaXMueSQgPSBjb21wLiRwcm9wcy5jdXJzb3IueSQ7XG4gIH0gLy8gWW91IGNhbiBjaG9vc2Ugd2hlcmUgdG8gcGxhY2UgdGhlIGhhbmRsZXJcbiAgLy8gKGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIHF1ZXVlKVxuXG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoTW91c2UsIFt7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKG5hbWUsIGhhbmRsZXIsIGRpcikge1xuICAgICAgaWYgKGRpciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRpciA9IFwidW5zaGlmdFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICAgIHRoaXMubWFwW25hbWVdID0gdGhpcy5tYXBbbmFtZV0gfHwgW107XG4gICAgICB0aGlzLm1hcFtuYW1lXVtkaXJdKGhhbmRsZXIpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMrKztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMubWFwW25hbWVdKSByZXR1cm47XG4gICAgICB2YXIgaSA9IHRoaXMubWFwW25hbWVdLmluZGV4T2YoaGFuZGxlcik7XG4gICAgICBpZiAoaSA8IDApIHJldHVybjtcbiAgICAgIHRoaXMubWFwW25hbWVdLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLS07XG4gICAgfSAvLyBDYWxsZWQgYnkgZ3JpZC5qc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KG5hbWUsIGV2ZW50KSB7XG4gICAgICB2YXIgbCA9IHRoaXMuY29tcC5sYXlvdXQ7XG5cbiAgICAgIGlmIChuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBtb3VzZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMubWFwW25hbWVdKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBmID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBmKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgdGhpcy54ID0gZXZlbnQubGF5ZXJYO1xuICAgICAgICB0aGlzLnkgPSBldmVudC5sYXllclk7XG4gICAgICAgIHRoaXMudCA9IGwuc2NyZWVuMnQodGhpcy54KTtcbiAgICAgICAgdGhpcy55JCA9IGwuc2NyZWVuMiQodGhpcy55KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAnbW91c2V1cCcpIHtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1vdXNlO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvb3ZlcmxheS5qc1xuLy8gVXN1ZnVsIHN0dWZmIGZvciBjcmVhdGluZyBvdmVybGF5cy4gSW5jbHVkZSBhcyBtaXhpblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXkgPSAoe1xuICBwcm9wczogWydpZCcsICdudW0nLCAnaW50ZXJ2YWwnLCAnY3Vyc29yJywgJ2NvbG9ycycsICdsYXlvdXQnLCAnc3ViJywgJ2RhdGEnLCAnc2V0dGluZ3MnLCAnZ3JpZF9pZCcsICdmb250JywgJ2NvbmZpZycsICdtZXRhJywgJ3RmJywgJ2kwJywgJ2xhc3QnXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAvLyBUT0RPKDEpOiB3aGVuIGhvdCByZWxvYWRpbmcsIGR5bmFtaWNhbHkgY2hhbmdlZCBtaXhpbnNcbiAgICAvLyBkaXNzYXBlYXIgKGN1eiBpdCdzIGEgaGFjayksIHRoZSBvbmx5IHdheSBmb3Igbm93XG4gICAgLy8gaXMgdG8gcmVsb2FkIHRoZSBicm93c2VyXG4gICAgaWYgKCF0aGlzLmRyYXcpIHtcbiAgICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIHRleHQgPSAnRUFSTFkgQURPUFRFUiBCVUc6IHJlbG9hZCB0aGUgYnJvd3NlciAmIGVuam95JztcbiAgICAgICAgY29uc29sZS53YXJuKHRleHQpO1xuICAgICAgfTtcbiAgICB9IC8vIE1haW4gY2hhcnQ/XG5cblxuICAgIHZhciBtYWluID0gdGhpcy4kcHJvcHMuc3ViID09PSB0aGlzLiRwcm9wcy5kYXRhO1xuICAgIHRoaXMubWV0YV9pbmZvKCk7IC8vIFRPRE8oMSk6IHF1aWNrIGZpeCBmb3IgdnVlMiwgaW4gdnVlMyB3ZSB1c2UgM3JkIHBhcnR5IGVtaXRcblxuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgdGhpcy4kZW1pdCkoKTtcbiAgICAgIHRoaXMuXyRlbWl0ID0gdGhpcy4kZW1pdDtcbiAgICAgIHRoaXMuJGVtaXQgPSB0aGlzLmN1c3RvbV9ldmVudDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fJGVtaXQoJ25ldy1ncmlkLWxheWVyJywge1xuICAgICAgbmFtZTogdGhpcy4kb3B0aW9ucy5uYW1lLFxuICAgICAgaWQ6IHRoaXMuJHByb3BzLmlkLFxuICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICBkaXNwbGF5OiAnZGlzcGxheScgaW4gdGhpcy4kcHJvcHMuc2V0dGluZ3MgPyB0aGlzLiRwcm9wcy5zZXR0aW5nc1snZGlzcGxheSddIDogdHJ1ZSxcbiAgICAgIHo6IHRoaXMuJHByb3BzLnNldHRpbmdzWyd6LWluZGV4J10gfHwgdGhpcy4kcHJvcHMuc2V0dGluZ3NbJ3pJbmRleCddIHx8IChtYWluID8gMCA6IC0xKVxuICAgIH0pOyAvLyBPdmVybGF5IG1ldGEtcHJvcHMgKGFkanVzdGluZyBiZWhhdmlvdXIpXG5cblxuICAgIHRoaXMuXyRlbWl0KCdsYXllci1tZXRhLXByb3BzJywge1xuICAgICAgZ3JpZF9pZDogdGhpcy4kcHJvcHMuZ3JpZF9pZCxcbiAgICAgIGxheWVyX2lkOiB0aGlzLiRwcm9wcy5pZCxcbiAgICAgIGxlZ2VuZDogdGhpcy5sZWdlbmQsXG4gICAgICBkYXRhX2NvbG9yczogdGhpcy5kYXRhX2NvbG9ycyxcbiAgICAgIHlfcmFuZ2U6IHRoaXMueV9yYW5nZVxuICAgIH0pO1xuXG4gICAgdGhpcy5leGVjX3NjcmlwdCgpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcyk7XG4gICAgaWYgKHRoaXMuaW5pdF90b29sKSB0aGlzLmluaXRfdG9vbCgpO1xuICAgIGlmICh0aGlzLmluaXQpIHRoaXMuaW5pdCgpO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3kpIHRoaXMuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5fJGVtaXQoJ2RlbGV0ZS1ncmlkLWxheWVyJywgdGhpcy4kcHJvcHMuaWQpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIC8qIG92ZXJyaWRlIGl0IChtYW5kYXRvcnkpICovXG4gICAgICBjb25zb2xlLndhcm4oJ3VzZV9mb3IoKSBzaG91bGQgYmUgaW1wbGVtZW50ZWQnKTtcbiAgICAgIGNvbnNvbGUud2FybihcIkZvcm1hdDogdXNlX2ZvcigpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gWyd0eXBlMScsICd0eXBlMicsIC4uLl1cXG4gICAgICAgICAgICB9XCIpO1xuICAgIH0sXG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICAvKiBvdmVycmlkZSBpdCAob3B0aW9uYWwpICovXG4gICAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5pZDtcbiAgICAgIGNvbnNvbGUud2FybihcIlwiLmNvbmNhdChpZCwgXCIgbWV0YV9pbmZvKCkgaXMgcmVxLiBmb3IgcHVibGlzaGluZ1wiKSk7XG4gICAgICBjb25zb2xlLndhcm4oXCJGb3JtYXQ6IG1ldGFfaW5mbygpIHtcXG4gICAgICAgICAgICAgICAgYXV0aG9yOiAnU2F0b3NoaSBTbWl0aCcsXFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXFxuICAgICAgICAgICAgICAgIGNvbnRhY3QgKG9wdCkgJzxlbWFpbD4nXFxuICAgICAgICAgICAgICAgIGdpdGh1YjogKG9wdCkgJzxHaXRIdWIgUGFnZT4nLFxcbiAgICAgICAgICAgIH1cIik7XG4gICAgfSxcbiAgICBjdXN0b21fZXZlbnQ6IGZ1bmN0aW9uIGN1c3RvbV9ldmVudChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnNwbGl0KCc6JylbMF0gPT09ICdob29rJykgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQgPT09ICdjaGFuZ2Utc2V0dGluZ3MnIHx8IGV2ZW50ID09PSAnb2JqZWN0LXNlbGVjdGVkJyB8fCBldmVudCA9PT0gJ25ldy1zaGFkZXInIHx8IGV2ZW50ID09PSAnbmV3LWludGVyZmFjZScgfHwgZXZlbnQgPT09ICdyZW1vdmUtdG9vbCcpIHtcbiAgICAgICAgYXJncy5wdXNoKHRoaXMuZ3JpZF9pZCwgdGhpcy5pZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuJHByb3BzLnNldHRpbmdzLiR1dWlkKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHRoaXMuJHByb3BzLnNldHRpbmdzLiR1dWlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQgPT09ICduZXctaW50ZXJmYWNlJykge1xuICAgICAgICBhcmdzWzBdLm92ZXJsYXkgPSB0aGlzO1xuICAgICAgICBhcmdzWzBdLnV1aWQgPSB0aGlzLmxhc3RfdXhfaWQgPSBcIlwiLmNvbmNhdCh0aGlzLmdyaWRfaWQsIFwiLVwiKS5jb25jYXQodGhpcy5pZCwgXCItXCIpLmNvbmNhdCh0aGlzLnV4c19jb3VudCsrKTtcbiAgICAgIH0gLy8gVE9ETzogYWRkIGEgbmFtZXNwYWNlIHRvIHRoZSBldmVudCBuYW1lXG4gICAgICAvLyBUT0RPKDIpOiB0aGlzIHByZXZlbnRzIGNhbGwgb3ZlcmZsb3csIGJ1dFxuICAgICAgLy8gdGhlIHJvb3Qgb2YgZXZpbCBpcyBpbiAoMSlcblxuXG4gICAgICBpZiAoZXZlbnQgPT09ICdjdXN0b20tZXZlbnQnKSByZXR1cm47XG5cbiAgICAgIHRoaXMuXyRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBUT0RPOiB0aGUgZXZlbnQgaXMgbm90IGZpcmluZyB3aGVuIHRoZSBzYW1lXG4gICAgLy8gb3ZlcmxheSB0eXBlIGlzIGFkZGVkIHRvIHRoZSBvZmZjaGFydFtdXG4gICAgZXhlY19zY3JpcHQ6IGZ1bmN0aW9uIGV4ZWNfc2NyaXB0KCkge1xuICAgICAgaWYgKHRoaXMuY2FsYykgdGhpcy4kZW1pdCgnZXhlYy1zY3JpcHQnLCB7XG4gICAgICAgIGdyaWRfaWQ6IHRoaXMuJHByb3BzLmdyaWRfaWQsXG4gICAgICAgIGxheWVyX2lkOiB0aGlzLiRwcm9wcy5pZCxcbiAgICAgICAgc3JjOiB0aGlzLmNhbGMoKSxcbiAgICAgICAgdXNlX2ZvcjogdGhpcy51c2VfZm9yKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBzZXR0aW5nczoge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihuLCBwKSB7XG4gICAgICAgIGlmICh0aGlzLndhdGNoX3V1aWQpIHRoaXMud2F0Y2hfdXVpZChuLCBwKTtcblxuICAgICAgICB0aGlzLl8kZW1pdCgnc2hvdy1ncmlkLWxheWVyJywge1xuICAgICAgICAgIGlkOiB0aGlzLiRwcm9wcy5pZCxcbiAgICAgICAgICBkaXNwbGF5OiAnZGlzcGxheScgaW4gdGhpcy4kcHJvcHMuc2V0dGluZ3MgPyB0aGlzLiRwcm9wcy5zZXR0aW5nc1snZGlzcGxheSddIDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1eHNfY291bnQ6IDAsXG4gICAgICBsYXN0X3V4X2lkOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHJldHVybiBoKCk7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGluZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBTcGxpbmUgcmVuZGVyZXIuIChTTUFzLCBFTUFzLCBURU1Bcy4uLlxuLy8geW91IGtub3cgd2hhdCBJIG1lYW4pXG4vLyBUT0RPOiBtYWtlIGEgcmVhbCBzcGxpbmUsIG5vdCBhIGJ1bmNoIG9mIGxpbmVzLi4uXG4vLyBBZGRzIGFsbCBuZWNlc3Nhcnkgc3R1ZmYgZm9yIHlvdS5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTcGxpbmV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU3BsaW5lJyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4xLjInXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gSGVyZSBnb2VzIHlvdXIgY29kZS4gWW91IGFyZSBwcm92aWRlZCB3aXRoOlxuICAgIC8vIHsgQWxsIHN0dWZmIGlzIHJlYWN0aXZlIH1cbiAgICAvLyAkcHJvcHMubGF5b3V0IC0+IHBvc2l0aW9ucyBvZiBhbGwgY2hhcnQgZWxlbWVudHMgK1xuICAgIC8vICBzb21lIGhlbHBlciBmdW5jdGlvbnMgKHNlZSBsYXlvdXRfZm4uanMpXG4gICAgLy8gJHByb3BzLmludGVydmFsIC0+IGNhbmRsZXN0aWNrIHRpbWUgaW50ZXJ2YWxcbiAgICAvLyAkcHJvcHMuc3ViIC0+IGN1cnJlbnQgc3Vic2V0IG9mIGNhbmRsZXN0aWNrIGRhdGFcbiAgICAvLyAkcHJvcHMuZGF0YSAtPiB5b3VyIGluZGljYXRvcidzIGRhdGEgc3Vic2V0LlxuICAgIC8vICBDb21lcyBcImFzIGlzXCIsIHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuICAgIC8vICBbWzx0aW1lc3RhbXA+LCAuLi4gXSwgLi4uIF1cbiAgICAvLyAkcHJvcHMuY29sb3JzIC0+IGNvbG9ycyAoc2VlIFRyYWRpbmdWdWUudnVlKVxuICAgIC8vICRwcm9wcy5jdXJzb3IgLT4gY3VycmVudCBwb3NpdGlvbiBvZiBjcm9zc2hhaXJcbiAgICAvLyAkcHJvcHMuc2V0dGluZ3MgLT4gaW5kaWNhdG9yJ3MgY3VzdG9tIHNldHRpbmdzXG4gICAgLy8gIEUuZy4gY29sb3JzLCBsaW5lIHRoaWNrbmVzcywgZXRjLiBZb3UgZGVmaW5lIGl0LlxuICAgIC8vICRwcm9wcy5udW0gLT4gaW5kaWNhdG9yJ3MgbGF5ZXIgbnVtYmVyIChvZiBBbGxcbiAgICAvLyBsYXllcnMgaW4gdGhlIGN1cnJlbnQgZ3JpZClcbiAgICAvLyAkcHJvcHMuaWQgLT4gaW5kaWNhdG9yJ3MgaWQgKGUuZy4gRU1BXzApXG4gICAgLy8gflxuICAgIC8vIEZpbmFsbHksIGxldCdzIG1ha2UgdGhlIGNhbnZhcyBkaXJ0eSFcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGkgPSB0aGlzLmRhdGFfaW5kZXg7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuJHByb3BzLmRhdGE7XG5cbiAgICAgIGlmICghdGhpcy5za2lwX25hbikge1xuICAgICAgICBmb3IgKHZhciBrID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBrIDwgbjsgaysrKSB7XG4gICAgICAgICAgdmFyIHAgPSBkYXRhW2tdO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuICAgICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbaV0pO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBza2lwID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgayA8IG47IGsrKykge1xuICAgICAgICAgIHZhciBfcCA9IGRhdGFba107XG5cbiAgICAgICAgICB2YXIgX3ggPSBsYXlvdXQudDJzY3JlZW4oX3BbMF0pO1xuXG4gICAgICAgICAgdmFyIF95ID0gbGF5b3V0LiQyc2NyZWVuKF9wW2ldKTtcblxuICAgICAgICAgIGlmIChfcFtpXSA9PSBudWxsIHx8IF95ICE9PSBfeSkge1xuICAgICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChza2lwKSBjdHgubW92ZVRvKF94LCBfeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKF94LCBfeSk7XG4gICAgICAgICAgICBza2lwID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIC8vIEZvciBhbGwgZGF0YSB3aXRoIHRoZXNlIHR5cGVzIG92ZXJsYXkgd2lsbCBiZVxuICAgIC8vIGFkZGVkIHRvIHRoZSByZW5kZXJlciBsaXN0LiBBbmQgJyRwcm9wcy5kYXRhJ1xuICAgIC8vIHdpbGwgaGF2ZSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuIElmIHlvdSB3YW50IHRvXG4gICAgLy8gcmVkZWZpbmUgdGhlIGRlZmF1bHQgYmVodmlvdXIgZm9yIGEgcHJ0aWN1bGFyXG4gICAgLy8gaW5kaWNhdG9yIChsZXQncyBzYXkgRU1BKSxcbiAgICAvLyBqdXN0IGNyZWF0ZSBhIG5ldyBvdmVybGF5IHdpdGggdGhlIHNhbWUgdHlwZTpcbiAgICAvLyBlLmcuIHVzZV9mb3IoKSB7IHJldHVybiBbJ0VNQSddIH0uXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1NwbGluZScsICdFTUEnLCAnU01BJ107XG4gICAgfSxcbiAgICAvLyBDb2xvcnMgZm9yIHRoZSBsZWdlbmQsIHNob3VsZCBoYXZlIHRoZVxuICAgIC8vIHNhbWUgZGltZW50aW9uIGFzIGEgZGF0YSBwb2ludCAoZXhjbC4gdGltZXN0YW1wKVxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvcl07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjc1O1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgdmFyIG4gPSB0aGlzLiRwcm9wcy5udW0gJSA1O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCB0aGlzLkNPTE9SU1tuXTtcbiAgICB9LFxuICAgIGRhdGFfaW5kZXg6IGZ1bmN0aW9uIGRhdGFfaW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmRhdGFJbmRleCB8fCAxO1xuICAgIH0sXG4gICAgLy8gRG9uJ3QgY29ubmVjdCBzZXBhcmF0ZSBwYXJ0cyBpZiB0cnVlXG4gICAgc2tpcF9uYW46IGZ1bmN0aW9uIHNraXBfbmFuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5za2lwTmFOO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQ09MT1JTOiBbJyM0MmIyOGEnLCAnIzU2OTFjZScsICcjNjEyZmY5JywgJyNkNTBiOTAnLCAnI2ZmMjMxNiddXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpbmUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfU3BsaW5ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNwbGluZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaW5lLnZ1ZVxudmFyIFNwbGluZV9yZW5kZXIsIFNwbGluZV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTcGxpbmVfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19TcGxpbmV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNwbGluZV9yZW5kZXIsXG4gIFNwbGluZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNwbGluZV9hcGk7IH1cblNwbGluZV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGluZS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTcGxpbmUgPSAoU3BsaW5lX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpbmVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIENoYW5uZWwgcmVuZGVyZXIuIChLZWx0bmVyLCBCb2xsaW5nZXIpXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3BsaW5lc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTcGxpbmVzJyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4xLjAnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lc19udW07IGkrKykge1xuICAgICAgICB2YXIgX2kgPSBpICUgdGhpcy5jbHJ4Lmxlbmd0aDtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNscnhbX2ldO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy53aWR0aHNbaV0gfHwgdGhpcy5saW5lX3dpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuZHJhd19zcGxpbmUoY3R4LCBpKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhd19zcGxpbmU6IGZ1bmN0aW9uIGRyYXdfc3BsaW5lKGN0eCwgaSkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBkYXRhID0gdGhpcy4kcHJvcHMuZGF0YTtcblxuICAgICAgaWYgKCF0aGlzLnNraXBfbmFuKSB7XG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICB2YXIgcCA9IGRhdGFba107XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG4gICAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFtpICsgMV0pO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBza2lwID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgayA8IG47IGsrKykge1xuICAgICAgICAgIHZhciBfcCA9IGRhdGFba107XG5cbiAgICAgICAgICB2YXIgX3ggPSBsYXlvdXQudDJzY3JlZW4oX3BbMF0pO1xuXG4gICAgICAgICAgdmFyIF95ID0gbGF5b3V0LiQyc2NyZWVuKF9wW2kgKyAxXSk7XG5cbiAgICAgICAgICBpZiAoX3BbaSArIDFdID09IG51bGwgfHwgX3kgIT09IF95KSB7XG4gICAgICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNraXApIGN0eC5tb3ZlVG8oX3gsIF95KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oX3gsIF95KTtcbiAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydTcGxpbmVzJywgJ0RNSSddO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xyeDtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuNzU7XG4gICAgfSxcbiAgICB3aWR0aHM6IGZ1bmN0aW9uIHdpZHRocygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRocyB8fCBbXTtcbiAgICB9LFxuICAgIGNscng6IGZ1bmN0aW9uIGNscngoKSB7XG4gICAgICB2YXIgY29sb3JzID0gdGhpcy5zZXR0LmNvbG9ycyB8fCBbXTtcbiAgICAgIHZhciBuID0gdGhpcy4kcHJvcHMubnVtO1xuXG4gICAgICBpZiAoIWNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzX251bTsgaSsrKSB7XG4gICAgICAgICAgY29sb3JzLnB1c2godGhpcy5DT0xPUlNbKG4gKyBpKSAlIDVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3JzO1xuICAgIH0sXG4gICAgbGluZXNfbnVtOiBmdW5jdGlvbiBsaW5lc19udW0oKSB7XG4gICAgICBpZiAoIXRoaXMuJHByb3BzLmRhdGFbMF0pIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmRhdGFbMF0ubGVuZ3RoIC0gMTtcbiAgICB9LFxuICAgIC8vIERvbid0IGNvbm5lY3Qgc2VwYXJhdGUgcGFydHMgaWYgdHJ1ZVxuICAgIHNraXBfbmFuOiBmdW5jdGlvbiBza2lwX25hbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2tpcE5hTjtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIENPTE9SUzogWycjNDJiMjhhJywgJyM1NjkxY2UnLCAnIzYxMmZmOScsICcjZDUwYjkwJywgJyNmZjIzMTYnXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaW5lcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19TcGxpbmVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNwbGluZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGluZXMudnVlXG52YXIgU3BsaW5lc19yZW5kZXIsIFNwbGluZXNfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU3BsaW5lc19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX1NwbGluZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNwbGluZXNfcmVuZGVyLFxuICBTcGxpbmVzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU3BsaW5lc19hcGk7IH1cblNwbGluZXNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpbmVzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNwbGluZXMgPSAoU3BsaW5lc19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvUmFuZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gUiBTIEkgLiBCZWNhdXNlIHdlIGxvdmUgaXRcbi8vIEFkZHMgYWxsIG5lY2Vzc2FyeSBzdHVmZiBmb3IgeW91LlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1JhbmdlJyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjEnXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gSGVyZSBnb2VzIHlvdXIgY29kZS4gWW91IGFyZSBwcm92aWRlZCB3aXRoOlxuICAgIC8vIHsgQWxsIHN0dWZmIGlzIHJlYWN0aXZlIH1cbiAgICAvLyAkcHJvcHMubGF5b3V0IC0+IHBvc2l0aW9ucyBvZiBhbGwgY2hhcnQgZWxlbWVudHMgK1xuICAgIC8vICBzb21lIGhlbHBlciBmdW5jdGlvbnMgKHNlZSBsYXlvdXRfZm4uanMpXG4gICAgLy8gJHByb3BzLmludGVydmFsIC0+IGNhbmRsZXN0aWNrIHRpbWUgaW50ZXJ2YWxcbiAgICAvLyAkcHJvcHMuc3ViIC0+IGN1cnJlbnQgc3Vic2V0IG9mIGNhbmRsZXN0aWNrIGRhdGFcbiAgICAvLyAkcHJvcHMuZGF0YSAtPiB5b3VyIGluZGljYXRvcidzIGRhdGEgc3Vic2V0LlxuICAgIC8vICBDb21lcyBcImFzIGlzXCIsIHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuICAgIC8vICBbWzx0aW1lc3RhbXA+LCAuLi4gXSwgLi4uIF1cbiAgICAvLyAkcHJvcHMuY29sb3JzIC0+IGNvbG9ycyAoc2VlIFRyYWRpbmdWdWUudnVlKVxuICAgIC8vICRwcm9wcy5jdXJzb3IgLT4gY3VycmVudCBwb3NpdGlvbiBvZiBjcm9zc2hhaXJcbiAgICAvLyAkcHJvcHMuc2V0dGluZ3MgLT4gaW5kaWNhdG9yJ3MgY3VzdG9tIHNldHRpbmdzXG4gICAgLy8gIEUuZy4gY29sb3JzLCBsaW5lIHRoaWNrbmVzcywgZXRjLiBZb3UgZGVmaW5lIGl0LlxuICAgIC8vICRwcm9wcy5udW0gLT4gaW5kaWNhdG9yJ3MgbGF5ZXIgbnVtYmVyIChvZiBBbGxcbiAgICAvLyBsYXllcnMgaW4gdGhlIGN1cnJlbnQgZ3JpZClcbiAgICAvLyAkcHJvcHMuaWQgLT4gaW5kaWNhdG9yJ3MgaWQgKGUuZy4gRU1BXzApXG4gICAgLy8gflxuICAgIC8vIEZpbmFsbHksIGxldCdzIG1ha2UgdGhlIGNhbnZhcyBkaXJ0eSFcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciB1cHBlciA9IGxheW91dC4kMnNjcmVlbih0aGlzLnNldHQudXBwZXIgfHwgNzApO1xuICAgICAgdmFyIGxvd2VyID0gbGF5b3V0LiQyc2NyZWVuKHRoaXMuc2V0dC5sb3dlciB8fCAzMCk7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuJHByb3BzLmRhdGE7IC8vIFJTSSB2YWx1ZXNcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgdmFyIHAgPSBkYXRhW2tdO1xuICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcbiAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYmFuZF9jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbNV0pOyAvLyBXaWxsIGJlIHJlbW92ZWQgYWZ0ZXIgZHJhdygpXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTsgLy8gRmlsbCB0aGUgYXJlYSBiZXR3ZWVuIHRoZSBiYW5kc1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrX2NvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIHVwcGVyLCBsYXlvdXQud2lkdGgsIGxvd2VyIC0gdXBwZXIpOyAvLyBVcHBlciBiYW5kXG5cbiAgICAgIGN0eC5tb3ZlVG8oMCwgdXBwZXIpO1xuICAgICAgY3R4LmxpbmVUbyhsYXlvdXQud2lkdGgsIHVwcGVyKTsgLy8gTG93ZXIgYmFuZFxuXG4gICAgICBjdHgubW92ZVRvKDAsIGxvd2VyKTtcbiAgICAgIGN0eC5saW5lVG8obGF5b3V0LndpZHRoLCBsb3dlcik7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICAvLyBGb3IgYWxsIGRhdGEgd2l0aCB0aGVzZSB0eXBlcyBvdmVybGF5IHdpbGwgYmVcbiAgICAvLyBhZGRlZCB0byB0aGUgcmVuZGVyZXIgbGlzdC4gQW5kICckcHJvcHMuZGF0YSdcbiAgICAvLyB3aWxsIGhhdmUgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLiBJZiB5b3Ugd2FudCB0b1xuICAgIC8vIHJlZGVmaW5lIHRoZSBkZWZhdWx0IGJlaHZpb3VyIGZvciBhIHBydGljdWxhclxuICAgIC8vIGluZGljYXRvciAobGV0J3Mgc2F5IEVNQSksXG4gICAgLy8ganVzdCBjcmVhdGUgYSBuZXcgb3ZlcmxheSB3aXRoIHRoZSBzYW1lIHR5cGU6XG4gICAgLy8gZS5nLiB1c2VfZm9yKCkgeyByZXR1cm4gWydFTUEnXSB9LlxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydSYW5nZScsICdSU0knXTtcbiAgICB9LFxuICAgIC8vIENvbG9ycyBmb3IgdGhlIGxlZ2VuZCwgc2hvdWxkIGhhdmUgdGhlXG4gICAgLy8gc2FtZSBkaW1lbnRpb24gYXMgYSBkYXRhIHBvaW50IChleGNsLiB0aW1lc3RhbXApXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yXTtcbiAgICB9LFxuICAgIC8vIFktUmFuZ2UgdGFuc2Zvcm0uIEZvciBleGFtcGxlIHlvdSBuZWVkIGEgZml4ZWRcbiAgICAvLyBZLXJhbmdlIGZvciBhbiBpbmRpY2F0b3IsIHlvdSBjYW4gZG8gaXQgaGVyZSFcbiAgICAvLyBHZXRzIGVzdGltYXRlZCByYW5nZSwgQHJldHVybiB5b3UgZmF2b3JpdGUgcmFuZ2VcbiAgICB5X3JhbmdlOiBmdW5jdGlvbiB5X3JhbmdlKGhpLCBsbykge1xuICAgICAgcmV0dXJuIFtNYXRoLm1heChoaSwgdGhpcy5zZXR0LnVwcGVyIHx8IDcwKSwgTWF0aC5taW4obG8sIHRoaXMuc2V0dC5sb3dlciB8fCAzMCldO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC43NTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgJyNlYzIwNmUnO1xuICAgIH0sXG4gICAgYmFuZF9jb2xvcjogZnVuY3Rpb24gYmFuZF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFuZENvbG9yIHx8ICcjZGRkJztcbiAgICB9LFxuICAgIGJhY2tfY29sb3I6IGZ1bmN0aW9uIGJhY2tfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhY2tDb2xvciB8fCAnIzM4MWU5YzE2JztcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvUmFuZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfUmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoUmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1JhbmdlLnZ1ZVxudmFyIFJhbmdlX3JlbmRlciwgUmFuZ2Vfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgUmFuZ2VfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19SYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgUmFuZ2VfcmVuZGVyLFxuICBSYW5nZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFJhbmdlX2FwaTsgfVxuUmFuZ2VfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9SYW5nZS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSYW5nZSA9IChSYW5nZV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvVHJhZGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVHJhZGVzJyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjInXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuJHByb3BzLmRhdGE7XG4gICAgICBjdHgubGluZVdpZHRoID0gMS41O1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcblxuICAgICAgZm9yICh2YXIgayA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgayA8IG47IGsrKykge1xuICAgICAgICB2YXIgcCA9IGRhdGFba107XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBwWzFdID8gdGhpcy5idXlfY29sb3IgOiB0aGlzLnNlbGxfY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7IC8vIHggLSBNYXBwaW5nXG5cbiAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsyXSk7IC8vIHkgLSBNYXBwaW5nXG5cbiAgICAgICAgY3R4LmFyYyh4LCB5LCB0aGlzLm1hcmtlcl9zaXplICsgMC41LCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBpZiAodGhpcy5zaG93X2xhYmVsICYmIHBbM10pIHtcbiAgICAgICAgICB0aGlzLmRyYXdfbGFiZWwoY3R4LCB4LCB5LCBwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZHJhd19sYWJlbDogZnVuY3Rpb24gZHJhd19sYWJlbChjdHgsIHgsIHksIHApIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsX2NvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLm5ld19mb250O1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgY3R4LmZpbGxUZXh0KHBbM10sIHgsIHkgLSAyNSk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnVHJhZGVzJ107XG4gICAgfSxcbiAgICAvLyBEZWZpbmVzIGxlZ2VuZCBmb3JtYXQgKHZhbHVlcyAmIGNvbG9ycylcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCh2YWx1ZXMpIHtcbiAgICAgIHN3aXRjaCAodmFsdWVzWzFdKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB2YXIgcG9zID0gJ1NlbGwnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwb3MgPSAnQnV5JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHBvcyA9ICdVbmtub3duJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZhbHVlOiBwb3NcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlc1syXS50b0ZpeGVkKDQpLFxuICAgICAgICBjb2xvcjogdGhpcy4kcHJvcHMuY29sb3JzLnRleHRcbiAgICAgIH1dLmNvbmNhdCh2YWx1ZXNbM10gPyBbe1xuICAgICAgICB2YWx1ZTogdmFsdWVzWzNdXG4gICAgICB9XSA6IFtdKTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgZGVmYXVsdF9mb250OiBmdW5jdGlvbiBkZWZhdWx0X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gJzEycHggJyArIHRoaXMuJHByb3BzLmZvbnQuc3BsaXQoJ3B4JykucG9wKCk7XG4gICAgfSxcbiAgICBidXlfY29sb3I6IGZ1bmN0aW9uIGJ1eV9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYnV5Q29sb3IgfHwgJyM2M2RmODknO1xuICAgIH0sXG4gICAgc2VsbF9jb2xvcjogZnVuY3Rpb24gc2VsbF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2VsbENvbG9yIHx8ICcjZWM0NjYyJztcbiAgICB9LFxuICAgIGxhYmVsX2NvbG9yOiBmdW5jdGlvbiBsYWJlbF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGFiZWxDb2xvciB8fCAnIzk5OSc7XG4gICAgfSxcbiAgICBtYXJrZXJfc2l6ZTogZnVuY3Rpb24gbWFya2VyX3NpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lm1hcmtlclNpemUgfHwgNTtcbiAgICB9LFxuICAgIHNob3dfbGFiZWw6IGZ1bmN0aW9uIHNob3dfbGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNob3dMYWJlbCAhPT0gZmFsc2U7XG4gICAgfSxcbiAgICBuZXdfZm9udDogZnVuY3Rpb24gbmV3X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmZvbnQgfHwgdGhpcy5kZWZhdWx0X2ZvbnQ7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1RyYWRlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19UcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9UcmFkZXMudnVlXG52YXIgVHJhZGVzX3JlbmRlciwgVHJhZGVzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFRyYWRlc19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX1RyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVHJhZGVzX3JlbmRlcixcbiAgVHJhZGVzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVHJhZGVzX2FwaTsgfVxuVHJhZGVzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvVHJhZGVzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYWRlcyA9IChUcmFkZXNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0NoYW5uZWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gQ2hhbm5lbCByZW5kZXJlci4gKEtlbHRuZXIsIEJvbGxpbmdlcilcbi8vIFRPRE86IGFsbG93IGNvbG9yIHRyYW5zcGFyZW5jeVxuLy8gVE9ETzogaW1wcm92ZSBwZXJmb3JtYW5jZTogZHJhdyBpbiBvbmUgc29saWQgY2h1bmtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDaGFubmVsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0NoYW5uZWwnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMSdcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qZHJhdyhjdHgpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aFxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tfY29sb3JcbiAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kcHJvcHMuZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IHAxID0gdGhpcy5tYXBwKHRoaXMuJHByb3BzLmRhdGFbaV0pXG4gICAgICAgICAgICBsZXQgcDIgPSB0aGlzLm1hcHAodGhpcy4kcHJvcHMuZGF0YVtpKzFdKVxuICAgICAgICAgICAgIGlmICghcDIpIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAocDEueTEgIT09IHAxLnkxKSBjb250aW51ZSAvLyBGaXggTmFOXG4gICAgICAgICAgICAgLy8gQmFja2dyb3VuZFxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkxKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyhwMi54ICsgMC4xLCBwMi55MSlcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocDIueCArIDAuMSwgcDIueTMpXG4gICAgICAgICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkzKVxuICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgICAgIC8vIExpbmVzXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueTEpXG4gICAgICAgICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkxKVxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd19taWQpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkyKVxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueTIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkzKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55MylcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICAgfVxuICAgIH0sKi9cbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgLy8gQmFja2dyb3VuZFxuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrX2NvbG9yO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBkYXRhW2ldO1xuICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcbiAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXSB8fCB1bmRlZmluZWQpO1xuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgX3AgPSBkYXRhW2ldO1xuXG4gICAgICAgIHZhciBfeCA9IGxheW91dC50MnNjcmVlbihfcFswXSk7XG5cbiAgICAgICAgdmFyIF95ID0gbGF5b3V0LiQyc2NyZWVuKF9wWzNdIHx8IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgY3R4LmxpbmVUbyhfeCwgX3kpO1xuICAgICAgfVxuXG4gICAgICBjdHguZmlsbCgpOyAvLyBMaW5lc1xuXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjsgLy8gVG9wIGxpbmVcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9wMiA9IGRhdGFbaV07XG5cbiAgICAgICAgdmFyIF94MiA9IGxheW91dC50MnNjcmVlbihfcDJbMF0pO1xuXG4gICAgICAgIHZhciBfeTIgPSBsYXlvdXQuJDJzY3JlZW4oX3AyWzFdIHx8IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgY3R4LmxpbmVUbyhfeDIsIF95Mik7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTsgLy8gQm90dG9tIGxpbmVcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9wMyA9IGRhdGFbaV07XG5cbiAgICAgICAgdmFyIF94MyA9IGxheW91dC50MnNjcmVlbihfcDNbMF0pO1xuXG4gICAgICAgIHZhciBfeTMgPSBsYXlvdXQuJDJzY3JlZW4oX3AzWzNdIHx8IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgY3R4LmxpbmVUbyhfeDMsIF95Myk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTsgLy8gTWlkZGxlIGxpbmVcblxuICAgICAgaWYgKCF0aGlzLnNob3dfbWlkKSByZXR1cm47XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3A0ID0gZGF0YVtpXTtcblxuICAgICAgICB2YXIgX3g0ID0gbGF5b3V0LnQyc2NyZWVuKF9wNFswXSk7XG5cbiAgICAgICAgdmFyIF95NCA9IGxheW91dC4kMnNjcmVlbihfcDRbMl0gfHwgdW5kZWZpbmVkKTtcblxuICAgICAgICBjdHgubGluZVRvKF94NCwgX3k0KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgbWFwcDogZnVuY3Rpb24gbWFwcChwKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgcmV0dXJuIHAgJiYge1xuICAgICAgICB4OiBsYXlvdXQudDJzY3JlZW4ocFswXSksXG4gICAgICAgIHkxOiBsYXlvdXQuJDJzY3JlZW4ocFsxXSksXG4gICAgICAgIHkyOiBsYXlvdXQuJDJzY3JlZW4ocFsyXSksXG4gICAgICAgIHkzOiBsYXlvdXQuJDJzY3JlZW4ocFszXSlcbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQ2hhbm5lbCcsICdLQycsICdCQiddO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yLCB0aGlzLmNvbG9yLCB0aGlzLmNvbG9yXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuNzU7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuJHByb3BzLm51bSAlIDU7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8IHRoaXMuQ09MT1JTW25dO1xuICAgIH0sXG4gICAgc2hvd19taWQ6IGZ1bmN0aW9uIHNob3dfbWlkKCkge1xuICAgICAgcmV0dXJuICdzaG93TWlkJyBpbiB0aGlzLnNldHQgPyB0aGlzLnNldHQuc2hvd01pZCA6IHRydWU7XG4gICAgfSxcbiAgICBiYWNrX2NvbG9yOiBmdW5jdGlvbiBiYWNrX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYWNrQ29sb3IgfHwgdGhpcy5jb2xvciArICcxMSc7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBDT0xPUlM6IFsnIzQyYjI4YScsICcjNTY5MWNlJywgJyM2MTJmZjknLCAnI2Q1MGI5MCcsICcjZmYyMzE2J11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0NoYW5uZWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfQ2hhbm5lbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDaGFubmVsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9DaGFubmVsLnZ1ZVxudmFyIENoYW5uZWxfcmVuZGVyLCBDaGFubmVsX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIENoYW5uZWxfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19DaGFubmVsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDaGFubmVsX3JlbmRlcixcbiAgQ2hhbm5lbF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIENoYW5uZWxfYXBpOyB9XG5DaGFubmVsX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvQ2hhbm5lbC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDaGFubmVsID0gKENoYW5uZWxfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NlZ21lbnQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gU2VnbWVudCByZW5kZXJlci5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTZWdtZW50dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NlZ21lbnQnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCdcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnAxIHx8ICF0aGlzLnAyKSByZXR1cm47XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgeDEgPSBsYXlvdXQudDJzY3JlZW4odGhpcy5wMVswXSk7XG4gICAgICB2YXIgeTEgPSBsYXlvdXQuJDJzY3JlZW4odGhpcy5wMVsxXSk7XG4gICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICB2YXIgeDIgPSBsYXlvdXQudDJzY3JlZW4odGhpcy5wMlswXSk7XG4gICAgICB2YXIgeTIgPSBsYXlvdXQuJDJzY3JlZW4odGhpcy5wMlsxXSk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnU2VnbWVudCddO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgcDE6IGZ1bmN0aW9uIHAxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzLnAxO1xuICAgIH0sXG4gICAgcDI6IGZ1bmN0aW9uIHAyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzLnAyO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuOTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHZhciBuID0gdGhpcy4kcHJvcHMubnVtICUgNTtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgdGhpcy5DT0xPUlNbbl07XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBDT0xPUlM6IFsnIzQyYjI4YScsICcjNTY5MWNlJywgJyM2MTJmZjknLCAnI2Q1MGI5MCcsICcjZmYyMzE2J11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NlZ21lbnQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfU2VnbWVudHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTZWdtZW50dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TZWdtZW50LnZ1ZVxudmFyIFNlZ21lbnRfcmVuZGVyLCBTZWdtZW50X3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFNlZ21lbnRfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19TZWdtZW50dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTZWdtZW50X3JlbmRlcixcbiAgU2VnbWVudF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNlZ21lbnRfYXBpOyB9XG5TZWdtZW50X2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU2VnbWVudC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTZWdtZW50ID0gKFNlZ21lbnRfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvbGF5b3V0X2Nudi5qc1xuXG5cbi8vIENsYWN1bGF0ZXMgcG9zdGlvbnMgYW5kIHNpemVzIGZvciBjYW5kbGVzdGlja1xuLy8gYW5kIHZvbHVtZSBiYXJzIGZvciB0aGUgZ2l2ZW4gc3Vic2V0IG9mIGRhdGFcblxuZnVuY3Rpb24gbGF5b3V0X2NudihzZWxmKSB7XG4gIHZhciAkcCA9IHNlbGYuJHByb3BzO1xuICB2YXIgc3ViID0gJHAuZGF0YTtcbiAgdmFyIHQyc2NyZWVuID0gJHAubGF5b3V0LnQyc2NyZWVuO1xuICB2YXIgbGF5b3V0ID0gJHAubGF5b3V0O1xuICB2YXIgY2FuZGxlcyA9IFtdO1xuICB2YXIgdm9sdW1lID0gW107IC8vIFRoZSB2b2x1bWUgYmFyIGhlaWdodCBpcyBkZXRlcm1pbmVkIGFzIGEgcGVyY2VudGFnZSBvZlxuICAvLyB0aGUgY2hhcnQncyBoZWlnaHQgKFZPTFNDQUxFKVxuXG4gIHZhciBtYXh2ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHN1Yi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geFs1XTtcbiAgfSkpKTtcbiAgdmFyIHZzID0gJHAuY29uZmlnLlZPTFNDQUxFICogbGF5b3V0LmhlaWdodCAvIG1heHY7XG4gIHZhciB4MSxcbiAgICAgIHgyLFxuICAgICAgdyxcbiAgICAgIGF2Z193LFxuICAgICAgbWlkLFxuICAgICAgcHJldiA9IHVuZGVmaW5lZDsgLy8gU3Vic2V0IGludGVydmFsIGFnYWluc3QgbWFpbiBpbnRlcnZhbFxuXG4gIHZhciBfbmV3X2ludGVydmFsID0gbmV3X2ludGVydmFsKGxheW91dCwgJHAsIHN1YiksXG4gICAgICBfbmV3X2ludGVydmFsMiA9IF9zbGljZWRUb0FycmF5KF9uZXdfaW50ZXJ2YWwsIDIpLFxuICAgICAgaW50ZXJ2YWwyID0gX25ld19pbnRlcnZhbDJbMF0sXG4gICAgICByYXRpbyA9IF9uZXdfaW50ZXJ2YWwyWzFdO1xuXG4gIHZhciBweF9zdGVwMiA9IGxheW91dC5weF9zdGVwICogcmF0aW87XG4gIHZhciBzcGxpdHRlciA9IHB4X3N0ZXAyID4gNSA/IDEgOiAwOyAvLyBBICYgQiBhcmUgY3VycmVudCBjaGFydCB0cmFuZm9ybWF0aW9uczpcbiAgLy8gQSA9PT0gc2NhbGUsICBCID09PSBZLWF4aXMgc2hpZnRcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gc3ViW2ldO1xuICAgIG1pZCA9IHQyc2NyZWVuKHBbMF0pICsgMTsgLy8gQ2xlYXIgdm9sdW1lIGJhciBpZiB0aGVyZSBpcyBhIHRpbWUgZ2FwXG5cbiAgICBpZiAoc3ViW2kgLSAxXSAmJiBwWzBdIC0gc3ViW2kgLSAxXVswXSA+IGludGVydmFsMikge1xuICAgICAgcHJldiA9IG51bGw7XG4gICAgfVxuXG4gICAgeDEgPSBwcmV2IHx8IE1hdGguZmxvb3IobWlkIC0gcHhfc3RlcDIgKiAwLjUpO1xuICAgIHgyID0gTWF0aC5mbG9vcihtaWQgKyBweF9zdGVwMiAqIDAuNSkgLSAwLjU7IC8vIFRPRE86IGFkZCBsb2cgc2NhbGUgc3VwcG9ydFxuXG4gICAgY2FuZGxlcy5wdXNoKHtcbiAgICAgIHg6IG1pZCxcbiAgICAgIHc6IGxheW91dC5weF9zdGVwICogJHAuY29uZmlnLkNBTkRMRVcgKiByYXRpbyxcbiAgICAgIG86IE1hdGguZmxvb3IocFsxXSAqIGxheW91dC5BICsgbGF5b3V0LkIpLFxuICAgICAgaDogTWF0aC5mbG9vcihwWzJdICogbGF5b3V0LkEgKyBsYXlvdXQuQiksXG4gICAgICBsOiBNYXRoLmZsb29yKHBbM10gKiBsYXlvdXQuQSArIGxheW91dC5CKSxcbiAgICAgIGM6IE1hdGguZmxvb3IocFs0XSAqIGxheW91dC5BICsgbGF5b3V0LkIpLFxuICAgICAgcmF3OiBwXG4gICAgfSk7XG4gICAgdm9sdW1lLnB1c2goe1xuICAgICAgeDE6IHgxLFxuICAgICAgeDI6IHgyLFxuICAgICAgaDogcFs1XSAqIHZzLFxuICAgICAgZ3JlZW46IHBbNF0gPj0gcFsxXSxcbiAgICAgIHJhdzogcFxuICAgIH0pO1xuICAgIHByZXYgPSB4MiArIHNwbGl0dGVyO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjYW5kbGVzOiBjYW5kbGVzLFxuICAgIHZvbHVtZTogdm9sdW1lXG4gIH07XG59XG5mdW5jdGlvbiBsYXlvdXRfdm9sKHNlbGYpIHtcbiAgdmFyICRwID0gc2VsZi4kcHJvcHM7XG4gIHZhciBzdWIgPSAkcC5kYXRhO1xuICB2YXIgdDJzY3JlZW4gPSAkcC5sYXlvdXQudDJzY3JlZW47XG4gIHZhciBsYXlvdXQgPSAkcC5sYXlvdXQ7XG4gIHZhciB2b2x1bWUgPSBbXTsgLy8gRGV0ZWN0IGRhdGEgc2Vjb25kIGRpbWVudGlvbiBzaXplOlxuXG4gIHZhciBkaW0gPSBzdWJbMF0gPyBzdWJbMF0ubGVuZ3RoIDogMDsgLy8gU3VwcG9ydCBzcGVjaWFsIHZvbHVtZSBkYXRhIChzZWUgQVBJIGJvb2spLCBvciBPSExDVlxuICAvLyBEYXRhIGluZGljZXM6XG5cbiAgc2VsZi5faTEgPSBkaW0gPCA2ID8gMSA6IDU7XG4gIHNlbGYuX2kyID0gZGltIDwgNiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHBbMl07XG4gIH0gOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwWzRdID49IHBbMV07XG4gIH07XG4gIHZhciBtYXh2ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHN1Yi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geFtzZWxmLl9pMV07XG4gIH0pKSk7XG4gIHZhciB2b2xzY2FsZSA9IHNlbGYudm9sc2NhbGUgfHwgJHAuY29uZmlnLlZPTFNDQUxFO1xuICB2YXIgdnMgPSB2b2xzY2FsZSAqIGxheW91dC5oZWlnaHQgLyBtYXh2O1xuICB2YXIgeDEsXG4gICAgICB4MixcbiAgICAgIG1pZCxcbiAgICAgIHByZXYgPSB1bmRlZmluZWQ7IC8vIFN1YnNldCBpbnRlcnZhbCBhZ2FpbnN0IG1haW4gaW50ZXJ2YWxcblxuICB2YXIgX25ld19pbnRlcnZhbDMgPSBuZXdfaW50ZXJ2YWwobGF5b3V0LCAkcCwgc3ViKSxcbiAgICAgIF9uZXdfaW50ZXJ2YWw0ID0gX3NsaWNlZFRvQXJyYXkoX25ld19pbnRlcnZhbDMsIDIpLFxuICAgICAgaW50ZXJ2YWwyID0gX25ld19pbnRlcnZhbDRbMF0sXG4gICAgICByYXRpbyA9IF9uZXdfaW50ZXJ2YWw0WzFdO1xuXG4gIHZhciBweF9zdGVwMiA9IGxheW91dC5weF9zdGVwICogcmF0aW87XG4gIHZhciBzcGxpdHRlciA9IHB4X3N0ZXAyID4gNSA/IDEgOiAwOyAvLyBBICYgQiBhcmUgY3VycmVudCBjaGFydCB0cmFuZm9ybWF0aW9uczpcbiAgLy8gQSA9PT0gc2NhbGUsICBCID09PSBZLWF4aXMgc2hpZnRcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gc3ViW2ldO1xuICAgIG1pZCA9IHQyc2NyZWVuKHBbMF0pICsgMTsgLy8gQ2xlYXIgdm9sdW1lIGJhciBpZiB0aGVyZSBpcyBhIHRpbWUgZ2FwXG5cbiAgICBpZiAoc3ViW2kgLSAxXSAmJiBwWzBdIC0gc3ViW2kgLSAxXVswXSA+IGludGVydmFsMikge1xuICAgICAgcHJldiA9IG51bGw7XG4gICAgfVxuXG4gICAgeDEgPSBwcmV2IHx8IE1hdGguZmxvb3IobWlkIC0gcHhfc3RlcDIgKiAwLjUpO1xuICAgIHgyID0gTWF0aC5mbG9vcihtaWQgKyBweF9zdGVwMiAqIDAuNSkgLSAwLjU7XG4gICAgdm9sdW1lLnB1c2goe1xuICAgICAgeDE6IHgxLFxuICAgICAgeDI6IHgyLFxuICAgICAgaDogcFtzZWxmLl9pMV0gKiB2cyxcbiAgICAgIGdyZWVuOiBzZWxmLl9pMihwKSxcbiAgICAgIHJhdzogcFxuICAgIH0pO1xuICAgIHByZXYgPSB4MiArIHNwbGl0dGVyO1xuICB9XG5cbiAgcmV0dXJuIHZvbHVtZTtcbn1cblxuZnVuY3Rpb24gbmV3X2ludGVydmFsKGxheW91dCwgJHAsIHN1Yikge1xuICAvLyBTdWJzZXQgaW50ZXJ2YWwgYWdhaW5zdCBtYWluIGludGVydmFsXG4gIGlmICghbGF5b3V0LnRpX21hcC5pYikge1xuICAgIHZhciBpbnRlcnZhbDIgPSAkcC50ZiB8fCB1dGlscy5kZXRlY3RfaW50ZXJ2YWwoc3ViKTtcbiAgICB2YXIgcmF0aW8gPSBpbnRlcnZhbDIgLyAkcC5pbnRlcnZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoJHAudGYpIHtcbiAgICAgIHZhciByYXRpbyA9ICRwLnRmIC8gbGF5b3V0LnRpX21hcC50ZjtcbiAgICAgIHZhciBpbnRlcnZhbDIgPSByYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGludGVydmFsMiA9IHV0aWxzLmRldGVjdF9pbnRlcnZhbChzdWIpO1xuICAgICAgdmFyIHJhdGlvID0gaW50ZXJ2YWwyIC8gJHAuaW50ZXJ2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtpbnRlcnZhbDIsIHJhdGlvXTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3ByaW1pdGl2ZXMvY2FuZGxlLmpzXG5cblxuXG4vLyBDYW5kbGUgb2JqZWN0IGZvciBDYW5kbGVzIG92ZXJsYXlcbnZhciBDYW5kbGVFeHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYW5kbGVFeHQob3ZlcmxheSwgY3R4LCBkYXRhKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FuZGxlRXh0KTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuc2VsZiA9IG92ZXJsYXk7XG4gICAgdGhpcy5zdHlsZSA9IGRhdGEucmF3WzZdIHx8IHRoaXMuc2VsZjtcbiAgICB0aGlzLmRyYXcoZGF0YSk7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhDYW5kbGVFeHQsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhkYXRhKSB7XG4gICAgICB2YXIgZ3JlZW4gPSBkYXRhLnJhd1s0XSA+PSBkYXRhLnJhd1sxXTtcbiAgICAgIHZhciBib2R5X2NvbG9yID0gZ3JlZW4gPyB0aGlzLnN0eWxlLmNvbG9yQ2FuZGxlVXAgOiB0aGlzLnN0eWxlLmNvbG9yQ2FuZGxlRHc7XG4gICAgICB2YXIgd2lja19jb2xvciA9IGdyZWVuID8gdGhpcy5zdHlsZS5jb2xvcldpY2tVcCA6IHRoaXMuc3R5bGUuY29sb3JXaWNrRHc7XG4gICAgICB2YXIgdyA9IE1hdGgubWF4KGRhdGEudywgMSk7XG4gICAgICB2YXIgaHcgPSBNYXRoLm1heChNYXRoLmZsb29yKHcgKiAwLjUpLCAxKTtcbiAgICAgIHZhciBoID0gTWF0aC5hYnMoZGF0YS5vIC0gZGF0YS5jKTtcbiAgICAgIHZhciBtYXhfaCA9IGRhdGEuYyA9PT0gZGF0YS5vID8gMSA6IDI7XG4gICAgICB2YXIgeDA1ID0gTWF0aC5mbG9vcihkYXRhLngpIC0gMC41O1xuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB3aWNrX2NvbG9yO1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmN0eC5tb3ZlVG8oeDA1LCBNYXRoLmZsb29yKGRhdGEuaCkpO1xuICAgICAgdGhpcy5jdHgubGluZVRvKHgwNSwgTWF0aC5mbG9vcihkYXRhLmwpKTtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuXG4gICAgICBpZiAoZGF0YS53ID4gMS41KSB7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGJvZHlfY29sb3I7IC8vIFRPRE86IE1vdmUgY29tbW9uIGNhbGN1bGF0aW9ucyB0byBsYXlvdXQuanNcblxuICAgICAgICB2YXIgcyA9IGdyZWVuID8gMSA6IC0xO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdChNYXRoLmZsb29yKGRhdGEueCAtIGh3IC0gMSksIGRhdGEuYywgTWF0aC5mbG9vcihodyAqIDIgKyAxKSwgcyAqIE1hdGgubWF4KGgsIG1heF9oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGJvZHlfY29sb3I7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeDA1LCBNYXRoLmZsb29yKE1hdGgubWluKGRhdGEubywgZGF0YS5jKSkpO1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oeDA1LCBNYXRoLmZsb29yKE1hdGgubWF4KGRhdGEubywgZGF0YS5jKSkgKyAoZGF0YS5vID09PSBkYXRhLmMgPyAxIDogMCkpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FuZGxlRXh0O1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3ByaW1pdGl2ZXMvdm9sYmFyLmpzXG5cblxuXG52YXIgVm9sYmFyRXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVm9sYmFyRXh0KG92ZXJsYXksIGN0eCwgZGF0YSkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbGJhckV4dCk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLiRwID0gb3ZlcmxheS4kcHJvcHM7XG4gICAgdGhpcy5zZWxmID0gb3ZlcmxheTtcbiAgICB0aGlzLnN0eWxlID0gZGF0YS5yYXdbNl0gfHwgdGhpcy5zZWxmO1xuICAgIHRoaXMuZHJhdyhkYXRhKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKFZvbGJhckV4dCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGRhdGEpIHtcbiAgICAgIHZhciB5MCA9IHRoaXMuJHAubGF5b3V0LmhlaWdodDtcbiAgICAgIHZhciB3ID0gZGF0YS54MiAtIGRhdGEueDE7XG4gICAgICB2YXIgaCA9IE1hdGguZmxvb3IoZGF0YS5oKTtcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGRhdGEuZ3JlZW4gPyB0aGlzLnN0eWxlLmNvbG9yVm9sVXAgOiB0aGlzLnN0eWxlLmNvbG9yVm9sRHc7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdChNYXRoLmZsb29yKGRhdGEueDEpLCBNYXRoLmZsb29yKHkwIC0gaCAtIDAuNSksIE1hdGguZmxvb3IodyksIE1hdGguZmxvb3IoaCArIDEpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVm9sYmFyRXh0O1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3ByaW1pdGl2ZXMvcHJpY2UuanNcblxuXG5cbi8vIFByaWNlIGJhciAmIHByaWNlIGxpbmUgKHNoYWRlcilcbnZhciBQcmljZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByaWNlKGNvbXApIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBQcmljZSk7XG5cbiAgICB0aGlzLmNvbXAgPSBjb21wO1xuICB9IC8vIERlZmluZXMgYW4gaW5saW5lIHNoYWRlciAoaGFzIGFjY2VzcyB0byBib3RoXG4gIC8vIHRhcmdldCAmIG92ZXJsYXkncyBjb250ZXh0cylcblxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKFByaWNlLCBbe1xuICAgIGtleTogXCJpbml0X3NoYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0X3NoYWRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmNvbXAuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbXAuJHByb3BzLmNvbmZpZztcbiAgICAgIHZhciBjb21wID0gdGhpcy5jb21wO1xuXG4gICAgICB2YXIgbGFzdF9iYXIgPSBmdW5jdGlvbiBsYXN0X2JhcigpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmxhc3RfYmFyKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ25ldy1zaGFkZXInLCB7XG4gICAgICAgIHRhcmdldDogJ3NpZGViYXInLFxuICAgICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgICAgIHZhciBiYXIgPSBsYXN0X2JhcigpO1xuICAgICAgICAgIGlmICghYmFyKSByZXR1cm47XG4gICAgICAgICAgdmFyIHcgPSBjdHguY2FudmFzLndpZHRoO1xuICAgICAgICAgIHZhciBoID0gY29uZmlnLlBBTkhFSUdIVDtcbiAgICAgICAgICB2YXIgbGJsID0gYmFyLnByaWNlLnRvRml4ZWQobGF5b3V0LnByZWMpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYXIuY29sb3I7XG4gICAgICAgICAgdmFyIHggPSAtMC41O1xuICAgICAgICAgIHZhciB5ID0gYmFyLnkgLSBoICogMC41IC0gMC41O1xuICAgICAgICAgIHZhciBhID0gNztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoeCAtIDAuNSwgeSwgdyArIDEsIGgpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb21wLiRwcm9wcy5jb2xvcnMudGV4dEhMO1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGxibCwgYSwgeSArIDE1KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNoYWRlciA9IHRydWU7XG4gICAgfSAvLyBSZWd1bGFyIGRyYXcgY2FsbCBmb3Igb3ZlcmFseVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmNvbXAuJHByb3BzLm1ldGEubGFzdCkgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnNoYWRlcikgdGhpcy5pbml0X3NoYWRlcigpO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuY29tcC4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLmNvbXAuJHByb3BzLmxhc3Q7XG4gICAgICB2YXIgZGlyID0gbGFzdFs0XSA+PSBsYXN0WzFdO1xuICAgICAgdmFyIGNvbG9yID0gZGlyID8gdGhpcy5ncmVlbigpIDogdGhpcy5yZWQoKTtcbiAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKGxhc3RbNF0pICsgKGRpciA/IDEgOiAwKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKDAsIHkpO1xuICAgICAgY3R4LmxpbmVUbyhsYXlvdXQud2lkdGgsIHkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdF9iYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdF9iYXIoKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcC5kYXRhLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmNvbXAuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBsYXN0ID0gdGhpcy5jb21wLmRhdGFbdGhpcy5jb21wLmRhdGEubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihsYXN0WzRdKTsgLy9sZXQgY25kbCA9IGxheW91dC5jX21hZ25ldChsYXN0WzBdKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB5OiB5LFxuICAgICAgICAvL01hdGguZmxvb3IoY25kbC5jKSAtIDAuNSxcbiAgICAgICAgcHJpY2U6IGxhc3RbNF0sXG4gICAgICAgIGNvbG9yOiBsYXN0WzRdID49IGxhc3RbMV0gPyB0aGlzLmdyZWVuKCkgOiB0aGlzLnJlZCgpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsYXN0X3ByaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3RfcHJpY2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wLiRwcm9wcy5tZXRhLmxhc3QgPyB0aGlzLmNvbXAuJHByb3BzLm1ldGEubGFzdFs0XSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JlZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wLmNvbG9yQ2FuZGxlVXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wLmNvbG9yQ2FuZGxlRHc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFByaWNlO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9DYW5kbGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIFJlbmVkcmVyIGZvciBjYW5kbGVzdGlja3MgKyB2b2x1bWUgKG9wdGlvbmFsKVxuLy8gSXQgY2FuIGJlIHVzZWQgYXMgdGhlIG1haW4gY2hhcnQgb3IgYW4gaW5kaWNhdG9yXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDYW5kbGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0NhbmRsZXMnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjIuMSdcbiAgICAgIH07XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5wcmljZSA9IG5ldyBQcmljZSh0aGlzKTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAvLyBJZiBkYXRhID09PSBtYWluIGNhbmRsZXN0aWNrIGRhdGFcbiAgICAgIC8vIHJlbmRlciBhcyBtYWluIGNoYXJ0OlxuICAgICAgaWYgKHRoaXMuJHByb3BzLnN1YiA9PT0gdGhpcy4kcHJvcHMuZGF0YSkge1xuICAgICAgICB2YXIgY252ID0ge1xuICAgICAgICAgIGNhbmRsZXM6IHRoaXMuJHByb3BzLmxheW91dC5jYW5kbGVzLFxuICAgICAgICAgIHZvbHVtZTogdGhpcy4kcHJvcHMubGF5b3V0LnZvbHVtZVxuICAgICAgICB9OyAvLyBFbHNlLCBhcyBvZmZjaGFydCAvIG9uY2hhcnQgaW5kaWNhdG9yOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY252ID0gbGF5b3V0X2Nudih0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd192b2x1bWUpIHtcbiAgICAgICAgdmFyIGN2ID0gY252LnZvbHVtZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGN2Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIG5ldyBWb2xiYXJFeHQodGhpcywgY3R4LCBjdltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNjID0gY252LmNhbmRsZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIG5ldyBDYW5kbGVFeHQodGhpcywgY3R4LCBjY1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByaWNlX2xpbmUpIHRoaXMucHJpY2UuZHJhdyhjdHgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0NhbmRsZXMnXTtcbiAgICB9LFxuICAgIC8vIEluIGNhc2UgaXQncyBhZGRlZCBhcyBvZmZjaGFydCBvdmVybGF5XG4gICAgeV9yYW5nZTogZnVuY3Rpb24geV9yYW5nZSgpIHtcbiAgICAgIHZhciBoaSA9IC1JbmZpbml0eSxcbiAgICAgICAgICBsbyA9IEluZmluaXR5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuc3ViLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgeCA9IHRoaXMuc3ViW2ldO1xuICAgICAgICBpZiAoeFsyXSA+IGhpKSBoaSA9IHhbMl07XG4gICAgICAgIGlmICh4WzNdIDwgbG8pIGxvID0geFszXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtoaSwgbG9dO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBzaG93X3ZvbHVtZTogZnVuY3Rpb24gc2hvd192b2x1bWUoKSB7XG4gICAgICByZXR1cm4gJ3Nob3dWb2x1bWUnIGluIHRoaXMuc2V0dCA/IHRoaXMuc2V0dC5zaG93Vm9sdW1lIDogdHJ1ZTtcbiAgICB9LFxuICAgIHByaWNlX2xpbmU6IGZ1bmN0aW9uIHByaWNlX2xpbmUoKSB7XG4gICAgICByZXR1cm4gJ3ByaWNlTGluZScgaW4gdGhpcy5zZXR0ID8gdGhpcy5zZXR0LnByaWNlTGluZSA6IHRydWU7XG4gICAgfSxcbiAgICBjb2xvckNhbmRsZVVwOiBmdW5jdGlvbiBjb2xvckNhbmRsZVVwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvckNhbmRsZVVwIHx8IHRoaXMuJHByb3BzLmNvbG9ycy5jYW5kbGVVcDtcbiAgICB9LFxuICAgIGNvbG9yQ2FuZGxlRHc6IGZ1bmN0aW9uIGNvbG9yQ2FuZGxlRHcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yQ2FuZGxlRHcgfHwgdGhpcy4kcHJvcHMuY29sb3JzLmNhbmRsZUR3O1xuICAgIH0sXG4gICAgY29sb3JXaWNrVXA6IGZ1bmN0aW9uIGNvbG9yV2lja1VwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvcldpY2tVcCB8fCB0aGlzLiRwcm9wcy5jb2xvcnMud2lja1VwO1xuICAgIH0sXG4gICAgY29sb3JXaWNrRHc6IGZ1bmN0aW9uIGNvbG9yV2lja0R3KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvcldpY2tEdyB8fCB0aGlzLiRwcm9wcy5jb2xvcnMud2lja0R3O1xuICAgIH0sXG4gICAgY29sb3JXaWNrU206IGZ1bmN0aW9uIGNvbG9yV2lja1NtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvcldpY2tTbSB8fCB0aGlzLiRwcm9wcy5jb2xvcnMud2lja1NtO1xuICAgIH0sXG4gICAgY29sb3JWb2xVcDogZnVuY3Rpb24gY29sb3JWb2xVcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JWb2xVcCB8fCB0aGlzLiRwcm9wcy5jb2xvcnMudm9sVXA7XG4gICAgfSxcbiAgICBjb2xvclZvbER3OiBmdW5jdGlvbiBjb2xvclZvbER3KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvclZvbER3IHx8IHRoaXMuJHByb3BzLmNvbG9ycy52b2xEdztcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaWNlOiB7fVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvQ2FuZGxlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19DYW5kbGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKENhbmRsZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0NhbmRsZXMudnVlXG52YXIgQ2FuZGxlc19yZW5kZXIsIENhbmRsZXNfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQ2FuZGxlc19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX0NhbmRsZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIENhbmRsZXNfcmVuZGVyLFxuICBDYW5kbGVzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQ2FuZGxlc19hcGk7IH1cbkNhbmRsZXNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9DYW5kbGVzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENhbmRsZXMgPSAoQ2FuZGxlc19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvVm9sdW1lLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5mdW5jdGlvbiBWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBTdGFuZGFsb25lIHJlbmVkcmVyIGZvciB0aGUgdm9sdW1lXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdWb2x1bWUnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjEuMCdcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgLy8gVE9ETzogdm9sdW1lIGF2ZXJhZ2VcbiAgICAgIC8vIFRPRE86IFktYXhpcyBzY2FsaW5nXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsYXlvdXRfdm9sKHRoaXMpKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIG5ldyBWb2xiYXJFeHQodGhpcywgY3R4LCB2KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1ZvbHVtZSddO1xuICAgIH0sXG4gICAgLy8gRGVmaW5lcyBsZWdlbmQgZm9ybWF0ICh2YWx1ZXMgJiBjb2xvcnMpXG4gICAgLy8gX2kyIC0gZGV0ZXRlY3RlZCBkYXRhIGluZGV4IChzZWUgbGF5b3V0X2NudilcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCh2YWx1ZXMpIHtcbiAgICAgIHZhciBmbGFnID0gdGhpcy5faTIgPyB0aGlzLl9pMih2YWx1ZXMpIDogdmFsdWVzWzJdO1xuICAgICAgdmFyIGNvbG9yID0gZmxhZyA/IHRoaXMuY29sb3JWb2xVcExlZ2VuZCA6IHRoaXMuY29sb3JWb2xEd0xlZ2VuZDtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2YWx1ZTogdmFsdWVzW3RoaXMuX2kxIHx8IDFdLFxuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgIH1dO1xuICAgIH0sXG4gICAgLy8gV2hlbiBhZGRlZCBhcyBvZmZjaGFydCBvdmVybGF5XG4gICAgLy8gSWYgZGF0YSBpcyBPSExDViA9PiByZWNhbGMgeS1yYW5nZVxuICAgIC8vIF9pMSAtIGRldGV0ZWN0ZWQgZGF0YSBpbmRleCAoc2VlIGxheW91dF9jbnYpXG4gICAgeV9yYW5nZTogZnVuY3Rpb24geV9yYW5nZShoaSwgbG8pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pMSA9PT0gNSkge1xuICAgICAgICB2YXIgc3ViID0gdGhpcy4kcHJvcHMuc3ViO1xuICAgICAgICByZXR1cm4gW01hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShzdWIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHhbX3RoaXMuX2kxXTtcbiAgICAgICAgfSkpKSwgTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHN1Yi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geFtfdGhpcy5faTFdO1xuICAgICAgICB9KSkpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbaGksIGxvXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgY29sb3JWb2xVcDogZnVuY3Rpb24gY29sb3JWb2xVcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JWb2xVcCB8fCB0aGlzLiRwcm9wcy5jb2xvcnMudm9sVXA7XG4gICAgfSxcbiAgICBjb2xvclZvbER3OiBmdW5jdGlvbiBjb2xvclZvbER3KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvclZvbER3IHx8IHRoaXMuJHByb3BzLmNvbG9ycy52b2xEdztcbiAgICB9LFxuICAgIGNvbG9yVm9sVXBMZWdlbmQ6IGZ1bmN0aW9uIGNvbG9yVm9sVXBMZWdlbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yVm9sVXBMZWdlbmQgfHwgdGhpcy4kcHJvcHMuY29sb3JzLmNhbmRsZVVwO1xuICAgIH0sXG4gICAgY29sb3JWb2xEd0xlZ2VuZDogZnVuY3Rpb24gY29sb3JWb2xEd0xlZ2VuZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JWb2xEd0xlZ2VuZCB8fCB0aGlzLiRwcm9wcy5jb2xvcnMuY2FuZGxlRHc7XG4gICAgfSxcbiAgICB2b2xzY2FsZTogZnVuY3Rpb24gdm9sc2NhbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnZvbHNjYWxlIHx8IHRoaXMuJHByb3BzLmdyaWRfaWQgPiAwID8gMC44NSA6IHRoaXMuJHByb3BzLmNvbmZpZy5WT0xTQ0FMRTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1ZvbHVtZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19Wb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9Wb2x1bWUudnVlXG52YXIgVm9sdW1lX3JlbmRlciwgVm9sdW1lX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFZvbHVtZV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX1ZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVm9sdW1lX3JlbmRlcixcbiAgVm9sdW1lX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVm9sdW1lX2FwaTsgfVxuVm9sdW1lX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvVm9sdW1lLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFZvbHVtZSA9IChWb2x1bWVfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGl0dGVycy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBEYXRhIHNlY3Rpb24gc3BsaXR0ZXJzICh3aXRoIGxhYmVscylcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTcGxpdHRlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU3BsaXR0ZXJzJyxcbiAgbWl4aW5zOiBbb3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjEnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5saW5lX2NvbG9yO1xuICAgICAgdGhpcy4kcHJvcHMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7IC8vIHggLSBNYXBwaW5nXG5cbiAgICAgICAgY3R4LnNldExpbmVEYXNoKFsxMCwgMTBdKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCBfdGhpcy5sYXlvdXQuaGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAocFsxXSkgX3RoaXMuZHJhd19sYWJlbChjdHgsIHgsIHApO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmF3X2xhYmVsOiBmdW5jdGlvbiBkcmF3X2xhYmVsKGN0eCwgeCwgcCkge1xuICAgICAgdmFyIHNpZGUgPSBwWzJdID8gMSA6IC0xO1xuICAgICAgeCArPSAyLjUgKiBzaWRlO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLm5ld19mb250O1xuICAgICAgdmFyIHBvcyA9IHBbNF0gfHwgdGhpcy55X3Bvc2l0aW9uO1xuICAgICAgdmFyIHcgPSBjdHgubWVhc3VyZVRleHQocFsxXSkud2lkdGggKyAxMDtcbiAgICAgIHZhciB5ID0gdGhpcy5sYXlvdXQuaGVpZ2h0ICogKDEuMCAtIHBvcyk7XG4gICAgICB5ID0gTWF0aC5mbG9vcih5KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwWzNdIHx8IHRoaXMuZmxhZ19jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyAxMCAqIHNpZGUsIHkgLSAxMCAqIHNpZGUpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgKHcgKyAxMCkgKiBzaWRlLCB5IC0gMTAgKiBzaWRlKTtcbiAgICAgIGN0eC5saW5lVG8oeCArICh3ICsgMTApICogc2lkZSwgeSArIDEwICogc2lkZSk7XG4gICAgICBjdHgubGluZVRvKHggKyAxMCAqIHNpZGUsIHkgKyAxMCAqIHNpZGUpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsX2NvbG9yO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHNpZGUgPCAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgIGN0eC5maWxsVGV4dChwWzFdLCB4ICsgMTUgKiBzaWRlLCB5ICsgNCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnU3BsaXR0ZXJzJ107XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIG5ld19mb250OiBmdW5jdGlvbiBuZXdfZm9udCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZm9udCB8fCAnMTJweCAnICsgdGhpcy4kcHJvcHMuZm9udC5zcGxpdCgncHgnKS5wb3AoKTtcbiAgICB9LFxuICAgIGZsYWdfY29sb3I6IGZ1bmN0aW9uIGZsYWdfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmZsYWdDb2xvciB8fCAnIzQyODVmNCc7XG4gICAgfSxcbiAgICBsYWJlbF9jb2xvcjogZnVuY3Rpb24gbGFiZWxfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxhYmVsQ29sb3IgfHwgJyNmZmYnO1xuICAgIH0sXG4gICAgbGluZV9jb2xvcjogZnVuY3Rpb24gbGluZV9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZUNvbG9yIHx8ICcjNDI4NWY0JztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAxLjA7XG4gICAgfSxcbiAgICB5X3Bvc2l0aW9uOiBmdW5jdGlvbiB5X3Bvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC55UG9zaXRpb24gfHwgMC45O1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaXR0ZXJzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX1NwbGl0dGVyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTcGxpdHRlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGl0dGVycy52dWVcbnZhciBTcGxpdHRlcnNfcmVuZGVyLCBTcGxpdHRlcnNfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU3BsaXR0ZXJzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfU3BsaXR0ZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTcGxpdHRlcnNfcmVuZGVyLFxuICBTcGxpdHRlcnNfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTcGxpdHRlcnNfYXBpOyB9XG5TcGxpdHRlcnNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpdHRlcnMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3BsaXR0ZXJzID0gKFNwbGl0dGVyc19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3R1ZmYva2V5cy5qc1xuXG5cblxuZnVuY3Rpb24ga2V5c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0ga2V5c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24ga2V5c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGtleXNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGtleXNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGtleXNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gS2V5Ym9hcmQgZXZlbnQgaGFuZGxlciBmb3Igb3ZlcmxheVxudmFyIEtleXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlzKGNvbXApIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlzKTtcblxuICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IDA7XG4gICAgdGhpcy5rZXltYXAgPSB7fTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKEtleXMsIFt7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgICAgdGhpcy5tYXBbbmFtZV0gPSB0aGlzLm1hcFtuYW1lXSB8fCBbXTtcbiAgICAgIHRoaXMubWFwW25hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgICB0aGlzLmxpc3RlbmVycysrO1xuICAgIH0gLy8gQ2FsbGVkIGJ5IGdyaWQuanNcblxuICB9LCB7XG4gICAga2V5OiBcImVtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChuYW1lLCBldmVudCkge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IGtleXNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLm1hcFtuYW1lXSksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgZihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdrZXlkb3duJykge1xuICAgICAgICBpZiAoIXRoaXMua2V5bWFwW2V2ZW50LmtleV0pIHtcbiAgICAgICAgICB0aGlzLmVtaXQoZXZlbnQua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMua2V5bWFwW2V2ZW50LmtleV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ2tleXVwJykge1xuICAgICAgICB0aGlzLmtleW1hcFtldmVudC5rZXldID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXNzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlc3NlZChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleW1hcFtrZXldO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLZXlzO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvdG9vbC5qc1xuZnVuY3Rpb24gdG9vbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gdG9vbF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gdG9vbF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRvb2xfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHRvb2xfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIHRvb2xfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gVXN1ZnVsIHN0dWZmIGZvciBjcmVhdGluZyB0b29scy4gSW5jbHVkZSBhcyBtaXhpblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgdG9vbCA9ICh7XG4gIG1ldGhvZHM6IHtcbiAgICBpbml0X3Rvb2w6IGZ1bmN0aW9uIGluaXRfdG9vbCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIENvbGxpc2lvbiBmdW5jdGlvbnMgKGZsb2F0LCBmbG9hdCkgPT4gYm9vbCxcbiAgICAgIHRoaXMuY29sbGlzaW9ucyA9IFtdO1xuICAgICAgdGhpcy5waW5zID0gW107XG4gICAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoX3RoaXMuY29sbGlzaW9ucy5zb21lKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIGYoX3RoaXMubW91c2UueCwgX3RoaXMubW91c2UueSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgX3RoaXMuc2hvd19waW5zID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zaG93X3BpbnMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcy5kcmFnKSBfdGhpcy5kcmFnX3VwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodXRpbHMuZGVmYXVsdF9wcmV2ZW50ZWQoZSkpIHJldHVybjtcblxuICAgICAgICBpZiAoX3RoaXMuY29sbGlzaW9ucy5zb21lKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIGYoX3RoaXMubW91c2UueCwgX3RoaXMubW91c2UueSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgX3RoaXMuJGVtaXQoJ29iamVjdC1zZWxlY3RlZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLnN0YXJ0X2RyYWcoKTtcblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLnBpbnMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHgubW91c2Vkb3duKGUsIHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubW91c2Uub24oJ21vdXNldXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpcy5kcmFnID0gbnVsbDtcblxuICAgICAgICBfdGhpcy4kZW1pdCgnc2Nyb2xsLWxvY2snLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMua2V5cyA9IG5ldyBLZXlzKHRoaXMpO1xuICAgICAgdGhpcy5rZXlzLm9uKCdEZWxldGUnLCB0aGlzLnJlbW92ZV90b29sKTtcbiAgICAgIHRoaXMua2V5cy5vbignQmFja3NwYWNlJywgdGhpcy5yZW1vdmVfdG9vbCk7XG4gICAgICB0aGlzLnNob3dfcGlucyA9IGZhbHNlO1xuICAgICAgdGhpcy5kcmFnID0gbnVsbDtcbiAgICB9LFxuICAgIHJlbmRlcl9waW5zOiBmdW5jdGlvbiByZW5kZXJfcGlucyhjdHgpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuc2hvd19waW5zKSB7XG4gICAgICAgIHRoaXMucGlucy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHguZHJhdyhjdHgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldF9zdGF0ZTogZnVuY3Rpb24gc2V0X3N0YXRlKG5hbWUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZS1zZXR0aW5ncycsIHtcbiAgICAgICAgJHN0YXRlOiBuYW1lXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHdhdGNoX3V1aWQ6IGZ1bmN0aW9uIHdhdGNoX3V1aWQobiwgcCkge1xuICAgICAgLy8gSWYgbGF5ZXIgJHV1aWQgaXMgY2hhbmdlZCwgdGhlbiByZS1pbml0XG4gICAgICAvLyBwaW5zICYgY29sbGlzaW9uc1xuICAgICAgaWYgKG4uJHV1aWQgIT09IHAuJHV1aWQpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IHRvb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnBpbnMpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHAucmVfaW5pdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25zID0gW107XG4gICAgICAgIHRoaXMuc2hvd19waW5zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZyA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcmVfZHJhdzogZnVuY3Rpb24gcHJlX2RyYXcoKSB7XG4gICAgICAvLyBEZWxldGUgYWxsIGNvbGxpc2lvbiBmdW5jdGlvbnMgYmVmb3JlXG4gICAgICAvLyB0aGUgZHJhdygpIGNhbGwgYW5kIGxldCBwcmltaXRpdmVzIHNldFxuICAgICAgLy8gdGhlbSBhZ2FpblxuICAgICAgdGhpcy5jb2xsaXNpb25zID0gW107XG4gICAgfSxcbiAgICByZW1vdmVfdG9vbDogZnVuY3Rpb24gcmVtb3ZlX3Rvb2woKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCkgdGhpcy4kZW1pdCgncmVtb3ZlLXRvb2wnKTtcbiAgICB9LFxuICAgIHN0YXJ0X2RyYWc6IGZ1bmN0aW9uIHN0YXJ0X2RyYWcoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdzY3JvbGwtbG9jaycsIHRydWUpO1xuICAgICAgdmFyIGN1cnNvciA9IHRoaXMuJHByb3BzLmN1cnNvcjtcbiAgICAgIHRoaXMuZHJhZyA9IHtcbiAgICAgICAgdDogY3Vyc29yLnQsXG4gICAgICAgIHkkOiBjdXJzb3IueSRcbiAgICAgIH07XG4gICAgICB0aGlzLnBpbnMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5yZWNfcG9zaXRpb24oKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZHJhZ191cGRhdGU6IGZ1bmN0aW9uIGRyYWdfdXBkYXRlKCkge1xuICAgICAgdmFyIGR0ID0gdGhpcy4kcHJvcHMuY3Vyc29yLnQgLSB0aGlzLmRyYWcudDtcbiAgICAgIHZhciBkeSA9IHRoaXMuJHByb3BzLmN1cnNvci55JCAtIHRoaXMuZHJhZy55JDtcbiAgICAgIHRoaXMucGlucy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnVwZGF0ZV9mcm9tKFt4LnQxICsgZHQsIHgueSQxICsgZHldLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAvLyBTZXR0aW5ncyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkXG4gICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzLiRzZWxlY3RlZDtcbiAgICB9LFxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncy4kc3RhdGU7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHVmZi9pY29ucy5qc29uXG5jb25zdCBpY29uc19uYW1lc3BhY2VPYmplY3QgPSBKU09OLnBhcnNlKCd7XCJleHRlbmRlZC5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkFRTUFBQUQrSnhjZ0FBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBWlFURlJGQUFBQVRVMU5rSityT1FBQUFBSjBVazVUQVA5YmtTSzFBQUFBTkVsRVFWUjRuR05nZ0FCR0VNRUVJbGhBQkFlSStBQVNGMEFsSG1BcUE0a3pLQUF4OHdHUXVBTUt3ZDZBb1l6QkFXb25Bd0FjTHdUZ05mSjNSUUFBQUFCSlJVNUVya0pnZ2c9PVwiLFwicmF5LnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQVFNQUFBRCtKeGNnQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFaUVRGUkZBQUFBVFUxTmtKK3JPUUFBQUFKMFVrNVRBUDlia1NLMUFBQUFNa2xFUVZSNG5HTmdRQUpNSUlJRlJIQ0FDQUVRb1FBaUhJQ1l2UUVramtyd1l5cGpBSWt6d2syekFSRXVxSVFGekQ0QUUza0U0QkVtR2dnQUFBQUFTVVZPUks1Q1lJST1cIixcInNlZ21lbnQucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpBZ01BQUFDNWgyM3dBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQWxRVEZSRkFBQUFUVTFOSkNRa0N4Y0hJUUFBQUFOMFVrNVRBUDhTbXV0STVBQUFBQ3hKUkVGVWVKeGpZTUFDR0FNZ05Bc0xkcG9WS2k4QVZlOEExUWJsUWxXUkt0MEFvVUx3Mncxekd4b0FBQmRpQXZpUWhGL21BQUFBQUVsRlRrU3VRbUNDXCIsXCJhZGQucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNvQUFBQXFDQU1BQUFEeUhUbHBBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBSDVRVEZSRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDZ29LQmdZR0d4c2JLaW9xUHo4L1BqNCtCUVVGQ1FrSkFRRUJaR1JraDRlSEFnSUNFQkFRTmpZMmc0T0RnWUdCQUFBQUF3TURlWGw1ZDNkM0dCZ1lFUkVSZ0lDQWdJQ0FORFEwUER3OFkyTmpDQWdJaFlXRkdob2FKeWNuT2pvNllXRmhnSUNBZFhWMTRZMTZzUUFBQUNwMFVrNVRBQUlMRHhJS0VTRW5KaVlvS0NnVEtTa3BLQ0FuS1NrRktDa3BKaURsL3ljcEtTQTJKeVlwS1NrcE9rUSt4Z0FBQVJkSlJFRlVlSnpsbE50Mmd5QVFSVFdpUnNITG9EVTBHcFBZbU12Ly8yQk1TK3NnbDZaOWJNOGJpNzNnbkprQnovc244bGNCSVVIb2Z3dEc4VHBKS1V1VExJNmNZRjdRRXFSS3luUDcxVlg5QWtoTlhWbHNiTVFyTExRVkd5UFpMc0dIV2dQckN4TUp3SFVQbFhhNzlOQnAyZXQ1ZDlmM3UzbTFYeGF0UU5uN1NhZ09YQ1VqQ2pZVUR1cXhjV2xIajRNU2Z3MTJGREpjaEZWaVJOOCsxcWNRb1VINmxSMUwxbUVNRUVyb2ZCNld6RVV3eWx6b21mek9RR2lPSmRYaVdIN21Rb1V5TWE0V1hKUVdPQnZMRnZQQ0d4dDZGU3I1a3lIMHFpMFlkZE5HMi9wZ0NzT2pmZjRaVGl6WFBOd0tJemw1Nk9vR2c5ZDlaLys1Y3M2T24rQ0ZDZmV2RlEzWmFUeWN4MVlNYnZEZFJ2amtwL2xIZEFjUFh6b2t4Y3dmRHdBQUFBQkpSVTVFcmtKZ2dnPT1cIixcImN1cnNvci5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkFnTUFBQUM1aDIzd0FBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBeFFURlJGQUFBQVRVMU5UVTFOVFUxTndsTUhId0FBQUFSMFVrNVRBT3ZoeGJwUHJVa0FBQUFrU1VSQlZIaWNZMkJnWUhCZ2dBQnlhYnhnMVdvR0JxMnBSQ2s5QUtVYmNORDQzQUVBdWZZSGxTdXVzRTRBQUFBQVNVVk9SSzVDWUlJPVwiLFwiZGlzcGxheV9vZmYucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNvQUFBQXFDQU1BQUFEeUhUbHBBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBVTFRVEZSRkFBQUFoNGVIaDRlSEFBQUFBQUFBQUFBQUF3TURBQUFBQUFBQWhvYUdHQmdZZ1lHQkFBQUFQejgvQWdJQ2c0T0RDUWtKaElTRWg0ZUhoNGVIUGo0K05qWTJnWUdCZzRPRGdZR0JnWUdCZ29LQ0FRRUJKeWNuZ29LQ2hZV0ZFQkFRZzRPRENBZ0lLaW9xWkdSa0Nnb0tCUVVGRVJFUmQzZDNnWUdCR3hzYk5EUTBoSVNFZ1lHQlBEdzhnWUdCZ1lHQmg0ZUhoNGVIaFlXRmg0ZUhnb0tDaFlXRmdZR0JnWUdCZzRPRGhvYUdnNE9EWVdGaGdvS0NCZ1lHZFhWMWdvS0NnNE9EZ1lHQmdJQ0FnWUdCQUFBQWc0T0RoWVdGaElTRWg0ZUhnb0tDaFlXRk9qbzZnb0tDR2hvYWg0ZUhoNGVIaDRlSGdvS0NoNGVIZVhsNWhvYUdnb0tDaElTRWdZR0JnWUdCZ29LQ1kyTmpnWUdCZ29LQ2g0ZUhnb0tDZ1lHQmhvYUdnNE9EaG9hR2hZV0ZoNGVIZ1lHQmhvYUdob2FHaG9hR2c0T0Rnb0tDaElTRWdvS0NoWVdGaDRlSGZLa3RVd0FBQUc5MFVrNVRBQ24vQWhFRktBOFNMQ2J4Q2lnb1ZCTktVVFlvSi9saDNQeUFLU2FUTmlCdElDWXBJU2dnS1NrbUowTEVLZWYzbEd4QThybi8vK3BjTVNrcG5DY3B0SFBKS2UwTFVqbng1THpLS2FNblg3M2hsNjRwTG5oa3pOU2dLZUx2MTdMUStsaUl6YUxlN1BmVHc1dEZwejNLMWZYUi9nQUFBZ0JKUkVGVWVKemxsTmRYd2pBVXhrbkIwbElvQ0tWc0dUSUZRUkFaN3IzMzNudXYvLy9SM0xaNG1sRFFaLzBla3A3YjM3bjVibklUayttZnlEeHY1VGlyM2Z3amFFbE81QklPS1pGTEpTMWRRVmZJMFk4MDlUdEVWK2Vsbzk1UnBGUFdHKzFnbzRmZFE1UXliSThoYWFOQmtNMkFOYk0wOWJucndhUFk3aUZLcno3RU1CZHU3Q0hkVnJ1WEl0ME0xaGIrR0tBM0xUUktrcDVsVEE2RGc2eElraGFIaHZRMUlsVy9VQ291UWRKTkpUUklwazFxTzcrd1VwY2ZwbDUzN29CYzdWTmlwM0dpL0FtVlBCQUMxVXJMNkhYdFNHVlQrazJZejBGb2NhZDA3T01SZjNQNUJFYmQ2M1BGUXg3SE4rdzYxSm9BbSt1QmxWNDhPLzBqa0xTTW10UENtUThId2xZZHlrRlY0L0xKUHA3ZTNoVnlGZGFwSE5laExrNlBTamhTa0J2d3UvY0Z5SkdJWXZPeWhvYzFqallRRkdieWdENENXam9BTWxhL29nM1lvU3crS1BoalBOb0ZjaW00aUZEK3BGWUE4elo5V2VZVTVPQmpaM09SV3lDZkcwM0UrNDdrS3BDSUpUcEdPNEtQOFhNZ3R3OTkweEcvUEJOVGdtUEVFWHdmN1A0Mm9PZEZJUkFvQkN0cVRLTDZSY3dxNFhzZ2g1eFlDL21tU3M2eUpLazFZYm5WZVRxMU5hRXBtbEhibVZuMkVPUmtXMnRyRjJaem1IR1RTVU1HbDFhOWhwNHlTUnBkUTh5S0dVUnBNbVJJWWc5cGIxWVB6ZzZrTzc5Y0xsRTZiWUZqRXR2OTFiTEVVeHZod2JXd2pZMTNCeFViOWw4K21uOUVYOHgzTmtpOGZmNXdBQUFBQUVsRlRrU3VRbUNDXCIsXCJkaXNwbGF5X29uLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDb0FBQUFxQ0FNQUFBRHlIVGxwQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQVIxUVRGUkZBQUFBaDRlSGdZR0JBQUFBQUFBQWdZR0JBQUFBQXdNREFBQUFBQUFBZ1lHQmc0T0RHQmdZZ1lHQmhJU0VBQUFBUHo4L0FnSUNob2FHQ1FrSmhZV0ZQajQrTmpZMmdvS0NnWUdCQVFFQkp5Y25nWUdCZ29LQ0VCQVFDQWdJaElTRUtpb3FaR1JrQ2dvS0JRVUZFUkVSZDNkM2dZR0JnNE9EZ1lHQkd4c2JORFEwaElTRWdvS0Nnb0tDaFlXRlBEdzhnWUdCZ1lHQmhvYUdnb0tDZzRPRGdvS0NnWUdCZ29LQ2dvS0Nnb0tDZzRPRGdvS0Nob2FHZ29LQ2dZR0Job2FHZzRPRFlXRmhCZ1lHZFhWMWdZR0JnNE9EZ29LQ2dJQ0FnNE9EZzRPRGhJU0VBQUFBZzRPRE9qbzZnWUdCR2hvYWVYbDVnb0tDZ1lHQmdvS0NoWVdGZ29LQ2hJU0Vnb0tDWTJOamdZR0JnNE9EZ1lHQmdZR0JnNE9EZ1lHQm84bjU0QUFBQUY5MFVrNVRBQ24vQWhIM0JTZ1BFdWhVSnZGQUNpZ29MQk0yS0NlQTZ5a20rcE1nSUVrbUtTRW9JQ245WENrbUowdTZuRG9wNHNVeXBHdUV6TFo2dm1DWUxaL2RMeWtwSnluVVlhOHBjbGxDQzFJcDJ5Y3Bpc2wxUGFkRnNpbnRic1BRWmRpL2JUVzdBQUFCNFVsRVFWUjRuT1dVWjFmQ01CU0dTU0dXRmlxMFVEYklrcjJYYkJ3TXhTMGIxUC8vTTB4SzlYU2lmdFg3b2VsNTg1emt2ZmNtTVJqK1NSaHZ6UlJsdGhtL0JVM1J5M1RZem9mVHNhanBJT2p3MmlOQWpJaWRkZWh2SFhTZEEwbWtYRUVkRzBma0UxREVLWG1rU1ZxVklBNnJCbXNrdFVnQVdMV0hvR3AzMFVOY2xidExtd1Fnb3l5YTkxd1BUYkZ5MG1RWEo1ekpRTzZCZ1hSamZIMGlTa1g1c3RISVhyNXIwYkIvbHU4c3lqUjhyenNGYlIyU3BYKzVKMmVNUDNjc0x0WXNFWTJLOEJlVEZ1RTJqYVZDQnc3YkhPQnV4cTE2QVhtcGJ1aTNMdElmYlJMVUhNWTJxNGxjRm8yV0I0S0ExU1VBbFd1bU5FS0N6eXhCS1p4Vkh2WUdhRmd1Q0J4MXZNL3gwSVB6b3FRb2o1U2RQNG1uczJjQ0doQnNyZ2owdWFlVUJ0ek15eFFOOHc0bVlST1RXOCtyMG9BTnA4VzVtZjZXUXc1YUNZSjJvN3ltUGFLTWkydVZwbVdNNFRXNnRkSW1nR28xYlQ0bks2RGJic0NjMEFaU2RtTEVGc3p6SHJoNnJpVnZSck5BMy85U0U4UUxXUXUrR2p0bzkrZ0U5TkJNd3I5emk4M2dGZWVGVGUxMXpwbTFDSEUzSGV5VkNTa25mM01JRGNGVGJmSktkYlIxTDR4WDQ5TCsvQm9pbGxWNXVQSnFrc2hEM0pXU2dwTk1YUC9sY3JEOCtoTzg0TW5EcjVZcEZIdjBGZTk5VmpKMEdCUnMySDc0YVA2UitBQ3IrVEZ2Wk5BUTF3QUFBQUJKUlU1RXJrSmdnZz09XCIsXCJkb3duLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDb0FBQUFxQ0FNQUFBRHlIVGxwQUFBQUFYTlNSMElCMmNrc2Z3QUFBS1ZRVEZSRkFBQUFnNE9EZ0lDQUFBQUFBQUFBQUFBQUNBZ0lBQUFBQUFBQUFBQUFBQUFBT1RrNWhZV0ZFQkFRZkh4OE9EZzRkbloyTkRRMFhWMWRHeHNiS0Nnb2dJQ0FGQlFVSWlJaVpHUmtnSUNBZ0lDQUZSVVZBQUFBZ0lDQWdJQ0FnSUNBZjM5L0xpNHVnSUNBY0hCd2dvS0NnSUNBZ29LQ2dJQ0FnNE9EZ1lHQlBqNCtnb0tDZ0lDQWhJU0VnWUdCZ0lDQWdvS0NnSUNBZ1lHQmdZR0JmMzkvZ0lDQWdJQ0FJZFBRSEFBQUFEZDBVazVUQUNuL0tBSVJJQk1GRHdvb0t5QXBLU2tuS1NZbXpDY21LZkw3SlJDVWkyTDNKN0lwY0xVcnIwVmJLWG50TkVua01ieHJVY0c1NkNNcGk1MEFBQUZaU1VSQlZIaWM1WlJwZjRNZ0RJZUZLRmF0V20vdGZXMDkxdTdldnY5SG0xQWNvdWptMnkwdkZQSDVKZitFRUUzN0o2YmJsbWxhdHY0amFCQ0k0ck1mUjBDTVh0QUVKMGZjY2dmTTd0QWtRSFh6QXJkRHhnZ21xR0VUR0NuSldST2tObE93T3FoSWhLQ3RnYlNpY3cxdUsvZEFUU0swYVJhdEl6eXRBOGlrNFhTaXlKbkxTbStWUHhVTGdleUxJM3VIUkpIK3FjQjRXWkdyS2I0YzIwV3dJN2IzaVV0NzRPUzZYRCt4WldyWFVDdG1lMHVLVHZmY0o2NUNaRmE5Vk9lYnF3WG1mdCtvVDh5RisvVnltVDRYZUdCK1h4OEwrajRnQmNvRklEVCtvTXo2UXA5M1k3NHBDZUJwVVhhTHVXMHJVazZyMWl2M25QMzIyZXdZa2d2Mm5aSXZncFNQUURyWTV3VGpSSkROZzlYQUUvK3VTWElWWDgxMkdkS0VtdHZSMnJ0V2F3KzVNQU91b2ZKeTc5U1h1OVRnQmw0ZDlEWmRJME5qZ3lpc3dOQ0IvcWsxSjVCbXZwK2xRT2E5SUpOaFc0YnhtNkg1Uit3TFFZTVNRWFpOemJjQUFBQUFTVVZPUks1Q1lJST1cIixcInByaWNlX3JhbmdlLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQVFNQUFBRCtKeGNnQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFaUVRGUkZBQUFBVFUxTmtKK3JPUUFBQUFKMFVrNVRBUDlia1NLMUFBQUFJVWxFUVZSNG5HTmdnQVBtL3c5Z1RBNFFJUU1pdEVDRUoxeU1FZ0xORGlBQUFEZmdCTVJ1NzhHZ0FBQUFBRWxGVGtTdVFtQ0NcIixcInByaWNlX3RpbWUucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpBUU1BQUFEK0p4Y2dBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQVpRVEZSRkFBQUFUVTFOa0orck9RQUFBQUowVWs1VEFQOWJrU0sxQUFBQU9rbEVRVlI0bkdOZ2dBUG0vdzlnVEE0UUlRUEVDbHBNUU1JVFJIQ0FDU2NRb1FRaWhCZ1k5UC8vZ3JLZ1lrNXdkVEFDWWhRSEZqdUFBQUJaRkFsYzRlMWZjUUFBQUFCSlJVNUVya0pnZ2c9PVwiLFwicmVtb3ZlLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDb0FBQUFxQ0FNQUFBRHlIVGxwQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUs1UVRGUkZBQUFBaDRlSGdJQ0FBQUFBQUFBQWg0ZUhBQUFBQXdNREFBQUFBQUFBZ0lDQUdCZ1lBQUFBUHo4L0FnSUNnSUNBQ1FrSmhvYUdob2FHZ0lDQVBqNCtOalkyZ1lHQmc0T0RnWUdCQVFFQkp5Y25nb0tDRUJBUWdJQ0FnSUNBQ0FnSUtpb3FaR1JrQ2dvS0JRVUZFUkVSZDNkM2dZR0JHeHNiTkRRMGdJQ0FQRHc4WVdGaEJnWUdkWFYxZ0lDQWc0T0RnSUNBQUFBQU9qbzZHaG9hZVhsNWdJQ0FoWVdGWTJOamhZV0ZnSUNBOU8wb0NnQUFBRHAwVWs1VEFDbi9BaEVyQlNnUEV2RW1DaWdvd3hNdU1jZ29KN2hXckNrbWRDRDZ2U0FtS1NFb0lDa3BKaWU2S1NrbktTa3Awd3NwSnluQ01pazExcnJMdGU4QUFBRndTVVJCVkhpYzVaVFhrb0l3RklaTkFBUFNwS2tvUlFWN1djdmEzdi9GRmlSbUV3aXNlN3Q3YnM3TVA5OGsveWxKcS9WUFFqaktpaUpyd28rZ09OMHV4cm83WGlSVHNSSHMrdm9FNEpqb1JyZis2c0Q3QUZUTXZhREdSaHQ5Z2xMTVVKdExxbVV3RDVYRENvaEhBbUJVUFFTVjI3R0h0Rks3eHljQldKYWI1dVBhUitIbG11ZTdHZlp4SHd5V0ZIVk1RZ2hYRmdEMkE4SU9adGZzc2ROSklYY3lGRWFTZmNoenA5QnVNVlArRmh2cjVRaDBuR2ZxWVRHaG0zQmNZRlVhUUJLT2hNV3pScUh5R0ZSWTAzcHBRNWxDRlozMFJsb1ZaR1FUYWEzUXFFdDBPeXJRbmtTa2s4STFZSmt2QXdQQ01nWTBVcGJ6WFJaaFZib3NJV0diWlRMTlFzekdNQ000MkZKRWpXRERqSUFNdHAreGo2eDJLKy9EcU5EYzByNFljOHlHbDN1ZXIyYUl5VDFpeWQ4c1lTdVk4Y2xkWmJWckg0elBlYlR2UDhPTU5Tb2VkajZYekR5azNwd0c5OHUwL3VmcUd1N3RCVzVjMVB4cmlYRnlIcTVQUXhYRnplRFRodmJtcC9sSDRndDZXeGZaMDNIOER3QUFBQUJKUlU1RXJrSmdnZz09XCIsXCJzZXR0aW5ncy5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ29BQUFBcUNBTUFBQUR5SFRscEFBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFXNVFURlJGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNnb0tCZ1lHR3hzYktpb3FRRUJBUGo0K0JRVUZDQWdJQVFFQlB6OC9aV1ZsaDRlSFpHUmtBZ0lDQ1FrSkR3OFBOalkyZzRPRGdvS0NOVFUxRUJBUUFBQUFBd01EZVhsNWQzZDNBQUFBR0JnWUFBQUFFUkVSaW9xS2dvS0Nnb0tDZ29LQ2dZR0Jnb0tDaElTRWhvYUdORFEwZzRPRGdJQ0FnSUNBZ0lDQWdZR0JnWUdCaFlXRmdJQ0FnSUNBUFQwOUFBQUFnWUdCZ0lDQWdJQ0FnSUNBZ0lDQVkyTmpDQWdJZ0lDQWdJQ0FoWVdGaFlXRmdZR0JIQndjZ0lDQWhZV0ZHaG9hZ1lHQmdZR0JnNE9EaG9hR0p5Y25BQUFBaElTRWdJQ0FnNE9EUER3OEFBQUFnb0tDZ0lDQWhJU0VPam82aDRlSGdvS0NnWUdCZ0lDQWYzOS9nWUdCZ29LQ2dJQ0FHQmdZZ1lHQmc0T0RnNE9EZ0lDQUN3c0xnWUdCZ0lDQWdZR0JnWUdCZ1lHQmdJQ0FnWUdCWVdGaGYzOS9nNE9EUGo0K2dZR0JnNE9EZ0lDQWhZV0Znb0tDZ1lHQmdJQ0FnWUdCZ29LQ2RYVjFUMGtDOVFBQUFIcDBVazVUQUFJTER4TUtFU0VuSmlZcEtTZ1RLU2dwS1Nrb0V5QW5LU2tuSUFZb0tTa0ZKUUVnS2w5NGpZVnZWQzRuVTlmLytLOHBPdTcxS0JDaTNOUHEvaWtnMGUwMU5va20xVVVuc1pWcVFTWU9UOWxyS1JKejVsSXBLMTJqeXUrc2VzZ25oR1ZMeENHNTVhNlVtK0dhS2ZKQ0tLUmdLVXQ4b2Nlcmd5bURROWtuQUFBQnNFbEVRVlI0bk9XVVYxdkNNQlNHZzFBUXBCWnJjVmRFM0tKeG80TGdudUNvZTRGN29yakh2N2RvVGszYmdGN3JkNU9uWDk0blorU2tDUDBUV1Fxc05wdVZzL3dJMmgyRlRsZVIyK1hrSGZhOFlMSGdLUkdKU2oyU04zZm9zdklLa1ZKbFZYV09OR3JrV3RFZ24xekhKUDFHTUNzL2c3WElMRklVcFhvVFdtYUtUbklJbUdvdmg3Mkd4cWJtbHRhMmR2Z09HcHNtUU8wZG5maFRYZDNFNkpIMHBOMURObnI3TUZFL0hEc1EwcUVPNlB4ZzlzQ2g0WERrR3gySjZzb3ZCRCtHOGVpWXVvNVB4TFRLZUxvSkJaTmdUMkVjbmpZMFlZYWpVS3NMN0ZrMWdjalUzUHdDaGNZVEZHb3JBbnNScWxwYTF0QVZoVWJkbXIrNlJ0aklPbGdiQ2pNQlVkemMydDdaemJKN3pBUTRwNkdTZlJWTndrZUtMc3ZDZzMxdzJKQmRqbFQwR0R4Wk56RW5wY1EreFdmbkZ4ZVhWeXA2VGF5MDdncStML1lVT29CdmJvbVYwVjhza2lxLy9EdXRXZmVFZkpEMUpQTENFRDQrUGI4a1g5ODZ0QXBOUTRpcWZTSlQ3NmJSenZsZ0JQT0RRWFcvZm9ZcUs1bHllQmVZSkVMMWdhb2VHbndJQmhqUm9ROVNaZ1RBZEViTy85Y0tSZm1aK01wR1BDVkhRM25CenpTNGhLSWt1TnloLzVnK0FMaUFYU1Nhczlod0FBQUFBRWxGVGtTdVFtQ0NcIixcInRpbWVfcmFuZ2UucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpBUU1BQUFEK0p4Y2dBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQVpRVEZSRkFBQUFUVTFOa0orck9RQUFBQUowVWs1VEFQOWJrU0sxQUFBQUpFbEVRVlI0bkdOZ3dBc1VHSmhRQ1NjUW9RUWloQmdZOVAvL2dyS2dZazRZT3ZBQ0FDT3BCS0c2U3ZqK0FBQUFBRWxGVGtTdVFtQ0NcIixcInRyYXNoLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQVFNQUFBRCtKeGNnQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFaUVRGUkZBQUFBVFUxTmtKK3JPUUFBQUFKMFVrNVRBUDlia1NLMUFBQUFMVWxFUVZSNG5HTmdBSU42RU5IUUFDWDQvLzlnWUJCZ1lJRVNZQzRMa0EwbFBFa21HRkFJNXY4UElMWUNBSHlnREp4bEswUlVBQUFBQUVsRlRrU3VRbUNDXCIsXCJ1cC5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ29BQUFBcUNBTUFBQUR5SFRscEFBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFNWlFURlJGQUFBQWg0ZUhnSUNBQUFBQUFBQUFBQUFBQXdNREFBQUFBQUFBR0JnWUFBQUFQejgvQWdJQ0NRa0pnSUNBaDRlSFBqNCtOalkyQVFFQkp5Y25FQkFRZ0lDQWdJQ0FDQWdJS2lvcVpHUmtDZ29LQlFVRmdZR0JFUkVSZDNkM2dZR0JHeHNiTkRRMGdJQ0FnWUdCUER3OGdZR0JoNGVIZ0lDQVlXRmhCZ1lHZ1lHQmRYVjFnb0tDZzRPRGhZV0ZnSUNBZ29LQ0FBQUFoSVNFT2pvNmdJQ0FHaG9hZ1lHQmVYbDVob2FHZ0lDQVkyTmpnNE9EZ29LQ2dvS0NnWUdCZ29LQ2c0T0Rnb0tDNjR1dzFnQUFBRUowVWs1VEFDbi9BaEVGS0E4U0pnb29LQlA3S2lnbktTWWc5YzBnSmlraEtMUWdLU2ttSjd5d0tZOHM1U2tubENseEtUTXBYd3RGS2UwbmVpa3U4Q2xLV21TYmJGRmpNNUdIU2dBQUFXNUpSRUZVZUp6bGxHZC9nakFReGszQU1GV1dPSER2VmEyclZidS8vNWNxaEpXUVFPM2I5bmtWanYvdjdybkxLSlgraVlTOUpNdVNLdndJaXUzbG9La1p6WUhYRmd2QmlxVzFRS1NXcGxmeVN6dm1BeURVTjUwY0cyWDBERExxb1RLWFZMSmdJSVhEQ29oSEFxQ3pIaHltZXVTaHkvUnU4a2tBaHRtaFdVVHZXOWZkRW5QUWFWTFUwbjhYRjBMM2tuNVA2TFR0WlBLZ05vSytSclVrY0d0UTdTOVRzZ094eGlucmtVUFlEK0x3TENJaDdDVHNXU1ZRcVJtVHVQcXBpdGxaRkxRbEFwWGpyc1lCYzMzNXdPdzQ3a3NtVVNNTXJnS2kvZ25BRS9hd0NxTkhtVFV3RGY1WDM0TGxCdWVkc2diVXNLMTVrUE14VElYenp2RlNJZHNTUEJ3N25HRDFLKzdiTDNGOXhTdEVuWmhvQ3c3MVRicEw3MUdCQmJVRjFNWm1aV1RPaTk3UEkzZUlKbjl6Q0V0T2owK3VtYU9kZTJFc3pxVzkveHI2ck01NFdGdGMwdmZRTmFrNTdJYmQvSmVyb2h1M0dGd1lxUGpWRWh2ZTJaNGNiUVUxaWtGc1E3M3owZndqK2dhM1ZCZXpHdWdnRlFBQUFBQkpSVTVFcmtKZ2dnPT1cIn0nKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wcmltaXRpdmVzL3Bpbi5qc1xuXG5cblxuLy8gU2VtaS1hdXRvbWF0aWMgcGluIG9iamVjdC4gRm9yIHN0cmV0Y2hpbmcgdGhpbmdzLlxuXG5cbnZhciBQaW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyAoQ29tcCByZWZlcmVuY2UsIGEgbmFtZSBpbiBvdmVybGF5IHNldHRpbmdzLFxuICAvLyBwaW4gcGFyYW1ldGVycylcbiAgZnVuY3Rpb24gUGluKGNvbXAsIG5hbWUsIHBhcmFtcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgIH1cblxuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpbik7XG5cbiAgICB0aGlzLlJBRElVUyA9IGNvbXAuJHByb3BzLmNvbmZpZy5QSU5fUkFESVVTIHx8IDUuNTtcbiAgICB0aGlzLlJBRElVU19TUSA9IE1hdGgucG93KHRoaXMuUkFESVVTICsgNywgMik7XG5cbiAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSB7XG4gICAgICB0aGlzLlJBRElVUyArPSAyO1xuICAgICAgdGhpcy5SQURJVVNfU1EgKj0gMi41O1xuICAgIH1cblxuICAgIHRoaXMuQ09MT1JfQkFDSyA9IGNvbXAuJHByb3BzLmNvbG9ycy5iYWNrO1xuICAgIHRoaXMuQ09MT1JfQlIgPSBjb21wLiRwcm9wcy5jb2xvcnMudGV4dDtcbiAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgIHRoaXMubGF5b3V0ID0gY29tcC5sYXlvdXQ7XG4gICAgdGhpcy5tb3VzZSA9IGNvbXAubW91c2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnN0YXRlID0gcGFyYW1zLnN0YXRlIHx8ICdzZXR0bGVkJztcbiAgICB0aGlzLmhpZGRlbiA9IHBhcmFtcy5oaWRkZW4gfHwgZmFsc2U7XG4gICAgdGhpcy5tb3VzZS5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBfdGhpcy5tb3VzZW1vdmUoZSk7XG4gICAgfSk7XG4gICAgdGhpcy5tb3VzZS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBfdGhpcy5tb3VzZWRvd24oZSk7XG4gICAgfSk7XG4gICAgdGhpcy5tb3VzZS5vbignbW91c2V1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gX3RoaXMubW91c2V1cChlKTtcbiAgICB9KTtcblxuICAgIGlmIChjb21wLnN0YXRlID09PSAnZmluaXNoZWQnKSB7XG4gICAgICB0aGlzLnN0YXRlID0gJ3NldHRsZWQnO1xuICAgICAgdGhpcy51cGRhdGVfZnJvbShjb21wLiRwcm9wcy5zZXR0aW5nc1tuYW1lXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdzZXR0bGVkJykge1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdzY3JvbGwtbG9jaycsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKFBpbiwgW3tcbiAgICBrZXk6IFwicmVfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZV9pbml0KCkge1xuICAgICAgdGhpcy51cGRhdGVfZnJvbSh0aGlzLmNvbXAuJHByb3BzLnNldHRpbmdzW3RoaXMubmFtZV0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBpZiAodGhpcy5oaWRkZW4pIHJldHVybjtcblxuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ3RyYWNraW5nJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkcmFnZ2luZyc6XG4gICAgICAgICAgaWYgKCF0aGlzLm1vdmVkKSB0aGlzLmRyYXdfY2lyY2xlKGN0eCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2V0dGxlZCc6XG4gICAgICAgICAgdGhpcy5kcmF3X2NpcmNsZShjdHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3X2NpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3X2NpcmNsZShjdHgpIHtcbiAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy5jb21wLmxheW91dDtcblxuICAgICAgaWYgKHRoaXMuY29tcC5zZWxlY3RlZCkge1xuICAgICAgICB2YXIgciA9IHRoaXMuUkFESVVTLFxuICAgICAgICAgICAgbHcgPSAxLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgciA9IHRoaXMuUkFESVVTICogMC45NSxcbiAgICAgICAgICAgIGx3ID0gMTtcbiAgICAgIH1cblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IGx3O1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5DT0xPUl9CUjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLkNPTE9SX0JBQ0s7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHRoaXMueCA9IHRoaXMubGF5b3V0LnQyc2NyZWVuKHRoaXMudCksIHRoaXMueSA9IHRoaXMubGF5b3V0LiQyc2NyZWVuKHRoaXMueSQpLCByICsgMC41LCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy55JCA9IHRoaXMuY29tcC4kcHJvcHMuY3Vyc29yLnkkO1xuICAgICAgdGhpcy55ID0gdGhpcy5jb21wLiRwcm9wcy5jdXJzb3IueTtcbiAgICAgIHRoaXMudCA9IHRoaXMuY29tcC4kcHJvcHMuY3Vyc29yLnQ7XG4gICAgICB0aGlzLnggPSB0aGlzLmNvbXAuJHByb3BzLmN1cnNvci54OyAvLyBTYXZlIHBpbiBhcyB0aW1lIGluIElCIG1vZGVcbiAgICAgIC8vaWYgKHRoaXMubGF5b3V0LnRpX21hcC5pYikge1xuICAgICAgLy8gICAgdGhpcy50ID0gdGhpcy5sYXlvdXQudGlfbWFwLmkydCh0aGlzLnQgKVxuICAgICAgLy99XG4gICAgICAvLyBSZXNldCB0aGUgc2V0dGluZ3MgYXR0YWhlZCB0byB0aGUgcGluIChwb3NpdGlvbilcblxuICAgICAgdGhpcy5jb21wLiRlbWl0KCdjaGFuZ2Utc2V0dGluZ3MnLCBfZGVmaW5lUHJvcGVydHkoe30sIHRoaXMubmFtZSwgW3RoaXMudCwgdGhpcy55JF0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlX2Zyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlX2Zyb20oZGF0YSwgZW1pdCkge1xuICAgICAgaWYgKGVtaXQgPT09IHZvaWQgMCkge1xuICAgICAgICBlbWl0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLmNvbXAubGF5b3V0O1xuICAgICAgdGhpcy55JCA9IGRhdGFbMV07XG4gICAgICB0aGlzLnkgPSB0aGlzLmxheW91dC4kMnNjcmVlbih0aGlzLnkkKTtcbiAgICAgIHRoaXMudCA9IGRhdGFbMF07XG4gICAgICB0aGlzLnggPSB0aGlzLmxheW91dC50MnNjcmVlbih0aGlzLnQpOyAvLyBUT0RPOiBTYXZlIHBpbiBhcyB0aW1lIGluIElCIG1vZGVcbiAgICAgIC8vaWYgKHRoaXMubGF5b3V0LnRpX21hcC5pYikge1xuICAgICAgLy8gICAgdGhpcy50ID0gdGhpcy5sYXlvdXQudGlfbWFwLmkydCh0aGlzLnQgKVxuICAgICAgLy99XG5cbiAgICAgIGlmIChlbWl0KSB0aGlzLmNvbXAuJGVtaXQoJ2NoYW5nZS1zZXR0aW5ncycsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgdGhpcy5uYW1lLCBbdGhpcy50LCB0aGlzLnkkXSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWNfcG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjX3Bvc2l0aW9uKCkge1xuICAgICAgdGhpcy50MSA9IHRoaXMudDtcbiAgICAgIHRoaXMueSQxID0gdGhpcy55JDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2Vtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ3RyYWNraW5nJzpcbiAgICAgICAgY2FzZSAnZHJhZ2dpbmcnOlxuICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZWRvd24oZXZlbnQsIGZvcmNlKSB7XG4gICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkge1xuICAgICAgICBmb3JjZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuZGVmYXVsdF9wcmV2ZW50ZWQoZXZlbnQpICYmICFmb3JjZSkgcmV0dXJuO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAndHJhY2tpbmcnOlxuICAgICAgICAgIHRoaXMuc3RhdGUgPSAnc2V0dGxlZCc7XG4gICAgICAgICAgaWYgKHRoaXMub25fc2V0dGxlZCkgdGhpcy5vbl9zZXR0bGVkKCk7XG4gICAgICAgICAgdGhpcy5jb21wLiRlbWl0KCdzY3JvbGwtbG9jaycsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZXR0bGVkJzpcbiAgICAgICAgICBpZiAodGhpcy5oaWRkZW4pIHJldHVybjtcblxuICAgICAgICAgIGlmICh0aGlzLmhvdmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnZHJhZ2dpbmcnO1xuICAgICAgICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb21wLiRlbWl0KCdzY3JvbGwtbG9jaycsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5jb21wLiRlbWl0KCdvYmplY3Qtc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaG92ZXIoKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZXVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNldXAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlICdkcmFnZ2luZyc6XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdzZXR0bGVkJztcbiAgICAgICAgICBpZiAodGhpcy5vbl9zZXR0bGVkKSB0aGlzLm9uX3NldHRsZWQoKTtcbiAgICAgICAgICB0aGlzLmNvbXAuJGVtaXQoJ3Njcm9sbC1sb2NrJywgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSAnc2V0dGxlZCc6XG4gICAgICAgICAgdGhpcy5vbl9zZXR0bGVkID0gaGFuZGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaG92ZXIoKSB7XG4gICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgcmV0dXJuICh4IC0gdGhpcy5tb3VzZS54KSAqICh4IC0gdGhpcy5tb3VzZS54KSArICh5IC0gdGhpcy5tb3VzZS55KSAqICh5IC0gdGhpcy5tb3VzZS55KSA8IHRoaXMuUkFESVVTX1NRO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQaW47XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJpbWl0aXZlcy9zZWcuanNcblxuXG4vLyBEcmF3cyBhIHNlZ21lbnQsIGFkZHMgY29ycmVzcG9uZGluZyBjb2xsaXNpb24gZi1uXG5cblxuXG52YXIgU2VnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gT3ZlcmxheSByZWYsIGNhbnZhcyBjdHhcbiAgZnVuY3Rpb24gU2VnKG92ZXJsYXksIGN0eCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlZyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNvbXAgPSBvdmVybGF5O1xuICAgIHRoaXMuVCA9IG92ZXJsYXkuJHByb3BzLmNvbmZpZy5UT09MX0NPTEw7XG4gICAgaWYgKHV0aWxzLmlzX21vYmlsZSkgdGhpcy5UICo9IDI7XG4gIH0gLy8gcDFbdCwgJF0sIHAyW3QsICRdICh0aW1lLXByaWNlIGNvb3JkaW5hdGVzKVxuXG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoU2VnLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcocDEsIHAyKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5jb21wLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgeDEgPSBsYXlvdXQudDJzY3JlZW4ocDFbMF0pO1xuICAgICAgdmFyIHkxID0gbGF5b3V0LiQyc2NyZWVuKHAxWzFdKTtcbiAgICAgIHZhciB4MiA9IGxheW91dC50MnNjcmVlbihwMlswXSk7XG4gICAgICB2YXIgeTIgPSBsYXlvdXQuJDJzY3JlZW4ocDJbMV0pO1xuICAgICAgdGhpcy5jdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICB0aGlzLmN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgIHRoaXMuY29tcC5jb2xsaXNpb25zLnB1c2godGhpcy5tYWtlKFt4MSwgeTFdLCBbeDIsIHkyXSkpO1xuICAgIH0gLy8gQ29sbGlzaW9uIGZ1bmN0aW9uLiB4LCB5IC0gbW91c2UgY29vcmQuXG5cbiAgfSwge1xuICAgIGtleTogXCJtYWtlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2UocDEsIHAyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGgucG9pbnQyc2VnKFt4LCB5XSwgcDEsIHAyKSA8IF90aGlzLlQ7XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZWc7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJpbWl0aXZlcy9saW5lLmpzXG5cblxuLy8gRHJhd3MgYSBsaW5lLCBhZGRzIGNvcnJlc3BvbmRpbmcgY29sbGlzaW9uIGYtblxuXG5cblxudmFyIExpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBPdmVybGF5IHJlZiwgY2FudmFzIGN0eFxuICBmdW5jdGlvbiBMaW5lKG92ZXJsYXksIGN0eCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmUpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jb21wID0gb3ZlcmxheTtcbiAgICB0aGlzLlQgPSBvdmVybGF5LiRwcm9wcy5jb25maWcuVE9PTF9DT0xMO1xuICAgIGlmICh1dGlscy5pc19tb2JpbGUpIHRoaXMuVCAqPSAyO1xuICB9IC8vIHAxW3QsICRdLCBwMlt0LCAkXSAodGltZS1wcmljZSBjb29yZGluYXRlcylcblxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKExpbmUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhwMSwgcDIpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmNvbXAuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciB4MSA9IGxheW91dC50MnNjcmVlbihwMVswXSk7XG4gICAgICB2YXIgeTEgPSBsYXlvdXQuJDJzY3JlZW4ocDFbMV0pO1xuICAgICAgdmFyIHgyID0gbGF5b3V0LnQyc2NyZWVuKHAyWzBdKTtcbiAgICAgIHZhciB5MiA9IGxheW91dC4kMnNjcmVlbihwMlsxXSk7XG4gICAgICB0aGlzLmN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgdmFyIHcgPSBsYXlvdXQud2lkdGg7XG4gICAgICB2YXIgaCA9IGxheW91dC5oZWlnaHQ7IC8vIFRPRE86IHRyYW5zZm9ybSBrIChhbmdsZSkgdG8gc2NyZWVuIHJhdGlvXG4gICAgICAvLyAodGhpcyByZXF1aXJlcyBhIG5ldyBhMnNjcmVlbiBmdW5jdGlvbilcblxuICAgICAgdmFyIGsgPSAoeTIgLSB5MSkgLyAoeDIgLSB4MSk7XG4gICAgICB2YXIgcyA9IE1hdGguc2lnbih4MiAtIHgxIHx8IHkyIC0geTEpO1xuICAgICAgdmFyIGR4ID0gdyAqIHMgKiAyO1xuICAgICAgdmFyIGR5ID0gdyAqIGsgKiBzICogMjtcblxuICAgICAgaWYgKGR5ID09PSBJbmZpbml0eSkge1xuICAgICAgICBkeCA9IDAsIGR5ID0gaCAqIHM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4MiwgeTIpO1xuICAgICAgdGhpcy5jdHgubGluZVRvKHgyICsgZHgsIHkyICsgZHkpO1xuXG4gICAgICBpZiAoIXRoaXMucmF5KSB7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oeDEgLSBkeCwgeTEgLSBkeSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tcC5jb2xsaXNpb25zLnB1c2godGhpcy5tYWtlKFt4MSwgeTFdLCBbeDIsIHkyXSkpO1xuICAgIH0gLy8gQ29sbGlzaW9uIGZ1bmN0aW9uLiB4LCB5IC0gbW91c2UgY29vcmQuXG5cbiAgfSwge1xuICAgIGtleTogXCJtYWtlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2UocDEsIHAyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZiA9IHRoaXMucmF5ID8gbWF0aC5wb2ludDJyYXkuYmluZChtYXRoKSA6IG1hdGgucG9pbnQybGluZS5iaW5kKG1hdGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBmKFt4LCB5XSwgcDEsIHAyKSA8IF90aGlzLlQ7XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qc1xuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanNcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanNcbmZ1bmN0aW9uIHR5cGVvZl90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICB0eXBlb2ZfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdHlwZW9mX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZl90eXBlb2Yob2JqKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuXG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wcmltaXRpdmVzL3JheS5qc1xuXG5cblxuXG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vLyBEcmF3cyBhIHJheSwgYWRkcyBjb3JyZXNwb25kaW5nIGNvbGxpc2lvbiBmLW5cblxuXG52YXIgUmF5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGluZSkge1xuICBfaW5oZXJpdHMoUmF5LCBfTGluZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSYXkpO1xuXG4gIGZ1bmN0aW9uIFJheShvdmVybGF5LCBjdHgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXkpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvdmVybGF5LCBjdHgpO1xuICAgIF90aGlzLnJheSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFJheTtcbn0oTGluZSk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0xpbmVUb29sLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIExpbmUgZHJhd2luZyB0b29sXG4vLyBUT0RPOiBtYWtlIGFuIGFuZ2xlLXNuYXAgd2hlbiBcIlNoaWZ0XCIgaXMgcHJlc3NlZFxuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExpbmVUb29sdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0xpbmVUb29sJyxcbiAgbWl4aW5zOiBbb3ZlcmxheSwgdG9vbF0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4xLjAnXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9vbDogZnVuY3Rpb24gdG9vbCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIERlc2NyaXB0b3IgZm9yIHRoZSB0b29sXG4gICAgICAgIGdyb3VwOiAnTGluZXMnLFxuICAgICAgICBpY29uOiBpY29uc19uYW1lc3BhY2VPYmplY3RbXCJzZWdtZW50LnBuZ1wiXSxcbiAgICAgICAgdHlwZTogJ1NlZ21lbnQnLFxuICAgICAgICBoaW50OiAnVGhpcyBoaW50IHdpbGwgYmUgc2hvd24gb24gaG92ZXInLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgLy8gRGVmYXVsdCBkYXRhXG4gICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgLy8gRGVmYXVsdCBzZXR0aW5nc1xuICAgICAgICAvLyBNb2RpZmljYXRpb25zXG4gICAgICAgIG1vZHM6IHtcbiAgICAgICAgICAnRXh0ZW5kZWQnOiB7XG4gICAgICAgICAgICAvLyBSZXdyaXRlcyB0aGUgZGVmYXVsdCBzZXR0aW5nIGZpZWxkc1xuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgZXh0ZW5kZWQ6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpY29uOiBpY29uc19uYW1lc3BhY2VPYmplY3RbXCJleHRlbmRlZC5wbmdcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgICdSYXknOiB7XG4gICAgICAgICAgICAvLyBSZXdyaXRlcyB0aGUgZGVmYXVsdCBzZXR0aW5nIGZpZWxkc1xuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgcmF5OiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWNvbjogaWNvbnNfbmFtZXNwYWNlT2JqZWN0W1wicmF5LnBuZ1wiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIENhbGxlZCBhZnRlciBvdmVybGF5IG1vdW50ZWRcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gRmlyc3QgcGluIGlzIHNldHRsZWQgYXQgdGhlIG1vdXNlIHBvc2l0aW9uXG4gICAgICB0aGlzLnBpbnMucHVzaChuZXcgUGluKHRoaXMsICdwMScpKTsgLy8gU2Vjb25kIG9uZSBpcyBmb2xsb3dpbmcgbW91c2UgdW50aWwgaXQgY2xpY2tzXG5cbiAgICAgIHRoaXMucGlucy5wdXNoKG5ldyBQaW4odGhpcywgJ3AyJywge1xuICAgICAgICBzdGF0ZTogJ3RyYWNraW5nJ1xuICAgICAgfSkpO1xuICAgICAgdGhpcy5waW5zWzFdLm9uKCdzZXR0bGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDYWxsIHdoZW4gY3VycmVudCB0b29sIGRyYXdpbmcgaXMgZmluaXNoZWRcbiAgICAgICAgLy8gKE9wdGlvbmFsbHkpIHJlc2V0IHRoZSBtb2RlIGJhY2sgdG8gJ0N1cnNvcidcbiAgICAgICAgX3RoaXMuc2V0X3N0YXRlKCdmaW5pc2hlZCcpO1xuXG4gICAgICAgIF90aGlzLiRlbWl0KCdkcmF3aW5nLW1vZGUtb2ZmJyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBpZiAoIXRoaXMucDEgfHwgIXRoaXMucDIpIHJldHVybjtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBpZiAodGhpcy5zZXR0LnJheSkge1xuICAgICAgICBuZXcgUmF5KHRoaXMsIGN0eCkuZHJhdyh0aGlzLnAxLCB0aGlzLnAyKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0LmV4dGVuZGVkKSB7XG4gICAgICAgIG5ldyBMaW5lKHRoaXMsIGN0eCkuZHJhdyh0aGlzLnAxLCB0aGlzLnAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldyBTZWcodGhpcywgY3R4KS5kcmF3KHRoaXMucDEsIHRoaXMucDIpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB0aGlzLnJlbmRlcl9waW5zKGN0eCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnTGluZVRvb2wnXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvcl07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIHAxOiBmdW5jdGlvbiBwMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncy5wMTtcbiAgICB9LFxuICAgIHAyOiBmdW5jdGlvbiBwMigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncy5wMjtcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjk7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8ICcjNDJiMjhhJztcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0xpbmVUb29sLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX0xpbmVUb29sdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKExpbmVUb29sdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9MaW5lVG9vbC52dWVcbnZhciBMaW5lVG9vbF9yZW5kZXIsIExpbmVUb29sX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIExpbmVUb29sX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfTGluZVRvb2x2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIExpbmVUb29sX3JlbmRlcixcbiAgTGluZVRvb2xfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBMaW5lVG9vbF9hcGk7IH1cbkxpbmVUb29sX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvTGluZVRvb2wudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTGluZVRvb2wgPSAoTGluZVRvb2xfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1JhbmdlVG9vbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8vIFByaWNlL1RpbWUgbWVhc3VybWVudCB0b29sXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSYW5nZVRvb2x2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnUmFuZ2VUb29sJyxcbiAgbWl4aW5zOiBbb3ZlcmxheSwgdG9vbF0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMi4wLjEnXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9vbDogZnVuY3Rpb24gdG9vbCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIERlc2NyaXB0b3IgZm9yIHRoZSB0b29sXG4gICAgICAgIGdyb3VwOiAnTWVhc3VyZW1lbnRzJyxcbiAgICAgICAgaWNvbjogaWNvbnNfbmFtZXNwYWNlT2JqZWN0W1wicHJpY2VfcmFuZ2UucG5nXCJdLFxuICAgICAgICB0eXBlOiAnUHJpY2UnLFxuICAgICAgICBoaW50OiAnUHJpY2UgUmFuZ2UnLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgLy8gRGVmYXVsdCBkYXRhXG4gICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgLy8gRGVmYXVsdCBzZXR0aW5nc1xuICAgICAgICBtb2RzOiB7XG4gICAgICAgICAgJ1RpbWUnOiB7XG4gICAgICAgICAgICAvLyBSZXdyaXRlcyB0aGUgZGVmYXVsdCBzZXR0aW5nIGZpZWxkc1xuICAgICAgICAgICAgaWNvbjogaWNvbnNfbmFtZXNwYWNlT2JqZWN0W1widGltZV9yYW5nZS5wbmdcIl0sXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICBwcmljZTogZmFsc2UsXG4gICAgICAgICAgICAgIHRpbWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICdQcmljZVRpbWUnOiB7XG4gICAgICAgICAgICAvLyBSZXdyaXRlcyB0aGUgZGVmYXVsdCBzZXR0aW5nIGZpZWxkc1xuICAgICAgICAgICAgaWNvbjogaWNvbnNfbmFtZXNwYWNlT2JqZWN0W1wicHJpY2VfdGltZS5wbmdcIl0sXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICBwcmljZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdGltZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ1NoaWZ0TW9kZSc6IHtcbiAgICAgICAgICAgIC8vIFJld3JpdGVzIHRoZSBkZWZhdWx0IHNldHRpbmcgZmllbGRzXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICBwcmljZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdGltZTogdHJ1ZSxcbiAgICAgICAgICAgICAgc2hpZnRNb2RlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gQ2FsbGVkIGFmdGVyIG92ZXJsYXkgbW91bnRlZFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBGaXJzdCBwaW4gaXMgc2V0dGxlZCBhdCB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgIHRoaXMucGlucy5wdXNoKG5ldyBQaW4odGhpcywgJ3AxJywge1xuICAgICAgICBoaWRkZW46IHRoaXMuc2hpZnRcbiAgICAgIH0pKTsgLy8gU2Vjb25kIG9uZSBpcyBmb2xsb3dpbmcgbW91c2UgdW50aWwgaXQgY2xpY2tzXG5cbiAgICAgIHRoaXMucGlucy5wdXNoKG5ldyBQaW4odGhpcywgJ3AyJywge1xuICAgICAgICBzdGF0ZTogJ3RyYWNraW5nJyxcbiAgICAgICAgaGlkZGVuOiB0aGlzLnNoaWZ0XG4gICAgICB9KSk7XG4gICAgICB0aGlzLnBpbnNbMV0ub24oJ3NldHRsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENhbGwgd2hlbiBjdXJyZW50IHRvb2wgZHJhd2luZyBpcyBmaW5pc2hlZFxuICAgICAgICAvLyAoT3B0aW9uYWxseSkgcmVzZXQgdGhlIG1vZGUgYmFjayB0byAnQ3Vyc29yJ1xuICAgICAgICBfdGhpcy5zZXRfc3RhdGUoJ2ZpbmlzaGVkJyk7XG5cbiAgICAgICAgX3RoaXMuJGVtaXQoJ2RyYXdpbmctbW9kZS1vZmYnKTsgLy8gRGVzZWxlY3QgdGhlIHRvb2wgaW4gc2hpZnRNb2RlXG5cblxuICAgICAgICBpZiAoX3RoaXMuc2hpZnQpIF90aGlzLl8kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICAgIGV2ZW50OiAnb2JqZWN0LXNlbGVjdGVkJyxcbiAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGlmICghdGhpcy5wMSB8fCAhdGhpcy5wMikgcmV0dXJuO1xuICAgICAgdmFyIGRpciA9IE1hdGguc2lnbih0aGlzLnAyWzFdIC0gdGhpcy5wMVsxXSk7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHhtID0gbGF5b3V0LnQyc2NyZWVuKCh0aGlzLnAxWzBdICsgdGhpcy5wMlswXSkgKiAwLjUpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7IC8vIEJhY2tncm91bmRcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja19jb2xvcjtcbiAgICAgIHZhciB4MSA9IGxheW91dC50MnNjcmVlbih0aGlzLnAxWzBdKTtcbiAgICAgIHZhciB5MSA9IGxheW91dC4kMnNjcmVlbih0aGlzLnAxWzFdKTtcbiAgICAgIHZhciB4MiA9IGxheW91dC50MnNjcmVlbih0aGlzLnAyWzBdKTtcbiAgICAgIHZhciB5MiA9IGxheW91dC4kMnNjcmVlbih0aGlzLnAyWzFdKTtcbiAgICAgIGN0eC5maWxsUmVjdCh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgICAgaWYgKHRoaXMucHJpY2UpIHRoaXMudmVydGljYWwoY3R4LCB4MSwgeTEsIHgyLCB5MiwgeG0pO1xuICAgICAgaWYgKHRoaXMudGltZSkgdGhpcy5ob3Jpem9udGFsKGN0eCwgeDEsIHkxLCB4MiwgeTIsIHhtKTtcbiAgICAgIHRoaXMuZHJhd192YWx1ZShjdHgsIGRpciwgeG0sIHkyKTtcbiAgICAgIHRoaXMucmVuZGVyX3BpbnMoY3R4KTtcbiAgICB9LFxuICAgIHZlcnRpY2FsOiBmdW5jdGlvbiB2ZXJ0aWNhbChjdHgsIHgxLCB5MSwgeDIsIHkyLCB4bSkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBkaXIgPSBNYXRoLnNpZ24odGhpcy5wMlsxXSAtIHRoaXMucDFbMV0pO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBpZiAoIXRoaXMuc2hpZnQpIHtcbiAgICAgICAgLy8gVG9wXG4gICAgICAgIG5ldyBTZWcodGhpcywgY3R4KS5kcmF3KFt0aGlzLnAxWzBdLCB0aGlzLnAyWzFdXSwgW3RoaXMucDJbMF0sIHRoaXMucDJbMV1dKTsgLy8gQm90dG9tXG5cbiAgICAgICAgbmV3IFNlZyh0aGlzLCBjdHgpLmRyYXcoW3RoaXMucDFbMF0sIHRoaXMucDFbMV1dLCBbdGhpcy5wMlswXSwgdGhpcy5wMVsxXV0pO1xuICAgICAgfSAvLyBWZXJ0aWNhbCBBcnJvd1xuXG5cbiAgICAgIGN0eC5tb3ZlVG8oeG0gLSA0LCB5MiArIDUgKiBkaXIpO1xuICAgICAgY3R4LmxpbmVUbyh4bSwgeTIpO1xuICAgICAgY3R4LmxpbmVUbyh4bSArIDQsIHkyICsgNSAqIGRpcik7XG4gICAgICBjdHguc3Ryb2tlKCk7IC8vIFZlcnRpY2FsIExpbmVcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFs1LCA1XSk7XG4gICAgICBuZXcgU2VnKHRoaXMsIGN0eCkuZHJhdyhbKHRoaXMucDFbMF0gKyB0aGlzLnAyWzBdKSAqIDAuNSwgdGhpcy5wMlsxXV0sIFsodGhpcy5wMVswXSArIHRoaXMucDJbMF0pICogMC41LCB0aGlzLnAxWzFdXSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIH0sXG4gICAgaG9yaXpvbnRhbDogZnVuY3Rpb24gaG9yaXpvbnRhbChjdHgsIHgxLCB5MSwgeDIsIHkyLCB4bSkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciB4ZGlyID0gTWF0aC5zaWduKHRoaXMucDJbMF0gLSB0aGlzLnAxWzBdKTtcbiAgICAgIHZhciB5bSA9IChsYXlvdXQuJDJzY3JlZW4odGhpcy5wMVsxXSkgKyBsYXlvdXQuJDJzY3JlZW4odGhpcy5wMlsxXSkpIC8gMjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKCF0aGlzLnNoaWZ0KSB7XG4gICAgICAgIC8vIExlZnRcbiAgICAgICAgbmV3IFNlZyh0aGlzLCBjdHgpLmRyYXcoW3RoaXMucDFbMF0sIHRoaXMucDFbMV1dLCBbdGhpcy5wMVswXSwgdGhpcy5wMlsxXV0pOyAvLyBSaWdodFxuXG4gICAgICAgIG5ldyBTZWcodGhpcywgY3R4KS5kcmF3KFt0aGlzLnAyWzBdLCB0aGlzLnAxWzFdXSwgW3RoaXMucDJbMF0sIHRoaXMucDJbMV1dKTtcbiAgICAgIH0gLy8gSG9yaXpvbnRhbCBBcnJvd1xuXG5cbiAgICAgIGN0eC5tb3ZlVG8oeDIgLSA1ICogeGRpciwgeW0gLSA0KTtcbiAgICAgIGN0eC5saW5lVG8oeDIsIHltKTtcbiAgICAgIGN0eC5saW5lVG8oeDIgLSA1ICogeGRpciwgeW0gKyA0KTtcbiAgICAgIGN0eC5zdHJva2UoKTsgLy8gSG9yaXpvbnRhbCBMaW5lXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbNSwgNV0pO1xuICAgICAgY3R4Lm1vdmVUbyh4MSwgeW0pO1xuICAgICAgY3R4LmxpbmVUbyh4MiwgeW0pO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9LFxuICAgIC8vIFdURj8gSSBrbm93IGR1ZGUsIGEgbG90IG9mIHNoaXR0eSBjb2RlIGhlcmVcbiAgICBkcmF3X3ZhbHVlOiBmdW5jdGlvbiBkcmF3X3ZhbHVlKGN0eCwgZGlyLCB4bSwgeSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGN0eC5mb250ID0gdGhpcy5uZXdfZm9udDsgLy8gUHJpY2UgZGVsdGEgKGFuZiBwZXJjZW50KVxuXG4gICAgICB2YXIgZCQgPSAodGhpcy5wMlsxXSAtIHRoaXMucDFbMV0pLnRvRml4ZWQodGhpcy5wcmVjKTtcbiAgICAgIHZhciBwID0gKDEwMCAqICh0aGlzLnAyWzFdIC8gdGhpcy5wMVsxXSAtIDEpKS50b0ZpeGVkKHRoaXMucHJlYyk7IC8vIE1hcCBpbnRlcnZhbCB0byB0aGUgYWN0dWFsIHRmIChpbiBtcylcblxuICAgICAgdmFyIGYgPSBmdW5jdGlvbiBmKHQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5sYXlvdXQudGlfbWFwLnNtdGgydCh0KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkdCA9IGYodGhpcy5wMlswXSkgLSBmKHRoaXMucDFbMF0pO1xuICAgICAgdmFyIHRmID0gdGhpcy5sYXlvdXQudGlfbWFwLnRmOyAvLyBCYXJzIGNvdW50ICh0aHJvdWdoIHRoZSBjYW5kbGUgaW5kZXgpXG5cbiAgICAgIHZhciBmMiA9IGZ1bmN0aW9uIGYyKHQpIHtcbiAgICAgICAgdmFyIGMgPSBfdGhpczIubGF5b3V0LmNfbWFnbmV0KHQpO1xuXG4gICAgICAgIHZhciBjbiA9IF90aGlzMi5sYXlvdXQuY2FuZGxlcyB8fCBfdGhpczIubGF5b3V0Lm1hc3Rlcl9ncmlkLmNhbmRsZXM7XG4gICAgICAgIHJldHVybiBjbi5pbmRleE9mKGMpO1xuICAgICAgfTsgLy8gQmFycyBjb3VudCAoYW5kIGhhbmRsaW5nIHRoZSBuZWdhdGl2ZSB2YWx1ZXMpXG5cblxuICAgICAgdmFyIGIgPSBmMih0aGlzLnAyWzBdKSAtIGYyKHRoaXMucDFbMF0pOyAvLyBGb3JtYXQgdGltZSBkZWx0YVxuICAgICAgLy8gRm9ybWF0IHRpbWUgZGVsdGFcblxuICAgICAgdmFyIGR0c3RyID0gdGhpcy50MnN0cihkdCk7XG4gICAgICB2YXIgdGV4dCA9IFtdO1xuICAgICAgaWYgKHRoaXMucHJpY2UpIHRleHQucHVzaChcIlwiLmNvbmNhdChkJCwgXCIgIChcIikuY29uY2F0KHAsIFwiJSlcIikpO1xuICAgICAgaWYgKHRoaXMudGltZSkgdGV4dC5wdXNoKFwiXCIuY29uY2F0KGIsIFwiIGJhcnMsIFwiKS5jb25jYXQoZHRzdHIpKTtcbiAgICAgIHRleHQgPSB0ZXh0LmpvaW4oJ1xcbicpOyAvLyBcIk11bHRpcGxlXCIgZmlsbFRleHRcblxuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgdyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShsaW5lcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh4KS53aWR0aCArIDIwO1xuICAgICAgfSkpLmNvbmNhdChbMTAwXSkpO1xuICAgICAgdmFyIG4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICB2YXIgaCA9IDIwICogbjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnZhbHVlX2JhY2s7XG4gICAgICBjdHguZmlsbFJlY3QoeG0gLSB3ICogMC41LCB5IC0gKDEwICsgaCkgKiBkaXIsIHcsIGggKiBkaXIpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMudmFsdWVfY29sb3I7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsLCBpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChsLCB4bSwgeSArIChkaXIgPiAwID8gMjAgKiBpIC0gMjAgKiBuICsgNSA6IDIwICogaSArIDI1KSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIEZvcm1hdHMgdGltZSBmcm9tIG1zIHRvIGAxRCAxMmhgIGZvciBleGFtcGxlXG4gICAgdDJzdHI6IGZ1bmN0aW9uIHQyc3RyKHQpIHtcbiAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKHQpO1xuICAgICAgdmFyIGFicyA9IE1hdGguYWJzKHQpO1xuICAgICAgdmFyIHRmcyA9IFtbMTAwMCwgJ3MnLCA2MF0sIFs2MDAwMCwgJ20nLCA2MF0sIFszNjAwMDAwLCAnaCcsIDI0XSwgWzg2NDAwMDAwLCAnRCcsIDddLCBbNjA0ODAwMDAwLCAnVycsIDRdLCBbMjU5MjAwMDAwMCwgJ00nLCAxMl0sIFszMTUzNjAwMDAwMCwgJ1knLCBJbmZpbml0eV0sIFtJbmZpbml0eSwgJ0V0ZXJuaXR5JywgSW5maW5pdHldXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGZzW2ldWzBdID0gTWF0aC5mbG9vcihhYnMgLyB0ZnNbaV1bMF0pO1xuXG4gICAgICAgIGlmICh0ZnNbaV1bMF0gPT09IDApIHtcbiAgICAgICAgICB2YXIgcDEgPSB0ZnNbaSAtIDFdO1xuICAgICAgICAgIHZhciBwMiA9IHRmc1tpIC0gMl07XG4gICAgICAgICAgdmFyIHR4dCA9IHNpZ24gPCAwID8gJy0nIDogJyc7XG5cbiAgICAgICAgICBpZiAocDEpIHtcbiAgICAgICAgICAgIHR4dCArPSBwMS5zbGljZSgwLCAyKS5qb2luKCcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbjIgPSBwMiA/IHAyWzBdIC0gcDFbMF0gKiBwMlsyXSA6IDA7XG5cbiAgICAgICAgICBpZiAocDIgJiYgbjIpIHtcbiAgICAgICAgICAgIHR4dCArPSAnICc7XG4gICAgICAgICAgICB0eHQgKz0gXCJcIi5jb25jYXQobjIpLmNvbmNhdChwMlsxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHR4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1JhbmdlVG9vbCddO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgcDE6IGZ1bmN0aW9uIHAxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzLnAxO1xuICAgIH0sXG4gICAgcDI6IGZ1bmN0aW9uIHAyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzLnAyO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuOTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgdGhpcy4kcHJvcHMuY29sb3JzLmNyb3NzO1xuICAgIH0sXG4gICAgYmFja19jb2xvcjogZnVuY3Rpb24gYmFja19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFja0NvbG9yIHx8ICcjOWI5YmEzMTYnO1xuICAgIH0sXG4gICAgdmFsdWVfYmFjazogZnVuY3Rpb24gdmFsdWVfYmFjaygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQudmFsdWVCYWNrIHx8ICcjOWI5YmEzMTYnO1xuICAgIH0sXG4gICAgdmFsdWVfY29sb3I6IGZ1bmN0aW9uIHZhbHVlX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC52YWx1ZUNvbG9yIHx8IHRoaXMuJHByb3BzLmNvbG9ycy50ZXh0O1xuICAgIH0sXG4gICAgcHJlYzogZnVuY3Rpb24gcHJlYygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQucHJlY2lzaW9uIHx8IDI7XG4gICAgfSxcbiAgICBuZXdfZm9udDogZnVuY3Rpb24gbmV3X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gJzEycHggJyArIHRoaXMuJHByb3BzLmZvbnQuc3BsaXQoJ3B4JykucG9wKCk7XG4gICAgfSxcbiAgICBwcmljZTogZnVuY3Rpb24gcHJpY2UoKSB7XG4gICAgICByZXR1cm4gJ3ByaWNlJyBpbiB0aGlzLnNldHQgPyB0aGlzLnNldHQucHJpY2UgOiB0cnVlO1xuICAgIH0sXG4gICAgdGltZTogZnVuY3Rpb24gdGltZSgpIHtcbiAgICAgIHJldHVybiAndGltZScgaW4gdGhpcy5zZXR0ID8gdGhpcy5zZXR0LnRpbWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2hpZnRNb2RlO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvUmFuZ2VUb29sLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX1JhbmdlVG9vbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChSYW5nZVRvb2x2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1JhbmdlVG9vbC52dWVcbnZhciBSYW5nZVRvb2xfcmVuZGVyLCBSYW5nZVRvb2xfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgUmFuZ2VUb29sX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfUmFuZ2VUb29sdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBSYW5nZVRvb2xfcmVuZGVyLFxuICBSYW5nZVRvb2xfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBSYW5nZVRvb2xfYXBpOyB9XG5SYW5nZVRvb2xfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9SYW5nZVRvb2wudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUmFuZ2VUb29sID0gKFJhbmdlVG9vbF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvR3JpZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBTZXRzIHVwIGFsbCBsYXllcnMvb3ZlcmxheXMgZm9yIHRoZSBncmlkIHdpdGggJ2dyaWRfaWQnXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0dyaWQnLFxuICBwcm9wczogWydzdWInLCAnbGF5b3V0JywgJ3JhbmdlJywgJ2ludGVydmFsJywgJ2N1cnNvcicsICdjb2xvcnMnLCAnb3ZlcmxheXMnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2RhdGEnLCAnZ3JpZF9pZCcsICd5X3RyYW5zZm9ybScsICdmb250JywgJ3R2X2lkJywgJ2NvbmZpZycsICdtZXRhJywgJ3NoYWRlcnMnXSxcbiAgbWl4aW5zOiBbY2FudmFzLCB1eGxpc3RdLFxuICBjb21wb25lbnRzOiB7XG4gICAgQ3Jvc3NoYWlyOiBjb21wb25lbnRzX0Nyb3NzaGFpcixcbiAgICBLZXlib2FyZExpc3RlbmVyOiBLZXlib2FyZExpc3RlbmVyXG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIExpc3Qgb2YgYWxsIHBvc3NpYmxlIG92ZXJsYXlzIChidWlsdGluICsgY3VzdG9tKVxuICAgIHRoaXMuX2xpc3QgPSBbU3BsaW5lLCBTcGxpbmVzLCBSYW5nZSwgVHJhZGVzLCBDaGFubmVsLCBTZWdtZW50LCBDYW5kbGVzLCBWb2x1bWUsIFNwbGl0dGVycywgTGluZVRvb2wsIFJhbmdlVG9vbF0uY29uY2F0KHRoaXMuJHByb3BzLm92ZXJsYXlzKTtcbiAgICB0aGlzLl9yZWdpc3RyeSA9IHt9OyAvLyBXZSBuZWVkIHRvIGtub3cgd2hpY2ggY29tcG9uZW50cyB3ZSB3aWxsIHVzZS5cbiAgICAvLyBDdXN0b20gb3ZlcmxheSBjb21wb25lbnRzIG92ZXJ3cml0ZSBidWlsdC1pbnM6XG5cbiAgICB2YXIgdG9vbHMgPSBbXTtcblxuICAgIHRoaXMuX2xpc3QuZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgdmFyIHVzZV9mb3IgPSB4Lm1ldGhvZHMudXNlX2ZvcigpO1xuICAgICAgaWYgKHgubWV0aG9kcy50b29sKSB0b29scy5wdXNoKHtcbiAgICAgICAgdXNlX2ZvcjogdXNlX2ZvcixcbiAgICAgICAgaW5mbzogeC5tZXRob2RzLnRvb2woKVxuICAgICAgfSk7XG4gICAgICB1c2VfZm9yLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICBfdGhpcy5fcmVnaXN0cnlbaW5kaWNhdG9yXSA9IGk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgIGV2ZW50OiAncmVnaXN0ZXItdG9vbHMnLFxuICAgICAgYXJnczogdG9vbHNcbiAgICB9KTtcbiAgICB0aGlzLiRvbignY3VzdG9tLWV2ZW50JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBfdGhpcy5vbl91eF9ldmVudChlLCAnZ3JpZCcpO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBlbCA9IHRoaXMuJHJlZnNbJ2NhbnZhcyddO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgR3JpZChlbCwgdGhpcyk7XG4gICAgdGhpcy5zZXR1cCgpO1xuICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczIucmVkcmF3KCk7XG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQuZ3JpZHNbaWRdO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZV9jYW52YXMoaCwgXCJncmlkLVwiLmNvbmNhdChpZCksIHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IGxheW91dC5vZmZzZXQgfHwgMFxuICAgICAgfSxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGgsXG4gICAgICAgIGhlaWdodDogbGF5b3V0LmhlaWdodCxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLiRwcm9wcy5jb2xvcnMuYmFja1xuICAgICAgfSxcbiAgICAgIGhzOiBbaChjb21wb25lbnRzX0Nyb3NzaGFpciwge1xuICAgICAgICBwcm9wczogdGhpcy5jb21tb25fcHJvcHMoKSxcbiAgICAgICAgb246IHRoaXMubGF5ZXJfZXZlbnRzXG4gICAgICB9KSwgaChLZXlib2FyZExpc3RlbmVyLCB7XG4gICAgICAgIG9uOiB0aGlzLmtleWJvYXJkX2V2ZW50c1xuICAgICAgfSksIGgoVXhMYXllciwge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB0dl9pZDogdGhpcy4kcHJvcHMudHZfaWQsXG4gICAgICAgICAgdXhzOiB0aGlzLnV4cyxcbiAgICAgICAgICBjb2xvcnM6IHRoaXMuJHByb3BzLmNvbG9ycyxcbiAgICAgICAgICBjb25maWc6IHRoaXMuJHByb3BzLmNvbmZpZyxcbiAgICAgICAgICB1cGRhdGVyOiBNYXRoLnJhbmRvbSgpXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgJ2N1c3RvbS1ldmVudCc6IHRoaXMuZW1pdF91eF9ldmVudFxuICAgICAgICB9XG4gICAgICB9KV0uY29uY2F0KHRoaXMuZ2V0X292ZXJsYXlzKGgpKVxuICAgIH0pO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgbmV3X2xheWVyOiBmdW5jdGlvbiBuZXdfbGF5ZXIobGF5ZXIpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMucmVuZGVyZXIubmV3X2xheWVyKGxheWVyKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVsX2xheWVyOiBmdW5jdGlvbiBkZWxfbGF5ZXIobGF5ZXIpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQucmVuZGVyZXIuZGVsX2xheWVyKGxheWVyKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGdyaWRfaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogJ3JlbW92ZS1zaGFkZXJzJyxcbiAgICAgICAgYXJnczogW2dyaWRfaWQsIGxheWVyXVxuICAgICAgfSk7IC8vIFRPRE86IGNsb3NlIGFsbCBpbnRlcmZhY2VzXG5cbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6ICdyZW1vdmUtbGF5ZXItbWV0YScsXG4gICAgICAgIGFyZ3M6IFtncmlkX2lkLCBsYXllcl1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW1vdmVfYWxsX3V4KGxheWVyKTtcbiAgICB9LFxuICAgIGdldF9vdmVybGF5czogZnVuY3Rpb24gZ2V0X292ZXJsYXlzKGgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAvLyBEaXN0cmlidXRlcyBvdmVybGF5IGRhdGEgJiBzZXR0aW5ncyBhY2NvcmRpbmdcbiAgICAgIC8vIHRvIHRoaXMuX3JlZ2lzdHJ5OyByZXR1cm5zIGNvbXBvIGxpc3RcbiAgICAgIHZhciBjb21wX2xpc3QgPSBbXSxcbiAgICAgICAgICBjb3VudCA9IHt9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgY29tcCA9IHRoaXMuX2xpc3RbdGhpcy5fcmVnaXN0cnlbZC50eXBlXV07XG5cbiAgICAgICAgICBpZiAoY29tcCkge1xuICAgICAgICAgICAgaWYgKGNvbXAubWV0aG9kcy5jYWxjKSB7XG4gICAgICAgICAgICAgIGNvbXAgPSB0aGlzLmluamVjdF9yZW5kZXJlcihjb21wKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tcF9saXN0LnB1c2goe1xuICAgICAgICAgICAgICBjbHM6IGNvbXAsXG4gICAgICAgICAgICAgIHR5cGU6IGQudHlwZSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhLFxuICAgICAgICAgICAgICBzZXR0aW5nczogZC5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgaTA6IGQuaTAsXG4gICAgICAgICAgICAgIHRmOiBkLnRmLFxuICAgICAgICAgICAgICBsYXN0OiBkLmxhc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY291bnRbZC50eXBlXSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21wX2xpc3QubWFwKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgIHJldHVybiBoKHguY2xzLCB7XG4gICAgICAgICAgb246IF90aGlzNS5sYXllcl9ldmVudHMsXG4gICAgICAgICAgYXR0cnM6IE9iamVjdC5hc3NpZ24oX3RoaXM1LmNvbW1vbl9wcm9wcygpLCB7XG4gICAgICAgICAgICBpZDogXCJcIi5jb25jYXQoeC50eXBlLCBcIl9cIikuY29uY2F0KGNvdW50W3gudHlwZV0rKyksXG4gICAgICAgICAgICB0eXBlOiB4LnR5cGUsXG4gICAgICAgICAgICBkYXRhOiB4LmRhdGEsXG4gICAgICAgICAgICBzZXR0aW5nczogeC5zZXR0aW5ncyxcbiAgICAgICAgICAgIGkwOiB4LmkwLFxuICAgICAgICAgICAgdGY6IHgudGYsXG4gICAgICAgICAgICBudW06IGksXG4gICAgICAgICAgICBncmlkX2lkOiBfdGhpczUuJHByb3BzLmdyaWRfaWQsXG4gICAgICAgICAgICBtZXRhOiBfdGhpczUuJHByb3BzLm1ldGEsXG4gICAgICAgICAgICBsYXN0OiB4Lmxhc3RcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY29tbW9uX3Byb3BzOiBmdW5jdGlvbiBjb21tb25fcHJvcHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJzb3I6IHRoaXMuJHByb3BzLmN1cnNvcixcbiAgICAgICAgY29sb3JzOiB0aGlzLiRwcm9wcy5jb2xvcnMsXG4gICAgICAgIGxheW91dDogdGhpcy4kcHJvcHMubGF5b3V0LmdyaWRzW3RoaXMuJHByb3BzLmdyaWRfaWRdLFxuICAgICAgICBpbnRlcnZhbDogdGhpcy4kcHJvcHMuaW50ZXJ2YWwsXG4gICAgICAgIHN1YjogdGhpcy4kcHJvcHMuc3ViLFxuICAgICAgICBmb250OiB0aGlzLiRwcm9wcy5mb250LFxuICAgICAgICBjb25maWc6IHRoaXMuJHByb3BzLmNvbmZpZ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGVtaXRfdXhfZXZlbnQ6IGZ1bmN0aW9uIGVtaXRfdXhfZXZlbnQoZSkge1xuICAgICAgdmFyIGVfcGFzcyA9IHRoaXMub25fdXhfZXZlbnQoZSwgJ2dyaWQnKTtcbiAgICAgIGlmIChlX3Bhc3MpIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIGUpO1xuICAgIH0sXG4gICAgLy8gUmVwbGFjZSB0aGUgY3VycmVudCBjb21wIHdpdGggJ3JlbmRlcmVyJ1xuICAgIGluamVjdF9yZW5kZXJlcjogZnVuY3Rpb24gaW5qZWN0X3JlbmRlcmVyKGNvbXApIHtcbiAgICAgIHZhciBzcmMgPSBjb21wLm1ldGhvZHMuY2FsYygpO1xuXG4gICAgICBpZiAoIXNyYy5jb25mIHx8ICFzcmMuY29uZi5yZW5kZXJlciB8fCBjb21wLl9fcmVuZGVyZXJfXykge1xuICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgIH0gLy8gU2VhcmNoIGZvciBhbiBvdmVybGF5IHdpdGggdGhlIHRhcmdldCAnbmFtZSdcblxuXG4gICAgICB2YXIgZiA9IHRoaXMuX2xpc3QuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5uYW1lID09PSBzcmMuY29uZi5yZW5kZXJlcjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWYpIHJldHVybiBjb21wO1xuICAgICAgY29tcC5taXhpbnMucHVzaChmKTtcbiAgICAgIGNvbXAuX19yZW5kZXJlcl9fID0gc3JjLmNvbmYucmVuZGVyZXI7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNfYWN0aXZlOiBmdW5jdGlvbiBpc19hY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuY3Vyc29yLnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLiRwcm9wcy5jdXJzb3IuZ3JpZF9pZCA9PT0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgcmFuZ2U6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRPRE86IExlZnQtc2lkZSByZW5kZXIgbGFnIGZpeDpcbiAgICAgICAgLy8gT3ZlcmxheSBkYXRhIGlzIHVwZGF0ZWQgb25lIHRpY2sgbGF0ZXIgdGhhblxuICAgICAgICAvLyB0aGUgbWFpbiBzdWIuIEZhc3QgZml4IGlzIHRvIGRlbGF5IHJlZHJhdygpXG4gICAgICAgIC8vIGNhbGwuIEl0IHdpbGwgYmUgYSBzb2x1dGlvbiB1bnRpbCBhIGJldHRlclxuICAgICAgICAvLyBvbmUgY29tZXMgYnkuXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM2LnJlZHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfSxcbiAgICBjdXJzb3I6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy4kcHJvcHMuY3Vyc29yLmxvY2tlZCkgdGhpcy5yZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfSxcbiAgICBvdmVybGF5czoge1xuICAgICAgLy8gVHJhY2sgY2hhbmdlcyBpbiBjYWxjKCkgZnVuY3Rpb25zXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG92cykge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG92cyksXG4gICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIG92ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJGNoaWxkcmVuKSxcbiAgICAgICAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXAgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wLmlkICE9PSAnc3RyaW5nJykgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIHR1cGxlID0gY29tcC5pZC5zcGxpdCgnXycpO1xuICAgICAgICAgICAgICAgIHR1cGxlLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR1cGxlLmpvaW4oJ18nKSA9PT0gb3YubmFtZSkge1xuICAgICAgICAgICAgICAgICAgY29tcC5jYWxjID0gb3YubWV0aG9kcy5jYWxjO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjb21wLmNhbGMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgdmFyIGNhbGMgPSBjb21wLmNhbGMudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGNhbGMgIT09IG92Ll9fcHJldnNjcmlwdF9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAuZXhlY19zY3JpcHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgb3YuX19wcmV2c2NyaXB0X18gPSBjYWxjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9LFxuICAgIC8vIFJlZHJhdyBvbiB0aGUgc2hhZGVyIGxpc3QgY2hhbmdlXG4gICAgc2hhZGVyczogZnVuY3Rpb24gc2hhZGVycyhuLCBwKSB7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBsYXllcl9ldmVudHM6IHtcbiAgICAgICAgJ25ldy1ncmlkLWxheWVyJzogdGhpcy5uZXdfbGF5ZXIsXG4gICAgICAgICdkZWxldGUtZ3JpZC1sYXllcic6IHRoaXMuZGVsX2xheWVyLFxuICAgICAgICAnc2hvdy1ncmlkLWxheWVyJzogZnVuY3Rpb24gc2hvd0dyaWRMYXllcihkKSB7XG4gICAgICAgICAgX3RoaXM3LnJlbmRlcmVyLnNob3dfaGlkZV9sYXllcihkKTtcblxuICAgICAgICAgIF90aGlzNy5yZWRyYXcoKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3JlZHJhdy1ncmlkJzogdGhpcy5yZWRyYXcsXG4gICAgICAgICdsYXllci1tZXRhLXByb3BzJzogZnVuY3Rpb24gbGF5ZXJNZXRhUHJvcHMoZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczcuJGVtaXQoJ2xheWVyLW1ldGEtcHJvcHMnLCBkKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2N1c3RvbS1ldmVudCc6IGZ1bmN0aW9uIGN1c3RvbUV2ZW50KGQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM3LiRlbWl0KCdjdXN0b20tZXZlbnQnLCBkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleWJvYXJkX2V2ZW50czoge1xuICAgICAgICAncmVnaXN0ZXIta2ItbGlzdGVuZXInOiBmdW5jdGlvbiByZWdpc3RlcktiTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczcuJGVtaXQoJ3JlZ2lzdGVyLWtiLWxpc3RlbmVyJywgZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICAncmVtb3ZlLWtiLWxpc3RlbmVyJzogZnVuY3Rpb24gcmVtb3ZlS2JMaXN0ZW5lcihldmVudCkge1xuICAgICAgICAgIF90aGlzNy4kZW1pdCgncmVtb3ZlLWtiLWxpc3RlbmVyJywgZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICAna2V5dXAnOiBmdW5jdGlvbiBrZXl1cChldmVudCkge1xuICAgICAgICAgIGlmICghX3RoaXM3LmlzX2FjdGl2ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgX3RoaXM3LnJlbmRlcmVyLnByb3BhZ2F0ZSgna2V5dXAnLCBldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgICdrZXlkb3duJzogZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xuICAgICAgICAgIGlmICghX3RoaXM3LmlzX2FjdGl2ZSkgcmV0dXJuOyAvLyBUT0RPOiBpcyB0aGlzIG5lZWVkZWQ/XG5cbiAgICAgICAgICBfdGhpczcucmVuZGVyZXIucHJvcGFnYXRlKCdrZXlkb3duJywgZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICAna2V5cHJlc3MnOiBmdW5jdGlvbiBrZXlwcmVzcyhldmVudCkge1xuICAgICAgICAgIGlmICghX3RoaXM3LmlzX2FjdGl2ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgX3RoaXM3LnJlbmRlcmVyLnByb3BhZ2F0ZSgna2V5cHJlc3MnLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0dyaWQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19HcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0dyaWQudnVlXG52YXIgR3JpZF9yZW5kZXIsIEdyaWRfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgR3JpZF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgR3JpZF9yZW5kZXIsXG4gIEdyaWRfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBHcmlkX2FwaTsgfVxuR3JpZF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0dyaWQudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19HcmlkID0gKEdyaWRfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvc2lkZWJhci5qc1xuXG5cblxuZnVuY3Rpb24gc2lkZWJhcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gc2lkZWJhcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gc2lkZWJhcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHNpZGViYXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHNpZGViYXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIHNpZGViYXJfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG5cblxudmFyIFBBTkhFSUdIVDtcblxudmFyIFNpZGViYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaWRlYmFyKGNhbnZhcywgY29tcCwgc2lkZSkge1xuICAgIGlmIChzaWRlID09PSB2b2lkIDApIHtcbiAgICAgIHNpZGUgPSAncmlnaHQnO1xuICAgIH1cblxuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZGViYXIpO1xuXG4gICAgUEFOSEVJR0hUID0gY29tcC5jb25maWcuUEFOSEVJR0hUO1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5jb21wID0gY29tcDtcbiAgICB0aGlzLiRwID0gY29tcC4kcHJvcHM7XG4gICAgdGhpcy5kYXRhID0gdGhpcy4kcC5zdWI7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuJHAucmFuZ2U7XG4gICAgdGhpcy5pZCA9IHRoaXMuJHAuZ3JpZF9pZDtcbiAgICB0aGlzLmxheW91dCA9IHRoaXMuJHAubGF5b3V0LmdyaWRzW3RoaXMuaWRdO1xuICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgdGhpcy5saXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKFNpZGViYXIsIFt7XG4gICAga2V5OiBcImxpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgbWMgPSB0aGlzLm1jID0gbmV3IGhhbW1lci5NYW5hZ2VyKHRoaXMuY2FudmFzKTtcbiAgICAgIG1jLmFkZChuZXcgaGFtbWVyLlBhbih7XG4gICAgICAgIGRpcmVjdGlvbjogaGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgICAgdGhyZXNob2xkOiAwXG4gICAgICB9KSk7XG4gICAgICBtYy5hZGQobmV3IGhhbW1lci5UYXAoe1xuICAgICAgICBldmVudDogJ2RvdWJsZXRhcCcsXG4gICAgICAgIHRhcHM6IDIsXG4gICAgICAgIHBvc1RocmVzaG9sZDogNTBcbiAgICAgIH0pKTtcbiAgICAgIG1jLm9uKCdwYW5zdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMuJHAueV90cmFuc2Zvcm0pIHtcbiAgICAgICAgICBfdGhpcy56b29tID0gX3RoaXMuJHAueV90cmFuc2Zvcm0uem9vbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy56b29tID0gMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMueV9yYW5nZSA9IFtfdGhpcy5sYXlvdXQuJF9oaSwgX3RoaXMubGF5b3V0LiRfbG9dO1xuICAgICAgICBfdGhpcy5kcnVnID0ge1xuICAgICAgICAgIHk6IGV2ZW50LmNlbnRlci55LFxuICAgICAgICAgIHo6IF90aGlzLnpvb20sXG4gICAgICAgICAgbWlkOiBtYXRoLmxvZ19taWQoX3RoaXMueV9yYW5nZSwgX3RoaXMubGF5b3V0LmhlaWdodCksXG4gICAgICAgICAgQTogX3RoaXMubGF5b3V0LkEsXG4gICAgICAgICAgQjogX3RoaXMubGF5b3V0LkJcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3Bhbm1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzLmRydWcpIHtcbiAgICAgICAgICBfdGhpcy56b29tID0gX3RoaXMuY2FsY196b29tKGV2ZW50KTtcblxuICAgICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ3NpZGViYXItdHJhbnNmb3JtJywge1xuICAgICAgICAgICAgZ3JpZF9pZDogX3RoaXMuaWQsXG4gICAgICAgICAgICB6b29tOiBfdGhpcy56b29tLFxuICAgICAgICAgICAgYXV0bzogZmFsc2UsXG4gICAgICAgICAgICByYW5nZTogX3RoaXMuY2FsY19yYW5nZSgpLFxuICAgICAgICAgICAgZHJ1Z2dpbmc6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG1jLm9uKCdwYW5lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRydWcgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ3NpZGViYXItdHJhbnNmb3JtJywge1xuICAgICAgICAgIGdyaWRfaWQ6IF90aGlzLmlkLFxuICAgICAgICAgIGRydWdnaW5nOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgbWMub24oJ2RvdWJsZXRhcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnc2lkZWJhci10cmFuc2Zvcm0nLCB7XG4gICAgICAgICAgZ3JpZF9pZDogX3RoaXMuaWQsXG4gICAgICAgICAgem9vbTogMS4wLFxuICAgICAgICAgIGF1dG86IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuem9vbSA9IDEuMDtcblxuICAgICAgICBfdGhpcy51cGRhdGUoKTtcbiAgICAgIH0pOyAvLyBUT0RPOiBEbyBsYXRlciBmb3IgbW9iaWxlIHZlcnNpb25cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2UgdG8gdGhlIGdyaWRcbiAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQuZ3JpZHNbdGhpcy5pZF07XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5sYXlvdXQueXM7XG4gICAgICB2YXIgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHcsXG4gICAgICAgICAgaCxcbiAgICAgICAgICBzaWRlID0gdGhpcy5zaWRlO1xuICAgICAgdmFyIHNiID0gdGhpcy5sYXlvdXQuc2I7IC8vdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy4kcC5jb2xvcnMuYmFja1xuXG4gICAgICB0aGlzLmN0eC5mb250ID0gdGhpcy4kcC5mb250O1xuXG4gICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgdyA9IE1hdGguZmxvb3Ioc2IpO1xuICAgICAgICAgIGggPSB0aGlzLmxheW91dC5oZWlnaHQ7IC8vdGhpcy5jdHguZmlsbFJlY3QoeCwgeSwgdywgaClcblxuICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnNjYWxlO1xuICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4ICsgMC41LCAwKTtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCArIDAuNSwgaCk7XG4gICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHggPSAwO1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgIHcgPSBNYXRoLmZsb29yKHNiKTtcbiAgICAgICAgICBoID0gdGhpcy5sYXlvdXQuaGVpZ2h0OyAvL3RoaXMuY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpXG5cbiAgICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5zY2FsZTtcbiAgICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeCArIDAuNSwgMCk7XG4gICAgICAgICAgdGhpcy5jdHgubGluZVRvKHggKyAwLjUsIGgpO1xuICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy50ZXh0O1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBzaWRlYmFyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocG9pbnRzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChwWzBdID4gdGhpcy5sYXlvdXQuaGVpZ2h0KSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgeDEgPSBzaWRlID09PSAnbGVmdCcgPyB3IC0gMC41IDogeCAtIDAuNTtcbiAgICAgICAgICB2YXIgeDIgPSBzaWRlID09PSAnbGVmdCcgPyB4MSAtIDQuNSA6IHgxICsgNC41O1xuICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4MSwgcFswXSAtIDAuNSk7XG4gICAgICAgICAgdGhpcy5jdHgubGluZVRvKHgyLCBwWzBdIC0gMC41KTtcbiAgICAgICAgICB2YXIgb2Zmc3QgPSBzaWRlID09PSAnbGVmdCcgPyAtMTAgOiAxMDtcbiAgICAgICAgICB0aGlzLmN0eC50ZXh0QWxpZ24gPSBzaWRlID09PSAnbGVmdCcgPyAnZW5kJyA6ICdzdGFydCc7XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLmxheW91dC5wcmVjO1xuICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KHBbMV0udG9GaXhlZChkKSwgeDEgKyBvZmZzdCwgcFswXSArIDQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgaWYgKHRoaXMuJHAuZ3JpZF9pZCkgdGhpcy51cHBlcl9ib3JkZXIoKTtcbiAgICAgIHRoaXMuYXBwbHlfc2hhZGVycygpO1xuICAgICAgaWYgKHRoaXMuJHAuY3Vyc29yLnkgJiYgdGhpcy4kcC5jdXJzb3IueSQpIHRoaXMucGFuZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlfc2hhZGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseV9zaGFkZXJzKCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHAubGF5b3V0LmdyaWRzW3RoaXMuaWRdO1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgY3Vyc29yOiB0aGlzLiRwLmN1cnNvclxuICAgICAgfTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBzaWRlYmFyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcC5zaGFkZXJzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHMgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICAgIHMuZHJhdyh0aGlzLmN0eCwgcHJvcHMpO1xuICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwcGVyX2JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cHBlcl9ib3JkZXIoKSB7XG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnNjYWxlO1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgMC41KTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLmxheW91dC53aWR0aCwgMC41KTtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgIH0gLy8gQSBncmF5IGJhciBiZWhpbmQgdGhlIGN1cnJlbnQgcHJpY2VcblxuICB9LCB7XG4gICAga2V5OiBcInBhbmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhbmVsKCkge1xuICAgICAgaWYgKHRoaXMuJHAuY3Vyc29yLmdyaWRfaWQgIT09IHRoaXMubGF5b3V0LmlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxibCA9IHRoaXMuJHAuY3Vyc29yLnkkLnRvRml4ZWQodGhpcy5sYXlvdXQucHJlYyk7XG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5wYW5lbDtcbiAgICAgIHZhciBwYW53aWR0aCA9IHRoaXMubGF5b3V0LnNiICsgMTtcbiAgICAgIHZhciB4ID0gLTAuNTtcbiAgICAgIHZhciB5ID0gdGhpcy4kcC5jdXJzb3IueSAtIFBBTkhFSUdIVCAqIDAuNSAtIDAuNTtcbiAgICAgIHZhciBhID0gNztcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHggLSAwLjUsIHksIHBhbndpZHRoLCBQQU5IRUlHSFQpO1xuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy4kcC5jb2xvcnMudGV4dEhMO1xuICAgICAgdGhpcy5jdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgdGhpcy5jdHguZmlsbFRleHQobGJsLCBhLCB5ICsgMTUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjX3pvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY196b29tKGV2ZW50KSB7XG4gICAgICB2YXIgZCA9IHRoaXMuZHJ1Zy55IC0gZXZlbnQuY2VudGVyLnk7XG4gICAgICB2YXIgc3BlZWQgPSBkID4gMCA/IDMgOiAxO1xuICAgICAgdmFyIGsgPSAxICsgc3BlZWQgKiBkIC8gdGhpcy5sYXlvdXQuaGVpZ2h0O1xuICAgICAgcmV0dXJuIHV0aWxzLmNsYW1wKHRoaXMuZHJ1Zy56ICogaywgMC4wMDUsIDEwMCk7XG4gICAgfSAvLyBOb3QgdGhlIGJlc3QgcGxhY2UgdG8gY2FsY3VsYXRlIHktcmFuZ2UgYnV0XG4gICAgLy8gdGhpcyBpcyB0aGUgc2ltcGxlc3Qgc29sdXRpb24gSSBmb3VuZCB1cCB0b1xuICAgIC8vIGRhdGVcblxuICB9LCB7XG4gICAga2V5OiBcImNhbGNfcmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY19yYW5nZShkaWZmMSwgZGlmZjIpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoZGlmZjEgPT09IHZvaWQgMCkge1xuICAgICAgICBkaWZmMSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmMiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRpZmYyID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHogPSB0aGlzLnpvb20gLyB0aGlzLmRydWcuejtcbiAgICAgIHZhciB6ayA9ICgxIC8geiAtIDEpIC8gMjtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMueV9yYW5nZS5zbGljZSgpO1xuICAgICAgdmFyIGRlbHRhID0gcmFuZ2VbMF0gLSByYW5nZVsxXTtcblxuICAgICAgaWYgKCF0aGlzLmxheW91dC5ncmlkLmxvZ1NjYWxlKSB7XG4gICAgICAgIHJhbmdlWzBdID0gcmFuZ2VbMF0gKyBkZWx0YSAqIHprICogZGlmZjE7XG4gICAgICAgIHJhbmdlWzFdID0gcmFuZ2VbMV0gLSBkZWx0YSAqIHprICogZGlmZjI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHhfbWlkID0gdGhpcy5sYXlvdXQuaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIG5ld19oaSA9IHB4X21pZCAtIHB4X21pZCAqICgxIC8geik7XG4gICAgICAgIHZhciBuZXdfbG8gPSBweF9taWQgKyBweF9taWQgKiAoMSAvIHopOyAvLyBVc2Ugb2xkIG1hcHBpbmcgdG8gZ2V0IGEgbmV3IHJhbmdlXG5cbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiBmKHkpIHtcbiAgICAgICAgICByZXR1cm4gbWF0aC5leHAoKHkgLSBfdGhpczIuZHJ1Zy5CKSAvIF90aGlzMi5kcnVnLkEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjb3B5ID0gcmFuZ2Uuc2xpY2UoKTtcbiAgICAgICAgcmFuZ2VbMF0gPSBmKG5ld19oaSk7XG4gICAgICAgIHJhbmdlWzFdID0gZihuZXdfbG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlem9vbV9yYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXpvb21fcmFuZ2UoZGVsdGEsIGRpZmYxLCBkaWZmMikge1xuICAgICAgaWYgKCF0aGlzLiRwLnlfdHJhbnNmb3JtIHx8IHRoaXMuJHAueV90cmFuc2Zvcm0uYXV0bykgcmV0dXJuO1xuICAgICAgdGhpcy56b29tID0gMS4wOyAvLyBUT0RPOiBmdXJ0aGVyIHdvcmsgKGltcHJvdmUgc2NhbGluZyByYXRpbylcblxuICAgICAgaWYgKGRlbHRhIDwgMCkgZGVsdGEgLz0gMy43NTsgLy8gQnR3LCBpZGsgd2h5IDMuNzUsIGJ1dCBpdCB3b3Jrc1xuXG4gICAgICBkZWx0YSAqPSAwLjI1O1xuICAgICAgdGhpcy55X3JhbmdlID0gW3RoaXMubGF5b3V0LiRfaGksIHRoaXMubGF5b3V0LiRfbG9dO1xuICAgICAgdGhpcy5kcnVnID0ge1xuICAgICAgICB5OiAwLFxuICAgICAgICB6OiB0aGlzLnpvb20sXG4gICAgICAgIG1pZDogbWF0aC5sb2dfbWlkKHRoaXMueV9yYW5nZSwgdGhpcy5sYXlvdXQuaGVpZ2h0KSxcbiAgICAgICAgQTogdGhpcy5sYXlvdXQuQSxcbiAgICAgICAgQjogdGhpcy5sYXlvdXQuQlxuICAgICAgfTtcbiAgICAgIHRoaXMuem9vbSA9IHRoaXMuY2FsY196b29tKHtcbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgeTogZGVsdGEgKiB0aGlzLmxheW91dC5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ3NpZGViYXItdHJhbnNmb3JtJywge1xuICAgICAgICBncmlkX2lkOiB0aGlzLmlkLFxuICAgICAgICB6b29tOiB0aGlzLnpvb20sXG4gICAgICAgIGF1dG86IGZhbHNlLFxuICAgICAgICByYW5nZTogdGhpcy5jYWxjX3JhbmdlKGRpZmYxLCBkaWZmMiksXG4gICAgICAgIGRydWdnaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZHJ1ZyA9IG51bGw7XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ3NpZGViYXItdHJhbnNmb3JtJywge1xuICAgICAgICBncmlkX2lkOiB0aGlzLmlkLFxuICAgICAgICBkcnVnZ2luZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5tYykgdGhpcy5tYy5kZXN0cm95KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZW1vdmUoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlb3V0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZXVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNldXAoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNlZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZWRvd24oKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpZGViYXI7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1NpZGViYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gVGhlIHNpZGUgYmFyICh5ZXAsIHRoYXQgdGhpbmcgd2l0aCBhIGJ1bmNoIG9mICQkJClcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNpZGViYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU2lkZWJhcicsXG4gIHByb3BzOiBbJ3N1YicsICdsYXlvdXQnLCAncmFuZ2UnLCAnaW50ZXJ2YWwnLCAnY3Vyc29yJywgJ2NvbG9ycycsICdmb250JywgJ3dpZHRoJywgJ2hlaWdodCcsICdncmlkX2lkJywgJ3JlcmVuZGVyJywgJ3lfdHJhbnNmb3JtJywgJ3R2X2lkJywgJ2NvbmZpZycsICdzaGFkZXJzJ10sXG4gIG1peGluczogW2NhbnZhc10sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy4kcmVmc1snY2FudmFzJ107XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBTaWRlYmFyKGVsLCB0aGlzKTtcbiAgICB0aGlzLnNldHVwKCk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dC5ncmlkc1tpZF07XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlX2NhbnZhcyhoLCBcInNpZGViYXItXCIuY29uY2F0KGlkKSwge1xuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogbGF5b3V0LndpZHRoLFxuICAgICAgICB5OiBsYXlvdXQub2Zmc2V0IHx8IDBcbiAgICAgIH0sXG4gICAgICBhdHRyczoge1xuICAgICAgICByZXJlbmRlcjogdGhpcy4kcHJvcHMucmVyZW5kZXIsXG4gICAgICAgIHdpZHRoOiB0aGlzLiRwcm9wcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLiRwcm9wcy5jb2xvcnMuYmFja1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICB3YXRjaDoge1xuICAgIHJhbmdlOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9LFxuICAgIGN1cnNvcjoge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfSxcbiAgICByZXJlbmRlcjogZnVuY3Rpb24gcmVyZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZWRyYXcoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1NpZGViYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU2lkZWJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWVcbnZhciBTaWRlYmFyX3JlbmRlciwgU2lkZWJhcl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTaWRlYmFyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19TaWRlYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTaWRlYmFyX3JlbmRlcixcbiAgU2lkZWJhcl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNpZGViYXJfYXBpOyB9XG5TaWRlYmFyX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1NpZGViYXIgPSAoU2lkZWJhcl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9MZWdlbmQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM0NzI0ODg2JlxudmFyIExlZ2VuZHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM0NzI0ODg2X3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtbGVnZW5kXCIsIHN0eWxlOiBfdm0uY2FsY19zdHlsZSB9LFxuICAgIFtcbiAgICAgIF92bS5ncmlkX2lkID09PSAwXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS1vaGxjdlwiLFxuICAgICAgICAgICAgICBzdHlsZTogeyBcIm1heC13aWR0aFwiOiBfdm0uY29tbW9uLndpZHRoICsgXCJweFwiIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInQtdnVlLXRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICBzdHlsZTogeyBjb2xvcjogX3ZtLmNvbW1vbi5jb2xvcnMudGl0bGUgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0uY29tbW9uLnRpdGxlX3R4dCkgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX3ZtLnNob3dfdmFsdWVzXG4gICAgICAgICAgICAgICAgPyBfYyhcInNwYW5cIiwgW1xuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBPXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sc3BhblwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5vaGxjdlswXSkpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBIXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sc3BhblwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5vaGxjdlsxXSkpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBMXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sc3BhblwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5vaGxjdlsyXSkpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBDXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sc3BhblwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5vaGxjdlszXSkpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBWXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sc3BhblwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5vaGxjdls0XSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICFfdm0uc2hvd192YWx1ZXNcbiAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInQtdnVlLWxzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgY29sb3I6IF92bS5jb21tb24uY29sb3JzLnRleHQgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcygoX3ZtLmNvbW1vbi5tZXRhLmxhc3QgfHwgW10pWzRdKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9sKHRoaXMuaW5kaWNhdG9ycywgZnVuY3Rpb24oaW5kKSB7XG4gICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtaW5kXCIgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1pbmFtZVwiIH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhpbmQubmFtZSkpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcImJ1dHRvbi1ncm91cFwiLCB7XG4gICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uczogX3ZtLmNvbW1vbi5idXR0b25zLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogX3ZtLmNvbW1vbi5jb25maWcsXG4gICAgICAgICAgICAgICAgb3ZfaWQ6IGluZC5pZCxcbiAgICAgICAgICAgICAgICBncmlkX2lkOiBfdm0uZ3JpZF9pZCxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kLmluZGV4LFxuICAgICAgICAgICAgICAgIHR2X2lkOiBfdm0uY29tbW9uLnR2X2lkLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGluZC52XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uOiB7IFwibGVnZW5kLWJ1dHRvbi1jbGlja1wiOiBfdm0uYnV0dG9uX2NsaWNrIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIGluZC52XG4gICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtaXZhbHVlc1wiIH0sXG4gICAgICAgICAgICAgICAgICBfdm0uX2woaW5kLnZhbHVlcywgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLnNob3dfdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sc3BhbiB0LXZ1ZS1pdmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogeyBjb2xvcjogdi5jb2xvciB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyh2LnZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgaW5kLnVua1xuICAgICAgICAgICAgICA/IF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLXVua25vd25cIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICAoVW5rbm93biB0eXBlKVxcbiAgICAgICAgXCIpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgICAgICAgICAgIHsgYXR0cnM6IHsgbmFtZTogXCJ0dmpzLWFwcGVhclwiIH0gfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGluZC5sb2FkaW5nXG4gICAgICAgICAgICAgICAgICA/IF9jKFwic3Bpbm5lclwiLCB7IGF0dHJzOiB7IGNvbG9yczogX3ZtLmNvbW1vbi5jb2xvcnMgfSB9KVxuICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApXG4gICAgICAgICAgXSxcbiAgICAgICAgICAxXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBMZWdlbmR2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zNDcyNDg4Nl9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuTGVnZW5kdnVlX3R5cGVfdGVtcGxhdGVfaWRfMzQ3MjQ4ODZfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTGVnZW5kLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zNDcyNDg4NiZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQnV0dG9uR3JvdXAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZmODI2NDI2JlxudmFyIEJ1dHRvbkdyb3VwdnVlX3R5cGVfdGVtcGxhdGVfaWRfNmY4MjY0MjZfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwic3BhblwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtbGJ0bi1ncnBcIiB9LFxuICAgIF92bS5fbChfdm0uYnV0dG9ucywgZnVuY3Rpb24oYiwgaSkge1xuICAgICAgcmV0dXJuIF9jKFwibGVnZW5kLWJ1dHRvblwiLCB7XG4gICAgICAgIGtleTogaSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogYi5uYW1lIHx8IGIsXG4gICAgICAgICAgdHZfaWQ6IF92bS50dl9pZCxcbiAgICAgICAgICBvdl9pZDogX3ZtLm92X2lkLFxuICAgICAgICAgIGdyaWRfaWQ6IF92bS5ncmlkX2lkLFxuICAgICAgICAgIGluZGV4OiBfdm0uaW5kZXgsXG4gICAgICAgICAgZGlzcGxheTogX3ZtLmRpc3BsYXksXG4gICAgICAgICAgaWNvbjogYi5pY29uLFxuICAgICAgICAgIGNvbmZpZzogX3ZtLmNvbmZpZ1xuICAgICAgICB9LFxuICAgICAgICBvbjogeyBcImxlZ2VuZC1idXR0b24tY2xpY2tcIjogX3ZtLmJ1dHRvbl9jbGljayB9XG4gICAgICB9KVxuICAgIH0pLFxuICAgIDFcbiAgKVxufVxudmFyIEJ1dHRvbkdyb3VwdnVlX3R5cGVfdGVtcGxhdGVfaWRfNmY4MjY0MjZfc3RhdGljUmVuZGVyRm5zID0gW11cbkJ1dHRvbkdyb3VwdnVlX3R5cGVfdGVtcGxhdGVfaWRfNmY4MjY0MjZfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQnV0dG9uR3JvdXAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZmODI2NDI2JlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9MZWdlbmRCdXR0b24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFhZDg3MzYyJlxudmFyIExlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzFhZDg3MzYyX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImltZ1wiLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidC12dWUtbGJ0blwiLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogX3ZtLmNvbmZpZy5MX0JUTl9TSVpFICsgXCJweFwiLFxuICAgICAgaGVpZ2h0OiBfdm0uY29uZmlnLkxfQlROX1NJWkUgKyBcInB4XCIsXG4gICAgICBtYXJnaW46IF92bS5jb25maWcuTF9CVE5fTUFSR0lOXG4gICAgfSxcbiAgICBhdHRyczogeyBzcmM6IF92bS5iYXNlNjQsIGlkOiBfdm0udXVpZCB9LFxuICAgIG9uOiB7IGNsaWNrOiBfdm0ub25jbGljayB9XG4gIH0pXG59XG52YXIgTGVnZW5kQnV0dG9udnVlX3R5cGVfdGVtcGxhdGVfaWRfMWFkODczNjJfc3RhdGljUmVuZGVyRm5zID0gW11cbkxlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzFhZDg3MzYyX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0xlZ2VuZEJ1dHRvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWFkODczNjImXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9MZWdlbmRCdXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdMZWdlbmRCdXR0b24nLFxuICBwcm9wczogWydpZCcsICd0dl9pZCcsICdncmlkX2lkJywgJ292X2lkJywgJ2luZGV4JywgJ2Rpc3BsYXknLCAnaWNvbicsICdjb25maWcnXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHt9LFxuICBjb21wdXRlZDoge1xuICAgIGJhc2U2NDogZnVuY3Rpb24gYmFzZTY0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWNvbiB8fCBpY29uc19uYW1lc3BhY2VPYmplY3RbdGhpcy5maWxlX25hbWVdO1xuICAgIH0sXG4gICAgZmlsZV9uYW1lOiBmdW5jdGlvbiBmaWxlX25hbWUoKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5pZDtcblxuICAgICAgaWYgKHRoaXMuJHByb3BzLmlkID09PSAnZGlzcGxheScpIHtcbiAgICAgICAgaWQgPSB0aGlzLiRwcm9wcy5kaXNwbGF5ID8gJ2Rpc3BsYXlfb24nIDogJ2Rpc3BsYXlfb2ZmJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkICsgJy5wbmcnO1xuICAgIH0sXG4gICAgdXVpZDogZnVuY3Rpb24gdXVpZCgpIHtcbiAgICAgIHZhciB0diA9IHRoaXMuJHByb3BzLnR2X2lkO1xuICAgICAgdmFyIGdyID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICAgIHZhciBvdiA9IHRoaXMuJHByb3BzLm92X2lkO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHR2LCBcIi1idG4tZ1wiKS5jb25jYXQoZ3IsIFwiLVwiKS5jb25jYXQob3YpO1xuICAgIH0sXG4gICAgZGF0YV90eXBlOiBmdW5jdGlvbiBkYXRhX3R5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuZ3JpZF9pZCA9PT0gMCA/IFwib25jaGFydFwiIDogXCJvZmZjaGFydFwiO1xuICAgIH0sXG4gICAgZGF0YV9pbmRleDogZnVuY3Rpb24gZGF0YV9pbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5pbmRleDtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbmNsaWNrOiBmdW5jdGlvbiBvbmNsaWNrKCkge1xuICAgICAgdGhpcy4kZW1pdCgnbGVnZW5kLWJ1dHRvbi1jbGljaycsIHtcbiAgICAgICAgYnV0dG9uOiB0aGlzLiRwcm9wcy5pZCxcbiAgICAgICAgdHlwZTogdGhpcy5kYXRhX3R5cGUsXG4gICAgICAgIGRhdGFJbmRleDogdGhpcy5kYXRhX2luZGV4LFxuICAgICAgICBncmlkOiB0aGlzLiRwcm9wcy5ncmlkX2lkLFxuICAgICAgICBvdmVybGF5OiB0aGlzLiRwcm9wcy5vdl9pZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0xlZ2VuZEJ1dHRvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0xlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChMZWdlbmRCdXR0b252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9MZWdlbmRCdXR0b24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgTGVnZW5kQnV0dG9udnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9MZWdlbmRCdXR0b24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0xlZ2VuZEJ1dHRvbi52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBMZWdlbmRCdXR0b25fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0xlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgTGVnZW5kQnV0dG9udnVlX3R5cGVfdGVtcGxhdGVfaWRfMWFkODczNjJfcmVuZGVyLFxuICBMZWdlbmRCdXR0b252dWVfdHlwZV90ZW1wbGF0ZV9pZF8xYWQ4NzM2Ml9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIExlZ2VuZEJ1dHRvbl9hcGk7IH1cbkxlZ2VuZEJ1dHRvbl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0xlZ2VuZEJ1dHRvbi52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMZWdlbmRCdXR0b24gPSAoTGVnZW5kQnV0dG9uX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCdXR0b25Hcm91cHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdCdXR0b25Hcm91cCcsXG4gIHByb3BzOiBbJ2J1dHRvbnMnLCAndHZfaWQnLCAnb3ZfaWQnLCAnZ3JpZF9pZCcsICdpbmRleCcsICdkaXNwbGF5JywgJ2NvbmZpZyddLFxuICBjb21wb25lbnRzOiB7XG4gICAgTGVnZW5kQnV0dG9uOiBMZWdlbmRCdXR0b25cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGJ1dHRvbl9jbGljazogZnVuY3Rpb24gYnV0dG9uX2NsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdsZWdlbmQtYnV0dG9uLWNsaWNrJywgZXZlbnQpO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0J1dHRvbkdyb3VwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEJ1dHRvbkdyb3VwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQnV0dG9uR3JvdXAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgQnV0dG9uR3JvdXB2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oODg2KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0J1dHRvbkdyb3VwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cC52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBCdXR0b25Hcm91cF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfQnV0dG9uR3JvdXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEJ1dHRvbkdyb3VwdnVlX3R5cGVfdGVtcGxhdGVfaWRfNmY4MjY0MjZfcmVuZGVyLFxuICBCdXR0b25Hcm91cHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzZmODI2NDI2X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQnV0dG9uR3JvdXBfYXBpOyB9XG5CdXR0b25Hcm91cF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0J1dHRvbkdyb3VwLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJ1dHRvbkdyb3VwID0gKEJ1dHRvbkdyb3VwX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1NwaW5uZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM5NDMyZjk5JlxudmFyIFNwaW5uZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTQzMmY5OV9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcInR2anMtc3Bpbm5lclwiIH0sXG4gICAgX3ZtLl9sKDQsIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBfYyhcImRpdlwiLCB7IGtleTogaSwgc3R5bGU6IHsgYmFja2dyb3VuZDogX3ZtLmNvbG9ycy50ZXh0IH0gfSlcbiAgICB9KSxcbiAgICAwXG4gIClcbn1cbnZhciBTcGlubmVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzk0MzJmOTlfc3RhdGljUmVuZGVyRm5zID0gW11cblNwaW5uZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTQzMmY5OV9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TcGlubmVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zOTQzMmY5OSZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1NwaW5uZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTcGlubmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NwaW5uZXInLFxuICBwcm9wczogWydjb2xvcnMnXVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TcGlubmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfU3Bpbm5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTcGlubmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvU3Bpbm5lci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBTcGlubmVydnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3Mik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TcGlubmVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TcGlubmVyLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFNwaW5uZXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1NwaW5uZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNwaW5uZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTQzMmY5OV9yZW5kZXIsXG4gIFNwaW5uZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTQzMmY5OV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNwaW5uZXJfYXBpOyB9XG5TcGlubmVyX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvU3Bpbm5lci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTcGlubmVyID0gKFNwaW5uZXJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0xlZ2VuZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMZWdlbmR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ2hhcnRMZWdlbmQnLFxuICBwcm9wczogWydjb21tb24nLCAndmFsdWVzJywgJ2dyaWRfaWQnLCAnbWV0YV9wcm9wcyddLFxuICBjb21wb25lbnRzOiB7XG4gICAgQnV0dG9uR3JvdXA6IEJ1dHRvbkdyb3VwLFxuICAgIFNwaW5uZXI6IFNwaW5uZXJcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBvaGxjdjogZnVuY3Rpb24gb2hsY3YoKSB7XG4gICAgICBpZiAoIXRoaXMuJHByb3BzLnZhbHVlcyB8fCAhdGhpcy4kcHJvcHMudmFsdWVzLm9obGN2KSB7XG4gICAgICAgIHJldHVybiBBcnJheSg2KS5maWxsKCduL2EnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZWMgPSB0aGlzLmxheW91dC5wcmVjOyAvLyBUT0RPOiBtYWluIHRoZSBtYWluIGxlZ2VuZCBtb3JlIGN1c3RvbWl6YWJsZVxuXG4gICAgICB2YXIgaWQgPSB0aGlzLm1haW5fdHlwZSArICdfMCc7XG4gICAgICB2YXIgbWV0YSA9IHRoaXMuJHByb3BzLm1ldGFfcHJvcHNbaWRdIHx8IHt9O1xuXG4gICAgICBpZiAobWV0YS5sZWdlbmQpIHtcbiAgICAgICAgcmV0dXJuIChtZXRhLmxlZ2VuZCgpIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdGhpcy4kcHJvcHMudmFsdWVzLm9obGN2WzFdLnRvRml4ZWQocHJlYyksIHRoaXMuJHByb3BzLnZhbHVlcy5vaGxjdlsyXS50b0ZpeGVkKHByZWMpLCB0aGlzLiRwcm9wcy52YWx1ZXMub2hsY3ZbM10udG9GaXhlZChwcmVjKSwgdGhpcy4kcHJvcHMudmFsdWVzLm9obGN2WzRdLnRvRml4ZWQocHJlYyksIHRoaXMuJHByb3BzLnZhbHVlcy5vaGxjdls1XSA/IHRoaXMuJHByb3BzLnZhbHVlcy5vaGxjdls1XS50b0ZpeGVkKDIpIDogJ24vYSddO1xuICAgIH0sXG4gICAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIHsgZ3JpZDogeyBpZCA6IE4gfX1cbiAgICBpbmRpY2F0b3JzOiBmdW5jdGlvbiBpbmRpY2F0b3JzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuJHByb3BzLnZhbHVlcztcbiAgICAgIHZhciBmID0gdGhpcy5mb3JtYXQ7XG4gICAgICB2YXIgdHlwZXMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzLmpzb25fZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguc2V0dGluZ3MubGVnZW5kICE9PSBmYWxzZSAmJiAheC5tYWluO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICghKHgudHlwZSBpbiB0eXBlcykpIHR5cGVzW3gudHlwZV0gPSAwO1xuICAgICAgICB2YXIgaWQgPSB4LnR5cGUgKyBcIl9cIi5jb25jYXQodHlwZXNbeC50eXBlXSsrKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2OiAnZGlzcGxheScgaW4geC5zZXR0aW5ncyA/IHguc2V0dGluZ3MuZGlzcGxheSA6IHRydWUsXG4gICAgICAgICAgbmFtZTogeC5uYW1lIHx8IGlkLFxuICAgICAgICAgIGluZGV4OiAoX3RoaXMub2ZmX2RhdGEgfHwgX3RoaXMuanNvbl9kYXRhKS5pbmRleE9mKHgpLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyA/IGYoaWQsIHZhbHVlcykgOiBfdGhpcy5uX2EoMSksXG4gICAgICAgICAgdW5rOiAhKGlkIGluIChfdGhpcy4kcHJvcHMubWV0YV9wcm9wcyB8fCB7fSkpLFxuICAgICAgICAgIGxvYWRpbmc6IHgubG9hZGluZ1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjYWxjX3N0eWxlOiBmdW5jdGlvbiBjYWxjX3N0eWxlKCkge1xuICAgICAgdmFyIHRvcCA9IHRoaXMubGF5b3V0LmhlaWdodCA+IDE1MCA/IDEwIDogNTtcbiAgICAgIHZhciBncmlkcyA9IHRoaXMuJHByb3BzLmNvbW1vbi5sYXlvdXQuZ3JpZHM7XG4gICAgICB2YXIgdyA9IGdyaWRzWzBdID8gZ3JpZHNbMF0ud2lkdGggOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IFwiXCIuY29uY2F0KHRoaXMubGF5b3V0Lm9mZnNldCArIHRvcCwgXCJweFwiKSxcbiAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHcgLSAyMCwgXCJweFwiKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5jb21tb24ubGF5b3V0LmdyaWRzW2lkXTtcbiAgICB9LFxuICAgIGpzb25fZGF0YTogZnVuY3Rpb24ganNvbl9kYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmNvbW1vbi5kYXRhO1xuICAgIH0sXG4gICAgb2ZmX2RhdGE6IGZ1bmN0aW9uIG9mZl9kYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmNvbW1vbi5vZmZjaGFydDtcbiAgICB9LFxuICAgIG1haW5fdHlwZTogZnVuY3Rpb24gbWFpbl90eXBlKCkge1xuICAgICAgdmFyIGYgPSB0aGlzLmNvbW1vbi5kYXRhLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgubWFpbjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGYgPyBmLnR5cGUgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBzaG93X3ZhbHVlczogZnVuY3Rpb24gc2hvd192YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21tb24uY3Vyc29yLm1vZGUgIT09ICdleHBsb3JlJztcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChpZCwgdmFsdWVzKSB7XG4gICAgICB2YXIgbWV0YSA9IHRoaXMuJHByb3BzLm1ldGFfcHJvcHNbaWRdIHx8IHt9OyAvLyBNYXRjaGVzIE92ZXJsYXkuZGF0YV9jb2xvcnMgd2l0aCB0aGUgZGF0YSB2YWx1ZXNcbiAgICAgIC8vIChzZWUgU3BsaW5lLnZ1ZSlcblxuICAgICAgaWYgKCF2YWx1ZXNbaWRdKSByZXR1cm4gdGhpcy5uX2EoMSk7IC8vIEN1c3RvbSBmb3JtYXR0ZXJcblxuICAgICAgaWYgKG1ldGEubGVnZW5kKSByZXR1cm4gbWV0YS5sZWdlbmQodmFsdWVzW2lkXSk7XG4gICAgICByZXR1cm4gdmFsdWVzW2lkXS5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgdmFyIGNzID0gbWV0YS5kYXRhX2NvbG9ycyA/IG1ldGEuZGF0YV9jb2xvcnMoKSA6IFtdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIFNob3cgOCBkaWdpdHMgZm9yIHNtYWxsIHZhbHVlc1xuICAgICAgICAgIHggPSB4LnRvRml4ZWQoTWF0aC5hYnMoeCkgPiAwLjAwMSA/IDQgOiA4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgICAgY29sb3I6IGNzID8gY3NbaSAlIGNzLmxlbmd0aF0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbl9hOiBmdW5jdGlvbiBuX2EobGVuKSB7XG4gICAgICByZXR1cm4gQXJyYXkobGVuKS5maWxsKHtcbiAgICAgICAgdmFsdWU6ICduL2EnXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJ1dHRvbl9jbGljazogZnVuY3Rpb24gYnV0dG9uX2NsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdsZWdlbmQtYnV0dG9uLWNsaWNrJywgZXZlbnQpO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9MZWdlbmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19MZWdlbmR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTGVnZW5kdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvTGVnZW5kLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIExlZ2VuZHZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDApO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTGVnZW5kLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9MZWdlbmQudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgTGVnZW5kX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19MZWdlbmR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIExlZ2VuZHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM0NzI0ODg2X3JlbmRlcixcbiAgTGVnZW5kdnVlX3R5cGVfdGVtcGxhdGVfaWRfMzQ3MjQ4ODZfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBMZWdlbmRfYXBpOyB9XG5MZWdlbmRfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9MZWdlbmQudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTGVnZW5kID0gKExlZ2VuZF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL3NoYWRlcnMuanNcbmZ1bmN0aW9uIHNoYWRlcnNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IHNoYWRlcnNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIHNoYWRlcnNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBzaGFkZXJzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBzaGFkZXJzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBzaGFkZXJzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIFBhcnNlciBmb3Igc2hhZGVyIGV2ZW50c1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBzaGFkZXJzID0gKHtcbiAgbWV0aG9kczoge1xuICAgIC8vIEluaXQgc2hhZGVycyBmcm9tIGV4dGVuc2lvbnNcbiAgICBpbml0X3NoYWRlcnM6IGZ1bmN0aW9uIGluaXRfc2hhZGVycyhza2luLCBwcmV2KSB7XG4gICAgICBpZiAoc2tpbiAhPT0gcHJldikge1xuICAgICAgICBpZiAocHJldikgdGhpcy5zaGFkZXJzID0gdGhpcy5zaGFkZXJzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4Lm93bmVyICE9PSBwcmV2LmlkO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gc2hhZGVyc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNraW4uc2hhZGVycyksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgU2hhZGVyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgc2hhZGVyID0gbmV3IFNoYWRlcigpO1xuICAgICAgICAgICAgc2hhZGVyLm93bmVyID0gc2tpbi5pZDtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy5wdXNoKHNoYWRlcik7XG4gICAgICAgICAgfSAvLyBUT0RPOiBTb3J0IGJ5IHpJbmRleFxuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25fc2hhZGVyX2V2ZW50OiBmdW5jdGlvbiBvbl9zaGFkZXJfZXZlbnQoZCwgdGFyZ2V0KSB7XG4gICAgICBpZiAoZC5ldmVudCA9PT0gJ25ldy1zaGFkZXInKSB7XG4gICAgICAgIGlmIChkLmFyZ3NbMF0udGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAgICAgICBkLmFyZ3NbMF0uaWQgPSBcIlwiLmNvbmNhdChkLmFyZ3NbMV0sIFwiLVwiKS5jb25jYXQoZC5hcmdzWzJdKTtcbiAgICAgICAgICB0aGlzLnNoYWRlcnMucHVzaChkLmFyZ3NbMF0pO1xuICAgICAgICAgIHRoaXMucmVyZW5kZXIrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZC5ldmVudCA9PT0gJ3JlbW92ZS1zaGFkZXJzJykge1xuICAgICAgICB2YXIgaWQgPSBkLmFyZ3Muam9pbignLScpO1xuICAgICAgICB0aGlzLnNoYWRlcnMgPSB0aGlzLnNoYWRlcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHguaWQgIT09IGlkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgc2tpbjogZnVuY3Rpb24gc2tpbihuLCBwKSB7XG4gICAgICB0aGlzLmluaXRfc2hhZGVycyhuLCBwKTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNoYWRlcnM6IFtdXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvU2VjdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNlY3Rpb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnR3JpZFNlY3Rpb24nLFxuICBwcm9wczogWydjb21tb24nLCAnZ3JpZF9pZCddLFxuICBtaXhpbnM6IFtzaGFkZXJzXSxcbiAgY29tcG9uZW50czoge1xuICAgIEdyaWQ6IGNvbXBvbmVudHNfR3JpZCxcbiAgICBTaWRlYmFyOiBjb21wb25lbnRzX1NpZGViYXIsXG4gICAgQ2hhcnRMZWdlbmQ6IExlZ2VuZFxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMuaW5pdF9zaGFkZXJzKHRoaXMuJHByb3BzLmNvbW1vbi5za2luKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHJhbmdlX2NoYW5nZWQ6IGZ1bmN0aW9uIHJhbmdlX2NoYW5nZWQocikge1xuICAgICAgdGhpcy4kZW1pdCgncmFuZ2UtY2hhbmdlZCcsIHIpO1xuICAgIH0sXG4gICAgY3Vyc29yX2NoYW5nZWQ6IGZ1bmN0aW9uIGN1cnNvcl9jaGFuZ2VkKGMpIHtcbiAgICAgIGMuZ3JpZF9pZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgICB0aGlzLiRlbWl0KCdjdXJzb3ItY2hhbmdlZCcsIGMpO1xuICAgIH0sXG4gICAgY3Vyc29yX2xvY2tlZDogZnVuY3Rpb24gY3Vyc29yX2xvY2tlZChzdGF0ZSkge1xuICAgICAgdGhpcy4kZW1pdCgnY3Vyc29yLWxvY2tlZCcsIHN0YXRlKTtcbiAgICB9LFxuICAgIHNpZGViYXJfdHJhbnNmb3JtOiBmdW5jdGlvbiBzaWRlYmFyX3RyYW5zZm9ybShzKSB7XG4gICAgICB0aGlzLiRlbWl0KCdzaWRlYmFyLXRyYW5zZm9ybScsIHMpO1xuICAgIH0sXG4gICAgZW1pdF9tZXRhX3Byb3BzOiBmdW5jdGlvbiBlbWl0X21ldGFfcHJvcHMoZCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMubWV0YV9wcm9wcywgZC5sYXllcl9pZCwgZCk7XG4gICAgICB0aGlzLiRlbWl0KCdsYXllci1tZXRhLXByb3BzJywgZCk7XG4gICAgfSxcbiAgICBlbWl0X2N1c3RvbV9ldmVudDogZnVuY3Rpb24gZW1pdF9jdXN0b21fZXZlbnQoZCkge1xuICAgICAgdGhpcy5vbl9zaGFkZXJfZXZlbnQoZCwgJ3NpZGViYXInKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIGQpO1xuICAgIH0sXG4gICAgYnV0dG9uX2NsaWNrOiBmdW5jdGlvbiBidXR0b25fY2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2xlZ2VuZC1idXR0b24tY2xpY2snLCBldmVudCk7XG4gICAgfSxcbiAgICByZWdpc3Rlcl9rYjogZnVuY3Rpb24gcmVnaXN0ZXJfa2IoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3JlZ2lzdGVyLWtiLWxpc3RlbmVyJywgZXZlbnQpO1xuICAgIH0sXG4gICAgcmVtb3ZlX2tiOiBmdW5jdGlvbiByZW1vdmVfa2IoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3JlbW92ZS1rYi1saXN0ZW5lcicsIGV2ZW50KTtcbiAgICB9LFxuICAgIHJlem9vbV9yYW5nZTogZnVuY3Rpb24gcmV6b29tX3JhbmdlKGV2ZW50KSB7XG4gICAgICB2YXIgaWQgPSAnc2ItJyArIGV2ZW50LmdyaWRfaWQ7XG5cbiAgICAgIGlmICh0aGlzLiRyZWZzW2lkXSkge1xuICAgICAgICB0aGlzLiRyZWZzW2lkXS5yZW5kZXJlci5yZXpvb21fcmFuZ2UoZXZlbnQueiwgZXZlbnQuZGlmZjEsIGV2ZW50LmRpZmYyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdoYXNoOiBmdW5jdGlvbiBnaGFzaCh2YWwpIHtcbiAgICAgIC8vIE1lYXN1cmVzIGdyaWQgaGVpZ2h0cyBjb25maWd1cmF0aW9uXG4gICAgICB2YXIgaHMgPSB2YWwubGF5b3V0LmdyaWRzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5oZWlnaHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBocy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgfSwgJycpO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAvLyBDb21wb25lbnQtc3BlY2lmaWMgcHJvcHMgc3Vic2V0czpcbiAgICBncmlkX3Byb3BzOiBmdW5jdGlvbiBncmlkX3Byb3BzKCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICAgIHZhciBwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kcHJvcHMuY29tbW9uKTsgLy8gU3BsaXQgb2ZmY2hhcnQgZGF0YSBiZXR3ZWVuIG9mZmNoYXJ0IGdyaWRzXG5cbiAgICAgIGlmIChpZCA+IDApIHtcbiAgICAgICAgdmFyIF9wJGRhdGE7XG5cbiAgICAgICAgdmFyIGFsbCA9IHAuZGF0YTtcbiAgICAgICAgcC5kYXRhID0gW3AuZGF0YVtpZCAtIDFdXTsgLy8gTWVyZ2Ugb2ZmY2hhcnQgb3ZlcmxheXMgd2l0aCBjdXN0b20gaWRzIHdpdGhcbiAgICAgICAgLy8gdGhlIGV4aXN0aW5nIG9uc2UgKGJ5IGNvbXBhcmluZyB0aGUgZ3JpZCBpZHMpXG5cbiAgICAgICAgKF9wJGRhdGEgPSBwLmRhdGEpLnB1c2guYXBwbHkoX3AkZGF0YSwgX3RvQ29uc3VtYWJsZUFycmF5KGFsbC5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5ncmlkICYmIHguZ3JpZC5pZCA9PT0gaWQ7XG4gICAgICAgIH0pKSk7XG4gICAgICB9XG5cbiAgICAgIHAud2lkdGggPSBwLmxheW91dC5ncmlkc1tpZF0ud2lkdGg7XG4gICAgICBwLmhlaWdodCA9IHAubGF5b3V0LmdyaWRzW2lkXS5oZWlnaHQ7XG4gICAgICBwLnlfdHJhbnNmb3JtID0gcC55X3RzW2lkXTtcbiAgICAgIHAuc2hhZGVycyA9IHRoaXMuZ3JpZF9zaGFkZXJzO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBzaWRlYmFyX3Byb3BzOiBmdW5jdGlvbiBzaWRlYmFyX3Byb3BzKCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICAgIHZhciBwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kcHJvcHMuY29tbW9uKTtcbiAgICAgIHAud2lkdGggPSBwLmxheW91dC5ncmlkc1tpZF0uc2I7XG4gICAgICBwLmhlaWdodCA9IHAubGF5b3V0LmdyaWRzW2lkXS5oZWlnaHQ7XG4gICAgICBwLnlfdHJhbnNmb3JtID0gcC55X3RzW2lkXTtcbiAgICAgIHAuc2hhZGVycyA9IHRoaXMuc2Jfc2hhZGVycztcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgc2VjdGlvbl92YWx1ZXM6IGZ1bmN0aW9uIHNlY3Rpb25fdmFsdWVzKCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICAgIHZhciBwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kcHJvcHMuY29tbW9uKTtcbiAgICAgIHAud2lkdGggPSBwLmxheW91dC5ncmlkc1tpZF0ud2lkdGg7XG4gICAgICByZXR1cm4gcC5jdXJzb3IudmFsdWVzW2lkXTtcbiAgICB9LFxuICAgIGxlZ2VuZF9wcm9wczogZnVuY3Rpb24gbGVnZW5kX3Byb3BzKCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICAgIHZhciBwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kcHJvcHMuY29tbW9uKTsgLy8gU3BsaXQgb2ZmY2hhcnQgZGF0YSBiZXR3ZWVuIG9mZmNoYXJ0IGdyaWRzXG5cbiAgICAgIGlmIChpZCA+IDApIHtcbiAgICAgICAgdmFyIF9wJGRhdGEyO1xuXG4gICAgICAgIHZhciBhbGwgPSBwLmRhdGE7XG4gICAgICAgIHAub2ZmY2hhcnQgPSBhbGw7XG4gICAgICAgIHAuZGF0YSA9IFtwLmRhdGFbaWQgLSAxXV07XG5cbiAgICAgICAgKF9wJGRhdGEyID0gcC5kYXRhKS5wdXNoLmFwcGx5KF9wJGRhdGEyLCBfdG9Db25zdW1hYmxlQXJyYXkoYWxsLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LmdyaWQgJiYgeC5ncmlkLmlkID09PSBpZDtcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBnZXRfbWV0YV9wcm9wczogZnVuY3Rpb24gZ2V0X21ldGFfcHJvcHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXRhX3Byb3BzO1xuICAgIH0sXG4gICAgZ3JpZF9zaGFkZXJzOiBmdW5jdGlvbiBncmlkX3NoYWRlcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFkZXJzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50YXJnZXQgPT09ICdncmlkJztcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2Jfc2hhZGVyczogZnVuY3Rpb24gc2Jfc2hhZGVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRlcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnRhcmdldCA9PT0gJ3NpZGViYXInO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGNvbW1vbjoge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcih2YWwsIG9sZF92YWwpIHtcbiAgICAgICAgdmFyIG5ld2hhc2ggPSB0aGlzLmdoYXNoKHZhbCk7XG5cbiAgICAgICAgaWYgKG5ld2hhc2ggIT09IHRoaXMubGFzdF9naGFzaCkge1xuICAgICAgICAgIHRoaXMucmVyZW5kZXIrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwuZGF0YS5sZW5ndGggIT09IG9sZF92YWwuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBMb29rIGF0IHRoaXMgbmFzdHkgdHJpY2shXG4gICAgICAgICAgdGhpcy5yZXJlbmRlcisrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0X2doYXNoID0gbmV3aGFzaDtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRhX3Byb3BzOiB7fSxcbiAgICAgIHJlcmVuZGVyOiAwLFxuICAgICAgbGFzdF9naGFzaDogJydcbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NlY3Rpb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19TZWN0aW9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNlY3Rpb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9TZWN0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIFNlY3Rpb252dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU2VjdGlvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU2VjdGlvbi52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBTZWN0aW9uX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19TZWN0aW9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTZWN0aW9udnVlX3R5cGVfdGVtcGxhdGVfaWRfOGZiZTkzMzZfcmVuZGVyLFxuICBTZWN0aW9udnVlX3R5cGVfdGVtcGxhdGVfaWRfOGZiZTkzMzZfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTZWN0aW9uX2FwaTsgfVxuU2VjdGlvbl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1NlY3Rpb24udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU2VjdGlvbiA9IChTZWN0aW9uX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL2JvdGJhci5qc1xuXG5cblxuZnVuY3Rpb24gYm90YmFyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBib3RiYXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIGJvdGJhcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGJvdGJhcl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYm90YmFyX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBib3RiYXJfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG5cbnZhciBib3RiYXJfTUlOVVRFMTUgPSBjb25zdGFudHMuTUlOVVRFMTUsXG4gICAgYm90YmFyX01JTlVURSA9IGNvbnN0YW50cy5NSU5VVEUsXG4gICAgYm90YmFyX0hPVVIgPSBjb25zdGFudHMuSE9VUixcbiAgICBib3RiYXJfREFZID0gY29uc3RhbnRzLkRBWSxcbiAgICBib3RiYXJfV0VFSyA9IGNvbnN0YW50cy5XRUVLLFxuICAgIGJvdGJhcl9NT05USCA9IGNvbnN0YW50cy5NT05USCxcbiAgICBib3RiYXJfWUVBUiA9IGNvbnN0YW50cy5ZRUFSLFxuICAgIGJvdGJhcl9NT05USE1BUCA9IGNvbnN0YW50cy5NT05USE1BUDtcblxudmFyIEJvdGJhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJvdGJhcihjYW52YXMsIGNvbXApIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBCb3RiYXIpO1xuXG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgIHRoaXMuJHAgPSBjb21wLiRwcm9wcztcbiAgICB0aGlzLmRhdGEgPSB0aGlzLiRwLnN1YjtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy4kcC5yYW5nZTtcbiAgICB0aGlzLmxheW91dCA9IHRoaXMuJHAubGF5b3V0O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoQm90YmFyLCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5ncmlkXzAgPSB0aGlzLmxheW91dC5ncmlkc1swXTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMubGF5b3V0LmJvdGJhci53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmxheW91dC5ib3RiYXIuaGVpZ2h0O1xuICAgICAgdmFyIHNiID0gdGhpcy5sYXlvdXQuZ3JpZHNbMF0uc2I7IC8vdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy4kcC5jb2xvcnMuYmFja1xuXG4gICAgICB0aGlzLmN0eC5mb250ID0gdGhpcy4kcC5mb250OyAvL3RoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpXG5cbiAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy4kcC5jb2xvcnMuc2NhbGU7XG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCAwLjUpO1xuICAgICAgdGhpcy5jdHgubGluZVRvKE1hdGguZmxvb3Iod2lkdGggKyAxKSwgMC41KTtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy4kcC5jb2xvcnMudGV4dDtcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gYm90YmFyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5sYXlvdXQuYm90YmFyLnhzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBsYmwgPSB0aGlzLmZvcm1hdF9kYXRlKHApO1xuICAgICAgICAgIGlmIChwWzBdID4gd2lkdGggLSBzYikgY29udGludWU7XG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKHBbMF0gLSAwLjUsIDApO1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyhwWzBdIC0gMC41LCA0LjUpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmxibF9oaWdobGlnaHQocFsxXVswXSkpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gMC44NTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChsYmwsIHBbMF0sIDE4KTtcbiAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICB0aGlzLmFwcGx5X3NoYWRlcnMoKTtcbiAgICAgIGlmICh0aGlzLiRwLmN1cnNvci54ICYmIHRoaXMuJHAuY3Vyc29yLnQgIT09IHVuZGVmaW5lZCkgdGhpcy5wYW5lbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseV9zaGFkZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5X3NoYWRlcnMoKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQuZ3JpZHNbMF07XG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICBjdXJzb3I6IHRoaXMuJHAuY3Vyc29yXG4gICAgICB9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IGJvdGJhcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY29tcC5ib3Rfc2hhZGVycyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICBzLmRyYXcodGhpcy5jdHgsIHByb3BzKTtcbiAgICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW5lbCgpIHtcbiAgICAgIHZhciBsYmwgPSB0aGlzLmZvcm1hdF9jdXJzb3JfeCgpO1xuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy4kcC5jb2xvcnMucGFuZWw7XG4gICAgICB2YXIgbWVhc3VyZSA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxibCArICcgICAgJyk7XG4gICAgICB2YXIgcGFud2lkdGggPSBNYXRoLmZsb29yKG1lYXN1cmUud2lkdGgpO1xuICAgICAgdmFyIGN1cnNvciA9IHRoaXMuJHAuY3Vyc29yLng7XG4gICAgICB2YXIgeCA9IE1hdGguZmxvb3IoY3Vyc29yIC0gcGFud2lkdGggKiAwLjUpO1xuICAgICAgdmFyIHkgPSAtMC41O1xuICAgICAgdmFyIHBhbmhlaWdodCA9IHRoaXMuY29tcC5jb25maWcuUEFOSEVJR0hUO1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeCwgeSwgcGFud2lkdGgsIHBhbmhlaWdodCArIDAuNSk7XG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy50ZXh0SEw7XG4gICAgICB0aGlzLmN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KGxibCwgY3Vyc29yLCB5ICsgMTYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRfZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRfZGF0ZShwKSB7XG4gICAgICB2YXIgdCA9IHBbMV1bMF07XG4gICAgICB0ID0gdGhpcy5ncmlkXzAudGlfbWFwLmkydCh0KTtcbiAgICAgIHZhciB0aSA9IHRoaXMuJHAubGF5b3V0LmdyaWRzWzBdLnRpX21hcC50ZjsgLy8gRW5hYmxlIHRpbWV6b25lcyBvbmx5IGZvciB0ZiA8IDFEXG5cbiAgICAgIHZhciBrID0gdGkgPCBib3RiYXJfREFZID8gMSA6IDA7XG4gICAgICB2YXIgdFogPSB0ICsgayAqIHRoaXMuJHAudGltZXpvbmUgKiBib3RiYXJfSE9VUjsgLy90ICs9IG5ldyBEYXRlKHQpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBNSU5VVEVcblxuICAgICAgdmFyIGQgPSBuZXcgRGF0ZSh0Wik7XG5cbiAgICAgIGlmIChwWzJdID09PSBib3RiYXJfWUVBUiB8fCB1dGlscy55ZWFyX3N0YXJ0KHQpID09PSB0KSB7XG4gICAgICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwWzJdID09PSBib3RiYXJfTU9OVEggfHwgdXRpbHMubW9udGhfc3RhcnQodCkgPT09IHQpIHtcbiAgICAgICAgcmV0dXJuIGJvdGJhcl9NT05USE1BUFtkLmdldFVUQ01vbnRoKCldO1xuICAgICAgfSAvLyBUT0RPKCopIHNlZSBncmlkX21ha2VyLmpzXG5cblxuICAgICAgaWYgKHV0aWxzLmRheV9zdGFydCh0WikgPT09IHRaKSByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgICB2YXIgaCA9IHV0aWxzLmFkZF96ZXJvKGQuZ2V0VVRDSG91cnMoKSk7XG4gICAgICB2YXIgbSA9IHV0aWxzLmFkZF96ZXJvKGQuZ2V0VVRDTWludXRlcygpKTtcbiAgICAgIHJldHVybiBoICsgXCI6XCIgKyBtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRfY3Vyc29yX3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0X2N1cnNvcl94KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLiRwLmN1cnNvci50O1xuICAgICAgdCA9IHRoaXMuZ3JpZF8wLnRpX21hcC5pMnQodCk7IC8vbGV0IHRpID0gdGhpcy4kcC5pbnRlcnZhbFxuXG4gICAgICB2YXIgdGkgPSB0aGlzLiRwLmxheW91dC5ncmlkc1swXS50aV9tYXAudGY7IC8vIEVuYWJsZSB0aW1lem9uZXMgb25seSBmb3IgdGYgPCAxRFxuXG4gICAgICB2YXIgayA9IHRpIDwgYm90YmFyX0RBWSA/IDEgOiAwOyAvL3QgKz0gbmV3IERhdGUodCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIE1JTlVURVxuXG4gICAgICB2YXIgZCA9IG5ldyBEYXRlKHQgKyBrICogdGhpcy4kcC50aW1lem9uZSAqIGJvdGJhcl9IT1VSKTtcblxuICAgICAgaWYgKHRpID09PSBib3RiYXJfWUVBUikge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGkgPCBib3RiYXJfWUVBUikge1xuICAgICAgICB2YXIgeXIgPSAnYCcgKyBcIlwiLmNvbmNhdChkLmdldFVUQ0Z1bGxZZWFyKCkpLnNsaWNlKC0yKTtcbiAgICAgICAgdmFyIG1vID0gYm90YmFyX01PTlRITUFQW2QuZ2V0VVRDTW9udGgoKV07XG4gICAgICAgIHZhciBkZCA9ICcwMSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aSA8PSBib3RiYXJfV0VFSykgZGQgPSBkLmdldFVUQ0RhdGUoKTtcbiAgICAgIHZhciBkYXRlID0gXCJcIi5jb25jYXQoZGQsIFwiIFwiKS5jb25jYXQobW8sIFwiIFwiKS5jb25jYXQoeXIpO1xuICAgICAgdmFyIHRpbWUgPSAnJztcblxuICAgICAgaWYgKHRpIDwgYm90YmFyX0RBWSkge1xuICAgICAgICB2YXIgaCA9IHV0aWxzLmFkZF96ZXJvKGQuZ2V0VVRDSG91cnMoKSk7XG4gICAgICAgIHZhciBtID0gdXRpbHMuYWRkX3plcm8oZC5nZXRVVENNaW51dGVzKCkpO1xuICAgICAgICB0aW1lID0gaCArIFwiOlwiICsgbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGRhdGUsIFwiICBcIikuY29uY2F0KHRpbWUpO1xuICAgIH0gLy8gSGlnaGxpZ2h0cyB0aGUgYmVnaW5pbmcgb2YgYSB0aW1lIGludGVydmFsXG4gICAgLy8gVE9ETzogaW1wcm92ZS4gUHJvYmxlbTogbGV0J3Mgc2F5IHdlIGhhdmUgYSBuZXcgbW9udGgsXG4gICAgLy8gYnV0IGlmIHRoZXJlIGlzIG5vIGdyaWQgbGluZSBpbiBwbGFjZSwgdGhlcmVcbiAgICAvLyB3aWxsIGJlIG5vIG1vbnRoIG5hbWUgb24gdC1heGlzLiBTYWQuXG4gICAgLy8gU29sdXRpb246IG1hbmlwdWxhdGUgdGhlIGdyaWQsIHNrZXcgaXQsIHlvdSBrbm93XG5cbiAgfSwge1xuICAgIGtleTogXCJsYmxfaGlnaGxpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxibF9oaWdobGlnaHQodCkge1xuICAgICAgdmFyIHRpID0gdGhpcy4kcC5pbnRlcnZhbDtcbiAgICAgIGlmICh0ID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh1dGlscy5tb250aF9zdGFydCh0KSA9PT0gdCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodXRpbHMuZGF5X3N0YXJ0KHQpID09PSB0KSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aSA8PSBib3RiYXJfTUlOVVRFMTUgJiYgdCAlIGJvdGJhcl9IT1VSID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2Vtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlbW92ZSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2VvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2VvdXQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNldXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2V1cCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2Vkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlZG93bigpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gQm90YmFyO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Cb3RiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gVGhlIGJvdHRvbSBiYXIgKHllcCwgdGhhdCB0aGluZyB3aXRoIGEgYnVuY2ggb2YgZGF0ZXMpXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCb3RiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQm90YmFyJyxcbiAgcHJvcHM6IFsnc3ViJywgJ2xheW91dCcsICdyYW5nZScsICdpbnRlcnZhbCcsICdjdXJzb3InLCAnY29sb3JzJywgJ2ZvbnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3JlcmVuZGVyJywgJ3R2X2lkJywgJ2NvbmZpZycsICdzaGFkZXJzJywgJ3RpbWV6b25lJ10sXG4gIG1peGluczogW2NhbnZhc10sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy4kcmVmc1snY2FudmFzJ107XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBCb3RiYXIoZWwsIHRoaXMpO1xuICAgIHRoaXMuc2V0dXAoKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgdmFyIHNldHQgPSB0aGlzLiRwcm9wcy5sYXlvdXQuYm90YmFyO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZV9jYW52YXMoaCwgJ2JvdGJhcicsIHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IHNldHQub2Zmc2V0IHx8IDBcbiAgICAgIH0sXG4gICAgICBhdHRyczoge1xuICAgICAgICByZXJlbmRlcjogdGhpcy4kcHJvcHMucmVyZW5kZXIsXG4gICAgICAgIHdpZHRoOiBzZXR0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNldHQuaGVpZ2h0XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLiRwcm9wcy5jb2xvcnMuYmFja1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGJvdF9zaGFkZXJzOiBmdW5jdGlvbiBib3Rfc2hhZGVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zaGFkZXJzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50YXJnZXQgPT09ICdib3RiYXInO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHJhbmdlOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9LFxuICAgIGN1cnNvcjoge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfSxcbiAgICByZXJlbmRlcjogZnVuY3Rpb24gcmVyZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZWRyYXcoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Cb3RiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19Cb3RiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQm90YmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQm90YmFyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIEJvdGJhcnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjQpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQm90YmFyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Cb3RiYXIudnVlXG52YXIgQm90YmFyX3JlbmRlciwgQm90YmFyX3N0YXRpY1JlbmRlckZuc1xuO1xuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgQm90YmFyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19Cb3RiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEJvdGJhcl9yZW5kZXIsXG4gIEJvdGJhcl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEJvdGJhcl9hcGk7IH1cbkJvdGJhcl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0JvdGJhci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0JvdGJhciA9IChCb3RiYXJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtleWJvYXJkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0tleWJvYXJkJyxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5rZXl1cCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5rZXlwcmVzcyk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd24pO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMua2V5dXApO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMua2V5cHJlc3MpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGtleWRvd246IGZ1bmN0aW9uIGtleWRvd24oZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICB2YXIgbCA9IHRoaXMuX2xpc3RlbmVyc1tpZF07XG5cbiAgICAgICAgaWYgKGwgJiYgbC5rZXlkb3duKSB7XG4gICAgICAgICAgbC5rZXlkb3duKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyAna2V5ZG93bicgbGlzdGVuZXIgZm9yIFwiLmNvbmNhdChpZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBrZXl1cDogZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICB2YXIgbCA9IHRoaXMuX2xpc3RlbmVyc1tpZF07XG5cbiAgICAgICAgaWYgKGwgJiYgbC5rZXl1cCkge1xuICAgICAgICAgIGwua2V5dXAoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vICdrZXl1cCcgbGlzdGVuZXIgZm9yIFwiLmNvbmNhdChpZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBrZXlwcmVzczogZnVuY3Rpb24ga2V5cHJlc3MoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICB2YXIgbCA9IHRoaXMuX2xpc3RlbmVyc1tpZF07XG5cbiAgICAgICAgaWYgKGwgJiYgbC5rZXlwcmVzcykge1xuICAgICAgICAgIGwua2V5cHJlc3MoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vICdrZXlwcmVzcycgbGlzdGVuZXIgZm9yIFwiLmNvbmNhdChpZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tsaXN0ZW5lci5pZF0gPSBsaXN0ZW5lcjtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGxpc3RlbmVyKSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2xpc3RlbmVyLmlkXTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19LZXlib2FyZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChLZXlib2FyZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvS2V5Ym9hcmQudnVlXG52YXIgS2V5Ym9hcmRfcmVuZGVyLCBLZXlib2FyZF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBLZXlib2FyZF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfS2V5Ym9hcmR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEtleWJvYXJkX3JlbmRlcixcbiAgS2V5Ym9hcmRfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBLZXlib2FyZF9hcGk7IH1cbktleWJvYXJkX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvS2V5Ym9hcmQudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS2V5Ym9hcmQgPSAoS2V5Ym9hcmRfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9kYXRhdHJhY2suanNcbi8vIERhdGEgdHJhY2tlci93YXRjaGVyXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgZGF0YXRyYWNrID0gKHtcbiAgbWV0aG9kczoge1xuICAgIGRhdGFfY2hhbmdlZDogZnVuY3Rpb24gZGF0YV9jaGFuZ2VkKCkge1xuICAgICAgdmFyIG4gPSB0aGlzLm9obGN2O1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX2RhdGFfbjAgIT09IG5bMF0gJiYgdGhpcy5fZGF0YV9sZW4gIT09IG4ubGVuZ3RoKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrX2FsbF9kYXRhKGNoYW5nZWQpO1xuXG4gICAgICBpZiAodGhpcy50aV9tYXAuaWIpIHtcbiAgICAgICAgdGhpcy5yZWluZGV4X2RlbHRhKG5bMF0sIHRoaXMuX2RhdGFfbjApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXRhX24wID0gblswXTtcbiAgICAgIHRoaXMuX2RhdGFfbGVuID0gbi5sZW5ndGg7XG4gICAgICB0aGlzLnNhdmVfZGF0YV90KCk7XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuICAgIGNoZWNrX2FsbF9kYXRhOiBmdW5jdGlvbiBjaGVja19hbGxfZGF0YShjaGFuZ2VkKSB7XG4gICAgICAvLyBJZiBsZW5ndGggb2YgZGF0YSBpbiB0aGUgU3RydWN0dXJlIGNoYW5nZWQgYnkgPiAxIHBvaW50XG4gICAgICAvLyBlbWl0IGEgc3BlY2lhbCBldmVudCBmb3IgREMgdG8gcmVjYWxjIHRoZSBzY3JpcHRzXG4gICAgICAvLyBUT0RPOiBjaGVjayBvdmVybGF5cyBkYXRhIHRvb1xuICAgICAgdmFyIGxlbiA9IHRoaXMuX2RhdGFfbGVuIHx8IDA7XG5cbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLm9obGN2Lmxlbmd0aCAtIGxlbikgPiAxIHx8IHRoaXMuX2RhdGFfbjAgIT09IHRoaXMub2hsY3ZbMF0pIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICAgIGV2ZW50OiAnZGF0YS1sZW4tY2hhbmdlZCcsXG4gICAgICAgICAgYXJnczogW11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWluZGV4X2RlbHRhOiBmdW5jdGlvbiByZWluZGV4X2RlbHRhKG4sIHApIHtcbiAgICAgIG4gPSBuIHx8IFtbMF1dO1xuICAgICAgcCA9IHAgfHwgW1swXV07XG4gICAgICB2YXIgZHQgPSBuWzBdIC0gcFswXTtcblxuICAgICAgaWYgKGR0ICE9PSAwICYmIHRoaXMuX2RhdGFfdCkge1xuICAgICAgICAvLyBDb252ZXJ0IHQgYmFjayB0byBpbmRleFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE1vcmUgcHJlY2lzZSBtZXRob2QgZmlyc3RcbiAgICAgICAgICB2YXIgbnQgPSB0aGlzLl9kYXRhX3QgKyAwLjAxOyAvLyBmaXggZm9yIHRoZSBmaWx0ZXIgbGliXG5cbiAgICAgICAgICB2YXIgcmVzID0gdXRpbHMuZmFzdF9uZWFyZXN0KHRoaXMub2hsY3YsIG50KTtcbiAgICAgICAgICB2YXIgY25kbCA9IHRoaXMub2hsY3ZbcmVzWzBdXTtcbiAgICAgICAgICB2YXIgb2ZmID0gKG50IC0gY25kbFswXSkgLyB0aGlzLmludGVydmFsX21zO1xuICAgICAgICAgIHRoaXNbXCJnb3RvXCJdKHJlc1swXSArIG9mZik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzW1wiZ290b1wiXSh0aGlzLnRpX21hcC50MmkodGhpcy5fZGF0YV90KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNhdmVfZGF0YV90OiBmdW5jdGlvbiBzYXZlX2RhdGFfdCgpIHtcbiAgICAgIHRoaXMuX2RhdGFfdCA9IHRoaXMudGlfbWFwLmkydCh0aGlzLnJhbmdlWzFdKTsgLy8gc2F2ZSBhcyB0XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfZGF0YV9uMDogbnVsbCxcbiAgICAgIF9kYXRhX2xlbjogMCxcbiAgICAgIF9kYXRhX3Q6IDBcbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL3RpX21hcHBpbmcuanNcblxuXG5cblxuLy8gVGltZS1pbmRleCBtYXBwaW5nIChmb3Igbm9uLWxpbmVhciB0LWF4aXMpXG5cbnZhciBNQVhfQVJSID0gTWF0aC5wb3coMiwgMzIpOyAvLyAzIE1PREVTIG9mIGluZGV4IGNhbGN1bGF0aW9uIGZvciBvdmVybGF5cy9zdWJjaGFydHM6XG4vLyA6OjogaW5kZXhTcmMgOjo6XG4vLyAqIFwibWFwXCIgICAgICAtPiB1c2UgVEkgbWFwcGluZyBmdW5jdGlvbnMgdG8gZGV0ZWN0IGluZGV4XG4vLyAgICAgICAgICAgICAgICAgKHNsb3dlc3QsIGZvciBzdG9ja3Mgb25seS4gREVGQVVMVClcbi8vXG4vLyAqIFwiY2FsY1wiICAgICAtPiBjYWxjdWxhdGUgc2hpZnQgYmV0d2VlbiBzdWIgJiBkYXRhXG4vLyAgICAgICAgICAgICAgICAgKGZhc3RlciwgYnV0IG92ZXJsYXkgZGF0YSBzaG91bGQgYmUgcGVyZmVjdGx5XG4vLyAgICAgICAgICAgICAgICAgIGFsaWduIHdpdGggdGhlIG1haW4gY2hhcnQsXG4vLyAgICAgICAgICAgICAgICAgIDEtMSBjYW5kbGUvZGF0YSBwb2ludC4gU3VwcG9ydHMgUmVua28pXG4vL1xuLy8gKiBcImRhdGFcIiAgICAgLT4gb3ZlcmxheSBkYXRhIHNob3VsZCBjb21lIHdpdGggY2FuZGxlIGluZGV4XG4vLyAgICAgICAgICAgICAgICAgKGZhc3Rlc3QsIHN1cHBvcnRzIFJlbmtvKVxuXG52YXIgVEkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUSSgpIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBUSSk7XG5cbiAgICB0aGlzLmliID0gZmFsc2U7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhUSSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KHBhcmFtcywgcmVzKSB7XG4gICAgICB2YXIgc3ViID0gcGFyYW1zLnN1YixcbiAgICAgICAgICBpbnRlcnZhbCA9IHBhcmFtcy5pbnRlcnZhbCxcbiAgICAgICAgICBtZXRhID0gcGFyYW1zLm1ldGEsXG4gICAgICAgICAgJHAgPSBwYXJhbXMuJHByb3BzLFxuICAgICAgICAgIGludGVydmFsX21zID0gcGFyYW1zLmludGVydmFsX21zLFxuICAgICAgICAgIHN1Yl9zdGFydCA9IHBhcmFtcy5zdWJfc3RhcnQsXG4gICAgICAgICAgaWIgPSBwYXJhbXMuaWI7XG4gICAgICB0aGlzLnRpX21hcCA9IFtdO1xuICAgICAgdGhpcy5pdF9tYXAgPSBbXTtcbiAgICAgIHRoaXMuc3ViX2kgPSBbXTtcbiAgICAgIHRoaXMuaWIgPSBpYjtcbiAgICAgIHRoaXMuc3ViID0gcmVzO1xuICAgICAgdGhpcy5zcyA9IHN1Yl9zdGFydDtcbiAgICAgIHRoaXMudGYgPSBpbnRlcnZhbF9tcztcbiAgICAgIHZhciBzdGFydCA9IG1ldGEuc3ViX3N0YXJ0OyAvLyBTa2lwIG1hcHBpbmcgZm9yIHRoZSByZWd1bGFyIG1vZGVcblxuICAgICAgaWYgKHRoaXMuaWIpIHtcbiAgICAgICAgdGhpcy5tYXBfc3ViKHJlcyk7XG4gICAgICB9XG4gICAgfSAvLyBNYWtlIG1hcHMgZm9yIHRoZSBtYWluIHN1YnNldFxuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFwX3N1YlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBfc3ViKHJlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHQgPSByZXNbaV1bMF07XG5cbiAgICAgICAgdmFyIF9pID0gdGhpcy5zcyArIGk7XG5cbiAgICAgICAgdGhpcy50aV9tYXBbdF0gPSBfaTtcbiAgICAgICAgdGhpcy5pdF9tYXBbX2ldID0gdDsgLy8gT3ZlcndyaXRlIHQgd2l0aCBpXG5cbiAgICAgICAgdmFyIGNvcHkgPSBfdG9Db25zdW1hYmxlQXJyYXkocmVzW2ldKTtcblxuICAgICAgICBjb3B5WzBdID0gX2k7XG4gICAgICAgIHRoaXMuc3ViX2kucHVzaChjb3B5KTtcbiAgICAgIH1cbiAgICB9IC8vIE1hcCBvdmVybGF5IGRhdGFcbiAgICAvLyBUT0RPOiBwYXJzZSgpIGNhbGxlZCAzIHRpbWVzIGluc3RlYWQgb2YgMiBmb3IgJ3NweF9zYW1wbGUuanNvbidcblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGRhdGEsIG1vZGUpIHtcbiAgICAgIGlmICghdGhpcy5pYiB8fCAhdGhpcy5zdWJbMF0gfHwgbW9kZSA9PT0gJ2RhdGEnKSByZXR1cm4gZGF0YTtcbiAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgIHZhciBrID0gMDsgLy8gQ2FuZGxlc3RpY2sgaW5kZXhcblxuICAgICAgaWYgKG1vZGUgPT09ICdjYWxjJykge1xuICAgICAgICB2YXIgc2hpZnQgPSB1dGlscy5pbmRleF9zaGlmdCh0aGlzLnN1YiwgZGF0YSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9pID0gdGhpcy5zcyArIGk7XG5cbiAgICAgICAgICB2YXIgY29weSA9IF90b0NvbnN1bWFibGVBcnJheShkYXRhW2ldKTtcblxuICAgICAgICAgIGNvcHlbMF0gPSBfaSArIHNoaWZ0O1xuICAgICAgICAgIHJlcy5wdXNoKGNvcHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gLy8gSWYgaW5kaWNhdG9yIGRhdGEgc3RhcnRzIGFmdGVyIG9obGN2LCBjYWxjIHRoZSBmaXJzdCBpbmRleFxuXG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBrMSA9IHV0aWxzLmZhc3RfbmVhcmVzdCh0aGlzLnN1YiwgZGF0YVswXVswXSlbMF07XG4gICAgICAgICAgaWYgKGsxICE9PSBudWxsICYmIGsxID49IDApIGsgPSBrMTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cblxuICAgICAgdmFyIHQwID0gdGhpcy5zdWJbMF1bMF07XG4gICAgICB2YXIgdE4gPSB0aGlzLnN1Ylt0aGlzLnN1Yi5sZW5ndGggLSAxXVswXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfY29weSA9IF90b0NvbnN1bWFibGVBcnJheShkYXRhW2ldKTtcblxuICAgICAgICB2YXIgdGsgPSB0aGlzLnN1YltrXVswXTtcbiAgICAgICAgdmFyIHQgPSBkYXRhW2ldWzBdO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnRpX21hcFt0XTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIExpbmVhciBleHRyYXBvbGF0aW9uXG4gICAgICAgICAgaWYgKHQgPCB0MCB8fCB0ID4gdE4pIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zcyArIGsgLSAodGsgLSB0KSAvIHRoaXMudGY7XG4gICAgICAgICAgICB0ID0gZGF0YVtpICsgMV0gPyBkYXRhW2kgKyAxXVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IC8vIExpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0azIgPSB0aGlzLnN1YltrICsgMV1bMF07XG4gICAgICAgICAgICAgIGluZGV4ID0gdGsgPT09IHRrMiA/IHRoaXMuc3MgKyBrIDogdGhpcy5zcyArIGsgKyAodCAtIHRrKSAvICh0azIgLSB0ayk7XG4gICAgICAgICAgICAgIHQgPSBkYXRhW2kgKyAxXSA/IGRhdGFbaSArIDFdWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIFJhY2Ugb2YgZGF0YSBwb2ludHMgJiBzdWIgcG9pbnRzIChvaGxjdilcbiAgICAgICAgLy8gKGxpa2UgdHVybiBiYXNlZCBpbmNyZW1lbnRzKVxuXG5cbiAgICAgICAgd2hpbGUgKGsgKyAxIDwgdGhpcy5zdWIubGVuZ3RoIC0gMSAmJiB0ID4gdGhpcy5zdWJbayArIDFdWzBdKSB7XG4gICAgICAgICAgaysrO1xuICAgICAgICAgIHRrID0gdGhpcy5zdWJba11bMF07XG4gICAgICAgIH1cblxuICAgICAgICBfY29weVswXSA9IGluZGV4O1xuICAgICAgICByZXMucHVzaChfY29weSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBpbmRleCA9PiB0aW1lXG5cbiAgfSwge1xuICAgIGtleTogXCJpMnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaTJ0KGkpIHtcbiAgICAgIGlmICghdGhpcy5pYiB8fCAhdGhpcy5zdWIubGVuZ3RoKSByZXR1cm4gaTsgLy8gUmVndWxhciBtb2RlXG4gICAgICAvLyBEaXNjcmV0ZSBtYXBwaW5nXG5cbiAgICAgIHZhciByZXMgPSB0aGlzLml0X21hcFtpXTtcbiAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHJlczsgLy8gTGluZWFyIGV4dHJhcG9sYXRpb25cbiAgICAgIGVsc2UgaWYgKGkgPj0gdGhpcy5zcyArIHRoaXMuc3ViX2kubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRpID0gaSAtICh0aGlzLnNzICsgdGhpcy5zdWJfaS5sZW5ndGgpICsgMTtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuc3ViW3RoaXMuc3ViLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHJldHVybiBsYXN0WzBdICsgZGkgKiB0aGlzLnRmO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPCB0aGlzLnNzKSB7XG4gICAgICAgICAgdmFyIF9kaSA9IGkgLSB0aGlzLnNzO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3ViWzBdWzBdICsgX2RpICogdGhpcy50ZjtcbiAgICAgICAgfSAvLyBMaW5lYXIgSW50ZXJwb2xhdGlvblxuXG4gICAgICB2YXIgaTEgPSBNYXRoLmZsb29yKGkpIC0gdGhpcy5zcztcbiAgICAgIHZhciBpMiA9IGkxICsgMTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnN1Yi5sZW5ndGg7XG4gICAgICBpZiAoaTIgPj0gbGVuKSBpMiA9IGxlbiAtIDE7XG4gICAgICB2YXIgc3ViMSA9IHRoaXMuc3ViW2kxXTtcbiAgICAgIHZhciBzdWIyID0gdGhpcy5zdWJbaTJdO1xuXG4gICAgICBpZiAoc3ViMSAmJiBzdWIyKSB7XG4gICAgICAgIHZhciB0MSA9IHN1YjFbMF07XG4gICAgICAgIHZhciB0MiA9IHN1YjJbMF07XG4gICAgICAgIHJldHVybiB0MSArICh0MiAtIHQxKSAqIChpIC0gaTEgLSB0aGlzLnNzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIE1hcCBvciBieXBhc3MgZGVwZW5kaW5nIG9uIHRoZSBtb2RlXG5cbiAgfSwge1xuICAgIGtleTogXCJpMnRfbW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpMnRfbW9kZShpLCBtb2RlKSB7XG4gICAgICByZXR1cm4gbW9kZSA9PT0gJ2RhdGEnID8gaSA6IHRoaXMuaTJ0KGkpO1xuICAgIH0gLy8gdGltZSA9PiBpbmRleFxuICAgIC8vIFRPRE86IHdoZW4gc3dpdGNoIGZyb20gSUIgbW9kZSB0byByZWd1bGFyIHRvb2xzXG4gICAgLy8gZGlzYXBwZWFyIChiYyB0aGVyZSBpcyBubyBtb3JlIG1hcHBpbmcpXG5cbiAgfSwge1xuICAgIGtleTogXCJ0MmlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdDJpKHQpIHtcbiAgICAgIGlmICghdGhpcy5zdWIubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkOyAvLyBEaXNjcmV0ZSBtYXBwaW5nXG5cbiAgICAgIHZhciByZXMgPSB0aGlzLnRpX21hcFt0XTtcbiAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHJlcztcbiAgICAgIHZhciB0MCA9IHRoaXMuc3ViWzBdWzBdO1xuICAgICAgdmFyIHROID0gdGhpcy5zdWJbdGhpcy5zdWIubGVuZ3RoIC0gMV1bMF07IC8vIExpbmVhciBleHRyYXBvbGF0aW9uXG5cbiAgICAgIGlmICh0IDwgdDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3MgLSAodDAgLSB0KSAvIHRoaXMudGY7XG4gICAgICB9IGVsc2UgaWYgKHQgPiB0Tikge1xuICAgICAgICB2YXIgayA9IHRoaXMuc3ViLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnNzICsgayAtICh0TiAtIHQpIC8gdGhpcy50ZjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTGluZWFyIEludGVycG9sYXRpb25cbiAgICAgICAgdmFyIGkgPSB1dGlscy5mYXN0X25lYXJlc3QodGhpcy5zdWIsIHQpO1xuICAgICAgICB2YXIgdGsgPSB0aGlzLnN1YltpWzBdXVswXTtcbiAgICAgICAgdmFyIHRrMiA9IHRoaXMuc3ViW2lbMV1dWzBdO1xuXG4gICAgICAgIHZhciBfayA9ICh0IC0gdGspIC8gKHRrMiAtIHRrKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zcyArIGlbMF0gKyBfayAqIChpWzFdIC0gaVswXSk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gQXV0byBkZXRlY3Q6IGlzIGl0IHRpbWUgb3IgaW5kZXg/XG4gICAgLy8gQXNzdW1pbmcgdGhhdCBpbmRleC1iYXNlZCBtb2RlIGlzIE9OXG5cbiAgfSwge1xuICAgIGtleTogXCJzbXRoMmlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc210aDJpKHNtdGgpIHtcbiAgICAgIGlmIChzbXRoID4gTUFYX0FSUikge1xuICAgICAgICByZXR1cm4gdGhpcy50Mmkoc210aCk7IC8vIGl0IHdhcyB0aW1lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzbXRoOyAvLyBpdCB3YXMgYW4gaW5kZXhcbiAgICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzbXRoMnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc210aDJ0KHNtdGgpIHtcbiAgICAgIGlmIChzbXRoIDwgTUFYX0FSUikge1xuICAgICAgICByZXR1cm4gdGhpcy5pMnQoc210aCk7IC8vIGl0IHdhcyBhbiBpbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc210aDsgLy8gaXQgd2FzIHRpbWVcbiAgICAgICAgfVxuICAgIH0gLy8gR2xvYmFsIFRpbWUgPT4gSW5kZXggKHVzZXMgYWxsIGRhdGEsIGFwcHJveC4gbWV0aG9kKVxuICAgIC8vIFVzZWQgYnkgdHYuZ290bygpXG5cbiAgfSwge1xuICAgIGtleTogXCJndDJpXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGd0Mmkoc210aCwgb2hsY3YpIHtcbiAgICAgIGlmIChzbXRoID4gTUFYX0FSUikge1xuICAgICAgICB2YXIgRSA9IDAuMTsgLy8gRml4ZXMgdGhlIGFycmF5c2xpY2VyIGJ1Z1xuXG4gICAgICAgIHZhciBfVXRpbHMkZmFzdF9uZWFyZXN0ID0gdXRpbHMuZmFzdF9uZWFyZXN0KG9obGN2LCBzbXRoICsgRSksXG4gICAgICAgICAgICBfVXRpbHMkZmFzdF9uZWFyZXN0MiA9IF9zbGljZWRUb0FycmF5KF9VdGlscyRmYXN0X25lYXJlc3QsIDIpLFxuICAgICAgICAgICAgaTEgPSBfVXRpbHMkZmFzdF9uZWFyZXN0MlswXSxcbiAgICAgICAgICAgIGkyID0gX1V0aWxzJGZhc3RfbmVhcmVzdDJbMV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpMSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gaTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudDJpKHNtdGgpOyAvLyBmYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzbXRoOyAvLyBpdCB3YXMgYW4gaW5kZXhcbiAgICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUSTtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQ2hhcnQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDaGFydHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDaGFydCcsXG4gIHByb3BzOiBbJ3RpdGxlX3R4dCcsICdkYXRhJywgJ3dpZHRoJywgJ2hlaWdodCcsICdmb250JywgJ2NvbG9ycycsICdvdmVybGF5cycsICd0dl9pZCcsICdjb25maWcnLCAnYnV0dG9ucycsICd0b29sYmFyJywgJ2liJywgJ3NraW4nLCAndGltZXpvbmUnXSxcbiAgbWl4aW5zOiBbc2hhZGVycywgZGF0YXRyYWNrXSxcbiAgY29tcG9uZW50czoge1xuICAgIEdyaWRTZWN0aW9uOiBTZWN0aW9uLFxuICAgIEJvdGJhcjogY29tcG9uZW50c19Cb3RiYXIsXG4gICAgS2V5Ym9hcmQ6IEtleWJvYXJkXG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgLy8gQ29udGV4dCBmb3IgdGV4dCBtZWFzdXJlbWVudHNcbiAgICB0aGlzLmN0eCA9IG5ldyBjb250ZXh0KHRoaXMuJHByb3BzKTsgLy8gSW5pdGlhbCBsYXlvdXQgKEFsbCBtZWFzdXJtZW50cyBmb3IgdGhlIGNoYXJ0KVxuXG4gICAgdGhpcy5pbml0X3JhbmdlKCk7XG4gICAgdGhpcy5zdWIgPSB0aGlzLnN1YnNldCgpO1xuICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCB0aGlzLnJhbmdlKTsgLy8gRml4IGZvciBJQiBtb2RlXG5cbiAgICB0aGlzLl9sYXlvdXQgPSBuZXcgbGF5b3V0KHRoaXMpOyAvLyBVcGRhdGVzIGN1cnJlbnQgY3Vyc29yIHZhbHVlc1xuXG4gICAgdGhpcy51cGRhdGVyID0gbmV3IHVwZGF0ZXIodGhpcyk7XG4gICAgdGhpcy51cGRhdGVfbGFzdF92YWx1ZXMoKTtcbiAgICB0aGlzLmluaXRfc2hhZGVycyh0aGlzLnNraW4pO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcmFuZ2VfY2hhbmdlZDogZnVuY3Rpb24gcmFuZ2VfY2hhbmdlZChyKSB7XG4gICAgICAvLyBPdmVyd2l0ZSAmIGtlZXAgdGhlIG9yaWdpbmFsIHJlZmVyZW5jZXNcbiAgICAgIC8vIFF1aWNrIGZpeCBmb3IgSUIgbW9kZSAoc3dpdGNoIDIgbmV4dCBsaW5lcylcbiAgICAgIC8vIFRPRE86IHd0Zj9cbiAgICAgIHZhciBzdWIgPSB0aGlzLnN1YnNldChyKTtcbiAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCByKTtcbiAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnN1Yiwgc3ViKTtcbiAgICAgIHRoaXMudXBkYXRlX2xheW91dCgpO1xuICAgICAgdGhpcy4kZW1pdCgncmFuZ2UtY2hhbmdlZCcsIHIpO1xuICAgICAgaWYgKHRoaXMuJHByb3BzLmliKSB0aGlzLnNhdmVfZGF0YV90KCk7XG4gICAgfSxcbiAgICBcImdvdG9cIjogZnVuY3Rpb24gZ290byh0KSB7XG4gICAgICB2YXIgZHQgPSB0aGlzLnJhbmdlWzFdIC0gdGhpcy5yYW5nZVswXTtcbiAgICAgIHRoaXMucmFuZ2VfY2hhbmdlZChbdCAtIGR0LCB0XSk7XG4gICAgfSxcbiAgICBzZXRSYW5nZTogZnVuY3Rpb24gc2V0UmFuZ2UodDEsIHQyKSB7XG4gICAgICB0aGlzLnJhbmdlX2NoYW5nZWQoW3QxLCB0Ml0pO1xuICAgIH0sXG4gICAgY3Vyc29yX2NoYW5nZWQ6IGZ1bmN0aW9uIGN1cnNvcl9jaGFuZ2VkKGUpIHtcbiAgICAgIGlmIChlLm1vZGUpIHRoaXMuY3Vyc29yLm1vZGUgPSBlLm1vZGU7XG5cbiAgICAgIGlmICh0aGlzLmN1cnNvci5tb2RlICE9PSAnZXhwbG9yZScpIHtcbiAgICAgICAgdGhpcy51cGRhdGVyLnN5bmMoZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ob29rX3hjaGFuZ2VkKSB0aGlzLmNlKCc/eC1jaGFuZ2VkJywgZSk7XG4gICAgfSxcbiAgICBjdXJzb3JfbG9ja2VkOiBmdW5jdGlvbiBjdXJzb3JfbG9ja2VkKHN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5jdXJzb3Iuc2Nyb2xsX2xvY2sgJiYgc3RhdGUpIHJldHVybjtcbiAgICAgIHRoaXMuY3Vyc29yLmxvY2tlZCA9IHN0YXRlO1xuICAgICAgaWYgKHRoaXMuX2hvb2tfeGxvY2tlZCkgdGhpcy5jZSgnP3gtbG9ja2VkJywgc3RhdGUpO1xuICAgIH0sXG4gICAgY2FsY19pbnRlcnZhbDogZnVuY3Rpb24gY2FsY19pbnRlcnZhbCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB0ZiA9IHV0aWxzLnBhcnNlX3RmKHRoaXMuZm9yY2VkX3RmKTtcbiAgICAgIGlmICh0aGlzLm9obGN2Lmxlbmd0aCA8IDIgJiYgIXRmKSByZXR1cm47XG4gICAgICB0aGlzLmludGVydmFsX21zID0gdGYgfHwgdXRpbHMuZGV0ZWN0X2ludGVydmFsKHRoaXMub2hsY3YpO1xuICAgICAgdGhpcy5pbnRlcnZhbCA9IHRoaXMuJHByb3BzLmliID8gMSA6IHRoaXMuaW50ZXJ2YWxfbXM7XG4gICAgICB1dGlscy53YXJuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLiRwcm9wcy5pYiAmJiAhX3RoaXMuY2hhcnQudGY7XG4gICAgICB9LCBjb25zdGFudHMuSUJfVEZfV0FSTiwgY29uc3RhbnRzLlNFQ09ORCk7XG4gICAgfSxcbiAgICBzZXRfeXRyYW5zZm9ybTogZnVuY3Rpb24gc2V0X3l0cmFuc2Zvcm0ocykge1xuICAgICAgdmFyIG9iaiA9IHRoaXMueV90cmFuc2Zvcm1zW3MuZ3JpZF9pZF0gfHwge307XG4gICAgICBPYmplY3QuYXNzaWduKG9iaiwgcyk7XG4gICAgICB0aGlzLiRzZXQodGhpcy55X3RyYW5zZm9ybXMsIHMuZ3JpZF9pZCwgb2JqKTtcbiAgICAgIHRoaXMudXBkYXRlX2xheW91dCgpO1xuICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIHRoaXMucmFuZ2UpO1xuICAgIH0sXG4gICAgZGVmYXVsdF9yYW5nZTogZnVuY3Rpb24gZGVmYXVsdF9yYW5nZSgpIHtcbiAgICAgIHZhciBkbCA9IHRoaXMuJHByb3BzLmNvbmZpZy5ERUZBVUxUX0xFTjtcbiAgICAgIHZhciBtbCA9IHRoaXMuJHByb3BzLmNvbmZpZy5NSU5JTVVNX0xFTiArIDAuNTtcbiAgICAgIHZhciBsID0gdGhpcy5vaGxjdi5sZW5ndGggLSAxO1xuICAgICAgaWYgKHRoaXMub2hsY3YubGVuZ3RoIDwgMikgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5vaGxjdi5sZW5ndGggPD0gZGwpIHtcbiAgICAgICAgdmFyIHMgPSAwLFxuICAgICAgICAgICAgZCA9IG1sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGwgLSBkbCwgZCA9IDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLiRwcm9wcy5pYikge1xuICAgICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgW3RoaXMub2hsY3Zbc11bMF0gLSB0aGlzLmludGVydmFsICogZCwgdGhpcy5vaGxjdltsXVswXSArIHRoaXMuaW50ZXJ2YWwgKiBtbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIFtzIC0gdGhpcy5pbnRlcnZhbCAqIGQsIGwgKyB0aGlzLmludGVydmFsICogbWxdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN1YnNldDogZnVuY3Rpb24gc3Vic2V0KHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgICByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyRmaWx0ZXIgPSB0aGlzLmZpbHRlcih0aGlzLm9obGN2LCByYW5nZVswXSAtIHRoaXMuaW50ZXJ2YWwsIHJhbmdlWzFdKSxcbiAgICAgICAgICBfdGhpcyRmaWx0ZXIyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkZmlsdGVyLCAyKSxcbiAgICAgICAgICByZXMgPSBfdGhpcyRmaWx0ZXIyWzBdLFxuICAgICAgICAgIGluZGV4ID0gX3RoaXMkZmlsdGVyMlsxXTtcblxuICAgICAgdGhpcy50aV9tYXAgPSBuZXcgVEkoKTtcblxuICAgICAgaWYgKHJlcykge1xuICAgICAgICB0aGlzLnN1Yl9zdGFydCA9IGluZGV4O1xuICAgICAgICB0aGlzLnRpX21hcC5pbml0KHRoaXMsIHJlcyk7XG4gICAgICAgIGlmICghdGhpcy4kcHJvcHMuaWIpIHJldHVybiByZXMgfHwgW107XG4gICAgICAgIHJldHVybiB0aGlzLnRpX21hcC5zdWJfaTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgY29tbW9uX3Byb3BzOiBmdW5jdGlvbiBjb21tb25fcHJvcHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZV90eHQ6IHRoaXMuY2hhcnQubmFtZSB8fCB0aGlzLiRwcm9wcy50aXRsZV90eHQsXG4gICAgICAgIGxheW91dDogdGhpcy5fbGF5b3V0LFxuICAgICAgICBzdWI6IHRoaXMuc3ViLFxuICAgICAgICByYW5nZTogdGhpcy5yYW5nZSxcbiAgICAgICAgaW50ZXJ2YWw6IHRoaXMuaW50ZXJ2YWwsXG4gICAgICAgIGN1cnNvcjogdGhpcy5jdXJzb3IsXG4gICAgICAgIGNvbG9yczogdGhpcy4kcHJvcHMuY29sb3JzLFxuICAgICAgICBmb250OiB0aGlzLiRwcm9wcy5mb250LFxuICAgICAgICB5X3RzOiB0aGlzLnlfdHJhbnNmb3JtcyxcbiAgICAgICAgdHZfaWQ6IHRoaXMuJHByb3BzLnR2X2lkLFxuICAgICAgICBjb25maWc6IHRoaXMuJHByb3BzLmNvbmZpZyxcbiAgICAgICAgYnV0dG9uczogdGhpcy4kcHJvcHMuYnV0dG9ucyxcbiAgICAgICAgbWV0YTogdGhpcy5tZXRhLFxuICAgICAgICBza2luOiB0aGlzLiRwcm9wcy5za2luXG4gICAgICB9O1xuICAgIH0sXG4gICAgb3ZlcmxheV9zdWJzZXQ6IGZ1bmN0aW9uIG92ZXJsYXlfc3Vic2V0KHNvdXJjZSwgc2lkZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBzb3VyY2UubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHZhciByZXMgPSB1dGlscy5mYXN0X2ZpbHRlcihkLmRhdGEsIF90aGlzMi50aV9tYXAuaTJ0X21vZGUoX3RoaXMyLnJhbmdlWzBdIC0gX3RoaXMyLmludGVydmFsLCBkLmluZGV4U3JjKSwgX3RoaXMyLnRpX21hcC5pMnRfbW9kZShfdGhpczIucmFuZ2VbMV0sIGQuaW5kZXhTcmMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBkLnR5cGUsXG4gICAgICAgICAgbmFtZTogdXRpbHMuZm9ybWF0X25hbWUoZCksXG4gICAgICAgICAgZGF0YTogX3RoaXMyLnRpX21hcC5wYXJzZShyZXNbMF0gfHwgW10sIGQuaW5kZXhTcmMgfHwgJ21hcCcpLFxuICAgICAgICAgIHNldHRpbmdzOiBkLnNldHRpbmdzIHx8IF90aGlzMi5zZXR0aW5nc19vdixcbiAgICAgICAgICBncmlkOiBkLmdyaWQgfHwge30sXG4gICAgICAgICAgdGY6IHV0aWxzLnBhcnNlX3RmKGQudGYpLFxuICAgICAgICAgIGkwOiByZXNbMV0sXG4gICAgICAgICAgbG9hZGluZzogZC5sb2FkaW5nLFxuICAgICAgICAgIGxhc3Q6IChfdGhpczIubGFzdF92YWx1ZXNbc2lkZV0gfHwgW10pW2ldXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNlY3Rpb25fcHJvcHM6IGZ1bmN0aW9uIHNlY3Rpb25fcHJvcHMoaSkge1xuICAgICAgcmV0dXJuIGkgPT09IDAgPyB0aGlzLm1haW5fc2VjdGlvbiA6IHRoaXMuc3ViX3NlY3Rpb247XG4gICAgfSxcbiAgICBpbml0X3JhbmdlOiBmdW5jdGlvbiBpbml0X3JhbmdlKCkge1xuICAgICAgdGhpcy5jYWxjX2ludGVydmFsKCk7XG4gICAgICB0aGlzLmRlZmF1bHRfcmFuZ2UoKTtcbiAgICB9LFxuICAgIGxheWVyX21ldGFfcHJvcHM6IGZ1bmN0aW9uIGxheWVyX21ldGFfcHJvcHMoZCkge1xuICAgICAgLy8gVE9ETzogY2hlY2sgcmVhY3Rpdml0eSB3aGVuIGxheW91dCBpcyBjaGFuZ2VkXG4gICAgICBpZiAoIShkLmdyaWRfaWQgaW4gdGhpcy5sYXllcnNfbWV0YSkpIHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMubGF5ZXJzX21ldGEsIGQuZ3JpZF9pZCwge30pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRzZXQodGhpcy5sYXllcnNfbWV0YVtkLmdyaWRfaWRdLCBkLmxheWVyX2lkLCBkKTsgLy8gUmVyZW5kZXJcblxuICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KCk7XG4gICAgfSxcbiAgICByZW1vdmVfbWV0YV9wcm9wczogZnVuY3Rpb24gcmVtb3ZlX21ldGFfcHJvcHMoZ3JpZF9pZCwgbGF5ZXJfaWQpIHtcbiAgICAgIGlmIChncmlkX2lkIGluIHRoaXMubGF5ZXJzX21ldGEpIHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMubGF5ZXJzX21ldGFbZ3JpZF9pZF0sIGxheWVyX2lkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtaXRfY3VzdG9tX2V2ZW50OiBmdW5jdGlvbiBlbWl0X2N1c3RvbV9ldmVudChkKSB7XG4gICAgICB0aGlzLm9uX3NoYWRlcl9ldmVudChkLCAnYm90YmFyJyk7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCBkKTtcblxuICAgICAgaWYgKGQuZXZlbnQgPT09ICdyZW1vdmUtbGF5ZXItbWV0YScpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVfbWV0YV9wcm9wcy5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkoZC5hcmdzKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVfbGF5b3V0OiBmdW5jdGlvbiB1cGRhdGVfbGF5b3V0KGNsYWNfdGYpIHtcbiAgICAgIGlmIChjbGFjX3RmKSB0aGlzLmNhbGNfaW50ZXJ2YWwoKTtcbiAgICAgIHZhciBsYXkgPSBuZXcgbGF5b3V0KHRoaXMpO1xuICAgICAgdXRpbHMuY29weV9sYXlvdXQodGhpcy5fbGF5b3V0LCBsYXkpO1xuICAgICAgaWYgKHRoaXMuX2hvb2tfdXBkYXRlKSB0aGlzLmNlKCc/Y2hhcnQtdXBkYXRlJywgbGF5KTtcbiAgICB9LFxuICAgIGxlZ2VuZF9idXR0b25fY2xpY2s6IGZ1bmN0aW9uIGxlZ2VuZF9idXR0b25fY2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2xlZ2VuZC1idXR0b24tY2xpY2snLCBldmVudCk7XG4gICAgfSxcbiAgICByZWdpc3Rlcl9rYjogZnVuY3Rpb24gcmVnaXN0ZXJfa2IoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy4kcmVmcy5rZXlib2FyZCkgcmV0dXJuO1xuICAgICAgdGhpcy4kcmVmcy5rZXlib2FyZC5yZWdpc3RlcihldmVudCk7XG4gICAgfSxcbiAgICByZW1vdmVfa2I6IGZ1bmN0aW9uIHJlbW92ZV9rYihldmVudCkge1xuICAgICAgaWYgKCF0aGlzLiRyZWZzLmtleWJvYXJkKSByZXR1cm47XG4gICAgICB0aGlzLiRyZWZzLmtleWJvYXJkLnJlbW92ZShldmVudCk7XG4gICAgfSxcbiAgICB1cGRhdGVfbGFzdF92YWx1ZXM6IGZ1bmN0aW9uIHVwZGF0ZV9sYXN0X3ZhbHVlcygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmxhc3RfY2FuZGxlID0gdGhpcy5vaGxjdiA/IHRoaXMub2hsY3ZbdGhpcy5vaGxjdi5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGFzdF92YWx1ZXMgPSB7XG4gICAgICAgIG9uY2hhcnQ6IFtdLFxuICAgICAgICBvZmZjaGFydDogW11cbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2hhcnQuZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICB2YXIgZCA9IHguZGF0YSB8fCBbXTtcbiAgICAgICAgX3RoaXMzLmxhc3RfdmFsdWVzLm9uY2hhcnRbaV0gPSBkW2QubGVuZ3RoIC0gMV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMub2ZmY2hhcnQuZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICB2YXIgZCA9IHguZGF0YSB8fCBbXTtcbiAgICAgICAgX3RoaXMzLmxhc3RfdmFsdWVzLm9mZmNoYXJ0W2ldID0gZFtkLmxlbmd0aCAtIDFdO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBIb29rIGV2ZW50cyBmb3IgZXh0ZW5zaW9uc1xuICAgIGNlOiBmdW5jdGlvbiBjZShldmVudCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0X2N1c3RvbV9ldmVudCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBTZXQgaG9va3MgbGlzdCAoY2FsbGVkIGZyb20gYW4gZXh0ZW5zaW9uKVxuICAgIGhvb2tzOiBmdW5jdGlvbiBob29rcygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGxpc3QgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgbGlzdFtfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNFtcIl9ob29rX1wiLmNvbmNhdCh4KV0gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC8vIENvbXBvbmVudC1zcGVjaWZpYyBwcm9wcyBzdWJzZXRzOlxuICAgIG1haW5fc2VjdGlvbjogZnVuY3Rpb24gbWFpbl9zZWN0aW9uKCkge1xuICAgICAgdmFyIHAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbW1vbl9wcm9wcygpKTtcbiAgICAgIHAuZGF0YSA9IHRoaXMub3ZlcmxheV9zdWJzZXQodGhpcy5vbmNoYXJ0LCAnb25jaGFydCcpO1xuICAgICAgcC5kYXRhLnB1c2goe1xuICAgICAgICB0eXBlOiB0aGlzLmNoYXJ0LnR5cGUgfHwgJ0NhbmRsZXMnLFxuICAgICAgICBtYWluOiB0cnVlLFxuICAgICAgICBkYXRhOiB0aGlzLnN1YixcbiAgICAgICAgaTA6IHRoaXMuc3ViX3N0YXJ0LFxuICAgICAgICBzZXR0aW5nczogdGhpcy5jaGFydC5zZXR0aW5ncyB8fCB0aGlzLnNldHRpbmdzX29obGN2LFxuICAgICAgICBncmlkOiB0aGlzLmNoYXJ0LmdyaWQgfHwge30sXG4gICAgICAgIGxhc3Q6IHRoaXMubGFzdF9jYW5kbGVcbiAgICAgIH0pO1xuICAgICAgcC5vdmVybGF5cyA9IHRoaXMuJHByb3BzLm92ZXJsYXlzO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBzdWJfc2VjdGlvbjogZnVuY3Rpb24gc3ViX3NlY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29tbW9uX3Byb3BzKCkpO1xuICAgICAgcC5kYXRhID0gdGhpcy5vdmVybGF5X3N1YnNldCh0aGlzLm9mZmNoYXJ0LCAnb2ZmY2hhcnQnKTtcbiAgICAgIHAub3ZlcmxheXMgPSB0aGlzLiRwcm9wcy5vdmVybGF5cztcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgYm90YmFyX3Byb3BzOiBmdW5jdGlvbiBib3RiYXJfcHJvcHMoKSB7XG4gICAgICB2YXIgcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29tbW9uX3Byb3BzKCkpO1xuICAgICAgcC53aWR0aCA9IHAubGF5b3V0LmJvdGJhci53aWR0aDtcbiAgICAgIHAuaGVpZ2h0ID0gcC5sYXlvdXQuYm90YmFyLmhlaWdodDtcbiAgICAgIHAucmVyZW5kZXIgPSB0aGlzLnJlcmVuZGVyO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBvZmZzdWI6IGZ1bmN0aW9uIG9mZnN1YigpIHtcbiAgICAgIHJldHVybiB0aGlzLm92ZXJsYXlfc3Vic2V0KHRoaXMub2ZmY2hhcnQsICdvZmZjaGFydCcpO1xuICAgIH0sXG4gICAgLy8gRGF0YXNldHM6IGNhbmRsZXMsIG9uY2hhcnQsIG9mZmNoYXJ0IGluZGljYXRvcnNcbiAgICBvaGxjdjogZnVuY3Rpb24gb2hsY3YoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuZGF0YS5vaGxjdiB8fCB0aGlzLmNoYXJ0LmRhdGEgfHwgW107XG4gICAgfSxcbiAgICBjaGFydDogZnVuY3Rpb24gY2hhcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuZGF0YS5jaGFydCB8fCB7XG4gICAgICAgIGdyaWQ6IHt9XG4gICAgICB9O1xuICAgIH0sXG4gICAgb25jaGFydDogZnVuY3Rpb24gb25jaGFydCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm9uY2hhcnQgfHwgW107XG4gICAgfSxcbiAgICBvZmZjaGFydDogZnVuY3Rpb24gb2ZmY2hhcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuZGF0YS5vZmZjaGFydCB8fCBbXTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmliID8gdXRpbHMuZmFzdF9maWx0ZXJfaSA6IHV0aWxzLmZhc3RfZmlsdGVyO1xuICAgIH0sXG4gICAgc3R5bGVzOiBmdW5jdGlvbiBzdHlsZXMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMuJHByb3BzLnRvb2xiYXIgPyB0aGlzLiRwcm9wcy5jb25maWcuVE9PTEJBUiA6IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWFyZ2luLWxlZnQnOiBcIlwiLmNvbmNhdCh3LCBcInB4XCIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgbWV0YTogZnVuY3Rpb24gbWV0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhc3Q6IHRoaXMubGFzdF9jYW5kbGUsXG4gICAgICAgIHN1Yl9zdGFydDogdGhpcy5zdWJfc3RhcnQsXG4gICAgICAgIGFjdGl2YXRlZDogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBmb3JjZWRfdGY6IGZ1bmN0aW9uIGZvcmNlZF90ZigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnRmO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gQ3VycmVudCBkYXRhIHNsaWNlXG4gICAgICBzdWI6IFtdLFxuICAgICAgLy8gVGltZSByYW5nZVxuICAgICAgcmFuZ2U6IFtdLFxuICAgICAgLy8gQ2FuZGxlc3RpY2sgaW50ZXJ2YWxcbiAgICAgIGludGVydmFsOiAwLFxuICAgICAgLy8gQ3Jvc3NoYWlyIHN0YXRlc1xuICAgICAgY3Vyc29yOiB7XG4gICAgICAgIHg6IG51bGwsXG4gICAgICAgIHk6IG51bGwsXG4gICAgICAgIHQ6IG51bGwsXG4gICAgICAgIHkkOiBudWxsLFxuICAgICAgICBncmlkX2lkOiBudWxsLFxuICAgICAgICBsb2NrZWQ6IGZhbHNlLFxuICAgICAgICB2YWx1ZXM6IHt9LFxuICAgICAgICBzY3JvbGxfbG9jazogZmFsc2UsXG4gICAgICAgIG1vZGU6IHV0aWxzLnhtb2RlKClcbiAgICAgIH0sXG4gICAgICAvLyBBIHRyaWNrIHRvIHJlLXJlbmRlciBib3RiYXJcbiAgICAgIHJlcmVuZGVyOiAwLFxuICAgICAgLy8gTGF5ZXJzIG1ldGEtcHJvcHMgKGNoYW5naW5nIGJlaGF2aW91cilcbiAgICAgIGxheWVyc19tZXRhOiB7fSxcbiAgICAgIC8vIFktdHJhbnNmb3JtcyAoZm9yIHktem9vbSBhbmQgLXNoaWZ0KVxuICAgICAgeV90cmFuc2Zvcm1zOiB7fSxcbiAgICAgIC8vIERlZmF1bHQgT0hMQ1Ygc2V0dGluZ3MgKHdoZW4gdXNpbmcgRGF0YVN0cnVjdHVyZSB2MS4wKVxuICAgICAgc2V0dGluZ3Nfb2hsY3Y6IHt9LFxuICAgICAgLy8gRGVmYXVsdCBvdmVybGF5IHNldHRpbmdzXG4gICAgICBzZXR0aW5nc19vdjoge30sXG4gICAgICAvLyBNZXRhIGRhdGFcbiAgICAgIGxhc3RfY2FuZGxlOiBbXSxcbiAgICAgIGxhc3RfdmFsdWVzOiB7fSxcbiAgICAgIHN1Yl9zdGFydDogdW5kZWZpbmVkLFxuICAgICAgYWN0aXZhdGVkOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KCk7XG4gICAgICBpZiAodGhpcy5faG9va19yZXNpemUpIHRoaXMuY2UoJz9jaGFydC1yZXNpemUnKTtcbiAgICB9LFxuICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KCk7XG4gICAgICBpZiAodGhpcy5faG9va19yZXNpemUpIHRoaXMuY2UoJz9jaGFydC1yZXNpemUnKTtcbiAgICB9LFxuICAgIGliOiBmdW5jdGlvbiBpYihudykge1xuICAgICAgaWYgKCFudykge1xuICAgICAgICAvLyBDaGFuZ2UgcmFuZ2UgaW5kZXggPT4gdGltZVxuICAgICAgICB2YXIgdDEgPSB0aGlzLnRpX21hcC5pMnQodGhpcy5yYW5nZVswXSk7XG4gICAgICAgIHZhciB0MiA9IHRoaXMudGlfbWFwLmkydCh0aGlzLnJhbmdlWzFdKTtcbiAgICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIFt0MSwgdDJdKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWxfbXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluaXRfcmFuZ2UoKTsgLy8gVE9ETzogY2FsYyBpbmRleCByYW5nZSBpbnN0ZWFkXG5cbiAgICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIHRoaXMucmFuZ2UpO1xuICAgICAgICB0aGlzLmludGVydmFsID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN1YiA9IHRoaXMuc3Vic2V0KCk7XG4gICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5zdWIsIHN1Yik7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQoKTtcbiAgICB9LFxuICAgIHRpbWV6b25lOiBmdW5jdGlvbiB0aW1lem9uZSgpIHtcbiAgICAgIHRoaXMudXBkYXRlX2xheW91dCgpO1xuICAgIH0sXG4gICAgY29sb3JzOiBmdW5jdGlvbiBjb2xvcnMoKSB7XG4gICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgdGhpcy5yYW5nZSk7XG4gICAgfSxcbiAgICBmb3JjZWRfdGY6IGZ1bmN0aW9uIGZvcmNlZF90ZihuLCBwKSB7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQodHJ1ZSk7XG4gICAgICB0aGlzLmNlKCdleGVjLWFsbC1zY3JpcHRzJyk7XG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG4sIHApIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1Yi5sZW5ndGgpIHRoaXMuaW5pdF9yYW5nZSgpO1xuICAgICAgICB2YXIgc3ViID0gdGhpcy5zdWJzZXQoKTsgLy8gRml4ZXMgSW5maW5pdGUgbG9vcCB3YXJuLCB3aGVuIHRoZSBzdWJzZXQgaXMgZW1wdHlcbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgcmVtb3ZpbmcgJ3N1YicgZnJvbSBkYXRhIGVudGlyZWx5XG5cbiAgICAgICAgaWYgKHRoaXMuc3ViLmxlbmd0aCB8fCBzdWIubGVuZ3RoKSB7XG4gICAgICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMuc3ViLCBzdWIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG53ID0gdGhpcy5kYXRhX2NoYW5nZWQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KG53KTtcbiAgICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIHRoaXMucmFuZ2UpO1xuICAgICAgICB0aGlzLmN1cnNvci5zY3JvbGxfbG9jayA9ICEhbi5zY3JvbGxMb2NrO1xuXG4gICAgICAgIGlmIChuLnNjcm9sbExvY2sgJiYgdGhpcy5jdXJzb3IubG9ja2VkKSB7XG4gICAgICAgICAgdGhpcy5jdXJzb3IubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faG9va19kYXRhKSB0aGlzLmNlKCc/Y2hhcnQtZGF0YScsIG53KTtcbiAgICAgICAgdGhpcy51cGRhdGVfbGFzdF92YWx1ZXMoKTsgLy8gVE9ETzogdXBkYXRlIGxlZ2VuZCB2YWx1ZXMgZm9yIG92ZXJhbHlzXG5cbiAgICAgICAgdGhpcy5yZXJlbmRlcisrO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ2hhcnQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19DaGFydHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDaGFydHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ2hhcnQudnVlXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIENoYXJ0X2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19DaGFydHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQ2hhcnR2dWVfdHlwZV90ZW1wbGF0ZV9pZF80ZDA2YTRkZV9yZW5kZXIsXG4gIENoYXJ0dnVlX3R5cGVfdGVtcGxhdGVfaWRfNGQwNmE0ZGVfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBDaGFydF9hcGk7IH1cbkNoYXJ0X2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvQ2hhcnQudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ2hhcnQgPSAoQ2hhcnRfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVG9vbGJhci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MDIxODg3ZmImXG52YXIgVG9vbGJhcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzAyMTg4N2ZiX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGtleTogX3ZtLnRvb2xfY291bnQsXG4gICAgICBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS10b29sYmFyXCIsXG4gICAgICBzdHlsZTogX3ZtLnN0eWxlc1xuICAgIH0sXG4gICAgX3ZtLl9sKF92bS5ncm91cHMsIGZ1bmN0aW9uKHRvb2wsIGkpIHtcbiAgICAgIHJldHVybiB0b29sLmljb24gJiYgIXRvb2wuaGlkZGVuXG4gICAgICAgID8gX2MoXCJ0b29sYmFyLWl0ZW1cIiwge1xuICAgICAgICAgICAga2V5OiBpLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgZGF0YTogdG9vbCxcbiAgICAgICAgICAgICAgc3ViczogX3ZtLnN1Yl9tYXAsXG4gICAgICAgICAgICAgIGRjOiBfdm0uZGF0YSxcbiAgICAgICAgICAgICAgY29uZmlnOiBfdm0uY29uZmlnLFxuICAgICAgICAgICAgICBjb2xvcnM6IF92bS5jb2xvcnMsXG4gICAgICAgICAgICAgIHNlbGVjdGVkOiBfdm0uaXNfc2VsZWN0ZWQodG9vbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjogeyBcIml0ZW0tc2VsZWN0ZWRcIjogX3ZtLnNlbGVjdGVkIH1cbiAgICAgICAgICB9KVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgfSksXG4gICAgMVxuICApXG59XG52YXIgVG9vbGJhcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzAyMTg4N2ZiX3N0YXRpY1JlbmRlckZucyA9IFtdXG5Ub29sYmFydnVlX3R5cGVfdGVtcGxhdGVfaWRfMDIxODg3ZmJfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVG9vbGJhci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MDIxODg3ZmImXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXJJdGVtLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yMjdiM2MyZSZcbnZhciBUb29sYmFySXRlbXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzIyN2IzYzJlX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzOiBbXCJ0cmFkaW5nLXZ1ZS10Yml0ZW1cIiwgX3ZtLnNlbGVjdGVkID8gXCJzZWxlY3RlZC1pdGVtXCIgOiBcIlwiXSxcbiAgICAgIHN0eWxlOiBfdm0uaXRlbV9zdHlsZSxcbiAgICAgIG9uOiB7XG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3ZtLmVtaXRfc2VsZWN0ZWQoXCJjbGlja1wiKVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZWRvd246IF92bS5tb3VzZWRvd24sXG4gICAgICAgIHRvdWNoc3RhcnQ6IF92bS5tb3VzZWRvd24sXG4gICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3ZtLmVtaXRfc2VsZWN0ZWQoXCJ0b3VjaFwiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcImRpdlwiLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLXRiaWNvbiB0dmpzLXBpeGVsYXRlZFwiLFxuICAgICAgICBzdHlsZTogX3ZtLmljb25fc3R5bGVcbiAgICAgIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5kYXRhLmdyb3VwXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS10Yml0ZW0tZXhwXCIsXG4gICAgICAgICAgICAgIHN0eWxlOiBfdm0uZXhwX3N0eWxlLFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGNsaWNrOiBfdm0uZXhwX2NsaWNrLFxuICAgICAgICAgICAgICAgIG1vdXNlZG93bjogX3ZtLmV4cG1vdXNlZG93bixcbiAgICAgICAgICAgICAgICBtb3VzZW92ZXI6IF92bS5leHBtb3VzZW92ZXIsXG4gICAgICAgICAgICAgICAgbW91c2VsZWF2ZTogX3ZtLmV4cG1vdXNlbGVhdmVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtfdm0uX3YoXCJcXG4gICAgICAgIOGQs1xcbiAgICBcIildXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5zaG93X2V4cF9saXN0XG4gICAgICAgID8gX2MoXCJpdGVtLWxpc3RcIiwge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgY29uZmlnOiBfdm0uY29uZmlnLFxuICAgICAgICAgICAgICBpdGVtczogX3ZtLmRhdGEuaXRlbXMsXG4gICAgICAgICAgICAgIGNvbG9yczogX3ZtLmNvbG9ycyxcbiAgICAgICAgICAgICAgZGM6IF92bS5kY1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIFwiY2xvc2UtbGlzdFwiOiBfdm0uY2xvc2VfbGlzdCxcbiAgICAgICAgICAgICAgXCJpdGVtLXNlbGVjdGVkXCI6IF92bS5lbWl0X3NlbGVjdGVkX3N1YlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIDogX3ZtLl9lKClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIFRvb2xiYXJJdGVtdnVlX3R5cGVfdGVtcGxhdGVfaWRfMjI3YjNjMmVfc3RhdGljUmVuZGVyRm5zID0gW11cblRvb2xiYXJJdGVtdnVlX3R5cGVfdGVtcGxhdGVfaWRfMjI3YjNjMmVfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVG9vbGJhckl0ZW0udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTIyN2IzYzJlJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9JdGVtTGlzdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YzUwYjIzZmUmXG52YXIgSXRlbUxpc3R2dWVfdHlwZV90ZW1wbGF0ZV9pZF9jNTBiMjNmZV9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLWl0ZW0tbGlzdFwiLFxuICAgICAgc3R5bGU6IF92bS5saXN0X3N0eWxlKCksXG4gICAgICBvbjogeyBtb3VzZWRvd246IF92bS50aGlzbW91c2Vkb3duIH1cbiAgICB9LFxuICAgIF92bS5fbChfdm0uaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiAhaXRlbS5oaWRkZW5cbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzOiBfdm0uaXRlbV9jbGFzcyhpdGVtKSxcbiAgICAgICAgICAgICAgc3R5bGU6IF92bS5pdGVtX3N0eWxlKGl0ZW0pLFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLml0ZW1fY2xpY2soZSwgaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS10Ymljb24gdHZqcy1waXhlbGF0ZWRcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogX3ZtLmljb25fc3R5bGUoaXRlbSlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIFtfdm0uX3YoX3ZtLl9zKGl0ZW0udHlwZSkpXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApXG4gICAgICAgIDogX3ZtLl9lKClcbiAgICB9KSxcbiAgICAwXG4gIClcbn1cbnZhciBJdGVtTGlzdHZ1ZV90eXBlX3RlbXBsYXRlX2lkX2M1MGIyM2ZlX3N0YXRpY1JlbmRlckZucyA9IFtdXG5JdGVtTGlzdHZ1ZV90eXBlX3RlbXBsYXRlX2lkX2M1MGIyM2ZlX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0l0ZW1MaXN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1jNTBiMjNmZSZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0l0ZW1MaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSXRlbUxpc3R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnSXRlbUxpc3QnLFxuICBwcm9wczogWydjb25maWcnLCAnaXRlbXMnLCAnY29sb3JzJywgJ2RjJ10sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25tb3VzZWRvd24pO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9ubW91c2Vkb3duKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGxpc3Rfc3R5bGU6IGZ1bmN0aW9uIGxpc3Rfc3R5bGUoKSB7XG4gICAgICB2YXIgY29uZiA9IHRoaXMuJHByb3BzLmNvbmZpZztcbiAgICAgIHZhciB3ID0gY29uZi5UT09MQkFSO1xuICAgICAgdmFyIGJyZCA9IHRoaXMuY29sb3JzLnRiTGlzdEJvcmRlciB8fCB0aGlzLmNvbG9ycy5ncmlkO1xuICAgICAgdmFyIGJzdGwgPSBcIjFweCBzb2xpZCBcIi5jb25jYXQoYnJkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IFwiXCIuY29uY2F0KHcsIFwicHhcIiksXG4gICAgICAgIGJhY2tncm91bmQ6IHRoaXMuY29sb3JzLmJhY2ssXG4gICAgICAgIGJvcmRlclRvcDogYnN0bCxcbiAgICAgICAgYm9yZGVyUmlnaHQ6IGJzdGwsXG4gICAgICAgIGJvcmRlckJvdHRvbTogYnN0bFxuICAgICAgfTtcbiAgICB9LFxuICAgIGl0ZW1fY2xhc3M6IGZ1bmN0aW9uIGl0ZW1fY2xhc3MoaXRlbSkge1xuICAgICAgaWYgKHRoaXMuZGMudG9vbCA9PT0gaXRlbS50eXBlKSB7XG4gICAgICAgIHJldHVybiBcInR2anMtaXRlbS1saXN0LWl0ZW0gc2VsZWN0ZWQtaXRlbVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJ0dmpzLWl0ZW0tbGlzdC1pdGVtXCI7XG4gICAgfSxcbiAgICBpdGVtX3N0eWxlOiBmdW5jdGlvbiBpdGVtX3N0eWxlKGl0ZW0pIHtcbiAgICAgIHZhciBjb25mID0gdGhpcy4kcHJvcHMuY29uZmlnO1xuICAgICAgdmFyIGggPSBjb25mLlRCX0lDT04gKyBjb25mLlRCX0lURU1fTSAqIDIgKyA4O1xuICAgICAgdmFyIHNlbCA9IHRoaXMuZGMudG9vbCA9PT0gaXRlbS50eXBlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoLCBcInB4XCIpLFxuICAgICAgICBjb2xvcjogc2VsID8gdW5kZWZpbmVkIDogXCIjODg4ODg4XCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBpY29uX3N0eWxlOiBmdW5jdGlvbiBpY29uX3N0eWxlKGRhdGEpIHtcbiAgICAgIHZhciBjb25mID0gdGhpcy4kcHJvcHMuY29uZmlnO1xuICAgICAgdmFyIGJyID0gY29uZi5UQl9JQ09OX0JSSTtcbiAgICAgIHZhciBpbSA9IGNvbmYuVEJfSVRFTV9NO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiBcInVybChcIi5jb25jYXQoZGF0YS5pY29uLCBcIilcIiksXG4gICAgICAgICd3aWR0aCc6ICcyNXB4JyxcbiAgICAgICAgJ2hlaWdodCc6ICcyNXB4JyxcbiAgICAgICAgJ21hcmdpbic6IFwiXCIuY29uY2F0KGltLCBcInB4XCIpLFxuICAgICAgICAnZmlsdGVyJzogXCJicmlnaHRuZXNzKFwiLmNvbmNhdChiciwgXCIpXCIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgaXRlbV9jbGljazogZnVuY3Rpb24gaXRlbV9jbGljayhlLCBpdGVtKSB7XG4gICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB0aGlzLiRlbWl0KCdpdGVtLXNlbGVjdGVkJywgaXRlbSk7XG4gICAgICB0aGlzLiRlbWl0KCdjbG9zZS1saXN0Jyk7XG4gICAgfSxcbiAgICBvbm1vdXNlZG93bjogZnVuY3Rpb24gb25tb3VzZWRvd24oKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbG9zZS1saXN0Jyk7XG4gICAgfSxcbiAgICB0aGlzbW91c2Vkb3duOiBmdW5jdGlvbiB0aGlzbW91c2Vkb3duKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge30sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0l0ZW1MaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfSXRlbUxpc3R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoSXRlbUxpc3R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9JdGVtTGlzdC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBJdGVtTGlzdHZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDcpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvSXRlbUxpc3QudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0l0ZW1MaXN0LnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIEl0ZW1MaXN0X2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19JdGVtTGlzdHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgSXRlbUxpc3R2dWVfdHlwZV90ZW1wbGF0ZV9pZF9jNTBiMjNmZV9yZW5kZXIsXG4gIEl0ZW1MaXN0dnVlX3R5cGVfdGVtcGxhdGVfaWRfYzUwYjIzZmVfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBJdGVtTGlzdF9hcGk7IH1cbkl0ZW1MaXN0X2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvSXRlbUxpc3QudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSXRlbUxpc3QgPSAoSXRlbUxpc3RfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXJJdGVtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVG9vbGJhckl0ZW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVG9vbGJhckl0ZW0nLFxuICBwcm9wczogWydkYXRhJywgJ3NlbGVjdGVkJywgJ2NvbG9ycycsICd0dl9pZCcsICdjb25maWcnLCAnZGMnLCAnc3VicyddLFxuICBjb21wb25lbnRzOiB7XG4gICAgSXRlbUxpc3Q6IEl0ZW1MaXN0XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5ncm91cCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnN1YnNbdGhpcy5kYXRhLmdyb3VwXTtcbiAgICAgIHZhciBpdGVtID0gdGhpcy5kYXRhLml0ZW1zLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudHlwZSA9PT0gdHlwZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGl0ZW0pIHRoaXMuc3ViX2l0ZW0gPSBpdGVtO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY2xpY2tfc3RhcnQgPSB1dGlscy5ub3coKTtcbiAgICAgIHRoaXMuY2xpY2tfaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc2hvd19leHBfbGlzdCA9IHRydWU7XG4gICAgICB9LCB0aGlzLmNvbmZpZy5UQl9JQ09OX0hPTEQpO1xuICAgIH0sXG4gICAgZXhwbW91c2VvdmVyOiBmdW5jdGlvbiBleHBtb3VzZW92ZXIoKSB7XG4gICAgICB0aGlzLmV4cF9ob3ZlciA9IHRydWU7XG4gICAgfSxcbiAgICBleHBtb3VzZWxlYXZlOiBmdW5jdGlvbiBleHBtb3VzZWxlYXZlKCkge1xuICAgICAgdGhpcy5leHBfaG92ZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIGV4cG1vdXNlZG93bjogZnVuY3Rpb24gZXhwbW91c2Vkb3duKGUpIHtcbiAgICAgIGlmICh0aGlzLnNob3dfZXhwX2xpc3QpIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBlbWl0X3NlbGVjdGVkOiBmdW5jdGlvbiBlbWl0X3NlbGVjdGVkKHNyYykge1xuICAgICAgaWYgKHV0aWxzLm5vdygpIC0gdGhpcy5jbGlja19zdGFydCA+IHRoaXMuY29uZmlnLlRCX0lDT05fSE9MRCkgcmV0dXJuO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xpY2tfaWQpOyAvL2lmIChVdGlscy5pc19tb2JpbGUgJiYgc3JjID09PSAnY2xpY2snKSByZXR1cm5cbiAgICAgIC8vIFRPRE86IGRvdWJsZSBmaXJpbmdcblxuICAgICAgaWYgKCF0aGlzLmRhdGEuZ3JvdXApIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaXRlbS1zZWxlY3RlZCcsIHRoaXMuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuc3ViX2l0ZW0gfHwgdGhpcy5kYXRhLml0ZW1zWzBdO1xuICAgICAgICB0aGlzLiRlbWl0KCdpdGVtLXNlbGVjdGVkJywgaXRlbSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0X3NlbGVjdGVkX3N1YjogZnVuY3Rpb24gZW1pdF9zZWxlY3RlZF9zdWIoaXRlbSkge1xuICAgICAgdGhpcy4kZW1pdCgnaXRlbS1zZWxlY3RlZCcsIGl0ZW0pO1xuICAgICAgdGhpcy5zdWJfaXRlbSA9IGl0ZW07XG4gICAgfSxcbiAgICBleHBfY2xpY2s6IGZ1bmN0aW9uIGV4cF9jbGljayhlKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YS5ncm91cCkgcmV0dXJuO1xuICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgdGhpcy5zaG93X2V4cF9saXN0ID0gIXRoaXMuc2hvd19leHBfbGlzdDtcbiAgICB9LFxuICAgIGNsb3NlX2xpc3Q6IGZ1bmN0aW9uIGNsb3NlX2xpc3QoKSB7XG4gICAgICB0aGlzLnNob3dfZXhwX2xpc3QgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXRlbV9zdHlsZTogZnVuY3Rpb24gaXRlbV9zdHlsZSgpIHtcbiAgICAgIGlmICh0aGlzLiRwcm9wcy5kYXRhLnR5cGUgPT09ICdTeXN0ZW06U3BsaXR0ZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0dGVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29uZiA9IHRoaXMuJHByb3BzLmNvbmZpZztcbiAgICAgIHZhciBpbSA9IGNvbmYuVEJfSVRFTV9NO1xuICAgICAgdmFyIG0gPSAoY29uZi5UT09MQkFSIC0gY29uZi5UQl9JQ09OKSAqIDAuNSAtIGltO1xuICAgICAgdmFyIHMgPSBjb25mLlRCX0lDT04gKyBpbSAqIDI7XG4gICAgICB2YXIgYiA9IHRoaXMuZXhwX2hvdmVyID8gMCA6IDM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnd2lkdGgnOiBcIlwiLmNvbmNhdChzLCBcInB4XCIpLFxuICAgICAgICAnaGVpZ2h0JzogXCJcIi5jb25jYXQocywgXCJweFwiKSxcbiAgICAgICAgJ21hcmdpbic6IFwiOHB4IFwiLmNvbmNhdChtLCBcInB4IDBweCBcIikuY29uY2F0KG0sIFwicHhcIiksXG4gICAgICAgICdib3JkZXItcmFkaXVzJzogXCIzcHggXCIuY29uY2F0KGIsIFwicHggXCIpLmNvbmNhdChiLCBcInB4IDNweFwiKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGljb25fc3R5bGU6IGZ1bmN0aW9uIGljb25fc3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy4kcHJvcHMuZGF0YS50eXBlID09PSAnU3lzdGVtOlNwbGl0dGVyJykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25mID0gdGhpcy4kcHJvcHMuY29uZmlnO1xuICAgICAgdmFyIGJyID0gY29uZi5UQl9JQ09OX0JSSTtcbiAgICAgIHZhciBzeiA9IGNvbmYuVEJfSUNPTjtcbiAgICAgIHZhciBpbSA9IGNvbmYuVEJfSVRFTV9NO1xuICAgICAgdmFyIGljID0gdGhpcy5zdWJfaXRlbSA/IHRoaXMuc3ViX2l0ZW0uaWNvbiA6IHRoaXMuJHByb3BzLmRhdGEuaWNvbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogXCJ1cmwoXCIuY29uY2F0KGljLCBcIilcIiksXG4gICAgICAgICd3aWR0aCc6IFwiXCIuY29uY2F0KHN6LCBcInB4XCIpLFxuICAgICAgICAnaGVpZ2h0JzogXCJcIi5jb25jYXQoc3osIFwicHhcIiksXG4gICAgICAgICdtYXJnaW4nOiBcIlwiLmNvbmNhdChpbSwgXCJweFwiKSxcbiAgICAgICAgJ2ZpbHRlcic6IFwiYnJpZ2h0bmVzcyhcIi5jb25jYXQoYnIsIFwiKVwiKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGV4cF9zdHlsZTogZnVuY3Rpb24gZXhwX3N0eWxlKCkge1xuICAgICAgdmFyIGNvbmYgPSB0aGlzLiRwcm9wcy5jb25maWc7XG4gICAgICB2YXIgaW0gPSBjb25mLlRCX0lURU1fTTtcbiAgICAgIHZhciBzID0gY29uZi5UQl9JQ09OICogMC41ICsgaW07XG4gICAgICB2YXIgcCA9IChjb25mLlRPT0xCQVIgLSBzICogMikgLyA0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFkZGluZzogXCJcIi5jb25jYXQocywgXCJweCBcIikuY29uY2F0KHAsIFwicHhcIiksXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5zaG93X2V4cF9saXN0ID8gXCJzY2FsZSgtMC42LCAxKVwiIDogXCJzY2FsZVgoMC42KVwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgc3BsaXR0ZXI6IGZ1bmN0aW9uIHNwbGl0dGVyKCkge1xuICAgICAgdmFyIGNvbmYgPSB0aGlzLiRwcm9wcy5jb25maWc7XG4gICAgICB2YXIgY29sb3JzID0gdGhpcy4kcHJvcHMuY29sb3JzO1xuICAgICAgdmFyIGMgPSBjb2xvcnMuZ3JpZDtcbiAgICAgIHZhciBpbSA9IGNvbmYuVEJfSVRFTV9NO1xuICAgICAgdmFyIG0gPSAoY29uZi5UT09MQkFSIC0gY29uZi5UQl9JQ09OKSAqIDAuNSAtIGltO1xuICAgICAgdmFyIHMgPSBjb25mLlRCX0lDT04gKyBpbSAqIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnd2lkdGgnOiBcIlwiLmNvbmNhdChzLCBcInB4XCIpLFxuICAgICAgICAnaGVpZ2h0JzogJzFweCcsXG4gICAgICAgICdtYXJnaW4nOiBcIjhweCBcIi5jb25jYXQobSwgXCJweCA4cHggXCIpLmNvbmNhdChtLCBcInB4XCIpLFxuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGNcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHBfaG92ZXI6IGZhbHNlLFxuICAgICAgc2hvd19leHBfbGlzdDogZmFsc2UsXG4gICAgICBzdWJfaXRlbTogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVG9vbGJhckl0ZW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19Ub29sYmFySXRlbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChUb29sYmFySXRlbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXJJdGVtLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIFRvb2xiYXJJdGVtdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwMSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Ub29sYmFySXRlbS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVG9vbGJhckl0ZW0udnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgVG9vbGJhckl0ZW1fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1Rvb2xiYXJJdGVtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBUb29sYmFySXRlbXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzIyN2IzYzJlX3JlbmRlcixcbiAgVG9vbGJhckl0ZW12dWVfdHlwZV90ZW1wbGF0ZV9pZF8yMjdiM2MyZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFRvb2xiYXJJdGVtX2FwaTsgfVxuVG9vbGJhckl0ZW1fY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9Ub29sYmFySXRlbS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUb29sYmFySXRlbSA9IChUb29sYmFySXRlbV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVG9vbGJhci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdUb29sYmFyJyxcbiAgcHJvcHM6IFsnZGF0YScsICdoZWlnaHQnLCAnY29sb3JzJywgJ3R2X2lkJywgJ2NvbmZpZyddLFxuICBjb21wb25lbnRzOiB7XG4gICAgVG9vbGJhckl0ZW06IFRvb2xiYXJJdGVtXG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7fSxcbiAgbWV0aG9kczoge1xuICAgIHNlbGVjdGVkOiBmdW5jdGlvbiBzZWxlY3RlZCh0b29sKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiAndG9vbC1zZWxlY3RlZCcsXG4gICAgICAgIGFyZ3M6IFt0b29sLnR5cGVdXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRvb2wuZ3JvdXApIHtcbiAgICAgICAgLy8gVE9ETzogZW1pdCB0aGUgc3ViIG1hcCB0byBEQyAoc2F2ZSlcbiAgICAgICAgdGhpcy5zdWJfbWFwW3Rvb2wuZ3JvdXBdID0gdG9vbC50eXBlO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNfc2VsZWN0ZWQ6IGZ1bmN0aW9uIGlzX3NlbGVjdGVkKHRvb2wpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0b29sLmdyb3VwKSB7XG4gICAgICAgIHJldHVybiAhIXRvb2wuaXRlbXMuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LnR5cGUgPT09IF90aGlzLmRhdGEudG9vbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b29sLnR5cGUgPT09IHRoaXMuZGF0YS50b29sO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzdHlsZXM6IGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgIHZhciBjb2xvcnMgPSB0aGlzLiRwcm9wcy5jb2xvcnM7XG4gICAgICB2YXIgYiA9IHRoaXMuJHByb3BzLmNvbmZpZy5UQl9CT1JERVI7XG4gICAgICB2YXIgdyA9IHRoaXMuJHByb3BzLmNvbmZpZy5UT09MQkFSIC0gYjtcbiAgICAgIHZhciBjID0gY29sb3JzLmdyaWQ7XG4gICAgICB2YXIgY2IgPSBjb2xvcnMudGJCYWNrIHx8IGNvbG9ycy5iYWNrO1xuICAgICAgdmFyIGJyZCA9IGNvbG9ycy50YkJvcmRlciB8fCBjb2xvcnMuc2NhbGU7XG4gICAgICB2YXIgc3QgPSB0aGlzLiRwcm9wcy5jb25maWcuVEJfQl9TVFlMRTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICd3aWR0aCc6IFwiXCIuY29uY2F0KHcsIFwicHhcIiksXG4gICAgICAgICdoZWlnaHQnOiBcIlwiLmNvbmNhdCh0aGlzLiRwcm9wcy5oZWlnaHQgLSAzLCBcInB4XCIpLFxuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGNiLFxuICAgICAgICAnYm9yZGVyLXJpZ2h0JzogXCJcIi5jb25jYXQoYiwgXCJweCBcIikuY29uY2F0KHN0LCBcIiBcIikuY29uY2F0KGJyZClcbiAgICAgIH07XG4gICAgfSxcbiAgICBncm91cHM6IGZ1bmN0aW9uIGdyb3VwcygpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZGF0YS50b29scyB8fCBbXSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHRvb2wgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGlmICghdG9vbC5ncm91cCkge1xuICAgICAgICAgICAgYXJyLnB1c2godG9vbCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZyA9IGFyci5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geC5ncm91cCA9PT0gdG9vbC5ncm91cDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghZykge1xuICAgICAgICAgICAgYXJyLnB1c2goe1xuICAgICAgICAgICAgICBncm91cDogdG9vbC5ncm91cCxcbiAgICAgICAgICAgICAgaWNvbjogdG9vbC5pY29uLFxuICAgICAgICAgICAgICBpdGVtczogW3Rvb2xdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZy5pdGVtcy5wdXNoKHRvb2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBkYXRhOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG4pIHtcbiAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIFZ1ZS5qcyBkb2Vzbid0IHdhbnQgdG9cbiAgICAgICAgLy8gdXBkYXRlICd0b29scycgYXV0b21hdGljYWxseSB3aGVuIG5ldyBpdGVtXG4gICAgICAgIC8vIGlzIHB1c2hlZC9yZW1vdmVkLiBZbywgVnVlLCBJIGhlcmQgeW91XG4gICAgICAgIC8vIHlvdSB3YW50IG1vcmUgZGlydHkgdHJpY2tzP1xuICAgICAgICBpZiAobi50b29scykgdGhpcy50b29sX2NvdW50ID0gbi50b29scy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbF9jb3VudDogMCxcbiAgICAgIHN1Yl9tYXA6IHt9XG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVG9vbGJhci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBUb29sYmFydnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Myk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFRvb2xiYXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1Rvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wMjE4ODdmYl9yZW5kZXIsXG4gIFRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wMjE4ODdmYl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFRvb2xiYXJfYXBpOyB9XG5Ub29sYmFyX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvVG9vbGJhci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUb29sYmFyID0gKFRvb2xiYXJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvV2lkZ2V0cy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWZlNDMxMmYmXG52YXIgV2lkZ2V0c3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzVmZTQzMTJmX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMtd2lkZ2V0c1wiLFxuICAgICAgc3R5bGU6IHsgd2lkdGg6IF92bS53aWR0aCArIFwicHhcIiwgaGVpZ2h0OiBfdm0uaGVpZ2h0ICsgXCJweFwiIH1cbiAgICB9LFxuICAgIF92bS5fbChPYmplY3Qua2V5cyhfdm0ubWFwKSwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiBfYyhfdm0uaW5pdHcoaWQpLCB7XG4gICAgICAgIGtleTogaWQsXG4gICAgICAgIHRhZzogXCJjb21wb25lbnRcIixcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgbWFpbjogX3ZtLm1hcFtpZF0uY3RybCxcbiAgICAgICAgICBkYXRhOiBfdm0ubWFwW2lkXS5kYXRhLFxuICAgICAgICAgIHR2OiBfdm0udHYsXG4gICAgICAgICAgZGM6IF92bS5kY1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pLFxuICAgIDFcbiAgKVxufVxudmFyIFdpZGdldHN2dWVfdHlwZV90ZW1wbGF0ZV9pZF81ZmU0MzEyZl9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuV2lkZ2V0c3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzVmZTQzMTJmX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1dpZGdldHMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVmZTQzMTJmJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvV2lkZ2V0cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFdpZGdldHN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnV2lkZ2V0cycsXG4gIHByb3BzOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdtYXAnLCAndHYnLCAnZGMnXSxcbiAgbWV0aG9kczoge1xuICAgIGluaXR3OiBmdW5jdGlvbiBpbml0dyhpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLm1hcFtpZF0uY2xzO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9XaWRnZXRzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfV2lkZ2V0c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChXaWRnZXRzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvV2lkZ2V0cy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBXaWRnZXRzdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvV2lkZ2V0cy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvV2lkZ2V0cy52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBXaWRnZXRzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19XaWRnZXRzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBXaWRnZXRzdnVlX3R5cGVfdGVtcGxhdGVfaWRfNWZlNDMxMmZfcmVuZGVyLFxuICBXaWRnZXRzdnVlX3R5cGVfdGVtcGxhdGVfaWRfNWZlNDMxMmZfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBXaWRnZXRzX2FwaTsgfVxuV2lkZ2V0c19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1dpZGdldHMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgV2lkZ2V0cyA9IChXaWRnZXRzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1RoZVRpcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MmMxNzcwY2MmXG52YXIgVGhlVGlwdnVlX3R5cGVfdGVtcGxhdGVfaWRfMmMxNzcwY2NfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXRoZS10aXBcIixcbiAgICBzdHlsZTogX3ZtLnN0eWxlLFxuICAgIGRvbVByb3BzOiB7IGlubmVySFRNTDogX3ZtLl9zKF92bS5kYXRhLnRleHQpIH0sXG4gICAgb246IHtcbiAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdm0uJGVtaXQoXCJyZW1vdmUtbWVcIilcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG52YXIgVGhlVGlwdnVlX3R5cGVfdGVtcGxhdGVfaWRfMmMxNzcwY2Nfc3RhdGljUmVuZGVyRm5zID0gW11cblRoZVRpcHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzJjMTc3MGNjX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1RoZVRpcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MmMxNzcwY2MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9UaGVUaXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUaGVUaXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVGhlVGlwJyxcbiAgcHJvcHM6IFsnZGF0YSddLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgncmVtb3ZlLW1lJyk7XG4gICAgfSwgMzAwMCk7XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5kYXRhLmNvbG9yXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9UaGVUaXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19UaGVUaXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVGhlVGlwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVGhlVGlwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIFRoZVRpcHZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzcpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVGhlVGlwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9UaGVUaXAudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgVGhlVGlwX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19UaGVUaXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFRoZVRpcHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzJjMTc3MGNjX3JlbmRlcixcbiAgVGhlVGlwdnVlX3R5cGVfdGVtcGxhdGVfaWRfMmMxNzcwY2Nfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBUaGVUaXBfYXBpOyB9XG5UaGVUaXBfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9UaGVUaXAudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVGhlVGlwID0gKFRoZVRpcF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL3hjb250cm9sLmpzXG5mdW5jdGlvbiB4Y29udHJvbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0geGNvbnRyb2xfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIHhjb250cm9sX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4geGNvbnRyb2xfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHhjb250cm9sX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiB4Y29udHJvbF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBleHRlbnNpb25zIGNvbnRyb2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgeGNvbnRyb2wgPSAoe1xuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMuY3RybGxpc3QoKTtcbiAgICB0aGlzLnNraW5fc3R5bGVzKCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICAvLyBCdWlsZCAvIHJlYnVpbGQgY29tcG9uZW50IGxpc3RcbiAgICBjdHJsbGlzdDogZnVuY3Rpb24gY3RybGxpc3QoKSB7XG4gICAgICB0aGlzLmN0cmxfZGVzdHJveSgpO1xuICAgICAgdGhpcy5jb250cm9sbGVycyA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0geGNvbnRyb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5leHRlbnNpb25zKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgeCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBuYW1lID0geC5NYWluLl9fbmFtZV9fO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnhTZXR0aW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy4kc2V0KHRoaXMueFNldHRpbmdzLCBuYW1lLCB7fSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5jID0gbmV3IHguTWFpbih0aGlzLCAvLyB0diBpbnN0XG4gICAgICAgICAgdGhpcy5kYXRhLCAvLyBkY1xuICAgICAgICAgIHRoaXMueFNldHRpbmdzW25hbWVdIC8vIHNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuYy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzLnB1c2gobmMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJzO1xuICAgIH0sXG4gICAgLy8gVE9ETzogcHJldmVudERlZmF1bHRcbiAgICBwcmVfZGM6IGZ1bmN0aW9uIHByZV9kYyhlKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IHhjb250cm9sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jb250cm9sbGVycyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjdHJsID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGN0cmwudXBkYXRlKSB7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZShlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcG9zdF9kYzogZnVuY3Rpb24gcG9zdF9kYyhlKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IHhjb250cm9sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jb250cm9sbGVycyksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjdHJsID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGN0cmwucG9zdF91cGRhdGUpIHtcbiAgICAgICAgICAgIGN0cmwucG9zdF91cGRhdGUoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGN0cmxfZGVzdHJveTogZnVuY3Rpb24gY3RybF9kZXN0cm95KCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjQgPSB4Y29udHJvbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY29udHJvbGxlcnMpLFxuICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY3RybCA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgICBpZiAoY3RybC5kZXN0cm95KSBjdHJsLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBza2luX3N0eWxlczogZnVuY3Rpb24gc2tpbl9zdHlsZXMoKSB7XG4gICAgICB2YXIgaWQgPSAndHZqcy1za2luLXN0eWxlcyc7XG4gICAgICB2YXIgc3RiciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgaWYgKHN0YnIpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHN0YnIucGFyZW50Tm9kZTtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHN0YnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5za2luX3Byb3RvICYmIHRoaXMuc2tpbl9wcm90by5zdHlsZXMpIHtcbiAgICAgICAgdmFyIHNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc2hlZXQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgICAgICBzaGVldC5pbm5lckhUTUwgPSB0aGlzLnNraW5fcHJvdG8uc3R5bGVzO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChzaGVldCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHdzOiBmdW5jdGlvbiB3cygpIHtcbiAgICAgIHZhciB3cyA9IHt9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IHhjb250cm9sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jb250cm9sbGVycyksXG4gICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjdHJsID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGN0cmwud2lkZ2V0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gY3RybC53aWRnZXRzKSB7XG4gICAgICAgICAgICAgIHdzW2lkXSA9IGN0cmwud2lkZ2V0c1tpZF07XG4gICAgICAgICAgICAgIHdzW2lkXS5jdHJsID0gY3RybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd3M7XG4gICAgfSxcbiAgICBza2luczogZnVuY3Rpb24gc2tpbnMoKSB7XG4gICAgICB2YXIgc2tzID0ge307XG5cbiAgICAgIHZhciBfaXRlcmF0b3I2ID0geGNvbnRyb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5leHRlbnNpb25zKSxcbiAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHggPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpZCBpbiB4LnNraW5zIHx8IHt9KSB7XG4gICAgICAgICAgICBza3NbaWRdID0geC5za2luc1tpZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNrcztcbiAgICB9LFxuICAgIHNraW5fcHJvdG86IGZ1bmN0aW9uIHNraW5fcHJvdG8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5za2luc1t0aGlzLiRwcm9wcy5za2luXTtcbiAgICB9LFxuICAgIGNvbG9ycGFjazogZnVuY3Rpb24gY29sb3JwYWNrKCkge1xuICAgICAgdmFyIHNlbCA9IHRoaXMuc2tpbnNbdGhpcy4kcHJvcHMuc2tpbl07XG4gICAgICByZXR1cm4gc2VsID8gc2VsLmNvbG9ycyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBmYXN0ICYgZGlydHkgZml4LCBuZWVkXG4gICAgLy8gdG8gZml4IHRoZSBhY3R1YWwgcmVhY3Rpdml0eSBwcm9ibGVtXG4gICAgc2tpbjogZnVuY3Rpb24gc2tpbihuLCBwKSB7XG4gICAgICBpZiAobiAhPT0gcCkgdGhpcy5yZXNldENoYXJ0KCk7XG4gICAgICB0aGlzLnNraW5fc3R5bGVzKCk7XG4gICAgfSxcbiAgICBleHRlbnNpb25zOiBmdW5jdGlvbiBleHRlbnNpb25zKCkge1xuICAgICAgdGhpcy5jdHJsbGlzdCgpO1xuICAgIH0sXG4gICAgeFNldHRpbmdzOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG4sIHApIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjcgPSB4Y29udHJvbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY29udHJvbGxlcnMpLFxuICAgICAgICAgICAgX3N0ZXA3O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gX3N0ZXA3LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoY3RybC5vbnNldHRpbmdzKSB7XG4gICAgICAgICAgICAgIGN0cmwub25zZXR0aW5ncyhuLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjcuZigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJvbGxlcnM6IFtdXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL1RyYWRpbmdWdWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cbmZ1bmN0aW9uIFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVHJhZGluZ1Z1ZScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDaGFydDogQ2hhcnQsXG4gICAgVG9vbGJhcjogVG9vbGJhcixcbiAgICBXaWRnZXRzOiBXaWRnZXRzLFxuICAgIFRoZVRpcDogVGhlVGlwXG4gIH0sXG4gIG1peGluczogW3hjb250cm9sXSxcbiAgcHJvcHM6IHtcbiAgICB0aXRsZVR4dDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICdUcmFkaW5nVnVlLmpzJ1xuICAgIH0sXG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAndHJhZGluZy12dWUtanMnXG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgXCJkZWZhdWx0XCI6IDgwMFxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBcImRlZmF1bHRcIjogNDIxXG4gICAgfSxcbiAgICBjb2xvclRpdGxlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyM0MmI4ODMnXG4gICAgfSxcbiAgICBjb2xvckJhY2s6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzEyMTgyNidcbiAgICB9LFxuICAgIGNvbG9yR3JpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjMmYzMjQwJ1xuICAgIH0sXG4gICAgY29sb3JUZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyNkZWRkZGQnXG4gICAgfSxcbiAgICBjb2xvclRleHRITDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjZmZmJ1xuICAgIH0sXG4gICAgY29sb3JTY2FsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjODM4MzgzJ1xuICAgIH0sXG4gICAgY29sb3JDcm9zczoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjODA5MWEwJ1xuICAgIH0sXG4gICAgY29sb3JDYW5kbGVVcDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjMjNhNzc2J1xuICAgIH0sXG4gICAgY29sb3JDYW5kbGVEdzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjZTU0MTUwJ1xuICAgIH0sXG4gICAgY29sb3JXaWNrVXA6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzIzYTc3Njg4J1xuICAgIH0sXG4gICAgY29sb3JXaWNrRHc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnI2U1NDE1MDg4J1xuICAgIH0sXG4gICAgY29sb3JXaWNrU206IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAndHJhbnNwYXJlbnQnIC8vIGRlcHJlY2F0ZWRcblxuICAgIH0sXG4gICAgY29sb3JWb2xVcDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjNzk5OTllNDInXG4gICAgfSxcbiAgICBjb2xvclZvbER3OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyNlZjUzNTA0MidcbiAgICB9LFxuICAgIGNvbG9yUGFuZWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzU2NWM2OCdcbiAgICB9LFxuICAgIGNvbG9yVGJCYWNrOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIGNvbG9yVGJCb3JkZXI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzgyODI4MjdkJ1xuICAgIH0sXG4gICAgY29sb3JzOiB7XG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9LFxuICAgIGZvbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiBjb25zdGFudHMuQ2hhcnRDb25maWcuRk9OVFxuICAgIH0sXG4gICAgdG9vbGJhcjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIC8vIFlvdXIgb3ZlcmxheSBjbGFzc2VzIGhlcmVcbiAgICBvdmVybGF5czoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIE92ZXJ3cml0ZXMgQ2hhcnRDb25maWcgdmFsdWVzLFxuICAgIC8vIHNlZSBjb25zdGFudHMuanNcbiAgICBjaGFydENvbmZpZzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICBsZWdlbmRCdXR0b25zOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5kZXhCYXNlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgZXh0ZW5zaW9uczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHhTZXR0aW5nczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICBza2luOiB7XG4gICAgICB0eXBlOiBTdHJpbmcgLy8gU2tpbiBOYW1lXG5cbiAgICB9LFxuICAgIHRpbWV6b25lOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBcImRlZmF1bHRcIjogMFxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAvLyBDb3B5IGEgc3Vic2V0IG9mIFRyYWRpbmdWdWUgcHJvcHNcbiAgICBjaGFydF9wcm9wczogZnVuY3Rpb24gY2hhcnRfcHJvcHMoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy4kcHJvcHMudG9vbGJhciA/IHRoaXMuY2hhcnRfY29uZmlnLlRPT0xCQVIgOiAwO1xuICAgICAgdmFyIGNoYXJ0X3Byb3BzID0ge1xuICAgICAgICB0aXRsZV90eHQ6IHRoaXMuJHByb3BzLnRpdGxlVHh0LFxuICAgICAgICBvdmVybGF5czogdGhpcy4kcHJvcHMub3ZlcmxheXMuY29uY2F0KHRoaXMubW9kX292cyksXG4gICAgICAgIGRhdGE6IHRoaXMuZGVjdWJlZCxcbiAgICAgICAgd2lkdGg6IHRoaXMuJHByb3BzLndpZHRoIC0gb2Zmc2V0LFxuICAgICAgICBoZWlnaHQ6IHRoaXMuJHByb3BzLmhlaWdodCxcbiAgICAgICAgZm9udDogdGhpcy5mb250X2NvbXAsXG4gICAgICAgIGJ1dHRvbnM6IHRoaXMuJHByb3BzLmxlZ2VuZEJ1dHRvbnMsXG4gICAgICAgIHRvb2xiYXI6IHRoaXMuJHByb3BzLnRvb2xiYXIsXG4gICAgICAgIGliOiB0aGlzLiRwcm9wcy5pbmRleEJhc2VkIHx8IHRoaXMuaW5kZXhfYmFzZWQgfHwgZmFsc2UsXG4gICAgICAgIGNvbG9yczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kcHJvcHMuY29sb3JzIHx8IHRoaXMuY29sb3JwYWNrKSxcbiAgICAgICAgc2tpbjogdGhpcy5za2luX3Byb3RvLFxuICAgICAgICB0aW1lem9uZTogdGhpcy4kcHJvcHMudGltZXpvbmVcbiAgICAgIH07XG4gICAgICB0aGlzLnBhcnNlX2NvbG9ycyhjaGFydF9wcm9wcy5jb2xvcnMpO1xuICAgICAgcmV0dXJuIGNoYXJ0X3Byb3BzO1xuICAgIH0sXG4gICAgY2hhcnRfY29uZmlnOiBmdW5jdGlvbiBjaGFydF9jb25maWcoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RhbnRzLkNoYXJ0Q29uZmlnLCB0aGlzLiRwcm9wcy5jaGFydENvbmZpZyk7XG4gICAgfSxcbiAgICBkZWN1YmVkOiBmdW5jdGlvbiBkZWN1YmVkKCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLiRwcm9wcy5kYXRhO1xuXG4gICAgICBpZiAoZGF0YS5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRGF0YUN1YmUgZGV0ZWN0ZWRcbiAgICAgICAgZGF0YS5pbml0X3R2anModGhpcyk7XG4gICAgICAgIHJldHVybiBkYXRhLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluZGV4X2Jhc2VkOiBmdW5jdGlvbiBpbmRleF9iYXNlZCgpIHtcbiAgICAgIHZhciBiYXNlID0gdGhpcy4kcHJvcHMuZGF0YTtcblxuICAgICAgaWYgKGJhc2UuY2hhcnQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2UuY2hhcnQuaW5kZXhCYXNlZDtcbiAgICAgIH0gZWxzZSBpZiAoYmFzZS5kYXRhKSB7XG4gICAgICAgIHJldHVybiBiYXNlLmRhdGEuY2hhcnQuaW5kZXhCYXNlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbW9kX292czogZnVuY3Rpb24gbW9kX292cygpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmV4dGVuc2lvbnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB4ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgYXJyLnB1c2guYXBwbHkoYXJyLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LnZhbHVlcyh4Lm92ZXJsYXlzKSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICBmb250X2NvbXA6IGZ1bmN0aW9uIGZvbnRfY29tcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNraW5fcHJvdG8gJiYgdGhpcy5za2luX3Byb3RvLmZvbnQgPyB0aGlzLnNraW5fcHJvdG8uZm9udCA6IHRoaXMuZm9udDtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc2V0OiAwLFxuICAgICAgdGlwOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmN1c3RvbV9ldmVudCh7XG4gICAgICBldmVudDogJ2JlZm9yZS1kZXN0cm95J1xuICAgIH0pO1xuICAgIHRoaXMuY3RybF9kZXN0cm95KCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICAvLyBUT0RPOiByZXNldCBleHRlbnNpb25zP1xuICAgIHJlc2V0Q2hhcnQ6IGZ1bmN0aW9uIHJlc2V0Q2hhcnQocmVzZXRSYW5nZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHJlc2V0UmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgICByZXNldFJhbmdlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNldCsrO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuXG4gICAgICBpZiAoIXJlc2V0UmFuZ2UgJiYgcmFuZ2VbMF0gJiYgcmFuZ2VbMV0pIHtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRSYW5nZS5hcHBseShfdGhpcywgX3RvQ29uc3VtYWJsZUFycmF5KHJhbmdlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jdXN0b21fZXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiAnY2hhcnQtcmVzZXQnLFxuICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBcImdvdG9cIjogZnVuY3Rpb24gZ290byh0KSB7XG4gICAgICAvLyBUT0RPOiBsaW1pdCBnb3RvICYgc2V0UmFuZ2UgKG91dCBvZiBkYXRhIGVycm9yKVxuICAgICAgaWYgKHRoaXMuY2hhcnRfcHJvcHMuaWIpIHtcbiAgICAgICAgdmFyIHRpX21hcCA9IHRoaXMuJHJlZnMuY2hhcnQudGlfbWFwO1xuICAgICAgICB0ID0gdGlfbWFwLmd0MmkodCwgdGhpcy4kcmVmcy5jaGFydC5vaGxjdik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJHJlZnMuY2hhcnRbXCJnb3RvXCJdKHQpO1xuICAgIH0sXG4gICAgc2V0UmFuZ2U6IGZ1bmN0aW9uIHNldFJhbmdlKHQxLCB0Mikge1xuICAgICAgaWYgKHRoaXMuY2hhcnRfcHJvcHMuaWIpIHtcbiAgICAgICAgdmFyIHRpX21hcCA9IHRoaXMuJHJlZnMuY2hhcnQudGlfbWFwO1xuICAgICAgICB2YXIgb2hsY3YgPSB0aGlzLiRyZWZzLmNoYXJ0Lm9obGN2O1xuICAgICAgICB0MSA9IHRpX21hcC5ndDJpKHQxLCBvaGxjdik7XG4gICAgICAgIHQyID0gdGlfbWFwLmd0MmkodDIsIG9obGN2KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kcmVmcy5jaGFydC5zZXRSYW5nZSh0MSwgdDIpO1xuICAgIH0sXG4gICAgZ2V0UmFuZ2U6IGZ1bmN0aW9uIGdldFJhbmdlKCkge1xuICAgICAgaWYgKHRoaXMuY2hhcnRfcHJvcHMuaWIpIHtcbiAgICAgICAgdmFyIHRpX21hcCA9IHRoaXMuJHJlZnMuY2hhcnQudGlfbWFwOyAvLyBUaW1lIHJhbmdlID0+IGluZGV4IHJhbmdlXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuY2hhcnQucmFuZ2UubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHRpX21hcC5pMnQoeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy4kcmVmcy5jaGFydC5yYW5nZTtcbiAgICB9LFxuICAgIGdldEN1cnNvcjogZnVuY3Rpb24gZ2V0Q3Vyc29yKCkge1xuICAgICAgdmFyIGN1cnNvciA9IHRoaXMuJHJlZnMuY2hhcnQuY3Vyc29yO1xuXG4gICAgICBpZiAodGhpcy5jaGFydF9wcm9wcy5pYikge1xuICAgICAgICB2YXIgdGlfbWFwID0gdGhpcy4kcmVmcy5jaGFydC50aV9tYXA7XG4gICAgICAgIHZhciBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgY3Vyc29yKTtcbiAgICAgICAgY29weS5pID0gY29weS50O1xuICAgICAgICBjb3B5LnQgPSB0aV9tYXAuaTJ0KGNvcHkudCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH0sXG4gICAgc2hvd1RoZVRpcDogZnVuY3Rpb24gc2hvd1RoZVRpcCh0ZXh0LCBjb2xvcikge1xuICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHtcbiAgICAgICAgY29sb3IgPSBcIm9yYW5nZVwiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpcCA9IHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICB9O1xuICAgIH0sXG4gICAgbGVnZW5kX2J1dHRvbjogZnVuY3Rpb24gbGVnZW5kX2J1dHRvbihldmVudCkge1xuICAgICAgdGhpcy5jdXN0b21fZXZlbnQoe1xuICAgICAgICBldmVudDogJ2xlZ2VuZC1idXR0b24tY2xpY2snLFxuICAgICAgICBhcmdzOiBbZXZlbnRdXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGN1c3RvbV9ldmVudDogZnVuY3Rpb24gY3VzdG9tX2V2ZW50KGQpIHtcbiAgICAgIGlmICgnYXJncycgaW4gZCkge1xuICAgICAgICB0aGlzLiRlbWl0LmFwcGx5KHRoaXMsIFtkLmV2ZW50XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGQuYXJncykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVtaXQoZC5ldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gdGhpcy4kcHJvcHMuZGF0YTtcbiAgICAgIHZhciBjdHJsID0gdGhpcy5jb250cm9sbGVycy5sZW5ndGggIT09IDA7XG4gICAgICBpZiAoY3RybCkgdGhpcy5wcmVfZGMoZCk7XG5cbiAgICAgIGlmIChkYXRhLnR2KSB7XG4gICAgICAgIC8vIElmIHRoZSBkYXRhIG9iamVjdCBpcyBEYXRhQ3ViZVxuICAgICAgICBkYXRhLm9uX2N1c3RvbV9ldmVudChkLmV2ZW50LCBkLmFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3RybCkgdGhpcy5wb3N0X2RjKGQpO1xuICAgIH0sXG4gICAgcmFuZ2VfY2hhbmdlZDogZnVuY3Rpb24gcmFuZ2VfY2hhbmdlZChyKSB7XG4gICAgICBpZiAodGhpcy5jaGFydF9wcm9wcy5pYikge1xuICAgICAgICB2YXIgdGlfbWFwID0gdGhpcy4kcmVmcy5jaGFydC50aV9tYXA7XG4gICAgICAgIHIgPSByLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB0aV9tYXAuaTJ0KHgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZW1pdCgncmFuZ2UtY2hhbmdlZCcsIHIpO1xuICAgICAgdGhpcy5jdXN0b21fZXZlbnQoe1xuICAgICAgICBldmVudDogJ3JhbmdlLWNoYW5nZWQnLFxuICAgICAgICBhcmdzOiBbcl1cbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMub25yYW5nZSkgdGhpcy5vbnJhbmdlKHIpO1xuICAgIH0sXG4gICAgc2V0X2xvYWRlcjogZnVuY3Rpb24gc2V0X2xvYWRlcihkYykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMub25yYW5nZSA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciBwZiA9IF90aGlzMi5jaGFydF9wcm9wcy5pYiA/ICdfbXMnIDogJyc7XG4gICAgICAgIHZhciB0ZiA9IF90aGlzMi4kcmVmcy5jaGFydFsnaW50ZXJ2YWwnICsgcGZdO1xuICAgICAgICBkYy5yYW5nZV9jaGFuZ2VkKHIsIHRmKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZV9jb2xvcnM6IGZ1bmN0aW9uIHBhcnNlX2NvbG9ycyhjb2xvcnMpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy4kcHJvcHMpIHtcbiAgICAgICAgaWYgKGsuaW5kZXhPZignY29sb3InKSA9PT0gMCAmJiBrICE9PSAnY29sb3JzJykge1xuICAgICAgICAgIHZhciBrMiA9IGsucmVwbGFjZSgnY29sb3InLCAnJyk7XG4gICAgICAgICAgazIgPSBrMlswXS50b0xvd2VyQ2FzZSgpICsgazIuc2xpY2UoMSk7XG4gICAgICAgICAgaWYgKGNvbG9yc1trMl0pIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbG9yc1trMl0gPSB0aGlzLiRwcm9wc1trXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbiBtb3VzZWRvd24oKSB7XG4gICAgICB0aGlzLiRyZWZzLmNoYXJ0LmFjdGl2YXRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbiBtb3VzZWxlYXZlKCkge1xuICAgICAgdGhpcy4kcmVmcy5jaGFydC5hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1RyYWRpbmdWdWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgc3JjX1RyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9UcmFkaW5nVnVlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIFRyYWRpbmdWdWV2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9UcmFkaW5nVnVlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvVHJhZGluZ1Z1ZS52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBUcmFkaW5nVnVlX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgc3JjX1RyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBUcmFkaW5nVnVlX2FwaTsgfVxuVHJhZGluZ1Z1ZV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9UcmFkaW5nVnVlLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYWRpbmdWdWUgPSAoVHJhZGluZ1Z1ZV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qc1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG52YXIgcmVnZW5lcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1Nyk7XG52YXIgcmVnZW5lcmF0b3JfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3IpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvdG1wL3d3JCQkLmpzb25cbmNvbnN0IHd3JCQkX25hbWVzcGFjZU9iamVjdCA9IEpTT04ucGFyc2UoJ1tcIkJUQ1VGNEQ0RzhEY0VNQk9BQ0FMdWFCMkFySmdYTUtnRFFDbVJBZGhES2dIUWtBZUFEZ1BhS29ETzQ1d0FiSDZBRjhpMkFDdzg4NmFuU2FzT0djZ0ZjQXRnR01salBBRE1GNUZhZ0NXemJzUktob2lFcWdXSnlhQUxRa2g3VklqVWJ0dWcwY0trekZxelpvQUR3a0FQeDJBSXdTa0dGUkFBd0NpVVE4bUFBY0JDWVVWSEJJeUloY3dOaHhjYUJFK2dXaVBLWHdCUkZ4RWFBQTNCNTZocmJzUHFiUStwckFBSVNJTlByc0FNcXk4QUJHQURZa0FJS0lpUEFBbmdBeStnRFdKSVNnb0tnQUZvak1BTzdJNUNRbkFLSUxyTUFBUkFDUzVBaFQrZ0FteUsvd3FQQzNUVDM5SkFBUG9EYUROeUFCemZhUU9JQU1oaGZXQUpHUStsc3FBQTJuRUFMbzdmYUhFNW5TN1hSQjNSN1BON0k4aXZCaS9ScjdZWTBUN2ZjREVPbnNJYVVoamdNaXNtanNTd0FJV1lPaytpSDBKQTZwUjVLbVk2aVFKSEF0MFVTZ21KRVF0M0F6S1dqQkl6RTBhRDI5S1VLTmdvWDBOQ1ZiandadWNyblVSQjVmS1FLajI0SGd2SklUcjI5b05iT2VMRTQwQ0VVdXM3RllYQVVVeW0zdnBaM29xQ214M0RrZWpiTmpkUEJMc1VrWUV0QVlMRFluSFlSRFpqRU9xR1lxQzFKSGRxQUF3akxHSEx3QzB2TVl6UDliaTIycmMrcHJ0YnEwTHNEc2RUdWRrRmREc1NIazk0Qzkza2h3Y29TT1JVRFQvTlpVVDZhTkxaUlptU21uRFJTeFdLMVdheU1QYTRYVjN2S2gyNzFPenBXa1llMzJkWHE3N2lSd1R4MFNTVE81MlFCY2x4WE5kTEEzZlY2VWRLOTkxWlE5ajNMU3R0VjVXUm15ZlZzd0J5RkIwRlpVaG1TM0ZFcVhvUnAxMENIbEdUZFVNMkJBRzl1SElJaEVEOGNDeU8zQnM1V0FjZzBSSVRFR0s0N0VCQjJGTWEwRllVa0RGQ1VEMkxJOHkxUFpDK1ZRRVRLVEU4VTBNOE5wTUlRYkQ4UHBDaThKNVFpR0JJNWpOME5ZMW1Sb01GSVQyT0YwU3hQaWhLVWVCNkZnY3pMUDJHeTBWQlpjck1pVEY3TGdxU0VOazZ0TkVzWjFWT2ZOdHVsNk9JTlcwdGtLSXM3ejlsQVVpVExaRlFRekRMTW94NU5NRXlPSk5jcTNOTURReklxVTBhZjVJamlxVTJJc0h3ZVNOSjRkalN5Q01xeS9JY3FFL0xFMjZ2S0dIVEYwNGtxLzRJbHFyY2QwYkJxV1MzUnpuTmE0ejJ1M1RxS29HdU1Ddmloa3ZqZE55OWtpSHJCckt6TUkySzRaR2swNUI1UjVQMW1IWVR6TVNxM3BURGFrS2hVcFVKQ0VtMWJxd00raERvMnZyVG9Cb2FpdEFESnZzUUtpMXBLd2JOdXJVc1NGZ0VIanE1YzFCc2xIMEx0eWNndHVnNTF0MW5LWXZ1R2UwbWphNE1vZXk5a2lKQnpieUdrcEdVZjBjcUdiVFNTU3hrcERxM0JTd0lvd3U5b0ZRR3l0MUMxQm5XMmJHVUd1eUdxS01nSmJCeTNzdVZDY2lkcjR2QWN2Z3JtejE1MUFBQ1Y0QWhlVmFNNmU5Z0hHalU2dDNMWVRFV2hXMFVlbmt4WWx1OHBkT0xiTXFweEJnWFdvYmFWRnNLOWtSSnBMdnlTbXFOOTJIQWFPZVdJSnl1THlHQkJPTlVRVUpIWWtMZEV2WUY0VkMyZWpFQUFhZ2FKSTZpaVNSb0ZvcTZmQUxzb2lIZ014THM0SXZ5RWdOdUlpSVpoUGZxMjIwWFlQejlJNWVnZVAwY21sdVlVSlcvQU5QNERSZlJNUXdUUjN0ZVBBK2c3djdOZUJ4SFlEd1pnZ2ppVUpFRHdSQURyVFhmOThQNHZqNEVYZm9WQ2FzVkNKa21pMkllajJBTy9SNi9CaCtuOXc0aDJHTGd4T3VEYzhDejNub3ZaZXE4Um9ieUxOdlRleVl6NWF4ek5JZk1IQjNTZW41dXBRV2wxY1pxMitISFFJUDlJelB3b0VRRWFETTlvSFZtdlNXNjdCQkJDQ0tIRUNRVUFoWW9Oa0d5WVlZdzJDVEJtUE1SWXF3TmdtM1FsZ3BpQ3RrQ20wRm1sUG9DSmhZd2x1TXdDWUFBckVnZWgxUnZnSExJNFlBQXhGRStoVUMyeVNoQ0ZLTmxERldVZ09BV0VNSXZKR0pkQnFBQXNsOFBZTkJOQUpodU5ZcXlvQVRGN1NDQ0lBQVRBQVRoRVA0bElBU3FnQ0cySENDUm9pTndJajZLZ1lFOGlsRXFOWEwyYm1HaUVtMFZmR2tqOEtFMkNDRzJFa1BnNGdLNlhTRVdwVzhaaGJnS0Q1TWdHMCtoVkh1eklMakFBOGtrdlEwa1R6Y3dZbHdHZ2V4NERzR2FVY2NnQUFGUTQybzJCTERLQXFUSlZzcXdEaEdFc1pVekFwaWhBV1VzcVllQkF6MTNBR2FQUnFvdmlzQVNRQUFTT1hzeFk1WTFURmgyVFFmcFN4ZEQzSDBlY3c1Z0piZ25OdWZjeDVCekxsZHpOT1dFWUxnVVRnZ0FDcndIQk1jbzVmeUFVUWhCZUNXNHpSaEZHR1FBb1RvV1J6QkxWYWNvOXBWSk5Bb2hJS001ZzR6S3dvcHlGTUJRSkJOYWtDVlBzNlk1SytnaldsT1FIRmk1RmcwcWdVUUk0b3B2aXNycFFKZTBmRWN5SUNXTkFaRld6YmkvQUVJL2NXd2RCWUtFd2JlVWdxS0taOFM0SWtLdTBxRlVGMGJya2NvSkE0UUl4MXRxQ2t6Z2paNXdISXdlK2VCR0RiSXhjazdjRmd2aGJETkVGYm1wUk9BL2d1TUFIMmdKSFpqekVXNkFBK3NhWmdtdzVYR0ExVnFsQStSTkFFTnNLYlQrRGRvcWVyaXY2b2NlSlJ5RWtuSGNBQTRzdWZaRnprVHNDQWxNZTFyd2xoNUIwT1FRRk5KL2o1QTFLOGMydHd2eEhEVVRzMU5JNTRBeHVRUGNNQUFnbDdFZ1prb1N3ZXhtQ3ZCMlJRRzVpQndTdWthSTBDTnRTZWxVaG1PQ0IxVDFnQjBLd3NnTHVkaTExWkZYY3djMlhjTlN3RkFBeWd3aWdTQ2R1WUlrRHNhWVcwRHFIU08wQURNK1FyaDZmNmw5NkFHWUxrYUNRS1lOU094TnJ2VFFRZCt4SDJKdHJjMk50Sng4aXZISGQraG1yeGhpTmlsUmNlZ2VkR0FZUy9aT3dRdjYrUzNEU2tCa0R3N1hod2kvUk1SQUNnTU4zQUkzQjdESkZ3RCt2ZHJLbFFLTEtDcnNWS3dSeVV3VzBLQm9DNjhEQzZqQmhCWGxHWGpDNDRySHRQU2lNbE1hU1ZrcndHSnlkUkJYaENjMWd5SVRpUkczRG1iWEZYajNNNFJKdGcvZTBEbzZ0TjRsdUxScWRpbndUMFBDYS9ZczFSZTBJdHNDeHpJbEFoYUNyUlFySVdWWThBY2NRRnhpekM0SkNFMklVMCtoa3JYYlJKc0Q1N1VmbkFQMTBuUklSSXlDT1h3RVlPQVBZN3ROQUtuWU5VN1VISlhqL0tRS3VJZ1V4Y3Y1ZVhGU1Y0QUJOTVVVeFhnV2Y5UXFCZ0tpRkJudGhjcGhVVTBaajZNYTBRRnlnWjRYbE5zSXdUQ1RtUnZJQ1dPTnF1U2h4dVhTblVOOEVhSjRBTDFOdEY5S0FoM2JySEFEYTlwZXQ4V0lTck0welE3THdEckRoT3NZQVYyQUJ5d0FmVTdFYUVjT0VSeGxia0RoSU1SK3hDamhmd00xT280b2RjZ1RIQUVvRHBSM3RUZ0VZR0Q0S3UyMm0wQlVQYS9Sd0FiUERjaXNnZWcyeG9Cb2tWSU5Delpuamg0NEk1aVp4ckFMandBbHNBVTJYUmtXWkVwODV6SEZNdHlCcWVNR3JZM0pCQTdBRW9JS3Vzd3phVjJjNmNZQThiaXlkem5jeHdnYzhlTEVBYnV4d0R5czlOVmpuUzZhelJBY3RPT2VESnRxbWc0U0pNeGF1V1ovWTlUYTVoSjlwK3AzYmordjlmQUk0OEE5Ry9IdmpRQ3dvWXBpd0MySm9HZ2x2cmUyN3ZIeHZZeTRhTDA4RnR3SEhjWUxQLzFGN3l1bkkzTWZCNFMrSC9kWE84RFZpZDhzMTNsUFFDKy85MUh5S21QMWV6akpmdURvZXdPZEVHendMRGJndjhmTnZ0Q0xoUG5QbURBR3M0SVM2K2dBNzBtWjdBVm5vYWZDTVg1NU4rQW1FMm8vaTJHWDlTWkJSN1FERFlnQlZvOHVjQ0RhdVVmUXBwTS9jSGdGL1VCUGFKdG8rM2EvT2Q0Y2hpZkl1V2lZenhISG8xcmlsMGY0Q0hmMGtHWGZvaXFWZkNNUHZyWW0yZ1p5dm1PK01nWmsvSTZGUTBhdzFPbVFEdmxrRVFJL29uTUJzL3ZiQkJMQUkwRC9xWmdsZ0FWd0dPRUNsV0JPRGNMY0VDbjdzaUlmcXdCOE13T0tLY0JXTWdNZUxBRzhFaVBBTWdBQU9STnFVSElCRVlqcmlwdFN3QUNBdDdnQXNiVDV2NDRIVDRBRi9BUGlBWnhTL0tLNUQ0UUVtWUtnSUVUcFRwbWdMampxTHEzNE9vVlF3R1hRMUJTR1RxZHJ3Q2hCdWdxWm5DZlNjUzBCTzRSaW9BM2J3Q0RvTHh1Z2E1TkxveHhqbVJwZ3JETUFxQ2dFRVp2WWlIRWJmN09HLzRoNmxhSUdtQXlFMzUzN3lqZFRIcWdJRUJ3RmlIYVlXYUlFL2dvSGFob0ZUanY3NXI2RlRDb0FGcUVGSkZHeWJwdzYvQStGTHJ5RUJIYzRDN05LWTZsSVlBdUNyQjJFU0FZaVloYllSQVVob0FHWS94U3EyRXFETWhvZ1JEWWhFQytJMUd5S0lqT0lvaEV5bEZOSG9pK0k4VFZqd0NhQ1BLTkhORUFETWJSUElKUkZ3SzRvbzRvUjQxU3djcGdXK3JZeUFJd2hSdVExMHJFNmd2V2JRd0lRMjFZM01DbzVBbkdzNEZtc2graVYwRWg5b2V4akFCeFJnWEk2eGJRNDRtT3N4Z3E4eEFLS2thSUhtL1JmbWh3Rll0d0FnVXVKT2lBWk9Fc3pTS1ltTTlJVHVsZy9RSlFyeGlLZDJncy93MkNPTXpScTJxNmxBd2hYMnhNYnNIWU15NmlPU2FZcVVTMHFBcTZmUXd3UmhxSnBpS1VjNjVRQjBuQVZjM0FaZ2Zhd0FqUWhjaGMrZ1FRN2krd3M2TmFvV0JKWlFVQmdRRE01aHpSODhNaFFtNEFhOEZBbmFFcCtlOG9GaFdoOG9kS0ZBVzJiVXFZZzA0QTdBaVFhVWsrZzBlQTl3cXFBdTNhRzJjbTVLWkFhcFVDQnBTMFN3ME9weEV3ckU1QU5vQ2dlZ1lZU2dSQW9PREs3cG5wK1FreWpwaUc3QWp4eXdSaGc2NEF5SzNwekFvQk9hWndUeWlBV2l6bW1SYis3QThaZWFyQXlaSTIzZUdKMHMweUtaQnU3NHRSVmlycC9wRnlNYTBpdXFNSWlJY1VTd0NTR1ppWjJaa1VMYTNSSVpZWlN3RVpRSWdJMVk1QXhocGdnZzl4amtpQU8yVVNYbUVFZTJ0QThraDJ3VUoyb1FrNU5ZTTUzTUoyUGdTZzRNaEFIdS9xUVVsdUlPUkFOT25jY1p1YVRaS1pna3RBenFWWXNPZXVkcUhvU09Fd2tvUVlOeWFXR1dZNWhwbnVOdWVpeVdRZ0dPc3dUcGl1UkFQNTU1Mm9mY2EyOU9GZUFVdEFzdzdBZHlLZ0R5bVorUXN3OXg3eVRSVk9wQzArOGFqY3pBNUlzVUdvOEFCbU5RK0tSb2ZJZ09LQWJxWTR2T3F4cUZvcFg4bmFhWmpaWHl6Wm1Hb0FvUTdBZUFPcGNZWUFLK0FlMGVraUZKNm0yaHRBNWhyRmxocUFQYW5PUkFHT2Q1ZTV3QUV3QjV0d2RGRnltUkV3SzJJRjBlWUZQb1FnTHBrS29vRUkzZUcydHdhSUNpZXV5QThsckFtSUlKOXhtd1N3TEpnZWM2OG9qc3pRTndPQ25Sb0FDTUt4SEV2cUVFeWVTTXFvZklZQXF1QXViSmxjTndQNjlKV1dlK2FNTEFZMnZCbnF6bHdoa3AzQmZGNnBIYzVBOCtTMENHc3BHcEtWRDU1aG5BTjJSQUZ3djVFTzBBZnBMZ0hwRnllQUZ3REU0b2xnV2dObHIrVzQyOEZpSU1UVkRveTRPRVRPSDZYSVFrYXBjcEhjNUV2aE9Sd01UVXorWnh1T1FrNG0zSVc0Y3hDeDRrNEprSndjSXdwUWNTb0FISlRsS0k3VW9BamFRR3pvU0Fzd0lsSlFIMndwSkNsQWNJMUo3QXRKd0FoY3o2dWNXd0RRbmlOWnJJeCtDOGF4eFk1WTdnb0ZRc1djR1ZjUTdzN1Y5STAxUHg5MFdJRHhUeDVBc3VZUnRVZkdpdVRhYUFFaE5GVzRpQXp3UWc3Wlh3em9xRzZHcll0VjNGNXM1RVFtVUdhQTdzdUNXTVZjK2ducW9wNDVnUXpBVU5FT2orbmNFaCs0Yk11cGFGcmg5QnBtdDZsbVhJUzExSnZhamx1UU5RbnhTdzN4aXhiSWxDRVFqUThBNWlQMWRnZGdDYVRjVzBBTnd0eWxuY2VwSU5sZ2JRN0dRSit1R29iSUpSalI1SllpcE50d1ZXMWF2UU90Z3FqUlFRVzAyOFl1MDhSMVJZdHdrV2V3alJtUkxvcHV4Qzl0T0tmWmtZL1JKdGplY0l4ZTlWOUkyOFFRR1VxTlR0ZGgrdEVFcE5vZERSZGhSQWRLMFZQSXdkYkludGZSZXRDK2E2UFJYdFV3L1JPR2Y2U0kvd0NnT05EVkZnc0FJZGhNc2RLZ2tkZ1EwZEZkem9qUjhkU0p1R0pBaWFmUXhlTU43cWY0amFncXRTM3craWc2SzR5QVJ3ZWl3NjdXeUFqdG02S0FxZDN0dnRTZHBkNWQwOU9kNmRTMHRkaTl1ZEtXUWdrd0ZHR0dXTk9lZHNRVnhJT0M4dFh4TTFTeG90c0JrdGpRMHQ3bXJCQXRRdDRrVDFxNnZ5NXRkaGx0YzlTTWgxK0pRdW9CYTl6dDkxNzlaZFpvdjlFZEc2eWhqUTVHSG82d2lRdUZOWnR3RUQ4QTZ3TGE4U0x5VW01NlNEOTFib3V0cjlYSWVxbHRib3dES2dlRllNN3NuQTZoYm9QV2F0UmdteVdwUzBPdEY1Lzg5TlpBNmh6OGJoYk5ZMWZzcm9XZGFkY2RnUjFzanhsZ1d3ZENRZ0ZEK2l1OUFzdmdpYVlCVnMxTnBnTU50QTM2Qkc4RGlEa04zTUNTcURaS1NETWpxczBjT0VFaGdKeGttajNNbjBQSWlOczRXMDRtOGpTbXcxb2grR0JqelZSdGxJdndmbTV4QVdseEtqVlllcUJtSEQzaHpCcXV1aTdBZXdZaklpQjl3QVJSZDlwOUl0eVUrMFl0SkFsOTB0WFFSOTRUZ05mRU9KWEQzdEV4VnMxZDZVcXRTT0RNSWpiUWNHWXhxb2V0UkFXeGxBQTJTUWp0UVRGU0lUWVRVMUo5Z05vVmtRUDZjVERnYzZSTi8xRFRpdDNFcVRXRFRSbVRHNlhVT1Q2dEFHRU5xY01qakp0dDM2WlRnZ0MraVFIZFk0TVJkdytna1ljaFV3NDlZZFFFcUEvZEdHNHF5bUExK2lkV3Y2SzhFaXFGYWxPa0J6OG8zUVhCZUFxSnBRQ1JoaC9aRktOaFpSaUFRZ0hoU0RjMHorWGpXNEUxcFF6QlFZZG1iQ0JZVFFKUmFLdk1DWlh5K3NPZ0Jna1pqZ2p0bU9ERjZrK0doT3QrUjVVTE1MK2dnNnlBNEFlUXZ3SWNLV2VFUTJySm5xNXNKQWFJaUEySXIwRkx4T2VZN0M3c09xTkxHQWRMQlkxRE5EWWk2SWxMMzlab0xMSEFJQlBMTWdCWUFnYk16SUxDWVRKaWx1NG9kaUk2RVlZUVlBVUF0QTJLOEFCaEJBVkFsSndocndpSVJBMEE4QVNldktqZ01oNEFac0xDcTF1UUtBNjFwZ0RNRGVaQWpFcDFWclBlOTFDNTJLdUsrS2hLMDJ4QTArMEF5NFM0TEtNd2JLZXNTZU5MQWtRZ1ZyUnJkc1VBQzVnRjFZZlNBeVF5cnJxb2xZUjFkc3BlOHJNQVZTTlNkU0RTVmNJbCs5SEVwMEdvM1pzVC9KeGVkUnJrVVRUUXByS0F1TUkwWFVaRkN3eXdJY3NCSVFzQjNKcVVUMXpSNUFqMGJVYnpWY2JPcUsvd2wrRDRkU0VJYWkyU1YwV1RhQVdyYkdZY2w1dHFVYmZHekEveTJsNElSMXBndklOMXdBcVFSQWtRSGxOZ3R3azVMYWlBZXFaWnBWQVpCbStRRDhSZzVackE1by9acFF0d0RpakFoN0NTRjRXdDA4b1FmQ3l3emlod2MycGdmbTh3aTRBOUhBejdnSUFBOUFBSHJBQ2hCNEFBQ3ErZ2dJOXdUNklsMEhxUWdJRVFQQWdJa3h2aW9BVUhlQXRZVXd4aDJvOWFINzliU3dBQUpLQjN4dUtDSll4S3JGTytESjNsaFdhWk52MmhYbFR1YkorNDZjTUp4eUhCT3lKV3NlNWNDR09SMk1LQ1FKN1NRSTFxa25NbnFHc2hNTXNuQ0xKOHNnZm5CVFVaT2RzQk81eDkrektBVW9KejJicCt0cDlXbXBFYWdWM2FTTE9PU0Y4RHMwa2VXTFVvalBBTzhPY2VRSFlPL2pTa2F0OExvTldBQURya0NQQ1QxVWpZVE1ESUFxallIVW96QkVDRUZPZElEOExwRjY2RnBLRFZKSkY5S3U1QVRJQm9pS2RUREtlSm1ZaGdCMEhQNDBEaW85b2swMXhzZDFYL0NhZmNla2ZxY1V4MmFnQkNlQjRTTWljY2ppZVNja21iR0xKeWRUQUtmdGRLZHhHNEhyVnFkM2p0UGdDT3pkSWFubER5azFDTWZ2QS9WZ3VWdTFMSzNvanBlWmRmTFpkTkFJajVCcnJnQlUxcGhnQVo1cW4zVWNUTEVCT1ozbUZMWGRrVUpSUEt5bUQwWUoyTkFTcGgyWTdqY2pUODI5cTlIZTMvSG1ESno1dGJlZjRLekFoVTFwU0ZkdmM1Mkpxand3M3dEMmxpSlpYRmZBaTJ4WkIxZXFXR2ZmaklFbWVaclRoa2p6amJNa0RxRFdlQmRVamxuV0JJaU9mT2VmS3Vjb2pHb2VjMERlZStlc0QrZG9DQmZCY3VkaGNSY3kya2N4ZkpKeGNKZklCSmZrR3BkTGU5ZGN1Z0M1Y21iNWY1SjVIOTZzWkFMQzdycGd1WFJkem9pclpycWxDeXBVM21IM2RTb001TFJUZUM1M2dDQlUxcW4zeU43Z3dFWERCZVhPNXA1RjJjVm9YaTlvNGRBOFZpSUdkMU9reTR6QVJBZnNDS2xqZ20rK1dqN2VEVzhicWNEeU9NQ1BIVGJoYW80YkVONkN3RDVGaG9VSGtLQ2dIczI2OVZ3MDVtQlI5Uyt4K2dGeDZDQU43YTlJbWM3SW0yQVI4TmU5QXlKdWNtckZrRGtMTW5CUkVrQkxPM0MxaEd6bkZKSDRrcGNxQUVmc0NGcjlJcGVaSTI4Ykg3bGRCemZWdE52Vmg3UXR1RnpoWGt1ZHNrUjBCVXErdnlpRERldURxei9BanltZlpHQk1yV0E4THFralMzRG1HM0RyVkhzMW1EQWNwNktiOXlrbEJFQk90aWN1dGpJSnZ1c01RMENXVU1UMEpxcXNZVjdWazA2RlZrRGVIdll3ajdubE9vQXNGY2dUUmJnRGdFd0NsQWNzYk1ZQUZYVEQ1dkVDU0cyWUFPVmtmQWpaUjIwbk5ydXNoMXhRVjFrS0F3M0dnSTY3TGNMa29RRjhoU1ZRRUFEcW1VVUNtRHJtSkpqdDB1SmlFcWhSZ0RKeFFhQlZpWldFdHlqYWhCYmdtQWpycmNBa0FrQ0JJQlNLdVA2ajV5QTltc0M1YWNnYWhJQW5ZRWVlOUNSaFRFM0xibG1zM0lQZ1hiSHo0ZkJNSWpYWjFtY0VheEZrQncrc01Uak1EMERMOWRCTGlXMUhRTEtwWk0xNHE2SXdmb1BoeFh0VDJVNVBwR3VTa1JpMGlTaFpWcnZpbm9CTEJ6Qk0zVHpHMUVGRExJUFFETWVkdVlST3hIVXJCSmcyd2ZRSkVwK0NaZ1JzSWdDTng5NkJVdWNTMUJJQWkzdDR4SUlnekhOSExBRmY0VTF1QUxrVFZreFRDSHRKVEJlZ01nVGtKbmJINVRvWGJJN2s0blN6Qjh5YTEzVmdnU0dBQklzakFOQUNZSVJCdVJCOGM2RHJYZG9yRGhDQ0RQNGdROFFhVUgwQUNRdWg5UTdxSzd6YXBDTkxvR1dDSUNRRW1KRUFsZzRBSGdDUUJFQStsd0FreEVnTmdDSUJUcC9FT3dvZ0R0Z2lDcEJEaGhVU1ltc04ySEE0UkFBQUtoK3owQndBdmlXNFQ5bG1EZ0JNQU53LzZIWW5BQzNDRUt6U0xZVHdHd0FmRFNtR0FFWVB5RHNUM0Fic2VBSGdDTkZCRjJKWmdBQURUd0FSQlFPSTBJRk0wbWFRckIrUXN3ZldIZ0Z3QkVBZ1UvSWYxUGNGckROSklSdmlYWVFTS0pGQW9MZ2RpZjFIWWloSDRqQ1J4STBrZjZuNUQ2eDdnU0l4a1VTSkpFM1ovVUFBQ1F4RUFBUlBBSDRsUkdFaitRelNmV0lLSXVBNGlPNGxJd2tTTUNCUTFZVmdGd1B6Q3BpeDc5WTBSR0kvMUNTSldBckE4QW1BZkt2Q09HU3pBYnN3b21nQkVGMkcxaFRSZ29sVVFBSFU4QU5BSGdFUUN6VHNqQlJpSXVvQ05GZEgzQkJSTldFVVlhSWxFRWpzUmVBWHhGdXhORTNZK1JGd2U0Rm1qNUZBb1F4dmlJZ05LSzBTekFZT0t3SUZQNmhWR1FpaWdSQWNFVGRudUIySVlPdEl6TWJpSnpFUWovVUFBTFhSSDBqeVJPWWhFUldLckZJakZoUkFBQUdvWWlSZzFvbFVZNk10RkVBWU84SS8xTTBoTkcxaDdnU294MGY0aUlDVmpta3RJdXhNMG1sSHhaWUFGbUZZS3lLQlM4aVJnOXdjc2FxTjhRZHhGeC9JWmNYU094RlpvSVJmbU93RHdFWUQwQmtBY1FaQU1lTlBIbmlMTTdZL1dCaU1YRjJqSXhGd2ZVYmNHM2h0VUxNV2lVa1hHTnVBUkFJZzE0bVd0MEpJQjJBb0t6Z2JIa1FINUF2QnlBNndCeENvQVdSZ1NsQVdpSXdNUUc4N0lBMEpteFcvUGdXUUF3ZDdnUkFmV0FvaFBBWDhQQkVMSHNSTUJoWng5NitLNE9VTW1GUW5vU2RFaXdUWWtiQ0xDQ2pEZzVJRVlFeEtJQjhqZjBydUF3SS9HUUEzWVNBWktJZ0xSTFFuc0FtSklFMVVEMEJCS05BU3E0NEVFUmNCNUhDaXJVdVltRHRTTHdDVElWSjFJN0FIZ0c5S2FTTGdsb3ZBT0NGTEUzWlZKRndTWWt3bldDY1Rta01ISEVUOWdGRTJTUkFlQUdTb0tObUIrai9vZG9pNEJjQUFEU2VBQkN0T0p1eEFvK1JlQU94RVFCcXdYQmd4MEpmeVlGTGhIREk4QTJPQUFGSkd3OGNXaUVnQk1EeHdPSkxrdHdXWUtXSFNuTEE4YzhVblFQbElqQjQ1WmdDZ1RyTGNBdkJQdFFDelNWUktBUnV6TUI1eG9CUVVTb2x1QThRZ1UrWWk0TzJObUFxaVJnY1V1b0RjT2hLQWpvU2t4QWFlMFZHblFrZUFOd2tLYmNKQ2tqU1FwdmlLYVRtS0lDV2lnUi9VLzZPOFAraUFqL29JMC82QXRQK2ovUUlnQzBuN0pOSit3alNmc29nTTRVY0wySEpCRGgzcFE2ZXNPV0U4UXlPWFVucVhGSm9CeEJkaEZvb2dEUUFURS9UUHBuMHJkaDNBVEhZQWVJdFlQcEd3SHJDTW9XWWVBRVlENlhTeitvZEFINWFBTCtQWURjQ3JVdHdiQUtqTnhGTmpmeGNRTEdRc0kyRzNCZkVlTTdnYjRnZW0zQnpKV003WVlUSWlCS0J1Qmt5Q21YVEtSR25EQ1oyQUptZDZWL0ZzenVCUmtpbVhFQ1ptV1RmeGZJN2dUOWlKbEN5UXhkdzBBcE1URmxuVFFDSWdNV1RKVi9HK0l4WklnTERvY04vR0NqdUIvMFg4WGFPNEVJVmZ4ZGliZ1NGTi9FMVp1QnpTSVFQY0VKRkFvdEUvcU8wZGlNaEczQTdSZnVXd05Va0JSZHArUWRCRWRFaUNXQkNoYWtvOUJyTFp4VVE5QXkwc0xNVG9zR3hiQUJxQ21nV2dqaWhtRHZCMXFsQkhhbXdGb0tHVmtrcFFDc0g3a1FERDBhazNzaFFCczFzQjZ3Z0l6czJNTnFEMEFTY2d1SkFKTG9ZR3NEU1RMb04yY0FLQndTSElCQVFPSE5FR1IxbUIyQnl4L3FQeUhFRHNEK0oyNW5jc2pwNXhvQ1lnYmhvQU5FSjUzN2czRFFnbm5FQURRQ25tZ0JQT29BVUR1Q0N4WkVCN2c5Yys3RzNJN2xkeU1RdmMvdWY2a0huRHpSNTQ4eWVkUExSRDNad090d2NEcDV6UkRYek1RbUlRdUtFQVhtWWhsNXE4eFJCdk04NnZBeCt3QVR6a2NGSG5MenZTUUtEQUZ0aXJnckJNY04yQ3lQMGxRQ1BBaUlGaVJwT0FBZ1d0WlhNMFZMb09TMWFKOFpSUWMyVW9PU3lHSVlLc1dZQVR0T1MybUo0S3NGdklSNG5vanVDZ0VNOGprTWJBa00xNGNzU0ZvbFdac1pFZGdxREJSOUNpQ0ZPUTNadjRoNEs1VzRNak5BQ0FKUVFVQ21CUXdENFVDQmZnUGZONHJXRDV3NThMOHBiTVZLVUh1Q1FMbkFvaWg0VDlSVXdicGNZeWlwQlpMQ3Z6aFZPSTZDZ0ZGZ3FtU2NSY0Z4aWdoUjJEaUF0cDRPZ0lhYUh5RWVBaVZSNFFRYkFDZW1RblNZTDA3QVllaHIxN3lQdzhNdldiZ1g0cElBNzhrQWdTL3BNRW9JeDRCMUdqZ0pRZ3FGdUN1bEpVWk5mU3I4QVNWZkF0V0Z1UTJobmdaU0pMUDRGbVpBQ2t1eVZwTHA4dndNeXFDM01nV0F3eWVjRGlCVVMvaU4xRWdSd0EwRE1IY28wVVZCV2lSN2tPeWhTd3B0Qkg0UGp2QXRvQmFWQVVCQzE2T3UzcVJzNGFZWWloOEFJc0FURDhSRnZDaDhCSXM1eFZ3WU9zaXpFbUxTOFY2SUpZWFFJSlJ3TzRHNHdDcUl3QlNhU01GSGdON1U2d0dTZUV0dUJNeTlsTkFQU1Njc2dibks4TVlzNjVmWlAxaDNLRUdEeTRKUnJNMWpnQUNxTGttckc4ck9YYktkWjN5Z3FoNU84a0FxUGxEN1haVDhwdVhmaStSRUs3WlNiSkJVMEF3cDJJMUttSW5zVWtCSEYyd0c0U2xTcmpESjJsZHdKVUNxRFZEZExCd0ZNVmRFQ2dlZ1RzcVZxQVI2SW9oVVhRS2g0Y0Nvb2d5dDBWdXhYb24wV2xRdkdXVm9MaGlhSUlZcVVHNVVNZE1LMDNGUVFBRWNoQkZKUXVMY0RzQzNCQzQxWVVNaThCRXEzQWdnY3FqUEpGVUs0QzUrUUt5cXRzQW9jcUgweld6bFdwdHFocUtjUktXd0N2bEpTMDJvVVJYd095Yi9EUzBsek5GS1drdUpvT2F1SndVUXVRRXVTbHR0RytETUtvZUtnL1dPVU5GWG5qRTQzK0N4QlcxNXFSb21xNVFZdHMwMFFDVzFXOGM2R29BNG4yRE9KWEV4SVQxRHlTWG5ZZFYwQ3ZQeUoyd3Z3VHNPMCthcDZpRUVQaXVncjQ1UWVBSkVIUldlVStTeWxKNmhvVkFURndWQmZJN1l2bVIrb0Q5alY2Sko2cjZwZ2JvaE8yL2Fpb2k1VUxqZ0FBQVhoTGlIVVVRUjFOd3dkUjZwMmloVTYxaENGUVpPc0ZoemM3S1BFWEdBOUc2US9VTHVOaVdkQnVuS0NCQ0NVZmxHb01URkhqc1k1Ty9ncEtYRkFiaEZ4dmhQNmZPc2lBNlhMc1cwOTZzZFF0TE5BajltNkw2b2xjb0JKWHZyVW9ZNjFJRSt2L1FQZ1U1cWlPOVhDQnFnRnR4bDlBRmNxUEJXcFJyYWtOUlZ5c2QxSGlpbEFoYmxmUU1CWDlVUVFlMkF1TWpycW85aHhxTzQ0Y1IrZ01GaDRWRklBaUFDb3FyQnFFaHh5aWhheHdGWEN6U0Q1aklIRU1jSUtJZFFaNDlZUUtMRmxzQ2tXSW83UnNpa05kaFJ3WTFra3F4RkQyTmptT2g0NENvZU9Wdm5kR0NXZ0ZPODNHWW5IOUJYSWNxbG9wc1AzckVwNUNXNVVBbWdTM0czalpDVzQzZ3BteGZNQ0NXRDlLU0dLc1d6UTlBcUxIeEdnNnlqWHYwRU0zK3BVQWNRUzNNQ0gwRG1KUE4zbXkzSVhBYmcvTjZRT2dBSmowQkVxVEUzc3pGUEFPZjBDMCtibXMrZ1p6Z0FGSUc0cUtJSmVlTllxUUJIcVdJTUxVRFFYaDBJRVY0UzVBRkVIWUI4a2ZRRlJBclJVVDFKTkFsR0h5NUFMNGt6akRCYXQ3dkJyVmxzbUl0YkN0WTYvVWp5RDJoYlJMY1lJWHpZQ0d3Q1pDTmlOV0hJY01vczJ2QWR5SmdUY3NOdWF6MFJXTkF1Y3NTUnJCcnFDcittZzdBY1dYUzVmZEl3VnNOTHQxd3k0QzlzUWlhY3J1d0I0NTNoZ1FIRVhNa1h3ODFaTjJNdzdMcGExenZCdFJteFpzUW1yTzNhVHpzQmxFSUpOaG5oemlqTE4yMjdCb0kwSDNZWkV3MXBaRW9SY25EVTJDM1NkZ205bjJVSFRSVUgyNldPOUMrMHNCM29OT3BITFRuTmtKSVBnQU9JRVlEb25HQkFRZGNPY0hCRGtoMXc2b2QwT21IYkRyaDN3NkVjSk9URlRqaFJ5bzdPQjNLRTdEN2NvUFU2dzhiSU91WWxhcUIyMGFKUXFaZ0gvb1FDNEF5YjhnMENYU2tOa05Jc1VoaFpRaXZJZ0FDMmhWUWcwQVcwanlrMlJhNk80Z2xUbHR5VXFKQ0J5VVk1T1JrSUUwQldoNW0ybWROTWdHcjYxOHpPZ0VTenRqd3d6MDhRdTV5SW5rWUJKNmhjQzZDT3N2bFR4ODRGOUVBZFBHem96MUo3TTlpZVVYWllPenowQ2M5bkEzUGVBTWx3b0pIYjFrK0EweWpsMVpxaTlBQktBTmZKd0ExSmR3TEJDdTVYWlBtYUw4OHVDcTNFTmtYc3VpZnBoS1F5Mmh1WkRWTDJoamRaUXdXUG51ZTdNaHpkUmVzRnV3SDIzbFlla2FVWk9MOXczQkE5czZRcWY0UHVuQjRiMHE0UE9pUm5td08xY2hZZXVXc1hhVzJMYVJyRFZlcW10a2dST0E4ZHJ1NUFadHVRRmJaMGJDMTg2enRHODB1andqaHU4aUFySGpuazJnRkZOb0JaVFhoalUzTEpXcFJBZUtYTHV6YjBkRTBFZkgwR1RDRWh2QWVrYndJU01adkFBRXFHWXhtMkVpblF1TFY2KzBqa2FoR3lGQlNRZ0x5WDZjRUlnZTFBSkptQWV3S1lDb0VhazhoaDZsSVBxRFFEd01xWWZzenNGWmxNR1hTTUEzVVBSU01CUVpmaFp3ZG9YVlBCUEFDODBYa1JvVFVXM0xqR2tRRG9PRGYrMTRBOEtZT0JvK0RmbFdZalFzdFd6RWNzNGhtemYwdE96c0dVUUJXdmpEbGxzMEtINzJHQnJBL09JbWowZ0VEL0dNT0ZNalczd2pRV25tRGt0YUFJWHJkcmtiSlBia0prUFdQVlpVZ3djd2d2RW0xaXBVbE9iQWlMQmd0d0ZLakFpU291bkVKbUpWYUZBeE9TM0pvSElBN2xSTmx2RG9aU0dmaG9nL0RFQnlJLzRhODBtYm1zNGh4SUtrUGJCMEIrQndQVWZjNGszd2RocFFqQUpZSjgwME1vSHREZk5LNUhvWU1OQ29PU2JJQ1VJMEFSQTFCVXd1M1JLb2VzdWdLQXpOa1J6aG5ZZkFBT0g0bGhTNXcvU0VBTnVHc2xIaHRKVjRaOVFwZ1lqbTVZelhOcW1xYUFrakQzUVdHeUZ0amM1MGowQUZPb1Z4UTNEUkdnZXdTclRwRVhVajg5Z3JiRVErbGs4ajBIdmdhSVBZTjNQdm1aWUJBTGc1QVdTcDVCYUdQR0QxU2FBbUQ1QWRHN2dYUndZejBZNFN1SC9VRCs0SmFVQkdOU2huajFZQUkwRVlTTy9OQ2pWWUlTTDhmR1B4SDVhbWdDQThCZzRQbXc0a1V4cURHanZXckdiZlpRb2YyY0Z3MEVTYzRVU2h6S000QmxEK3BISUtJZUtPN0FHTEhIWjRka0xFSTBDVVBvQVZBZGdGUUtsdkVOQ1JLTWpJZk9NREFaT2xBbERpVVZROWdmN1doVW1xZkp4ZFFLZGdCQ25HQWJsTkVBeWFFZ0VwbHdOU25rTWRFVk5iZ0NvS3Ara0w4ZlZPK2hsa0ZSZmlNdXRzRHFvL2lsbFB6QnlZZFFXWkJLcHpMb0FSbkZQNUg0REVKN1VObzNDMk1CT1QvcWNVMmJEOHc1RzhqR2h1MDZnYkNBOGhUVCtpSDR3U2p2NS9za0JMWlc0K0NkOU9PbTJRQVprZ0Q4WVM3YWM3WWVBSFBra0dnREdtcWt6cGgxSzZjd1BZSHpUeXBadlJJeFZKU0crTVgyL1NId2RjM2VMWFkxSmxnOXFETUJaYW1FQTdYTGRTYU9QYkh2Z1RUVm9pT3FjSHV4dzRXNElnOGNIdmgyQmNEaEVZNElYSEVOSjRTSWRnYWVLeWFtTU10d0FRYXBnMC95Zm9CYnFUWXVyczdFcElDRndHVDBhRWdGc2UxTVpjak5TVzBjMU1ma1BxYmF0SlFBMWFFMXlDNTZSb1B5Um9IdkNZT2hVN3pyYlpZNzFTWXhiUVoxekFNL0wwQVVESDQrTWdtekVPWWdiZ05hZVE4cGhtQ0NjdHlONWZ6b0Y0WWdpZU9pYmxBakVGbjh3ekdPZ3dXaElCVWVDNkNjZ3NVSmpncUZ3RXlwb3d1SVhmenZ4M0MxdUhVMEVYQkJTRm1nT3BwZ3RYSFRheUp5MkZ0Qmpua0gwczdBVTZySWR4TEdRTEJsMEYwSGhiNUFWRXpOTkFVQytSZUFCZWh2Q1NwbG1FNG5BdUNEUkxDSjlDMUpaRXUrQW9UUUo0U3pKYUVoa1g1TEkwTll2cVo1UkNBMHpKQUpZQ2Fjek9CblBUZVowbENidnE2b0w1OWdJQms2V2FtbzBMN0lQWjFzN1BFN1pUSkV0Vm00dnJZdGlZN0lqei8xZUV5YXV6MXdMNEFMaThXcytjZXJ3amxLeE9DTFFhREdLaE54TmdnTnl3b0ljRFRuZkw5bWg4K2ZRU3ZlbmgxL2Nhclk4ZityMldFclJXN3BFd2J3MjBYU1dISkdvRDlTQ3ZZQVFyWS9UNnExdkN1clp6ajA4RmJNWEVxSy9yMFNvc01nN1FlUTNFZ0tyNHRZSy9BRkN0VmFHcjk4MnJieGI1V0VzOUxCbGpNeTZhSlBsZzZaQTJmTTVhYk1CRm5yTGRteEppNGVJaHVhcXpUbG1zMXN0SzBObmkrYVY4dGwyY2JQRlhqck5pWHlKMmM0dGkwWjJRNS9BMGNBSFAzWGlEUGxuV2hib3ZRbndwejRoMmMvT2VwT0xuL2cvbTk4enNaT3MzV0x6NjV6YzlJYXVRamRiejk1bGN5UDJZRFBtbWpRTms0NStkWFNVV1E1QUYxMEtBQWEwbGczS1JkVXE1RXhzVEw4R0xwQm1neXhkQURjWFBZeWwrUzhWdWJwcnhsWXBONWk1UVlNdzhXbmpLbWtkWlNhcHY0V0R6cG12b0NvQVgxc0ZYckNoNHhtemI1QTBBb3JVV2tTd2llaE04M0VySkFaSzI5ZkJqalhhdGV3YlN3a0YwdnBtS0lnaCtnS1pma3lPOWNnNkFJYk50ZWxTUm4rTTJ5bTAxYUNPdWl3b0R0bFpHelNjZWpWa2VBVjNkWFpNUXZ5aFY1RE1CcjRHSVVFMjd3Q3NSQVk2R1ZtT0JFQmZqeVo1L1VyZXR1dU4wQWphSDI2QmJ3REhROEFCVUtKVUNkRHZjWUJBRFdwVmlxMmRoUUh2Ymc2Sk95cHBCS001NlFudHFjdVFwVlYrWU04ZmFlYWx4Unp6aFl2Vzd0bUVJcXRMdVVLVWxsZDhuTUhEb1ZXbUtTeXFGS3B6bFBLSkFaaTRTQ3RnTGk4bnJiMk1vblpyaUxwazdIYWU5aDIwdlhCVE8xbGRjZEZYZmhOc0J1MjR4bHJyZE43Y1pDZTJkTEo3NUtwYUFBRVZQdFI5U051SUlYWkx0QVVBT2taVlVxM1k3dHdkQjdLSGZEdXZZSDlidFQ5eEhZTUdSM1hjT3dqN0RIUzhsZmJZNjJvbW5UUUQrejBXRTdKMHhPMUdhVHJBNlFkb09sT3hEaXVCcDFvY01PV0hIRHRCeVozcUFXZEpIZmhPenYwU2M3S0FFN0krN3pzRzc4NnJFZ3VnRGNMdHVOaTdKOFhqS1hkMlpqVnk3MldHNFpZMWFBb0JGN3UyYXV2YUJycTEwSkFkZHFtZVV2cm9wYUc2a2c1bDdHa2p4T0FBRFZjbHVuTU5idU03UkZUT0FFQ3psanh4NnU2NGlIdXB6a3p4OTBVODg0L3VtbmtIdFZDdTdROTN1OExoSHJaNlFhT0FkQkxuanp4UzdKNjhCcDI5UFhsM0ZSS0Vya2VlMTg0WG9NNjRJYkhQWE12VDJsWWY2MnRJak5kaW4wUG5TS3NoTWplMGdNM3JNQ3Q3dGtFamkzUVp5NzB6Mis5eGtBZllEMFdNajZ2OStOQ0hpbGlyaUVPWjlLY1F0b3ZyMmdIZGRpaFRzRzVpUTMwL2h0OWJxdmZRZnZiYkg3dTJXZXRBT2dBTTRmNnVnMyswbUhlQ0VqTGdYSWsxS0NQS0ZzMUNRUmdkb3VFY04yUkhPamZFb0hNWnhNK1drVE9wY1c0UlVkS09iSCtvTGd3eUVZT0FBV0dSQTJEY3pvRkFzNHJGclBnSkd3d3pYOUM4MkxBVkE2d1FaZmhzQ0NHbXByZm1abkVSR09mazR6bkk3UmEyWmNyMEcyOElDNUE3T0lPMDAraFNndU1FZXg4OHNDRElSa04vQ1pGMlE2QURsYVFoaG00TStoTU9TN0lCT3dCbytGUUVyS2tLekd5NE9MNG91VXc3V0FZU3ZETUJ5aVVYS09BeG1uRjhFckVuN0ZnbCtMdkRMYzRZRDNQVG5WYUNsOEVxODNzQTNneExqSlN5LzlUemo2WEZ1ZXpyTnYwQXN2RTVxNFRseDRmQmtDdnpibWdUUVB5NVplWURBbDdpODlBMDlqVk01dVhnYU1tbzlSOVYvYndRdTNLcURWb3RXejUxZVVXU2ZLa2NUNUxHR1l2UVd6TnEzVE5XNVhnUEwzV3lJK2tFSk5NU1lDN3d1VUJrWHloMkYzaExUUFNEQWdHMHJ1b1FiSWEwSUxqdVVuRDkyZWVEc0hnUlRCVXo1cmpnTXkrZWQ2MkxMZWxkNDdvRFNYRUJWVjZxd04xcGJOZjZXYm52TDZOemEvRWFkMm9lcDBYc05XWGxDU2JnVGdoeTNBWmo2Q2x2RnR2c2N4RlcrWENXNGluQzIrdHdrY0xpdUxHOUd0ak54Ymtha1duWTN1UTA0QVcrWkEyUXJZRXJNdC82Z3JlMEFodHpiZ1d4Ty85U0xhRHVNN3hiVnlGYmYza08zMDE0RHRtNExPQ0dpQWNSODJEdThMczYxbkF2UVlnSEVlM2R2QVpOTXNla0YwNzR6dDgwUWdocnRrdERDRGtzc1F6SUFnQmUvbU5QQnIzOTBPOThOenBXa0JOeWxtNXJJSWV3WGh2TzNoTHpRTmE0TE5rQWdQV2lyYUZlNDRCZnUzZzk3cUhwUEdFdDNnQ0FyOXJjSEI1dmZmdnFWLzcyYllCOEFOZ1c0ak81QWxkLzNJdmdCUk5EdElFeWtyQ09hdDhIbXBWZDM1bEpmOE1JUGxwMGhOQjd1dVllUDM4SDI5NGg1UDJIeFVQNjVKTkR5Q3c4SWZYZ0M4WER6TnAzSmJ2QmdSbTJFNkFmdWJrZlJOYTdXajZTM3VZZ2ZwcjVBY2RheDk3ZEQ1dnV5RFZBS2tudmpBZ21FQUF4ajRxQitBYnVpQitidWZRWjlTUWFmbkc0SHF6N3A1WHJzQWRFbGFKSEhlRlZpaDJzSzNyOGxMU1FjKzNCdVhPbjdpZ3FnNCtZbEROa2J6Vmx1NkMrV3ZNaWpsMU1BUGk4KzBrUXNVbi8xS3JHYzNFQjVYTVlBZktZRkNBcGZTM0FIKytNNW8rc1VrcHFIUUl1RU1QdUp5ZUczZ1h2TEdsT2MraGVvUFo3bUQ1RjZaZlJlK2o5WCtMMXREN0xiQjh2OEFTRVRPNksrMlJNUUVnVnl5VkZ5OU1VQ3ZlSHkzTVY2eERqbjkzMTd6MU01MUlRenVKakthUUwvRjBTSWhmYlhwN2wvQnRmYnhSZmdBTVhyYjZ1SHVZOWVrdlUzZ2I2bDlIY1pmNXZXWGk3eUhINitRakN2K0h1YjZOOUs4Y3R5dm5xRzRWVjdXL3hINkU2YjZhNGhtN2RMV0xMZTNvYm0xN2VESGUraklQN3IzbEV1L1BlYnZ3M3pMK041eTlQZnB2YVg5N3d0N0svL1VLdm9IUDd6Q2RxL21lemduV0h0NkYvQy81a29mSFgxdzZUOHlJZE5FdmZYbEwwTjdlOGplSkE4TlBIOEFEc0RMYnF2eEhqYitaOG1Db3pHdmU5Q3ZLbXRxRVRBN2VnUDY1MEYrbEJDL3lmSXZ2dDJMNXVTeStDazVucGwrQ0M5bzdmYzNHRkxDdklxazNBTDcyc1oyMCs2RjVEZ3lKT2RBVjNDdUJGaTlQM1E0UmpnUWpuMEFZWVFKTE1UWDlxMjVoamVLSWVyS1grbWZWOWUwcEp3djNONmlqa1VhZ0pkdU1RTUliNk12QkxNcll0Z0puS0ZlQVcrMnFYakVkd0I1b2NqZkpRMXZ5bzRxcXF4M0IyQUR2cDM3Nzh1SnUvZk1OcEhhSnJEbndDK3BnamtMWDFnZzFSQUpvUGMzYkwrWnFPOHhmWndqa080S205QUpVTEEzOUVQSEFNWVRjMGNxRmtpN1pFcjVjVE1Cb1hOd3hFRHUxZFJjaFFPMCtMdUNORmxRalIxam14aTlIc2RxdVhRbWlTdnZNRno0aUJUVEhFUjRZNENKWmxydEVsNXdBQmFVcjVZQkhBZDAySFI3QWpiWUo3a3gxNklZQ2RFeEhrcUI5VHkwRGdJM2xBNnhsUDQvMzRuMEQ3OHgra0ZFR3I4YW1OcUNWOGdBdHNFQzhkb2NnQkFEeUJKYUhBRDNPVlh3QUNndkZ3RmdDZkFMZHgzY04wZVVEaU1Fa2NJa0cxbS9Qb3krQXB3UU55VGROcVFTQVM5cCtDVTFqOExBVjREazBKTGVOMFNWVEFFZUZnOFAzYWdJazVzY1JUVlRkUUFIaUg1b3VQS2dMTjlhQXFqM3pzdUFuaUFENXZ2Y2hHM2R3RFR0RUsxSHZPalZhSW1LT2pTeEJuT1p6U1Y5NW9ZQUZVQ25JVDFBcUpsQXJFQnpGOS9RWHkwQ2xBMmVIa0RTZ2NBSWw4aGNiUU9NRHNRQkUxY1lkMFhmQ2dEWUFNbnpCOUVlT2JuUUJwaEZjRUpzcklQQ0FxZEt1RHAwSDVkOVNrbjMweCtDZmxNSndITjNrZm9FWVU5VlgxTHphTlZsMGZxWGttSDRvbUtxQVAweDFjbG5uZ1Q5VURrU0NiRU9yeFJBODROQU9QY1d2SjNpYjkydkdIMWNNbVhEempBQWFRV1JCWjl5M0I2bWFJc1FHVFFaOGx2SFBsOEJGU01hMUNBbUVReFFmbGtxUUx3bUFHdmVYMEQ5NklTbnp5QjhBa29KaTgrZzl2MjZOMGxMdnltQ2UvTWdOR0U4WU52MHlCR0lhSnkzQm5BS2tHeUZsZ3NlU3hCY1ZHTkRuZ2dERG9GdzBzUUVMUVlnWlZDSUREd2lmRk5BT0NMQW93Tk9DaVpDNEpxOFUwSTNXUUMrZzZ2QUdDYS9KcEFoOUJtVVlPaDl4Z2lZQ3Y4R0F0SlRJQmUvYnYwSDlCSVJ2MTVBbGdoVkVZZ2FsWGdLZ2hVQURZSlJRWVFuWUxCcEZ2VC93V2w0QUFueUFRLy9mbnhlQ3gvYmpBRDlnbUtSRGlSQXZGUUJVQXMzZDRQbFJtdmZid2k4bWNBZ05jTXlRdzJnNzlmZ0lmd29EMkFLRVBDdzBmQktDUmhYK2JaQWx3bEF4UU94QUc1ZDZSV2tqZzdFQTU4RDNZQURYeDZJSEVPOTlPM1BPQldaOGcwWDMzOEZRdUFWSkMra1kySHlDd3ZRb1BFMDlmV3NqQjBEdllvTitDK2pIYW1OaEpnajQzU1Y1Z2lVS1c4UnZRYzNzZ1pReTRMbERwck5RR1lBdFE2a01oODZRc1lKTkNsQUJ2RUJEK09NRVBPOHBRRFVONWdmQVpLZ1dEWmlDcnhvMExFUStHYzF5RUdWVTZ4WlExWU01OUJReVdnNkM4QU93RUZDS0FHVlFKREV3c1FLZ2hsQWIraWFRemczNEJxVjVlTllJTEMxOElzUHVEdGdwRDA0VnZ2VDBRbjkzNGZkQWJrQUVmZEZXOUhRMGtPWUFuQWw1elk5Ni9GRFNhREdYWTBJWkNmUTgwUDc5TFExa0x4Z0N3dHpCckNwa052VXF0bTJRYXpINTlBUi8yVW9KL1FhekIwMFFqb0djNVovZHNNZUNuUWowMVlCTGtTa01TRnpQV1h5VkRGZkZVTHVna0E2WHdSdzdvT1gyY0RkdllZSUhENlErL1VPQjIrZUh4bzBuM1RFRlNRV2lBQ3o1VnJRei8yNEplZmRiMzNDSGFOOE5EQlhjSThJZkRBL0o4SitDYWZWOEx2Q0dwWVhVRERQd25LM1JCV2lTMm4vRE53c21nZEM5dzBrUEFqUk9LQ0o3RHdmV0NPcDlTZ2hDUGI1Q0lqOEt4QVFnTkNOL0RhM1g4SUFpS3ZYY0w1OVFJektBV3RqdzlBTUtDZGlPQ1BJaUhhWlFIcDk1YURvRTB0Z0lnSHphRG4zUEtEWFVSMUlXeTA5cWxlUUlZOWtBejRHOWxOQUgwSlhBOWdjOEtIeHVOQjFFSUJpekgzRDFoVkpXc0I0MGtjVUNLVWpkUUk0QklBU0FSQmtKRFFBdEtpMGpQUFhTTDQxTEFBeUo0MXBzUVJReUZ6UERZTGRDdmdnZmw0aVl2UkVMOUR4dzhnTVdDa3ZjTkJxVnlnT2NQNnNMMFJjTkFCbHc4QURNQzdlWlNnekNnbkNNS0Z4TWdsaUpBakF2VjRDTkF2SWpBUEFOV3ZUMEtIRFFDTEtLWkNwZ3BOeG1DTFE0RVBtRHVrSEFKZVFMTUNFS3ZjMkF3UVBrMUEzUmlCNENXQS9nTGo4T0FnbkJhanVBcTVDRENqWUVNTS9oa3FZc0puQ3l3bU1GdndXR1UwSkRDMThZYU9yQ3NnR3BWbFFVb2hzSllaZXZPaENSOTJBU0FHWUE0UURhSVBnV0tjL24zMEtaSnJIQU4vYklTSXRoaWdDZndSOWdBZmRDUjltQVNBRllzWVFXNklQaG1BZUxWK2NaVkVRQ09qNFRZT3kyaGJBejRuNkJrcVNRTStqWDRHVld3Qk1pQ1F5emg5QVRZSVJvMi9PUGlCamJnSGdFeUo3Q0E2TlNCTWljckhJZ0lZbGhsc0N2UVdHTXdBRVlyTU51Qi9FVElqQk5ORFMxMHB3eXNQR0xxQVN3dWt6U2dXek5rQitqNnc4NlBpaktjYlFLbUFSMUJ1UWsxMHZLSUN1Q0RvdjhRK2pzRmNtTjhSUVlzckdlRHBmYkhrczlPSXpJRklpQ28rQ0tObzIvQUtNcWlKdzhaMFJCaTRjTVBFRDBvc1NJWHd4ckNid3NENUE2TTBoQ1FvOExHYzFFQU9kUXFKQzRDMkNTaTUxRXFFblZjTmVTTEdGelBQTUEwajRBL2YyMzlkZWN6MDBBaVlLdEdzaXcwZDBQOHRTTktXTDRpM1l5TUVHVTVZZ01LS3N3b3RaeXFnUWdZdUdTQ2x3M29GVjBwU0tsbHg5SlErVWx3aldJcGlNUkkxWS8vMmw4Y1VlZ0Q3SVlBejJNSlZMb3RQeDZzWWdxNkhEaWR6WXRoL1JXMmY0QlJOMGZKLzJzQ2hZTWF4U1lsR2Qvek05a0EwZjJ4ZDg0d1dCSDhNMWE4UFROam9hamh5aVd2SHlMSWlZdmZ1TTUxZzRsa0tDaklnRkVWbkNJNGk5R1hDeCtkRUhuaGFOYzluamprbzc3eUFqWlF3THpIalVBQ1lDUUI3dzRpS2E5dkkvc044aStqSGVMM2lvWVVjTVlDUTQvSUduaTRnN1pIbkNvby9ZMlVvVjR3L2l4Sm1BbVhHd2lWdkZPSXlqelBQWUNyOU80N1VKcEM5VkVlTFBqWlk1a0txajhnYnVMSDlpUUVnRkE1c09LWkNWOURnWVVIVUQ5L2RnSEZWcUlBY2lUQzJRVTd4WVlqZ0tFTzRJUm85b2hBSTh3dGtId1Q5WXZHSUZpMDVTY0ltQXBRa1hBT2pKaVQxenJENlFjaEt1aTY0QTZQZWpRSTBlaUlpWTNVUjAwaVRnSXlOdGdISW1nSDBpZ1VXc0Q1RWhRUytOQWllZ0p6M0ZqdzBQdDJxQ1p2TWR6cUMwL2UwQXRRc3FaQVBXQVZBTHlOcmhjb3Z5MkQ5cDRWZU51NWI2UDJKaTh0RXErS0JETy9kd3pIQ2UvY3FMSERpbEtxSnFBYW9zVkQ2aStBMDMwNmpiZ1pxS21DRzRIaURHajMzRHFKb0N1bzV0RURjZkV2Y2xnOE9Rc29DSVRYYVhXSmNBL295SlB1Q0FZOE8wNTlDdE93R1lBd29tVlVZVFJJaHR5K2lSUE52MUV0NGt6aEwyQ1lZNzd4L05qZ2xRQXFKY1ZlSkpCaXNrcTRKU2pTa3pFR1pNS2sraUdYQzRZaDROWWpoWTlNeTBTM2c2Q0krREtLUFJKMTlwdU9LQmZ0OGdZeE8xUlQ0MXd5NlNMRS8wSkJEWmdxeEw3OUVsQnhLSDg0UXRrSE1TM01JQkZ1QXVrM21MVGlwUTM4TXNDQlZjNHlYbDdiTUtKcVRRSXFDUXNCdXczaE4yOGhnblVOMThRL2NOWFBOT1BRN3k5RFhETTVJbWlKNHEwSVhkbTNPS1AzODFBejVOQk1UUFZvTllJMlBkekYwWWdkS3BVMHNNOFV1aDhvaE5SRTFvVU43YW1PNUJLaVI3QjBONDBKcWs0QWJ6SnFrWDhUbytsRGdVT1NZcHlTQ1ZBWnRoVUJuemF1UFJBVkFCT0xFUmFTYkxHYUp5VWtLMmJBYWxBQkhwVFdpQi8zcFNkZ3pRRkxDeDFkbExaVGZ3LzIyNUozL2NvSFlCUU9mYUNUUVJMRzRXWUFaYUc0VG9RRzVQWUJ1RUZBQ1ZJYmhRQUc0VXhDdlFJMkkzSlJhYm4wRVV4aFYvalRqUDREZ2c3RHpQQk1BdVNjM0lrTWRpMDFRMU43ak8zUTFJcGpPNDVVTE5TdXd1b0F0VHByQXFBSGpBRTcyT0hqVEV2bzJkVHg0aUJJbkRrUk9JTG5qbzQzWUVsd2dnWVpMWGkwNHplUDFUa0FyMU4zajk0d2VKZngzVXA1TUtqYmdhTkl2aU9nZDVOOVNaNDhLSWZqSW9tcXlEVFZzRU5OWGo4MUtaRS9qRTRwYjIvaVRremIzSngrc09STStEcDhZWUloREJ3NldNY2dWQVRWamxqNWt0SlVvQVdva09PV1M2QUNKSmFUemc2ZjF5U1FvNXBKbFVxRWhibkxEYUVuUFhpVEdFNVhuQ1NCOFdNalFvM29waEpzQURLUGNpRWg2dk5oTGo0V2trR080REswblczemoyU0ZEVGNDd2dtWVZDcHZBdXRoWHMvQXVCUUNEUitGeW5iWjNBamdFZnBobFRWVk1DZmtweUFtRWVoTVgxOEJOdkVkQ0RrM1Fzd0NVTVgwVnRKOURFTVRRQ1dCVWt5Q0lJNDhqYlZnVUFGQU40REc4Y1VZNWhZcEhBVUNMSWt4WEpsM0hWVk5HdExNQS9rbmNrY0J6UEpRQnhRNDBqME1UU20wbkZDbVRBb3dNTGNUR29xaTJXUXVRN2NHREM0ZVdhSUhUWVFyYUZ3UzBLUzJnUGhUUEdwUU9peDAwaE9Bd0RDTW1rQnN1TThvbDBDR0V6SWo4VGVRQ3NJMVFsMDJkSWRBQ3dvc0NyQ2QwazZKejVyUTNyeUxvYnRWbXpoSW1YVGRMeGo0WW1zSVJOUC9MMEIvaUFmVGIyQUNEMG4yT1BUQU9VOUwyaHowcmZWOERmbmE5TDVKYjBrSU5kQVQwandLZlNIM0EveWlvOUF0TldhZ1AwNmJDL1MwM2FYMmFoMnNMREo2U2JJcUhqc2loRXRhejR4SEkxQUFNaTdFYVRGd2ROOFpBSjlDT0lpTEs5aXZndzBJOXdYd3k1VzA1MDB4N0d3amJRdXVJempjUWtMT1FsMUltMUw3Y2Z3UVJKMGpZc3ZTS2NpeEU2VmpValVzbThPRmMwQXN3RUM4aFhFckIwVHNzM1VMdVNheU1Qd0VoWnplSU9lZ3JMU1ZYM1pkQURySWg5N1FaUDN3OERNV05VM0pkUVRRSGtnUnROZzNxQzJpQzdTdTEvNk9pT0JvMHZSYk0yemxzOURNc0IxcyswSE1nYUZhdTNMd0ZFaW9pU0Y0NkVUdy9jZXN0Z0Q0aGsxSHBHNWhHZ2E0aUo0WkdjZERJNG9LTlNMUDV4MGRnRE9kR0FXa2pQNTdOYmJJY3oyQkxHVEZRQkxLOXlleTY0K1FDZVp1UVh6SGdBWDJjaFRPQjVWSXNFOThSdWVTQTZ3V0tOK0R6OE9BVmVBN2h3UVVVQlhnR1lVbkxlQWppRkxIMEFiaGNBQzNOM1lMdUFoekwwcGlobE4rbEhrbUp3cGc0a0VHNDRwQmt4NUo3UVI2R0kwSHNpVTNoeStJZnRRanh6UEZiSWxkWFU5anh1VEJrd2JOdTF3L1BDRzdKSnNrN0hGY1pzb0QxR3k4MWViTnFDaGNjeUV0d1ZzdGJQOVFBVW5DQkhWL3lKZTB1MEhNanlIeTByRUNvaVVURHNrYjJPelZzMDdPTnpBUURiTm9CTHN1aFRTRXlJVzdKMkFscVlYTUVzeFhmbHhlelFHTjdLckFQc20vQnVJd0RTRXdaaGZzdTVIMkFBYzU5R0J6UWN1bEhCeUxjbmJLaHp1QkdISUR5cGM0VjJWUko4SkhQdEFVY3RIS2dsZ2xRdUN4elMvSEhNc0E4Y2lsRno5UlFEREJZcDVTU25QSnlSRXNuT3B6cjBPbklaeTVlY0FHWnlHMkx6elp5K01EbkphajFPWG5QWnpmL1FYSllZNGNvUEx6enVJY1hJVHhKYzNRR285cXM0a0lEeWFNand5Qk12R0c3WFFBdHpVb0dBQStjbmZOUzBDVk84QTFBa1NOWDJyekFVQStNdVRyczFmS3F4U1RYOUxBemdBWlkzUHlJUUZpZ0FGU2dCY242UmZmU2ZOWURYQUdzQlpCUUl3M0t4MFpjNkQzUklsRXZqaWR5amN4ZzFzdFNNdmlNQUtWVkgxS0NqUC9YZkJQMElDbDNLNm8zbUExTnhReElVQ0FzekF2TTREbEFiUUkyQ3NqT0lyckpKOENjQ3pNQjVhczNqUkVUTEFBVFVIUTJzOU0zR1E4NEJZaUlMT3N3TUhNOUdBQ0dQVGw2QW1YT3VUNDBsRFFvREcwdmlNNExPOElhQW96Z1F1eE1TVTVnb2Z4MVFycVFCSDVvbnFLNUIrb0t0VnZBQVFZNHFVTGZwZ0tiYUxldytPYjcxcEpzUXgwTFRpMThQVkx3aU9Dcmd2akJ5Q210Tmx6K0N0ZlJHRFFFMXd4RUtLd0FxSEVLNWswRU1uaUZnamMzMzBPNEJRcGN0MFUxelNDQlZDcXVONkFKYVpvbjdodENrUDEwTE9mZlFwTUxVNDdDT01LSzBqZ3NzTE1zamhVQ0FML1EveGRqa0EwVUhLQ2pVeUQyUGpiQzU4T2VTSENZWUNEaUVDbENOMER5Z1p3VWpqbkJJSXM5Uk5DNE4yd2prNGs1TFRqTXFCSXN5S0FFcXdzbGlZQ21MMXNEQ3M4NzNIeFRvaVFObERPME1VTWU5clk3RUYxajJRaWhNb0JuTmZrSWZsbHZCb0F0aVl3SzJOL0NkZ0hjTnRqTWl1d21Jejhvcm9yNk5EZ0ZqRjZLMDQ1YUpLeVhzMERsS3lUTXpPUFROa0V4eG1YelRVcHhDdUxOV0RJdWw4b1lDa09TS0pZbHIxSlN0WTB3R1BZMHZFaktORHBZNTR1QUIvb1R3UnBCWlVUMFEyYzRnQnVRaUFoYkVIMWY0UjFBUUdicGk5ZXdvY0lkTWc0c2VTTW9Sak5EQ0lmTU9KU2lOQWpIR254OW80c0pPVHNFc3ROVUNVUU1tZ0pLRWszTU8raTIvVCtDckNaMDBzT3BLQjhTc0x4ak9FaGFJc1E0b0NlRTlGNHRPS0hZQTB3c0VzOUZJUzh2Ty84TG5iSmsvODQrQTZPcVN0NHRYMUNWZUN2YjBTVEJtZWpLRUtZdk1TV0lEU28xd3FtQ0pDNnhLa0x1MGhqR00xY0ExeE12ZFdBZ1FMb0NNd0FLTkNUSk1ocU9OTGswN3FPOFRlb3hhT295clMzNHpOTGVvclRNbENXZy90TjVpY2s3NzNkTFIwejByQmpPZkgwc09qRWtzckZPakF5OTZPRExBUFl6VkNCSkxXZDJiZElnZFNVNEpWUUxyQUwwbG9mMUhNUUlnVmVMMkFlVWhpM1M5SUxMRUVnQWZ6Vm9rK2h5azU5dzdndVVoZUZ4SzEwQmxKV0x1a1VrdTRBMGszUUxTU1RBZ2dCTEtGNEE2SExMdmt2ekxKS0d5M3hKcktvRXQ5SXh4Q3RZc0JXTFNnRm1Ja2oxeVZzcllJZVVzY29YZ1dZNWxJN0wyVStTSVl0V3l6NkVLMUlBY3NvTXdPeW9jcG5MT3lweEdhZ0VCRTJQQ3cwNUNva3RvWDdTY29PZ3N5NTkzTExWY1dyUjdLeXNNYTJUS1NnZGNoN0tnZ0RjcHJJT3l1OHAzSzZ5Zzh1T0NqeTRjdnpMREVtc2tuS080UzhyV3dhbExjcHFVZHk0Z0ZIUUU2VW9GZUJOTTJyU0xnWnlpZjNMS2tvNWFUaWhXeS8yaWpDZXlsbTF2THRBOC9sZzBweW0zTkFyTGFRclZ3cm4zSHJTZkxTZ1ZXelB5R1VhdE5lS0s4S2d2c2lHcytMSU1pTHdPaW9sQWNnalh3ZGl4RUpYeS96SGluMzNNenhZMjFLY1J5Z3gxS1k5MmkxNHFBVEQwL0l2R1RRQ1NZcGNMM0MzZFZuaUVnd05JZlVsNDJzTElnTjR0S1BPTHlzbjN3d1RTc1lTb3ZDMDFkQk9vZ0JLenQzV0NrWUxZb0g0cGVPU280RUVRbmtONkxpU2hTc3lCTU5kRk9Wb2ZxUGVBdlFFYmRmMXlCWlVWK3dNb2VJVytQdHNzd3hpRmMweDFCUUZsU1c0Nzd6NHFES3RkRXlEUmhWb3VsOWlUWjBENnk2MDdpUE5ZN0t2TERtd0FveFpNRWdhZ0k0dTBEK3RZNEdvNE9JSi9qTnorTW5lSzFaa1FocE9LcnpJdkIzS3FxWTB0TS85TVFvc0YvOUkwNUtvRWpnQ29lSlBpa1NqZ1FMQ25LbVhSVXJtMkJlT0ExNDQ4TkxLelFJdkxFSlFMQWE0bzZMQURUQUp5eWxTenIwb3dFMldhdGJTU0E5VW9xaWI0M1VzMEI5UytxS05LUEVyeEl0RFdvNGtzdEtQRXpnSzV6ZW8valBPckFrb1FMd3dlbzN4UEFBYUFRRVJ1Q0g1ZTJ6a3pGaStBMWlTcXc4NE1TU2FsVjBxVzl4VThVdDlMZ3lxa3lXS1JMSGxOQXFtZ1VDcjFKNklsUUZDQkt5MEN1RHR3WVVDdXBTVW9oR3hCcWd5bmR4RExKSXBtUG5LSzJOclYvQ2dnRlpHL0xyeXFZSEJoeXk5MkNKakpRMmFQREtkM1R0SDlSTllpR3Facm1VcG1vYUR0M1dyVUlyMmF6RUcyaWFORlpDaUFjeW5LMEswZ2dCR3ZqS2VhdUlTV2prMGVqVkFxdEFIak9CalBTZ2FIVmQvVVBUSktVNnZjaEsxRGhndDkxeXpDaWpnUTFySE05RUdtSXZxbWdFR2M0UkUyTUdJUjVIa0ZOclpnWDhOSE5mdzQydXRyOWt1MnAyQ3Jhb1p4dHJwaU5PSjU4cFM1QUtsZHVxL2J3R3pKTldzbkQ4dnRYNkhncVFRRDFMS0RGa1gybERxdUFUcDFZREZrZTZFN1pJaS94TjVBRTZ2dFZqTnRnT09xb0MwNnlmbU5zRUJkVG1Lb0xsTXgyNEVaMkg4SGlsUHRWZkp6cUY0R0lxSzlCZ0xXMU9Jb2dPdXAyZzlyT0JRNjBMbElYVFZCajRUZldRQnk2N3FHOEltNjc0QmJyZkVFclR3eG50YmdST0lKRGJwRExxOTh4VmpGTWN6Q1UxMGgrNi90UmJxRWdSYndhaXE2NmVBWWhBdmR6aDRxSUlKWDBRRHpLdGQwRTEvMDlndVFDUTVZMUhVQTJDN2VwNFRqVStWSDZTNEFBT3E2SjBBTmVIUGM3SzJKSUNqU0FvZjF4aG5FaXpBb0RicTlnTThUNkE3djE2aURxZ0pJQWJMcWkwTW9BMm8xZk1kTHFQWUJ0RUM0RmJVa2U4ckEvK2hqQ2xBc1VPQ2tCeXd3SWFTeFEzelBGOUl3b3dKckxHWXNVSmxvUnk2NE1VekVrN2VxWmMrczRZTUVLOHN5TjBVckpDanRKRGlJUXFhS1l5N2c2eFdxQlRvNGhyTnlpNFg4VGFTUUlnMHZtTWxnekR4cExVS0loSnRaZlNtc05PTFJHcEwxa2E2RWd1QXlUTWlTUnR1QldTcHFxKzlra2d3dE1Ma0F6U0gwQXkrRStzQzlZQUczQ3Frakt3eG8xcS9hMzRwMXFrMG94dkFTTlNuYXBnYTQvV2pLakFJUXBBb3FUTXc3bUlFYUFmWnlyRWFxd3FoSXFJWkdxQ0RiOXA4T2tzcGpOSzBVbzZCcFFwZEtTcjB6Y3lNc2pkUUpZRXZCendvb2lZcVlzbmt4Q3A1SUF5SWtTUXdZQUJHaGNtc2hHd1Vhd09ySjVnbXN3eU8wakJGU1lqc0J1aVVSTktiWEl3dUNxQlV0TUFTKzBVbXFwcEtia3lTTUJxeEx3UHloR2dSQUlKeWhLa0U1ZUJBQkovU2dGQTVVZ0hnQkVBZGhPd0VtSlRZaW5KS2FYSXNBRHFiUUFCcHFYa3dCUUwzTWI1cW13cExpQ2lwTk5ZVEJxK2h3aWlnckorTjhxU0tJMW1Ba0c0RzRRK3RldFNKUGZqSlU2S3M1OTlBSGNOMHJRSW80QnlsQUUrK3FLQ3JHNldPZWJWU2kwTS9yQkliK3IxTGFvb3F3ZEtqcW9CdG1DUUc5cVBjUzdxaUJwc1Rlb250UC9yQkFwMHZnYWhHM3BBa3RTcWpna1V0Sk02Tk8vcGsyZnlwU1NQcWxzTzBDZXk5ZU01OEd3dXdEajRvUGNBMEM4RW1tVXFNcitFNUFEcXprR0hreG9LRXNzUkxhYXBnRHBxUUJOOEFld0lWZTJITmdrWWNFTWV5YTVjVUxRVmE0OXRRRUJUaEZ1WTdWVDFyVmM3WFR5SE10ZXp1MUIyQjdUU2dkN045VnVNSjJCQnp0Z3Z0VSswNlF6d05WeXZzd1VyWUZ2c3dkQ0hUMXc3MFdnUWlFeXFWZ0RoMFQyU0lTUjA3MmRqQi9zb0hDcVN4MUU0SEhYNFE4ZFVCenVBaWROM2wvdHlkV0IzZzU0SFpEandCYWRaQndaMDBIQWpnd2RpT05uVW81Y0hFU253Y2g4UGxvRTVpSEhzZ0YwNUVEdXIzc1Y5YWh6cURwMk0xbm9jRE9SaHhpeEZkWHh3K3AySE10aHNRdUhQaHg0ZE5kUGh6MTE4ekEzVUxobmcyK3FpZ3pkU1IxdGpLK1czVlI1MENCM1VVY3JPRlIwUHcxSEwzVm41UytTbm1wNUE5WVBRWjRDNk1QVElBV2VTUFRMUXpIV1BVUzRFOVhuazhjVHRieHlGNE05UngyS05yelpXaFRMdk1GaW5jY1M5S1Zyc2RCeWNnRmVkL0hHdlNDY0ErUktqQ2RtMnpIQ2ljWHVTUnppZFBNYnZYRmJ2dUJtSDcxeFd3ZlJzQmg5UG9uU2NKOUxKd0NvazJzd0ZuMWU5Zkp4WDFsOU1YVktkMTlLZW92U0cySGZXcWN4K1EvUVhnNm5KYUZQMHpXZEFBYmtxNFp1VTNsOTVidVQzbHQ1UStSSGt4NUNlUkhscDVXZVNua0o1VWVVWGtDZmIwajBRTjViRHBibFBPTGVVN2svSVpqcUhrZTVQdVczbGlPOGVWUUE3QVR6aFFCUE9lZ0ZtQTRnVHpnVUIwT1ZJRkU2RkFZbVdLQitPNlR1S0JaZ01UdUpsUXhKVHJpQUFrVlR0OFF0RVZUdXdBdE9oUUhNbGlnTVRxMFFMZ0xSQzBReU9tZVh1d0o1VHpoR0FSNVhqdjQ3Qk80VHFrNkpPcVRwazZlNVZUcmlCRk8rVHBVN1BPL3hBMDdkTzRtUjA2eE8vVHFrNmpPa3p1STZhT2xlVzlJdmJacHdGeC9ROXpEYWNYNEJFM1dENmNxY2dSRG1jUFhDNDF4SFQ0MVBJWEROR0ZnekFEQjBGY0JHRExjQ0ZCVUFLVTNRQUhERXJySzZMTUFFMnBOaHVXWnp4OEF3SU1EV0NFNnNReldDQkEyT3BBdDJzTXJ2YUZtQWVnRkpNRUdWVURZeUJ1LzFEazRNY1JWVmNBRVRlSE5hNzZRWFBKS3hnRmQveXVkMHpNaVJXWjZLdytKendjTTRycTY3MnNIcnI2N0hJVFlHNXlmOUIwQUVEbGhEcDAremxvU3J1MjdSdS9ydjI3QXZYUkVNcmtpamJwbTZ0dW5oUW9VcHEvUkJNYUdLaCt0dVRCM09vSVRvNXNxeEMzQUpiR0sxZnJPdTBydTI2TTYwRmttaGd6TFZnNmQrdExGbGU3QXZJSHZ1NjF1akNCa3FTNHBJZ3hOTnVzSHRvQWtlMkt5d3BETTl2aUhBR3VoNkV1Q280WW5ycFZ4Yk4wbWlzUktIUGxPVDRlNUhxdnoxSU9kRCtvMlFDN3NwSU4xVG9tRk5jTTEzTjJFSXc5ZEJ5eWVQSHBuM1VySU45RmpML2swYlVtdDB6RXkxZFNCazBOUUxaUzJVWkpBU3NlN3JvTnlUczFBRk0wbFlIN3BZWTJlc2F5VVM3dlViMWZndUFYMkZRTDFlbE5Gbk5RZXNydFl5YkxLL0R3b3gxY2dCdUVkOGlnQUhkOUFPRUcvVnkyVGdHVXBoOHBEVEEwa1FPV2hXd3lnQjIxMWpFb0tVMk80NkVicldIVUxySHlGYUk5U1N0TTJBUnUzcnFTYWRpQ2dHKzFhQVQ1MTFidFFiNTNoRDYwYnBCY1NkVUVTZ0JkVUFJRjNqWlFYZnNnNkI4SFNGM0tNYmdZd3pXNWF5TTBITU5FWFpHU3hjMVFaV0UyNXF3VTduUFl4MUIybHNGZTZXYlFDajdhSEZscVJmMGQzSFdEUmVRTjN0cDJoUWlEWFFoKzNrQVJDRjVHQUx6NWtqYm9BTmRVblA5cUFZZTBXSlJoeTV1UXRBeE1Pa1NnMnB6ellIUGdadGQrKzZIN2dxTFdjQXB0Y2dlWG1QN2dLTS9xbUFmZXpkSEFCRCtxMkRXRGY4M0hPQW9KaTEvdXJ6Z0tFTEdQQktERy91eFE2VWtKUlFBKyswQWdINnRTdEpYaWtSZ1VrUm43bDJJT1N1ajcyYnppM2FVQVdWRTM2VU5iZnV5Wkdvb25zcU5qU3NJb0I2b0lIQWRpTVUvR3NnVUJPKzJTUkFIYmdBZnBvendCa1NudHBFQjVGTnlBWFFWQWRzTDBCMkdnb2g5K2pkQ2FJbERXQTJkQi9VVjREdDRYRGU0aG5WVCtsMUR6VTJ1eHhyNEg3b2NsTkFBOWpickc3N3lCeWdZRUNHUUc5MG9KcUJxQVZBSktDQmRXK0E2Qm4zbzNRSkRMSzJKeDNzdjBuOEZDREpBR0R3akk4SlNTSVZCd04zTnhhQ1lZQ1JRaFc3YlR6NHdXTnFEOWNjL0lmdUxCanV4L1Z1QVJKZENWOEcvQnFnbXFRa1FUTmxRQktDUm9HODRmQi93ZjhIUU9VRG1RQitRT0RNU0puT1dOR2N4QzBLVUplQndsT2hBaUhJaDN3ZHlyUUNjSWRzQXNoeUllaUhrQWFWbGVCWldGSWRtQmhrZTRHUUFZaGxFRWVRM1l2T0F5SDhoZ29iOEhWQjlnemo2UU1zb2I4cHZCOGdFeUhtaG9vYm9McXFZV2w2R0NoMVFiajV1aDRZYXlHaWh3VVgwQUxBUFFBK0Fkb05BSFlBSmh5SWRra0tJU2dlbjZLSVpZZjhIWkpjVXdVSHhCOXZrRXQ1Ni90UzJHV2g5dEpFb3ZRY1lhYUhtaDlDU0tHUmdRbk1vSkMwWC9vVFp4SVpBQ0Z3UFBPZnV1SFRoa0pOeUdlaHE0YytHaWhyTkFUQTk0djlCT0hmQjJTVnh5TDg5WWFtQmgrei91MlpRUjlDVmtsTVRYRmhvempOZUViUWxaSlJZR05nOWhtZ01kd0Jva2dEeUhQaDN3Y0hnOUVBZnRLQ0IreWdrMXBLQ0lYaWdCa0FhQURSR3ZoMHFKTG9TQU1iQmU3MWU5Z0FtNmZod2tmUWtCQUFrYTVIbG9XTTFKSEJEY2tjcEhxUnlBRnBINlJzRWU3NmtpWkVjVUdSS0Q0YjVISlJoSFRkMXNSODN6T1F3QUNVZlFsV2hwa1paSHhiWjAzZlFPUjdvWVZHZVIzNFlWR2s2TzZHbEhYaG9VZHhZS1JzZnhDSFJSOFViK0crUnJVYURvS2xEY245QTJSZzBmcEhqUno0Y2tWZFhhVkFyeFhCamdYY0hHb3ZISHBIS0NRSWQ3cFJRUFFGQ0g2UjRrWXRHY3VHa2NEQll4d0hzajlTUiswYVRISFI1b2JORzQ5WEZnVEd4UmpNWjlIVFhFTE9HNk9obVlFdnk3MjVucmlWb09xNkJxSXVCa2REb1E2eHZnYkZ6MHNGM29lcFNCdVFlWkQxaDRESHJHMFFGUWJPSDBsRFFhNkZjTlBrR2hHaGdjVDFUSk8rN1FlcTRPQ2lwWFBDbzdUemxRQUZ4dENWNnhrQUxjZ3NBOVFYRmdBQURNam1nQkJEQVFEVlY1VkFycFVCeGJQa0g5USswRTJPVGROeHhBZEhNeWdZUlZVVm1WSDZpS0lORlpnQmc4OUVhUUJVUXZXbStqemF1Z3hoUVdDekZSNkU0Z1BhNjQzRE5VNEpvQVJMWWxCbUQrZ3JxTzNLMDBId080RWg2cyt5WEZUOEdxYzBlemlhNElnRzVKdkNRYTIrRlJoTzhhWlZZRlRKd0VBR2xGWm56Z2duR1JTVGQxZy8xSEZSRWl3OTMwQjkwcXd2Y3c1dUNnTDFncmNTZEg0R2k3YkZFUkI5a2hGMXN5SVE2YURhby9jUGtIQmN6Y250SlltRndkZ0g5UmZFSVhHbjlkb0pJSXExRUFjS3JINDNRRVB1RGdkK2NUV1hUYkFaU2JjcEtDTmNiRTRaVktPVkJDVkJxa2NsQlA4U3BVZFI1SzFMcmxqOWswQW5nbVFrbWdFVVJNS1lQSEM1TWlkd3NDOStKdFNPcXB5eGlKeDlqNVFjaEY2cGQxRWlENUpIekl1SFVMYmdPNEZxZ2FXVDZBM05DNFpQb1RweTdKQmhwWTlVYVdnb0E0UUNUUmVoZUtlcnh0QWNtMDRJM0NLU1FMMDBCc1VYZXEwckVKaW5yVmNHQ3p0ekVtMkp4UHFwOEVhTkZqNjdsTk00RTlRM1lHWlh2SFlGUjhjeEpxd2RsU0NkQUpnd2N3VU9LVGh4Nm15RlpWV2J0cUZkTEN1eVRVaGhRc1VPY0N1eFdaSGtjYWNpeU53REpSYTRmdWkzQ0pjR2JSUEZZVnpQU3FmQkFKSmdXT3F5TjFaUHBHNHMwaXEyY2NPNGZQUTdoWlVlVW1YOGdwM1kxYll3cGhLYk9ORnM3a2xJQWJ0T3lqMk1UQXdmd2luSHBtRUJTMDdBVUFteHd2cDNtcGhCRncwQWpNcEFadUVCclUvcDI0QlVId1ptc2x6MDZFSWdDTW5ZWnE2TGxJMncyNEUzR0hwb0djYnc1U0x3enh3R2JVNDB4QmdRQ0lHVmhiRlZITUJCWDI1Z0dCQUZBRWh5NG5vKzR6TVkxdkNONmRhdFNnQ1RWYkhxeVdtWVhoNlpsU1pEaHZBMDZHNm5ZVSthZTRBODNUaFd2c1JpYm9UdjVZRTN1eG1uRWlWVUVGbVVpOGdGQTViNVVqc0xoS09McWZMOU1pdXFaK01Fd0RISnVLb3NrNEYwRndRVkRCMUhRd2F3RHpoN2lGeEZCUWhHTS9NcEE3ODBET2d5akt3RE96OThzdTJZZ3pWUUtESXN4aFVPREpYZ3l6UHhpUXprc2VoRzVhM1ZYZ0RTQW1nY0VhYWRTMnpqUlNiNHNnWVo4Y0t3WE1rWXJQZUg5bE40NVoydTIxSmFDd1RSSzZZZTZhYTJ4NUVGeGpGQXFKVnNEWWE5K2JnSGF3RlFjZTJGYXNrVkFUN05IcmF1ZW9ZRHVMZ3dUMFdZRC9IbWdnVUlVR2RCaGtSeVk0QmwrUG9EN0pTQ08vQnZZbEFkZ0FjUjZBVnVZOUk5Z0R1ZHFIWDIzT2ZMQXg1NDFEWUJpNXBGR1FadHV3VVRzSmlkVWVlZEFETUZUSFlpMnFQY2xvQVY1N2VaWEIxNTR2QmsxMnNHQVVSUTlnWURxMFZCV3ZFeEZicUJhZXpmYmJQVmR1bGFGN1hvRjd6M1dXcmtCQmJ0RGUxSlRIdERzREhyMVd0cUQwQmo3VEVoMWJ3Y0U0a1haT2xBMW8zWmpXcG9GTmJra2MxdWgxTFdzOWlHenpJSnZ0dllVZFIxdlIxblcvK3pkYkFIWEhXQWRFelZIUjlhWmhQMXBnZFlPUU51cDBVT0pCM3AxVUhQRGtqYWlPVm5WSTRjSFVxb1RhbG9JQmFJY2RnRWgxa1JGUWNoMUpWWHRLaHdsMVAwYVhYemFQcVF0dklCbUhKWFFNNHkyNHRrcmF6Z08wbDRjNUYvaDNyYkJIUnR1RWR2SjF0b3QxMjJtUnhSNDVITkhoN2JNZVB0cHM1VkhGbmcwY1IyN1J6SGEvT2ZSeEQwcDJveDFuYlRIT0hFWGI0OVJQVDU1ajI5ZHVGNWlNVFBTY2NkMjg2ZGt3RDJqNmc4YzU3TExoOGN6MnZ4elFBZWtIYml2YjY5VUp3a2M3Mmx2UUJ6SDIySncrcDRuQitkNzBQMnBKeS9hVW5WN2pTY3g5REowbjBCY2RoZHlkdnVjRHFYMTlmRmZXckhxMldEdnN5VjdCRG92UWdndHRpUDFQTXNSSFE2cDZURHF1aUNzUUVHT2hBUUFxRUJCZmpRRUhVMGNPVCtXL2xmNWYrWEJCdlNSSWczbDFDRndFQkF1azBJRUJCaW84bWFRQnlaMWFyWUIxcXdFQythQmxyK1duay81QmVYWUFiaEdlUUFWSkFqZVdnNU1EWHhBNldzRFNZa0JBQlRIcG9BVVpKYnZ0ZUJEYlRGVzhtaWc1UHFuSlhBSFBvQ2pJSmp6MzFIN0Nib2RVR0dZRGsyK1dmaHY1WVA5bkFiNVlyWThKdFJTYXBFaVJsVWhXUm9MelJoV0h4ajdKZkgvZ0dvREdKM3g5Z2gyQkUwZTIzV29HVFFudWlWWnpYRmZ1aDdiZXd4MlRkQW4xQ3FoTGc4QUdXVlo0SVlucmcwUWFZbEdFbFBIWk9aU0U2Q2Z2Q01kWFlpYWFVWmNUUlJSWGRTOUZiVThzVmlvaHhYK2xQRlpsY1pNSk9uM2k0ekRnSGZSRmtVbGIxTk9WcllHNVdYeHBRbFhSejFYTUhvQVB4eGlCaWlId2FKUmJSUWx0d050cWFWcmRWZEI5a3ZOVnJHVXUyYlVlSnFrTEppNzZWd0R4VGhRODZsQnNMcmNYVHV1ckFxUVNnM3V4QUcwMHR2MXlDKzZ1Q1VlQTdpWk82Wit5MWRKUjdvT2xUdTFvUEpna2ZxYUhGK3FBTnVjdVVzb0F0c051cnd3aUE4ZW9aQm1Sam9CTktxczYwdXJ3L1ZsL1NOWGVUQzFhM0pRMWg2QWpXV3ZSYnlJQ3VJb3pFRUFSNjRKUzBTMDE5MWN6V3ZWN05idjA4MWdOY0ZVZzF5aWF0V3cxbFNsMjhZK1NOYTE0QTYxc2IxeS91bmtGV1RvUXV1QzNkRTEydFkyU1ZBWnRDVHgwMWoxYXpXRk5YMWFkTDIxdG9rQXpVdTd0ZExXMlBmdGZMWEIxNzd1SFdudUJFMG1UbGd5ZGNJOGExNU5lQ1Zpb2h0WXpYUFZtL1J6V2xOYWozWFhDMTROZUxYcWtIZFpJajkxalJvU2dqUUZGQ25YTDEwNVVoVVZTMjlhWFhtMWxkZHpXMTF1bFk3WE4xa05ZL1h3MTNkYStERnZGVXFSQ0Uxd0RmdVZ0bGFhcldyamFCZGNiWDcxbmdzZlg3OVo5ZWcyTjFvdGUzV0VOcjlaZnhrTjVaWmNCcy9ONHVyV2sxb0RlMlV2bTBEYWJXSDExdGFnMkMxenRhM1dTMWlqWXA5djE1aExJVFN3S3RheUFVc1hibWlVaUp4cFVWWEJ5VEZVWmNaVnBRRWc4ekFQT3NGaHRsRTVmcGtSVnRrQk9YWGpUeEttQTlwa1kwSlhla1hUZkk4cEY0eUJlcUovSlEyVk5qZ3BRelZNR2d4all3MkxsSE0wWVNFeXo5ME0yVkFWMndjTkhONnJ0STJYTnh6ZU0ySTVoV0JucVVXak1CTmpyTjQ0QkMzNGNJRTFaakppT3pmZVZ6YkhNM2Vqbk4rRDBPR3NERVFHMDJybHJ6ZGZXa3RxNWI4M0VlTktEK2x6TjJnRkF0d3RvTGRBcUliQ3lEQzJyTmlMZlp0Yk5wSUViWEZOclJXNlFMNXlXRm00YmdRWUNxTUVRWEdBL3Q2ak5Va2FNeGtwVWpNdHRrWmNQbmppK0tVUE5YUDNURmJscENWNVNsZU0xOGNsZk0wK2ZFQXg1bjV0aEMyYXhSTlQrRlpYVlBLMmI5R0djWmZxeVcvMndZQk5jVXNNK2RzQllBUytZRmJOdENlekpVeFdpVnFmblR0RGpqbGFXY2hWdS9tanJYK2RmVXEwQUJhV2dxTUxWcFBzNGNUL25QdElGcitoOXhEV2tIVHZzNEZxRFVHeTM3TzFwZnRjRVcxcXRhUDdCMXUvc3NGa1AweDAzMkRpekVRZ0hFQndKMXZXOXpKSjFrZDZCd3AwS0ZoQnlvVzZkRkIwWjE2RnpCeGphT2RlTnJGSlJzWURwcTRQNTZzbTRXTTJ5aDBLZHMydUYyRVhaZEF0dDhXV0hFSmY4MkNORGh5aVpaRjJsR3JiZGREZHdiYW0yOVJldDBZbktSdzdhN2RlUnd4NHRtUXhjQzVqRjRubE1YeWVkem5NV0E5U3hZQzV5NU4zVTM1akhUM1RuYm85Y3gzaTQ0OUt4eVQxQWxsYm5zY1JlSkFhQWhuSERGTDNhbUhQeGNSNEFsMXhmbnRnbDg5ckNXQW5PVWVrQ29sczRGdmJ2Smg5dmIwbjJwSlpmYUVuTkpiKzRNbHpqUlg3M3VISllBN3h0TjRpKzNDbHVmV0tYQ25TRHBLY2ZJOHB6ZzZRK0twMXFXYW5CcGNuNTZuV1NWczFOOU9oWFpJWXV6Q0hpN2Y5ZGd3eXd0a0pnMm03NWpEVlpVQkJER0dIcEJ4Vk1sQUx3UnVmcWtTSm1EZHZjRWxOMWRrMGo5L1VQdmM3MzZ1elAyMllHOW1mdmtJNjl1YUhySEo5cnRkRFhKOTRBeFROU2tCVWphaEZ1enR5UVVyY1NNRFlLcTlDazFiNUx3QVljem1SUEp2YUE5dXFPZXJVTjVETGZmLzE1SUkvZmF3MTBTbkE0cGh5SzdFYmtoTlB0eE5kQ0RSWURoVDZjZnZtQ3BaMFBPdjFRa1lOR0RKSm5WcEVFT3NOeU83dmZRKzZMWUFYSkxLTzNsaFMvY3V1elRCSGhBRlhmOFJpY2pFb3dWVkFqRkRuU3RaclE1STlDT00wZ1BMczBGaG9BUjlySUtzaFowZFZZL0hhQU1nOU45SmJSN0dyallEL1MzZ09hRkRQRlozZXlYVWxBMW00NFpXUVBEUlBRaDBBQ0ZMTFh3QkZXUllCUkJoOWp2ZkZCQkQwclhTQXB5Vy9PTlJqSXhyWDhST1hIRGVHVmlUS0trU0JzRmFhZEtBNmdQUG1RQ3Q5a2NZZzlidERvQS8zbjl3V2NuWTdYS3RqVDRjOUNreTF3T0tKOGpsbjExUC9kQUJsTnhtQmNoYUFFQS9yTkxiRmhuNU41Nm5ET0VvVUQ3Zzk0b3Q2VEErb3dER0hBNXFSbXRLL0JUNkgrWmc1RGhxRE9hYTl5d0tHb2h3VDBzTG5ELzB2bCtROUltL0Q1QTU0QlVEeGIwWFJCNjJnKzVteExHNUF3T3FNV3hnVmdhUUxMV0tRK01XS0EvMjREeHRpRU92RGpjbFFCeG9mcFRpQnV0dkdsWVJrRDlEbFFQejhmcFFpQmIrb1NScjJhV2JJOTFJL3hQSTZDT3lqbFZWMVdpQVJwcXkwL3hMUUJ1QUtDZGFnaEQ3TEgxWFpIangzL3RmYncvRlk5c0J5V1Nsa1d6UGU1NEM1QkhWVmJBUW5HOTZnN21oRGphMVh1SmVEMnRiSzF4QVdRUjZPdDJFeGdFTzJNQlk1a09zNFVRNkNNeURpU0Zhb2Jaekk2a09JanBoRzJVVkRqS2JlcE44U1VCaEk3czZ6M2pnQXNraEFmU2hHUWNoRmltOTZxZExqV1FjcGM1N05qMTBqMnJQNTE1ZVBHR1VITENWeUNUOWtEMFF2R1hrRi96SUR6WS9BQTJsVWs3dTdUeVNrK1BIWXpDazV4T0FWbWs3cE9tVDNVYzVOR1RuRS9kSFdUMy9QZEh2bDJrNDNJK1Q4MGNFaDdsbzhFbFhNNnBxSHJHc0I3c2FiR2gxUkdIOVF1bkRQd1ZQRTY0bkdWT3VuRGNqeTdZTU4yRzdVZCtycDI3ckUzQy9sKzNQOGwzeFlaR283Vmxqc1FMUDIzanR4TERNRURzamdjUG9LaGc3Wk8zR3NCc1paSEQ3MU5aVEhiNXcrM1NGUUEySEx6SWtjemtJTTdFUmZvUjVDREFMZE5rMHhIZVljUHRqT3lBZGZKVTA3U0E0TG9RRVRmSzNGc3ZabERvY2c1VDJVOFZQaWNBa0JWT25nTlU1QXlOVDlHQ09BaXp6WU16UDh1a2c2dmRsdWhySEtucHJJMzJxeWlnMFFhY3RrdDdBelZPZkR0UXlGTkNuRHF6aElLMFFGSGxQWXpjUS83M0dOWnFmenB0aWxJL2FINngvMUdIUmcwTk5PVk93Sko5aW96RFFFc2RuUDV6OVlFWFB6UnFBK1pITWljb0ZPWUo4T2JqNnNncllYb0ZKb296aUVWNDNZSnVHVnBUdDVyYWhkaVFLbW5hM051YmJrNk96Z1hyZVFHVmFjd2hDcDdMUHcwb0NaKzVrZWttWmpEWGhiMWR0dGVtZ0FxYVE3Zkt0QXJFTk1mTm9vdWpTdk9hMTJYajVvN2JEczRYcWRvSzVGa25Mck02Wk5YKzRNSktZT3JLRmhsWU9Ub2l3U083SEc3eWxmUVpyTTAwcE5WY1IvcHpZeWpFSm1IN1lYWkNuTkEzemk5RG5SeXNZOGUvUC9nR2NzMmlSMU1pNXhHa3psNHpHNUc4ZU9nYUI2NFJqUXBxU0xrYURVS2RCbmk1UEtpVy9GZG5oKzRjQUREZGdMdlYzZHdGalBiZmU1M2NRN2YwaEhrUFVpQU5jTDg0M1hUM3VuWkx3dmk4ZGRNVUdoTHBLaktCUkx5eTdoNmpRT1VmWFRiOGlIcGN2QVQ2QTU3UkYrb3dabUJ5dDlWeGRqYnVqSStnUDBUM1lnY215UzN2MnRDS01jZ0VyUUlRRVczYnduY2I0RFlBdVFUSzIrQWdjc1MvWEpiVDVjRFMycjlidzFnc0pMYlRadjBhdStrRTJnSERPL1NLdU1vSUUyMDJuUzNLN1V0bGtiVGZVME10MU0vbjJlTjZwSG4zMnVtZmQ2TURMelozK29XcU5ZT0J6L0p0NCtpdkFVQUhObUora0hiRElBRTZPcjFTNlVRTTFwYk9lSWd2cVhKanNJOXlDY1A4OXZndE9lblNveGF1RVoxdU9TcTVENEs0c3lBVDF0TzhoY1VFQ1gydmxqUW5KWW9DTDlpWlNQR0FOZzZpWXlzS0JTM0pWUWFNNGFwbnIyOGRWQncrczVBZXZRVndNOW1KbE1adW93enlVQVEwQnVHSVFjNGhCaWM0Tm10blp0WnM1SUs2clRQenQ4a0l4QUNneXlXeVB6RHdJN1dBd1JsSS9YYmtDOExBWm5EMFIrdWo3cFI2bWV5ek02SnJqMjY1UDJyanRjOFlCcVZIRzhLa04zV3NtTU9uOXBBQmYyV25kcGlzUGE4TmRLOUI3Q0tNQlZyWU1aR0VZQk8wRC9mc1BFamtKaG5SbkR5czJsUlhENndneGhRRDdMVU91N2dZNjdPQlRyczAyMVlvcm1LL0JBN1NSek01MXNGS3l5dXVpTDlMQVJObFRxSzl0bndYVmMrbk80elVzN25PeC9MYzd1QWx6OTd2M09odW1jNzRHcmJoYzl0dWR6NWM5VElwYjUwVW01K09CaS9LdGVRV0YxSVpXTGhGeDYzUUFMdUY5QmxTQnlFT05QemY4N3U2dkwyWXhUNHdMcFkzd1llMGUwdmJQeFRjWE1CcTU1a1NpOE1CTDgzd291bzdEMjYraXNzQlk2NjFxNHFBU0NCZU1RcHpHT3JDTERqNlBlZ0ZrMndCRmhYc0JLQnVqOFk4d0JKamhoUjZQRFJDc0J5YndqcEVBaUI4QUQ0cmhKcU9FckFrNWR1TnU2c0lJZ2Z4RTd1Ulo0SS9LUHNEeHJXbnVsamc3czZ2QnVwa3l4aXBxS01qUkJ5VXJVd0F1eHNIOHlrR3JMeHhwc3UyQ2VYSGJNUXluNmltQllMa2ZpbUFhbktZR3k1cnVackR2UHJ1RnJlSkIvVUFPNXI3UjBEKy9yN1E3cnVIajl6Q0tPK3B1WTdocUxNdkJBUmZvL3V0TDhDNC91b0xtNEhLd3I3Z0lzZk03N3BjTFJBSDd4dG1EQmlUSlFINjY1RFBBZk52c3pOUTJFTlZUZW51Qk9rUUFKQ2lWbnA5dy9HUEppQjQ2dzVrek9pL1FlSHowSmsvdnFqWUFBeXdKVFgrOHNNdzd5SENHT05yMkZNQ3IvenRucEJXNVI3YmV3UWs3dEp3bE05TC93OG1JWjdxOWVRQUxoSC90THAvaGU0bTgxVUZoN2lxQmc3SzltTUh6VTlvLzd1NUhwUSt6SDFlNDI5TE9lWnBPbWV1OVNPVWU1OGhJTlcrR3Y1U2VXL2tSSU01WURzQmJWSVNHTHNDYjNqa2EwVlpaUThjWmo0Q0U2aUNORG12RndnMFFORUdkRUxoZStTMFAvS1BoSzh5NmhIb1Z3Z2tUam5EVjk3Ym1Yc1RRREU5bWEzNU5EZzAreVloTFhIdlFpZkRla0RndHNud05icXJLZXlMUml0RGEzSjRxdjhMQXA1RUJ5bnB4dUtmcWVpWEJCa0NldWhENTYrMVI0SmlTYjNJZFhrc2trZzl6TFBzbjhyekxPdW5zQ2VmVU1uODdvS3hHNDVsSWRQWWFpMnJRc0t0bER2cFd4OTdjRWkySkl0RUdxZmFycUNyUkFRWlZNL2xPZVBUcDc1OTJuZ1o3UEhNTGJwOC9jbnFabXA2ZldudzU0Z3M2ZXB5N1lMTXJzODhCcWhMU2QzRjdlZXJjRGdzQnRTWjZiZG5ubVo2T0F1ZTFVMk9CUG5rYlJlZU5UWlMzZWZSYk90eStlYm9KVGxCZWFFSlRpZWZBWHFhOTZ5NXJtcWQ2ZHRtWGtFSnplQjVrWUZKT1ZTc3JqVXlBRW9IaTFNb240OUhPeVVMeVlNNSt6dGtGb1BDbkNtK2IybjRJWi9BMXZEMzlFS09KRHNYV3BmMzBYOUFaZWU5NGw4aUNvcUJFd0tQZTlpUTdxNzcramtnRXNSenlsNlNES3gvMHlIM2FEa3A1OTNKWHprMVY5WFlxQXdKdWRFdmZHMlFjYytoNXdoZ1FQVzVyM0hzTis4enBuei9JRHFNUTd6aDQzUXU0V3cwanUwN202OENxVG91RTdJZ3RzYXVPSm1OUVhqRFo3QmRJVER0Vm5YNTd1VGdHMEJNNTR4QkxUMTU3STUwSm9sSnB1eUV4anhHVC9XaTliS1F5OHBOYUlOamVPWVVUNGoyV1pGdWxVQUN1TndSdlMyakRjOCtMU2VPNXVnRmVGakpQZllPRjR3cjNDaUYrZHpnVjAxZ0FXS0NDK215U3NQQUIxVkMzeDdLcmUyQWYyelRscDg2dDlyZUJIbHQ4YmZpOERRL2hMbjFMTitEZ2MzM2VIK3Z2Z1VOMGh2RisrWXpTTTBuRll4Rkxsb09heEpNeVRIL2o3Zkg4K0RJZG9ac3ozd2ZNTTdpaUY1Uk1uTnVLVmVZYmg3bzNSMEFleWc1N01lcW04c2I3TEhwZ2RlbkNObnI4UHVaZ2Q1TDloM2htQ0xmMVlSOTQvZEVvVVdpUlRxeG9hdktCc2NlSEx4eFp1K2VhN1pFSGtmaENuWHMzRFVwWnF4bjNWT0JLQTVTam5RcURMcDBiVWVtTThqY29CM3h3MjhUUUNVZm8xSzRLMHZ3U2gxWUhEN2JOMzN5RzU3ZWFrSkQremY0TSs5OTFZdFlhZDUydkxpMGU3WUI4VENnczRzYTQ4elFTdVNzZVEzOVFXUHBLOXNlRWFNRzZuUXVQb09qTWVSb1NhL004TEFIME5keDMwQzY1Q3ZrK3U4N2RnOVhtRnhyNy9DWU80c04zejhmaDRlSTgzckNSQVJqeWxuVXYvUi9WeWdlalhUSTNpczFndmE3S2EzSjNHNk1mNng4OE9QZnNtVXMvbFBTenNYS051ZEFFczU3SFo4aHo4Z0NhSnd4NTBBVGJ5ejVRMUlQdk0rYWZaOXBzWmMrZHpxSzZjL0F2elUrQytCRHcrcjh3OXVpMjQzUHJiMGw3cW9paUk5LzdEU2J3MEZ6T0F2alU0ZWhqMmJtYjgvVG5pbnRVOWN2cE9xQ2Q4TXhTT2JxTEFkdlptSDZQb3l1ZVdXa1g3WnlwOWIyNjlwQlNNY2MraURXQ1A0bmQ5OTJQa1JXQmF3WnNSQkkyb21TNjRCK3JUd1BQT1NVM29FbDBpVjdFQzVQaTMwMStpUDZ2MGsrTGVLVmxTWVJQZFVxNklGbU83UzBuZ3ljZXIyYUx5NHNFNGlyQU5EdjNNU0FrYklCbG1uRTMyMS9JQStnQmNucSszVm5hQm1ud2pkYjc3Yzl2aUhHa1p1WU9mQ0t5bG9LdThGMkZBRWQ0SXl3NlhnWVMrbXZOSHFyMVV2dkQ0Ymh5WGlQb01HTHlBdGo0NVkrdU14dE1MTXZmWXdmNXJiQitXMTVhSVcyTTFhUWJrKzBpKzYvK2hYTU4zeGRXNW11SWU0aUszZEEyZ0VzMndTR3piQkpOVFVuNmNiZFRVQ05tSFp3WnZjQnUyQzRWNC9Pd2w5dFNZTWw1T29CRUJVZ1hBR2RGdGEzSE1JTUt6c09WbmQ2ZXFra1JBYklHSUIyQmdMSWg2Y3YzMGZRRXd5ZTBZRzRWLzVRVWN3WFlkRURWYzFZRUV3NjZnT1RQekFybC9tZmhINE50WnY1VW11disxVWFlLzNJbjd6RTIreHgrMEJDdzIrZFhvNU1EdnpINm9nUktMM0prRmVLUGpwT0kwajR0amhBenU4NnhnbnhQZnUzdklOWFdiRE8yY1lhK2EyMThUSzdmdm1idHkzWXVRWDU0QURmblY3VCtmWHRlM0grWlZhLzUzZXcrMnhFU0VHQVc5VlVCZUNoL3Q1ZGlnWGdkR0JmdnRJZENIZGgza0YxKzJyK0xrZEJhL3NId0oxcngyWFcxSGZkYXYyQWhmeDBpRm5IY2djOGQvMXZJV3FkSW5aRGJxRjBuWWpibWRhTnFZWFkybGhacDNrQVBQNDRXR2R0TnA0WGxRQ2gzNFhXZHdSZG9jWjJUbmRFWHVkeVJiNTNBZ09PSmtXYTJ4UlpGM2Eyc1haVVdKZDAzU2wyTzlMUmFNNGRGbXZubDN6T0F4ZWQxY2VQWGFqelBkTlhkOTFSMnJYZHA0ckZ5ZHIxMmFVQTNhUmNleGF4Y0N4eG03WmRyV09lUDVwNkRkb09PWnZEYnRBSEkrTE54eitMSTlvcDZFOW9WNmZWYmhMUWFDMTZNUkRYdEJ2UXhMUVBieExZUGFKTFJIakpMRk9BUjdEY0RKT2FQYmFYRUhoeDdhM1NFVEZRUnovWlBaZ2RCZlFRZFVwWlFkVFBhVkxaQUNWT0lmaTNwWkRvZHNNSnA1QUJwenJBY09ZdUJDdmExMkt2YXc5VlV5UFhEa3pnQWRqUUltZi9Sa0FaUDZVQU9LNmcvV09yeUllZW90b2RtYXpFQzhpZGZicjY5ZkVOemVIQmd3SVlEQzVhQWlIRFI1V3N3TGRId0JHbVR0eUw4WG1BaFhWQzRqOEFkaVdOR2RTMG1JS3AyMkxpQlhXY29ybVFHT1FKSGM3NW9BRThvOTJMaHEwQWJ3Rm5mT3FqSnZBQ3h2TVhWNjFkTTBDTWpKeXhmd0lqNGFmV3JyVWZUdHdFb0UrcktiU1FHZ3JhUUd5QXY5eG0yQzVUeVFiZ1QxN0c3N2ZBZTRnTS9MQXp5L1JYNzFhSmpZWEtSZERjQ2YzNFI5Rnd4Z2tFb0ZNL0ZYNEVLSzlhWEtTZEQ1QXI1aVRvTVpURnZZb0VxSVJuNWxBb1RRcFlIaUJXQXBzNUQ3SW1BbjFFWjZtQURzQTJtSFFyZkJaOUJOMmVKUWxoVm9qSndQTlREcUdWb3Q0YUp4ckF6UWJXSFdlQllYS1BwUFZKUUQ4Y0o2aCszRzRCUG5XRnpsQVY4N0d2WlQ0Ym9XVkJtZ2I4NzlBVjlyMUpPNklqcUNHYU1hZkd3aVBTSnhpUFA5cVFYSlg1YkF4bFNZM1VkQ3lBamVpQnpkbERQMU5aVFQ5SXdDRG9kdmlnb2VVQklVTUpZd0FGdzZKUUhJRjRZV014T1BKa3dRakYvTHFiUC9MMTZSZFFVUUdkWklLRUNTRTViZ1Mxa1VVeUQxY3I1d1pHZ0lia1JLRFp3SFlDblVJNEJkRWVrRUE1RWNidTRkMFoySWNVQmlTRU1LeFljbEMyTVB2Yk9BSng0N1FLNGlsK0ZES1piSExCSDVJVXhJZ3o2SktHQk00NGd0c3lKUUJNNUJySW81dVVXZXF5Z3hkUUl6SlF4YjdXbDc0Z3B2WXkwU01DRWcrdko0dVVwQ05BRWtIS2c1Z3prZ3lyNFBGY1VHcWcya0h3Z2VrRUdZUmtFYWtaa0ZDUE5rSFFnemtFZGZja0hVY2ZrSGZBUVVIRHZZVUZCcllBeGlnNmtHTHFZNkpTZ3ZFWXlnelFpTHFlVUhxZzAvYWFnMW9HVVlCTUQyY1QwRS9BRmU2Yk5aSTdUOVZrSHNnbUVHUDVEcjRVUUZHN3hnNnJBZ2thb0R2a0pJaTkzY1M0bWc4MzdRQUZjYTdFUU1FbkdTZmlrZzV5d0x3SDhCQ0FzcXByRUtVRjlBMG9HQTNQeWoyZ2p1QlJnbFJEYjdZbUFWQSt6WW9neDRqTUFCTUdsamNsd3JqS05DSmZIaUxFc0ZMNFltYlZaM0FlZDUycUgvaDc4WmFaZmphTlJnS2VkUmdUZHRnL2dWd2JUNGRoU2JnNmQ2T0FLa0c0ZzI3NzBtRDNJOWpNc0dKUVJEemQxSGNIMDRaMlo0NEx3WXZBQnJ6N2d5MEZ0bWVkNDdBWThFcWd0c3lBR2ZweGhWVm9Gamdod0NXK0FWeXhneVB5Smc3Z1JDQXJINkJtSitEOU9TOEczZlFRWW5ndHN6aW1PRUJLR0RPcXdReENHK0hHZFo2d1JNRjVBMWlocGc4MGJPZ2prRmJBQWQ1bGd3QXllK09zR2VRVjhHcllFYkt0QWlpRHlRVkpKUHNVQkJGZ3pkQWlVVXNHVVFzY1pqYkNpRElRazBFVVE2c0Z1Z1JEeUNXTWJBd1F5aUVtVFhpSG9yTGlIb3JQc0V0QXlvRkRnemt3UVpDU1RiTUMvSllnLzBHZmc4TUZ0bVlNRjZFVU1Gb1F0MENSZ3FnNU0vZGw1YVE5Tlk5N0FjR3hiWElGVllPd0FnWUd0UW9nSmVCS1EwVUVxUW9VenFRM0ViR3dNTUZDbUJNNHpyRVQ1SVJQVUdPK1BGeXRnMFQ1eG1PdkplUStBNjhRd0h5T3pTa0Joc1h3QXNJWlRaMW1JdW9PUGNESzJxUVZ3eFFsRzZjbUZseUszWUNTWkhGbHdnWklPU3V6Skc1NVNUbHdBUXVLR1liUW5MTytEWHlYRVhDR2pqZE1FdWdvaUh1K2FDcENnd2o0NGNEbkFFS0FBQlEwUXdBQXhMVWhKRW5uQkgySndVSVFEWklWZ0hxUjBYa2NBZm5rY0JXQVB0MTdKamRjZ0FBPT1cIl0nKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbHotc3RyaW5nL2xpYnMvbHotc3RyaW5nLmpzXG52YXIgbHpfc3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjEpO1xudmFyIGx6X3N0cmluZ19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsel9zdHJpbmcpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvc2NyaXB0X3d3X2FwaS5qc1xuXG5cblxuXG4vLyBXZWJ3b3JrZXIgaW50ZXJmYWNlXG4vLyBDb21waWxlZCB3ZWJ3b3JrZXIgKHNlZSB3ZWJwYWNrL3d3X3BsdWdpbi5qcylcblxuXG5cbiAvLyBGb3Igd2Vid29ya2VyLWxvYWRlciB0byBmaW5kIHRoZSB3d1xuXG52YXIgV2ViV29yayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdlYldvcmsoZGMpIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJXb3JrKTtcblxuICAgIHRoaXMuZGMgPSBkYztcbiAgICB0aGlzLnRhc2tzID0ge307XG5cbiAgICB0aGlzLm9uZXZlbnQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKFdlYldvcmssIFt7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMud29ya2VyKSB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTsgLy8gVVJMLmNyZWF0ZU9iamVjdFVSTFxuXG4gICAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgICAgdmFyIGRhdGEgPSBsel9zdHJpbmdfZGVmYXVsdCgpLmRlY29tcHJlc3NGcm9tQmFzZTY0KHd3JCQkX25hbWVzcGFjZU9iamVjdFswXSk7XG4gICAgICB2YXIgYmxvYjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiAgICAgICAgd2luZG93LkJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXI7XG4gICAgICAgIGJsb2IgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgICAgYmxvYi5hcHBlbmQoZGF0YSk7XG4gICAgICAgIGJsb2IgPSBibG9iLmdldEJsb2IoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpO1xuXG4gICAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMub25tZXNzYWdlKGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRfc29ja2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0X3NvY2tldCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuZGMuc2V0dC5ub2RlX3VybCkgcmV0dXJuO1xuICAgICAgdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMuZGMuc2V0dC5ub2RlX3VybCk7XG4gICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShlLmRhdGEpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1zZ19xdWV1ZSA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQobXNnLCB0eF9rZXlzKSB7XG4gICAgICBpZiAodGhpcy5kYy5zZXR0Lm5vZGVfdXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRfbm9kZShtc2csIHR4X2tleXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHhfa2V5cykge1xuICAgICAgICB2YXIgdHhfb2JqcyA9IHR4X2tleXMubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIG1zZy5kYXRhW2tdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnLCB0eF9vYmpzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9XG4gICAgfSAvLyBTZW5kIHRvIG5vZGUuanMgdmlhIHdlYnNvY2tldFxuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZF9ub2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmRfbm9kZShtc2csIHR4X2tleXMpIHtcbiAgICAgIGlmICghdGhpcy5zb2NrZXQpIHRoaXMuc3RhcnRfc29ja2V0KCk7XG5cbiAgICAgIGlmICh0aGlzLnNvY2tldCAmJiB0aGlzLnNvY2tldC5yZWFkeVN0YXRlKSB7XG4gICAgICAgIC8vIFNlbmQgdGhlIG9sZCBtZXNzYWdlcyBmaXJzdFxuICAgICAgICB3aGlsZSAodGhpcy5tc2dfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG0gPSB0aGlzLm1zZ19xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubXNnX3F1ZXVlLnB1c2gobXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25tZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9ubWVzc2FnZShlKSB7XG4gICAgICBpZiAoZS5kYXRhLmlkIGluIHRoaXMudGFza3MpIHtcbiAgICAgICAgdGhpcy50YXNrc1tlLmRhdGEuaWRdKGUuZGF0YS5kYXRhKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGFza3NbZS5kYXRhLmlkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25ldmVudChlKTtcbiAgICAgIH1cbiAgICB9IC8vIEV4ZWN1dGUgYSB0YXNrXG5cbiAgfSwge1xuICAgIGtleTogXCJleGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZXhlYyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JfZGVmYXVsdCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh0eXBlLCBkYXRhLCB0eF9rZXlzKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvcl9kZWZhdWx0KCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChycywgcmopIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHV0aWxzLnV1aWQoKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMzLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgIH0sIHR4X2tleXMpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczMudGFza3NbaWRdID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICBycyhyZXMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBleGVjKF94LCBfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX2V4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4ZWM7XG4gICAgfSgpIC8vIEV4ZWN1dGUgYSB0YXNrLCBidXQganVzdCBmdWNraW5nIGRvIGl0LFxuICAgIC8vIGRvIG5vdCB3YWl0IGZvciB0aGUgcmVzdWx0XG5cbiAgfSwge1xuICAgIGtleTogXCJqdXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGp1c3QodHlwZSwgZGF0YSwgdHhfa2V5cykge1xuICAgICAgdmFyIGlkID0gdXRpbHMudXVpZCgpO1xuICAgICAgdGhpcy5zZW5kKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9LCB0eF9rZXlzKTtcbiAgICB9IC8vIFJlbGF5IGFuIGV2ZW50IGZyb20gaWZyYW1lIHBvc3RNZXNzYWdlXG4gICAgLy8gKGZvciB0aGUgZnV0dXJlKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWxheSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JfZGVmYXVsdCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZXZlbnQsIGp1c3QpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yX2RlZmF1bHQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoanVzdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICBqdXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJzLCByaikge1xuICAgICAgICAgICAgICAgICAgX3RoaXM0LnNlbmQoZXZlbnQsIGV2ZW50LnR4X2tleXMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWp1c3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM0LnRhc2tzW2V2ZW50LmlkXSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBycyhyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVsYXkoX3g0LCBfeDUpIHtcbiAgICAgICAgcmV0dXJuIF9yZWxheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVsYXk7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMud29ya2VyKSB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViV29yaztcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBzY3JpcHRfd3dfYXBpID0gKFdlYldvcmspO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvc2NyaXB0X3V0aWxzLmpzXG5cblxudmFyIEZERUZTID0gLyhmdW5jdGlvbiB8KShbJEEtWl9dWzAtOUEtWl8kXFwuXSopW1xcc10qP1xcKCguKj8pXFwpL2dtaTtcbnZhciBTQlJBQ0tFVFMgPSAvKFskQS1aX11bMC05QS1aXyRcXC5dKilbXFxzXSo/XFxbKFteXCJeXFxbXlxcXV0rPylcXF0vZ21pO1xudmFyIFRGU1RSID0gLyhcXGQrKShcXHcqKS9nbTtcbnZhciBCVUZfSU5DID0gNTtcbnZhciB0Zl9jYWNoZSA9IHt9O1xuZnVuY3Rpb24gZl9hcmdzKHNyYykge1xuICBGREVGUy5sYXN0SW5kZXggPSAwO1xuICB2YXIgbSA9IEZERUZTLmV4ZWMoc3JjKTtcblxuICBpZiAobSkge1xuICAgIHZhciBma2V5d29yZCA9IG1bMV0udHJpbSgpO1xuICAgIHZhciBmbmFtZSA9IG1bMl0udHJpbSgpO1xuICAgIHZhciBmYXJncyA9IG1bM10udHJpbSgpO1xuICAgIHJldHVybiBmYXJncy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgudHJpbSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gZl9ib2R5KHNyYykge1xuICByZXR1cm4gc3JjLnNsaWNlKHNyYy5pbmRleE9mKFwie1wiKSArIDEsIHNyYy5sYXN0SW5kZXhPZihcIn1cIikpO1xufVxuZnVuY3Rpb24gd3JhcF9pZHhzKHNyYywgcHJlKSB7XG4gIGlmIChwcmUgPT09IHZvaWQgMCkge1xuICAgIHByZSA9ICcnO1xuICB9XG5cbiAgU0JSQUNLRVRTLmxhc3RJbmRleCA9IDA7XG4gIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgZG8ge1xuICAgIHZhciBtID0gU0JSQUNLRVRTLmV4ZWMoc3JjKTtcblxuICAgIGlmIChtKSB7XG4gICAgICB2YXIgdm5hbWUgPSBtWzFdLnRyaW0oKTtcbiAgICAgIHZhciB2aW5kZXggPSBtWzJdLnRyaW0oKTtcblxuICAgICAgaWYgKHZpbmRleCA9PT0gJzAnIHx8IHBhcnNlSW50KHZpbmRleCkgPCBCVUZfSU5DKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHZuYW1lKSB7XG4gICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgIGNhc2UgJ3JldHVybic6XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vbGV0IHdyYXAgPSBgJHtwcmV9X3YoJHt2bmFtZX0sICR7dmluZGV4fSlbJHt2aW5kZXh9XWBcblxuXG4gICAgICB2YXIgd3JhcCA9IFwiXCIuY29uY2F0KHZuYW1lLCBcIltcIikuY29uY2F0KHByZSwgXCJfaShcIikuY29uY2F0KHZpbmRleCwgXCIsIFwiKS5jb25jYXQodm5hbWUsIFwiKV1cIik7XG4gICAgICBzcmMgPSBzcmMucmVwbGFjZShtWzBdLCB3cmFwKTtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgfSB3aGlsZSAobSk7XG5cbiAgcmV0dXJuIGNoYW5nZWQgPyBzcmMgOiBzcmM7XG59IC8vIEdldCBhbGwgbW9kdWxlIGhlbHBlciBjbGFzc2VzXG5cbmZ1bmN0aW9uIG1ha2VfbW9kdWxlX2xpYihtb2QpIHtcbiAgdmFyIGxpYiA9IHt9O1xuXG4gIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgaWYgKGsgPT09ICdtYWluJyB8fCBrID09PSAnaWQnKSBjb250aW51ZTtcbiAgICB2YXIgYSA9IGZfYXJncyhtb2Rba10pO1xuICAgIGxpYltrXSA9IG5ldyBGdW5jdGlvbihhLCBmX2JvZHkobW9kW2tdKSk7XG4gIH1cblxuICByZXR1cm4gbGliO1xufVxuZnVuY3Rpb24gZ2V0X3Jhd19zcmMoZikge1xuICBpZiAodHlwZW9mIGYgPT09ICdzdHJpbmcnKSByZXR1cm4gZjtcbiAgdmFyIHNyYyA9IGYudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHNyYy5zbGljZShzcmMuaW5kZXhPZihcIntcIikgKyAxLCBzcmMubGFzdEluZGV4T2YoXCJ9XCIpKTtcbn0gLy8gR2V0IHRmIGluIG1zIGZyb20gcGFpcnMgc3VjaCAoYDE1YCwgYG1gKVxuXG5mdW5jdGlvbiB0Zl9mcm9tX3BhaXIobnVtLCBwZikge1xuICB2YXIgbXVsdCA9IDE7XG5cbiAgc3dpdGNoIChwZikge1xuICAgIGNhc2UgJ3MnOlxuICAgICAgbXVsdCA9IENvbnN0LlNFQ09ORDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbSc6XG4gICAgICBtdWx0ID0gQ29uc3QuTUlOVVRFO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdIJzpcbiAgICAgIG11bHQgPSBDb25zdC5IT1VSO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdEJzpcbiAgICAgIG11bHQgPSBDb25zdC5EQVk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1cnOlxuICAgICAgbXVsdCA9IENvbnN0LldFRUs7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ00nOlxuICAgICAgbXVsdCA9IENvbnN0Lk1PTlRIO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdZJzpcbiAgICAgIG11bHQgPSBDb25zdC5ZRUFSO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQobnVtKSAqIG11bHQ7XG59XG5mdW5jdGlvbiB0Zl9mcm9tX3N0cihzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdudW1iZXInKSByZXR1cm4gc3RyO1xuICBpZiAodGZfY2FjaGVbc3RyXSkgcmV0dXJuIHRmX2NhY2hlW3N0cl07XG4gIFRGU1RSLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtID0gVEZTVFIuZXhlYyhzdHIpO1xuXG4gIGlmIChtKSB7XG4gICAgdGZfY2FjaGVbc3RyXSA9IHRmX2Zyb21fcGFpcihtWzFdLCBtWzJdKTtcbiAgICByZXR1cm4gdGZfY2FjaGVbc3RyXTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRfZm5faWQocHJlLCBpZCkge1xuICByZXR1cm4gcHJlICsgJy0nICsgaWQuc3BsaXQoJzwtJykucG9wKCk7XG59IC8vIEFwcGx5IGZpbHRlciBmb3IgYWxsIG5ldyBvdmVybGF5c1xuXG5mdW5jdGlvbiBvdmYob2JqLCBmKSB7XG4gIHZhciBudyA9IHt9O1xuXG4gIGZvciAodmFyIGlkIGluIG9iaikge1xuICAgIG53W2lkXSA9IHt9O1xuXG4gICAgZm9yICh2YXIgayBpbiBvYmpbaWRdKSB7XG4gICAgICBpZiAoayA9PT0gJ2RhdGEnKSBjb250aW51ZTtcbiAgICAgIG53W2lkXVtrXSA9IG9ialtpZF1ba107XG4gICAgfVxuXG4gICAgbndbaWRdLmRhdGEgPSBmKG9ialtpZF0uZGF0YSk7XG4gIH1cblxuICByZXR1cm4gbnc7XG59IC8vIFJldHVybiBpbmRleCBvZiB0aGUgbmV4dCBlbGVtZW50IGluXG4vLyBkYXRhc2V0IChzaW5jZSB0KS4gSW1wbDogc2ltcGxlIGJpbmFyeSBzZWFyY2hcbi8vIFRPRE86IG9wdGltaXplIChyZW1lbWJlciB0aGUgcGVudWx0aW1hdGVcbi8vIGl0ZXJhdGlvbiBhbmQgc3RhcnQgZnJvbSB0aGVyZSlcblxuZnVuY3Rpb24gbmV4dHQoZGF0YSwgdCwgdGkpIHtcbiAgaWYgKHRpID09PSB2b2lkIDApIHtcbiAgICB0aSA9IDA7XG4gIH1cblxuICB2YXIgaTAgPSAwO1xuICB2YXIgaU4gPSBkYXRhLmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGkwIDw9IGlOKSB7XG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGkwICsgaU4pIC8gMik7XG5cbiAgICBpZiAoZGF0YVttaWRdW3RpXSA9PT0gdCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2UgaWYgKGRhdGFbbWlkXVt0aV0gPCB0KSB7XG4gICAgICBpMCA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlOID0gbWlkIC0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdCA8IGRhdGFbbWlkXVt0aV0gPyBtaWQgOiBtaWQgKyAxO1xufSAvLyBFc3RpbWF0ZWQgc2l6ZSBvZiBkYXRhc2V0c1xuXG5mdW5jdGlvbiBzaXplX29mX2RzcyhkYXRhKSB7XG4gIHZhciBieXRlcyA9IDA7XG5cbiAgZm9yICh2YXIgaWQgaW4gZGF0YSkge1xuICAgIGlmIChkYXRhW2lkXS5kYXRhICYmIGRhdGFbaWRdLmRhdGFbMF0pIHtcbiAgICAgIHZhciBzMCA9IHNpemVfb2YoZGF0YVtpZF0uZGF0YVswXSk7XG4gICAgICBieXRlcyArPSBzMCAqIGRhdGFbaWRdLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn0gLy8gVXNlZCB0byBtZWFzdXJlIHRoZSBzaXplIG9mIGRhdGFzZXRcblxuZnVuY3Rpb24gc2l6ZV9vZihvYmplY3QpIHtcbiAgdmFyIGxpc3QgPSBbXSxcbiAgICAgIHN0YWNrID0gW29iamVjdF0sXG4gICAgICBieXRlcyA9IDA7XG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgdmFyIHR5cGUgPSBfdHlwZW9mKHZhbHVlKTtcblxuICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGJ5dGVzICs9IDQ7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZXMgKz0gdmFsdWUubGVuZ3RoICogMjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBieXRlcyArPSA4O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgbGlzdC5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgIGxpc3QucHVzaCh2YWx1ZSk7XG5cbiAgICAgIGZvciAodmFyIGkgaW4gdmFsdWUpIHtcbiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufSAvLyBVcGRhdGUgb25jaGFydC9vZmZjaGFydFxuXG5mdW5jdGlvbiB1cGRhdGUoZGF0YSwgdmFsKSB7XG4gIHZhciBpID0gZGF0YS5sZW5ndGggLSAxO1xuICB2YXIgbGFzdCA9IGRhdGFbaV07XG5cbiAgaWYgKCFsYXN0IHx8IHZhbFswXSA+IGxhc3RbMF0pIHtcbiAgICBkYXRhLnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2ldID0gdmFsO1xuICB9XG59XG5mdW5jdGlvbiBzY3JpcHRfdXRpbHNfbm93KCkge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy9kYXRhc2V0LmpzXG5cblxuXG5cblxuZnVuY3Rpb24gZGF0YXNldF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gZGF0YXNldF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gZGF0YXNldF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGRhdGFzZXRfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGRhdGFzZXRfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGRhdGFzZXRfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vLyBEYXRhc2V0IHByb3h5IGJldHdlZW4gdnVlanMgJiBXZWJXb3JrZXJcblxuXG52YXIgRGF0YXNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFzZXQoZGMsIGRlc2MpIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhc2V0KTtcblxuICAgIC8vIFRPRE86IGRhdGFzZXQgdXJsIGFycm93IGZuIHRlbGxzIFdXXG4gICAgLy8gdG8gbG9hZCB0aGUgZHMgZGlyZWN0bHkgZnJvbSB3ZWJcbiAgICB0aGlzLnR5cGUgPSBkZXNjLnR5cGU7XG4gICAgdGhpcy5pZCA9IGRlc2MuaWQ7XG4gICAgdGhpcy5kYyA9IGRjOyAvLyBTZW5kIHRoZSBkYXRhIHRvIFdXXG5cbiAgICBpZiAoZGVzYy5kYXRhKSB7XG4gICAgICB0aGlzLmRjLnd3Lmp1c3QoJ3VwbG9hZC1kYXRhJywgX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLmlkLCBkZXNjKSk7IC8vIFJlbW92ZSB0aGUgZGF0YSBmcm9tIHRoZSBkZXNjcmlwdG9yXG5cbiAgICAgIGRlbGV0ZSBkZXNjLmRhdGE7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihkZXNjLCBwcm90byk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc2MsICdkYycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gZGM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gV2F0Y2ggZm9yIHRoZSBjaGFuZ2VzIG9mIGRlc2NyaXB0b3JzXG5cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhEYXRhc2V0LCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogLy8gU2V0IGRhdGEgKG92ZXJ3cml0ZSB0aGUgd2hvbGUgZGF0YXNldClcbiAgICBmdW5jdGlvbiBzZXQoZGF0YSwgZXhlYykge1xuICAgICAgaWYgKGV4ZWMgPT09IHZvaWQgMCkge1xuICAgICAgICBleGVjID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYy53dy5qdXN0KCdkYXRhc2V0LW9wJywge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgdHlwZTogJ3NldCcsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGV4ZWM6IGV4ZWNcbiAgICAgIH0pO1xuICAgIH0gLy8gVXBkYXRlIHdpdGggbmV3IGRhdGEgKGFycmF5IG9mIGRhdGEgcG9pbnRzKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShhcnIpIHtcbiAgICAgIHRoaXMuZGMud3cuanVzdCgndXBkYXRlLWRhdGEnLCBfZGVmaW5lUHJvcGVydHkoe30sIHRoaXMuaWQsIGFycikpO1xuICAgIH0gLy8gU2VuZCBXVyBhIGNodW5rIHRvIG1lcmdlLiBUaGUgbWVyZ2UgYWxnb1xuICAgIC8vIGhlcmUgaXMgc2ltcGxlciB0aGFuIGluIERDLiBJdCBqdXN0IGFkZHNcbiAgICAvLyBkYXRhIGF0IHRoZSBiZWdpbm5pbmcgb3IvYW5kIHRoZSBlbmQgb2YgZHNcblxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKGRhdGEsIGV4ZWMpIHtcbiAgICAgIGlmIChleGVjID09PSB2b2lkIDApIHtcbiAgICAgICAgZXhlYyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGMud3cuanVzdCgnZGF0YXNldC1vcCcsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIHR5cGU6ICdtcmcnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBleGVjOiBleGVjXG4gICAgICB9KTtcbiAgICB9IC8vIFJlbW92ZSB0aGUgZHMgZnJvbSBXV1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShleGVjKSB7XG4gICAgICBpZiAoZXhlYyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGV4ZWMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRjLmRlbChcImRhdGFzZXRzLlwiLmNvbmNhdCh0aGlzLmlkKSk7XG4gICAgICB0aGlzLmRjLnd3Lmp1c3QoJ2RhdGFzZXQtb3AnLCB7XG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgZXhlYzogZXhlY1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgdGhpcy5kYy5kc3NbdGhpcy5pZF07XG4gICAgfSAvLyBGZXRjaCBkYXRhIGZyb20gV1dcblxuICB9LCB7XG4gICAga2V5OiBcImRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9kYXRhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0KCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgZHM7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvcl9kZWZhdWx0KCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYy53dy5leGVjKCdnZXQtZGF0YXNldCcsIHRoaXMuaWQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBkcyA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHMpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBkcy5kYXRhKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiBfZGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KClcbiAgfV0sIFt7XG4gICAga2V5OiBcIndhdGNoZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2F0Y2hlcihuLCBwKSB7XG4gICAgICB2YXIgbmlkcyA9IG4ubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LmlkO1xuICAgICAgfSk7XG4gICAgICB2YXIgcGlkcyA9IHAubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LmlkO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBkYXRhc2V0X2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobmlkcyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGlkID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBpZiAoIXBpZHMuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgICAgICB2YXIgZHMgPSBuLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4geC5pZCA9PT0gaWQ7XG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIHRoaXMuZHNzW2lkXSA9IG5ldyBEYXRhc2V0KHRoaXMsIGRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBkYXRhc2V0X2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGlkcyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpZCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIGlmICghbmlkcy5pbmNsdWRlcyhpZCkgJiYgdGhpcy5kc3NbaWRdKSB7XG4gICAgICAgICAgICB0aGlzLmRzc1tpZF0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9IC8vIE1ha2UgYW4gb2JqZWN0IGZvciBkYXRhIHRyYW5zZmVyXG5cbiAgfSwge1xuICAgIGtleTogXCJtYWtlX3R4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VfdHgoZGMsIHR5cGVzKSB7XG4gICAgICB2YXIgbWFpbiA9IGRjLmRhdGEuY2hhcnQuZGF0YTtcbiAgICAgIHZhciBiYXNlID0ge307XG5cbiAgICAgIGlmICh0eXBlcy5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnR5cGUgPT09ICdPSExDVic7XG4gICAgICB9KSkge1xuICAgICAgICBiYXNlID0ge1xuICAgICAgICAgIG9obGN2OiBtYWluXG4gICAgICAgIH07XG4gICAgICB9IC8vIFRPRE86IGFkZCBtb3JlIHNvcGhpc3RpY2F0ZWQgc2VhcmNoXG4gICAgICAvLyAodXNpbmcgJ3NjcmlwdC5kYXRhc2V0cycgcGFyYW1lcnRlcilcblxuICAgICAgLypmb3IgKHZhciByZXEgb2YgdHlwZXMpIHtcbiAgICAgICAgICBsZXQgZHMgPSBPYmplY3QudmFsdWVzKGRjLmRzcyB8fCB7fSlcbiAgICAgICAgICAgICAgLmZpbmQoeCA9PiB4LnR5cGUgPT09IHJlcS50eXBlKVxuICAgICAgICAgIGlmIChkcyAmJiBkcy5kYXRhKSB7XG4gICAgICAgICAgICAgIGJhc2VbZHMuaWRdID0ge1xuICAgICAgICAgICAgICAgICAgaWQ6IGRzLmlkLFxuICAgICAgICAgICAgICAgICAgdHlwZTogZHMudHlwZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGRzLmRhdGFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0qL1xuICAgICAgLy8gVE9ETzogRGF0YSByZXF1ZXN0IGNhbGxiYWNrID9cblxuXG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YXNldDtcbn0oKTsgLy8gRGF0YXNldCByZWNpZXZlciAoY3JlYXRlZCBvbiBXVylcblxuXG5cbnZhciBEYXRhc2V0V1cgPSAvKiNfX1BVUkVfXyovKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRhc2V0V1coaWQsIGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YXNldFdXKTtcblxuICAgIHRoaXMubGFzdF91cGQgPSBub3coKTtcbiAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gUmVndWxhciBhcnJheVxuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIGlmIChpZCA9PT0gJ29obGN2JykgdGhpcy50eXBlID0gJ09ITENWJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGF0YXNldCBkZXNjcmlwdG9yXG4gICAgICB0aGlzLmRhdGEgPSBkYXRhLmRhdGE7XG4gICAgICB0aGlzLnR5cGUgPSBkYXRhLnR5cGU7XG4gICAgfVxuICB9IC8vIFVwZGF0ZSBmcm9tICd1cGRhdGUtZGF0YScgZXZlbnRcbiAgLy8gVE9ETzogZHMgc2l6ZSBsaW1pdCAoaW4gTUIgLyBkYXRhIHBvaW50cylcblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhc2V0V1csIFt7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKGRhdGEpIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbikge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0MCA9IHRoaXMuZGF0YVswXVswXTtcbiAgICAgIHZhciB0TiA9IHRoaXMuZGF0YVtsZW4gLSAxXVswXTtcbiAgICAgIHZhciBsID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhbMF0gPCB0MDtcbiAgICAgIH0pO1xuICAgICAgdmFyIHIgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFswXSA+IHROO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRhdGEgPSBsLmNvbmNhdCh0aGlzLmRhdGEsIHIpO1xuICAgIH0gLy8gT24gZGF0YXNldCBvcGVyYXRpb25cblxuICB9LCB7XG4gICAga2V5OiBcIm9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wKHNlLCBfb3ApIHtcbiAgICAgIHRoaXMubGFzdF91cGQgPSBub3coKTtcblxuICAgICAgc3dpdGNoIChfb3AudHlwZSkge1xuICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgIHRoaXMuZGF0YSA9IF9vcC5kYXRhO1xuICAgICAgICAgIHNlLnJlY2FsY19zaXplKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVsJzpcbiAgICAgICAgICBkZWxldGUgc2UuZGF0YVt0aGlzLmlkXTtcbiAgICAgICAgICBzZS5yZWNhbGNfc2l6ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21yZyc6XG4gICAgICAgICAgdGhpcy5tZXJnZShfb3AuZGF0YSk7XG4gICAgICAgICAgc2UucmVjYWxjX3NpemUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ1cGRhdGVfYWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZV9hbGwoc2UsIGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gZGF0YSkge1xuICAgICAgICBpZiAoayA9PT0gJ29obGN2JykgY29udGludWU7XG4gICAgICAgIHZhciBpZCA9IGsuc3BsaXQoJy4nKVsxXSB8fCBrO1xuICAgICAgICBpZiAoIXNlLmRhdGFbaWRdKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGFyciA9IHNlLmRhdGFbaWRdLmRhdGE7XG4gICAgICAgIHZhciBpTiA9IGFyci5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbGFzdCA9IGFycltpTl07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBkYXRhc2V0X2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YVtrXSksXG4gICAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGRwID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgZHBbMF0gPiBsYXN0WzBdKSB7XG4gICAgICAgICAgICAgIGFyci5wdXNoKGRwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2UuZGF0YVtpZF0ubGFzdF91cGQgPSBub3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YXNldFdXO1xufSgpKSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy9kY19ldmVudHMuanNcblxuXG5cblxuXG5mdW5jdGlvbiBkY19ldmVudHNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IGRjX2V2ZW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gZGNfZXZlbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gZGNfZXZlbnRzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBkY19ldmVudHNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGRjX2V2ZW50c19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBEYXRhQ3ViZSBldmVudCBoYW5kbGVyc1xuXG5cblxuXG5cbnZhciBEQ0V2ZW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERDRXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBEQ0V2ZW50cyk7XG5cbiAgICB0aGlzLnd3ID0gbmV3IHNjcmlwdF93d19hcGkodGhpcyk7IC8vIExpc3RlbiB0byB0aGUgd2ViLXdvcmtlciBldmVudHNcblxuICAgIHRoaXMud3cub25ldmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gZGNfZXZlbnRzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX3RoaXMudHYuY29udHJvbGxlcnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjdHJsID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGN0cmwud3cpIGN0cmwud3coZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGUuZGF0YS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3JlcXVlc3QtZGF0YSc6XG4gICAgICAgICAgLy8gVE9ETzogRGF0YVR1bm5lbCBjbGFzcyBmb3Igc21hcnRlciBkYXRhIHRyYW5zZmVyXG4gICAgICAgICAgaWYgKF90aGlzLnd3Ll9kYXRhX3VwbG9hZGluZykgYnJlYWs7XG4gICAgICAgICAgdmFyIGRhdGEgPSBEYXRhc2V0Lm1ha2VfdHgoX3RoaXMsIGUuZGF0YS5kYXRhKTtcblxuICAgICAgICAgIF90aGlzLnNlbmRfbWV0YV8yX3d3KCk7XG5cbiAgICAgICAgICBfdGhpcy53dy5qdXN0KCd1cGxvYWQtZGF0YScsIGRhdGEpO1xuXG4gICAgICAgICAgX3RoaXMud3cuX2RhdGFfdXBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvdmVybGF5LWRhdGEnOlxuICAgICAgICAgIF90aGlzLm9uX292ZXJsYXlfZGF0YShlLmRhdGEuZGF0YSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvdmVybGF5LXVwZGF0ZSc6XG4gICAgICAgICAgX3RoaXMub25fb3ZlcmxheV91cGRhdGUoZS5kYXRhLmRhdGEpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGF0YS11cGxvYWRlZCc6XG4gICAgICAgICAgX3RoaXMud3cuX2RhdGFfdXBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZW5naW5lLXN0YXRlJzpcbiAgICAgICAgICBfdGhpcy5zZV9zdGF0ZSA9IE9iamVjdC5hc3NpZ24oX3RoaXMuc2Vfc3RhdGUgfHwge30sIGUuZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtb2RpZnktb3ZlcmxheSc6XG4gICAgICAgICAgX3RoaXMubW9kaWZ5X292ZXJsYXkoZS5kYXRhLmRhdGEpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2NyaXB0LXNpZ25hbCc6XG4gICAgICAgICAgX3RoaXMudHYuJGVtaXQoJ3NpZ25hbCcsIGUuZGF0YS5kYXRhKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IGRjX2V2ZW50c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF90aGlzLnR2LmNvbnRyb2xsZXJzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGN0cmwgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgaWYgKGN0cmwucG9zdF93dykgY3RybC5wb3N0X3d3KGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH07XG4gIH0gLy8gQ2FsbGVkIHdoZW4gb3ZlcmFsYXkvdHYgZW1pdHMgJ2N1c3RvbS1ldmVudCdcblxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKERDRXZlbnRzLCBbe1xuICAgIGtleTogXCJvbl9jdXN0b21fZXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25fY3VzdG9tX2V2ZW50KGV2ZW50LCBhcmdzKSB7XG4gICAgICBzd2l0Y2ggKGV2ZW50KSB7XG4gICAgICAgIGNhc2UgJ3JlZ2lzdGVyLXRvb2xzJzpcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyX3Rvb2xzKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2V4ZWMtc2NyaXB0JzpcbiAgICAgICAgICB0aGlzLmV4ZWNfc2NyaXB0KGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2V4ZWMtYWxsLXNjcmlwdHMnOlxuICAgICAgICAgIHRoaXMuZXhlY19hbGxfc2NyaXB0cygpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RhdGEtbGVuLWNoYW5nZWQnOlxuICAgICAgICAgIHRoaXMuZGF0YV9jaGFuZ2VkKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Rvb2wtc2VsZWN0ZWQnOlxuICAgICAgICAgIGlmICghYXJnc1swXSkgYnJlYWs7IC8vIFRPRE86IFF1aWNrIGZpeCwgaW52ZXN0aWdhdGVcblxuICAgICAgICAgIGlmIChhcmdzWzBdLnNwbGl0KCc6JylbMF0gPT09ICdTeXN0ZW0nKSB7XG4gICAgICAgICAgICB0aGlzLnN5c3RlbV90b29sKGFyZ3NbMF0uc3BsaXQoJzonKVsxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAndG9vbCcsIGFyZ3NbMF0pO1xuXG4gICAgICAgICAgaWYgKGFyZ3NbMF0gPT09ICdDdXJzb3InKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdpbmdfbW9kZV9vZmYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdncmlkLW1vdXNlZG93bic6XG4gICAgICAgICAgdGhpcy5ncmlkX21vdXNlZG93bihhcmdzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkcmF3aW5nLW1vZGUtb2ZmJzpcbiAgICAgICAgICB0aGlzLmRyYXdpbmdfbW9kZV9vZmYoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjaGFuZ2Utc2V0dGluZ3MnOlxuICAgICAgICAgIHRoaXMuY2hhbmdlX3NldHRpbmdzKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JhbmdlLWNoYW5nZWQnOlxuICAgICAgICAgIHRoaXMuc2NyaXB0c19vbnJhbmdlLmFwcGx5KHRoaXMsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2Nyb2xsLWxvY2snOlxuICAgICAgICAgIHRoaXMub25fc2Nyb2xsX2xvY2soYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0LXNlbGVjdGVkJzpcbiAgICAgICAgICB0aGlzLm9iamVjdF9zZWxlY3RlZChhcmdzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZW1vdmUtdG9vbCc6XG4gICAgICAgICAgdGhpcy5zeXN0ZW1fdG9vbCgnUmVtb3ZlJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYmVmb3JlLWRlc3Ryb3knOlxuICAgICAgICAgIHRoaXMuYmVmb3JlX2Rlc3Ryb3koKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIFRyaWdnZXJlZCB3aGVuIG9uZSBvciBtdWx0aXBsZSBzZXR0aW5ncyBhcmUgY2hhbmdlZFxuICAgIC8vIFdlIHNlbGVjdCBvbmx5IHRoZSBjaGFuZ2VkIG9uZXMgJiByZS1leGVjIHRoZW0gb24gdGhlXG4gICAgLy8gd2ViIHdvcmtlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fc2V0dGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25fc2V0dGluZ3ModmFsdWVzLCBwcmV2KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnNldHQuc2NyaXB0cykgcmV0dXJuO1xuICAgICAgdmFyIGRlbHRhID0ge307XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXNbaV07XG4gICAgICAgIHZhciBhcnIgPSBwcmV2LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LnYgPT09IG4udjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoICYmIG4ucC5zZXR0aW5ncy4kcHJvcHMpIHtcbiAgICAgICAgICB2YXIgaWQgPSBuLnAuc2V0dGluZ3MuJHV1aWQ7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNfc2NyX3Byb3BzX3VwZChuLCBwcmV2KSAmJiB1dGlscy5kZWxheWVkX2V4ZWMobi5wKSkge1xuICAgICAgICAgICAgZGVsdGFbaWRdID0gbi52O1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIF90aGlzMi50di4kc2V0KG4ucCwgJ2xvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkICYmIE9iamVjdC5rZXlzKGRlbHRhKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRmID0gdGhpcy50di4kcmVmcy5jaGFydC5pbnRlcnZhbF9tcyB8fCB0aGlzLmRhdGEuY2hhcnQudGY7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMudHYuZ2V0UmFuZ2UoKTtcbiAgICAgICAgdGhpcy53dy5qdXN0KCd1cGRhdGUtb3Ytc2V0dGluZ3MnLCB7XG4gICAgICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgICAgIHRmOiB0ZixcbiAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBXaGVuIHRoZSBzZXQgb2YgJHV1aWRzIGlzIGNoYW5nZWRcblxuICB9LCB7XG4gICAga2V5OiBcIm9uX2lkc19jaGFuZ2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX2lkc19jaGFuZ2VkKHZhbHVlcywgcHJldikge1xuICAgICAgdmFyIHJlbSA9IHByZXYuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4ICE9PSB1bmRlZmluZWQgJiYgIXZhbHVlcy5pbmNsdWRlcyh4KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVtLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnd3Lmp1c3QoJ3JlbW92ZS1zY3JpcHRzJywgcmVtKTtcbiAgICAgIH1cbiAgICB9IC8vIENvbWJpbmUgYWxsIHRvb2xzIGFuZCB0aGVpciBtb2RzXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3Rlcl90b29sc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcl90b29scyh0b29scykge1xuICAgICAgdmFyIHByZXNldCA9IHt9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IGRjX2V2ZW50c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZGF0YS50b29scyB8fCBbXSksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB0b29sID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIHByZXNldFt0b29sLnR5cGVdID0gdG9vbDtcbiAgICAgICAgICBkZWxldGUgdG9vbC50eXBlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3Rvb2xzJywgW10pO1xuICAgICAgdmFyIGxpc3QgPSBbe1xuICAgICAgICB0eXBlOiAnQ3Vyc29yJyxcbiAgICAgICAgaWNvbjogaWNvbnNfbmFtZXNwYWNlT2JqZWN0W1wiY3Vyc29yLnBuZ1wiXVxuICAgICAgfV07XG5cbiAgICAgIHZhciBfaXRlcmF0b3I0ID0gZGNfZXZlbnRzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodG9vbHMpLFxuICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdG9vbCA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuYXNzaWduKHt9LCB0b29sLmluZm8pO1xuICAgICAgICAgIHZhciB0eXBlID0gdG9vbC5pbmZvLnR5cGUgfHwgJ0RlZmF1bHQnO1xuICAgICAgICAgIHByb3RvLnR5cGUgPSBcIlwiLmNvbmNhdCh0b29sLnVzZV9mb3IsIFwiOlwiKS5jb25jYXQodHlwZSk7XG4gICAgICAgICAgdGhpcy5tZXJnZV9wcmVzZXRzKHByb3RvLCBwcmVzZXRbdG9vbC51c2VfZm9yXSk7XG4gICAgICAgICAgdGhpcy5tZXJnZV9wcmVzZXRzKHByb3RvLCBwcmVzZXRbcHJvdG8udHlwZV0pO1xuICAgICAgICAgIGRlbGV0ZSBwcm90by5tb2RzO1xuICAgICAgICAgIGxpc3QucHVzaChwcm90byk7XG5cbiAgICAgICAgICBmb3IgKHZhciBtb2QgaW4gdG9vbC5pbmZvLm1vZHMpIHtcbiAgICAgICAgICAgIHZhciBtcCA9IE9iamVjdC5hc3NpZ24oe30sIHByb3RvKTtcbiAgICAgICAgICAgIG1wID0gT2JqZWN0LmFzc2lnbihtcCwgdG9vbC5pbmZvLm1vZHNbbW9kXSk7XG4gICAgICAgICAgICBtcC50eXBlID0gXCJcIi5jb25jYXQodG9vbC51c2VfZm9yLCBcIjpcIikuY29uY2F0KG1vZCk7XG4gICAgICAgICAgICB0aGlzLm1lcmdlX3ByZXNldHMobXAsIHByZXNldFt0b29sLnVzZV9mb3JdKTtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VfcHJlc2V0cyhtcCwgcHJlc2V0W21wLnR5cGVdKTtcbiAgICAgICAgICAgIGxpc3QucHVzaChtcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3Rvb2xzJywgbGlzdCk7XG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAndG9vbCcsICdDdXJzb3InKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhlY19zY3JpcHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhlY19zY3JpcHQoYXJncykge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICYmIHRoaXMuc2V0dC5zY3JpcHRzKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmdldF9vdmVybGF5KGFyZ3NbMF0pO1xuICAgICAgICBpZiAoIW9iaiB8fCBvYmouc2NyaXB0cyA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBpZiAob2JqLnNjcmlwdCAmJiBvYmouc2NyaXB0LnNyYykge1xuICAgICAgICAgIGFyZ3NbMF0uc3JjID0gb2JqLnNjcmlwdC5zcmM7IC8vIG9wdCwgb3ZlcnJpZGUgdGhlIHNyY1xuICAgICAgICB9IC8vIFBhcnNlIHNjcmlwdCBwcm9wcyAmIGdldCB0aGUgdmFsdWVzIGZyb20gdGhlIG92XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB1bm5lY2Vzc2FyeSBzY3JpcHQgaW5pdGlhbGl6YXRpb25zXG5cblxuICAgICAgICB2YXIgcyA9IG9iai5zZXR0aW5ncztcbiAgICAgICAgdmFyIHByb3BzID0gYXJnc1swXS5zcmMucHJvcHMgfHwge307XG4gICAgICAgIGlmICghcy4kdXVpZCkgcy4kdXVpZCA9IFwiXCIuY29uY2F0KG9iai50eXBlLCBcIi1cIikuY29uY2F0KHV0aWxzLnV1aWQyKCkpO1xuICAgICAgICBhcmdzWzBdLnV1aWQgPSBzLiR1dWlkO1xuICAgICAgICBhcmdzWzBdLnNldHQgPSBzO1xuXG4gICAgICAgIGZvciAodmFyIGsgaW4gcHJvcHMgfHwge30pIHtcbiAgICAgICAgICB2YXIgcHJvdG8gPSBwcm9wc1trXTtcblxuICAgICAgICAgIGlmIChzW2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb3RvLnZhbCA9IHNba107IC8vIHVzZSB0aGUgZXhpc3RpbmcgdmFsXG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm90by5kZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogYWRkIHN1cHBvcnQgb2YgaW5mbyAvIGVycm9ycyB0byB0aGUgbGVnZW5kXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiT3ZlcmxheSBcIi5jb25jYXQob2JqLmlkLCBcIjogc2NyaXB0IHByb3AgJ1wiKS5jb25jYXQoaywgXCInIFwiKSArIFwiZG9lc24ndCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzW2tdID0gcHJvdG8udmFsID0gcHJvdG8uZGVmOyAvLyBzZXQgdGhlIGRlZmF1bHRcbiAgICAgICAgfSAvLyBSZW1vdmUgb2xkIHByb3BzIChkcm9wcGVkIGJ5IHRoZSBjdXJyZW50IGV4ZWMpXG5cblxuICAgICAgICBpZiAocy4kcHJvcHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIHMpIHtcbiAgICAgICAgICAgIGlmIChzLiRwcm9wcy5pbmNsdWRlcyhrKSAmJiAhKGsgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHMuJHByb3BzID0gT2JqZWN0LmtleXMoYXJnc1swXS5zcmMucHJvcHMgfHwge30pO1xuICAgICAgICB0aGlzLnR2LiRzZXQob2JqLCAnbG9hZGluZycsIHRydWUpO1xuICAgICAgICB2YXIgdGYgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0LmludGVydmFsX21zIHx8IHRoaXMuZGF0YS5jaGFydC50ZjtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy50di5nZXRSYW5nZSgpO1xuXG4gICAgICAgIGlmIChvYmouc2NyaXB0ICYmIG9iai5zY3JpcHQub3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgICBhcmdzWzBdLm91dHB1dCA9IG9iai5zY3JpcHQub3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53dy5qdXN0KCdleGVjLXNjcmlwdCcsIHtcbiAgICAgICAgICBzOiBhcmdzWzBdLFxuICAgICAgICAgIHRmOiB0ZixcbiAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4ZWNfYWxsX3NjcmlwdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhlY19hbGxfc2NyaXB0cygpIHtcbiAgICAgIGlmICghdGhpcy5zZXR0LnNjcmlwdHMpIHJldHVybjtcbiAgICAgIHRoaXMuc2V0X2xvYWRpbmcodHJ1ZSk7XG4gICAgICB2YXIgdGYgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0LmludGVydmFsX21zIHx8IHRoaXMuZGF0YS5jaGFydC50ZjtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMudHYuZ2V0UmFuZ2UoKTtcbiAgICAgIHRoaXMud3cuanVzdCgnZXhlYy1hbGwtc2NyaXB0cycsIHtcbiAgICAgICAgdGY6IHRmLFxuICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JpcHRzX29ucmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NyaXB0c19vbnJhbmdlKHIpIHtcbiAgICAgIGlmICghdGhpcy5zZXR0LnNjcmlwdHMpIHJldHVybjtcbiAgICAgIHZhciBkZWx0YSA9IHt9O1xuICAgICAgdGhpcy5nZXQoJy4nKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2LnNjcmlwdCAmJiB2LnNjcmlwdC5leGVjT25SYW5nZSAmJiB2LnNldHRpbmdzLiR1dWlkKSB7XG4gICAgICAgICAgLy8gVE9ETzogZXhlY0ludGVycnVwdCBmbGFnP1xuICAgICAgICAgIGlmICh1dGlscy5kZWxheWVkX2V4ZWModikpIHtcbiAgICAgICAgICAgIGRlbHRhW3Yuc2V0dGluZ3MuJHV1aWRdID0gdi5zZXR0aW5ncztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZGVsdGEpLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGYgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0LmludGVydmFsX21zIHx8IHRoaXMuZGF0YS5jaGFydC50ZjtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy50di5nZXRSYW5nZSgpO1xuICAgICAgICB0aGlzLnd3Lmp1c3QoJ3VwZGF0ZS1vdi1zZXR0aW5ncycsIHtcbiAgICAgICAgICBkZWx0YTogZGVsdGEsXG4gICAgICAgICAgdGY6IHRmLFxuICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIE92ZXJsYXkgbW9kaWZpY2F0aW9uIGZyb20gV1dcblxuICB9LCB7XG4gICAga2V5OiBcIm1vZGlmeV9vdmVybGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vZGlmeV9vdmVybGF5KHVwZCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0X292ZXJsYXkodXBkKTtcblxuICAgICAgaWYgKG9iaikge1xuICAgICAgICBmb3IgKHZhciBrIGluIHVwZC5maWVsZHMgfHwge30pIHtcbiAgICAgICAgICBpZiAodHlwZW9mX3R5cGVvZihvYmpba10pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5tZXJnZShcIlwiLmNvbmNhdCh1cGQudXVpZCwgXCIuXCIpLmNvbmNhdChrKSwgdXBkLmZpZWxkc1trXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHYuJHNldChvYmosIGssIHVwZC5maWVsZHNba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRhX2NoYW5nZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YV9jaGFuZ2VkKGFyZ3MpIHtcbiAgICAgIGlmICghdGhpcy5zZXR0LnNjcmlwdHMpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnNldHQuZGF0YV9jaGFuZ2VfZXhlYyA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgIHZhciBtYWluID0gdGhpcy5kYXRhLmNoYXJ0LmRhdGE7XG4gICAgICBpZiAodGhpcy53dy5fZGF0YV91cGxvYWRpbmcpIHJldHVybjtcbiAgICAgIGlmICghdGhpcy5zZV9zdGF0ZS5zY3JpcHRzKSByZXR1cm47XG4gICAgICB0aGlzLnNlbmRfbWV0YV8yX3d3KCk7XG4gICAgICB0aGlzLnd3Lmp1c3QoJ3VwbG9hZC1kYXRhJywge1xuICAgICAgICBvaGxjdjogbWFpblxuICAgICAgfSk7XG4gICAgICB0aGlzLnd3Ll9kYXRhX3VwbG9hZGluZyA9IHRydWU7XG4gICAgICB0aGlzLnNldF9sb2FkaW5nKHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRfbG9hZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRfbG9hZGluZyhmbGFnKSB7XG4gICAgICB2YXIgc2tyciA9IHRoaXMuZ2V0KCcuJykuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnNldHRpbmdzLiRwcm9wcztcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IGRjX2V2ZW50c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNrcnIpLFxuICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcyA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICB0aGlzLm1lcmdlKFwiXCIuY29uY2F0KHMuaWQpLCB7XG4gICAgICAgICAgICBsb2FkaW5nOiBmbGFnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kX21ldGFfMl93d1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kX21ldGFfMl93dygpIHtcbiAgICAgIHZhciB0ZiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuaW50ZXJ2YWxfbXMgfHwgdGhpcy5kYXRhLmNoYXJ0LnRmO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy50di5nZXRSYW5nZSgpO1xuICAgICAgdGhpcy53dy5qdXN0KCdzZW5kLW1ldGEtaW5mbycsIHtcbiAgICAgICAgdGY6IHRmLFxuICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZV9wcmVzZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlX3ByZXNldHMocHJvdG8sIHByZXNldCkge1xuICAgICAgaWYgKCFwcmVzZXQpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIgayBpbiBwcmVzZXQpIHtcbiAgICAgICAgaWYgKGsgPT09ICdzZXR0aW5ncycpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3RvW2tdLCBwcmVzZXRba10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW2tdID0gcHJlc2V0W2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyaWRfbW91c2Vkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyaWRfbW91c2Vkb3duKGFyZ3MpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBUT0RPOiB0b29sIHN0YXRlIGZpbmlzaGVkP1xuICAgICAgdGhpcy5vYmplY3Rfc2VsZWN0ZWQoW10pOyAvLyBSZW1vdmUgdGhlIHByZXZpb3VzIFJhbmdlVG9vbFxuXG4gICAgICB2YXIgcmVtID0gZnVuY3Rpb24gcmVtKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLmdldCgnUmFuZ2VUb29sJykuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHguc2V0dGluZ3Muc2hpZnRNb2RlO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5kZWwoeC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS50b29sICYmIHRoaXMuZGF0YS50b29sICE9PSAnQ3Vyc29yJyAmJiAhdGhpcy5kYXRhLmRyYXdpbmdNb2RlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgZnJvbSBcIm51bGxcIiB0b29scyAodG9vbCBjcmVhdGVkIHdpdGggSE9ETClcbiAgICAgICAgaWYgKGFyZ3NbMV0udHlwZSAhPT0gJ3RhcCcpIHtcbiAgICAgICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnZHJhd2luZ01vZGUnLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmJ1aWxkX3Rvb2woYXJnc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50di5zaG93VGhlVGlwKFwiPGI+SG9kbDwvYj4rPGI+RHJ1ZzwvYj4gdG8gY3JlYXRlLCBcIiArIFwiPGI+VGFwPC9iPiB0byBmaW5pc2ggYSB0b29sXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dC5zaGlmdF9tZWFzdXJlICYmIGFyZ3NbMV0uc2hpZnRLZXkpIHtcbiAgICAgICAgcmVtKCk7XG4gICAgICAgIHRoaXMudHYuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmJ1aWxkX3Rvb2woYXJnc1swXSwgJ1JhbmdlVG9vbDpTaGlmdE1vZGUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd2luZ19tb2RlX29mZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3aW5nX21vZGVfb2ZmKCkge1xuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ2RyYXdpbmdNb2RlJywgZmFsc2UpO1xuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3Rvb2wnLCAnQ3Vyc29yJyk7XG4gICAgfSAvLyBQbGFjZSBhIG5ldyB0b29sXG5cbiAgfSwge1xuICAgIGtleTogXCJidWlsZF90b29sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkX3Rvb2woZ3JpZF9pZCwgdHlwZSkge1xuICAgICAgdmFyIGxpc3QgPSB0aGlzLmRhdGEudG9vbHM7XG4gICAgICB0eXBlID0gdHlwZSB8fCB0aGlzLmRhdGEudG9vbDtcbiAgICAgIHZhciBwcm90byA9IGxpc3QuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50eXBlID09PSB0eXBlO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXByb3RvKSByZXR1cm47XG4gICAgICB2YXIgc2V0dCA9IE9iamVjdC5hc3NpZ24oe30sIHByb3RvLnNldHRpbmdzIHx8IHt9KTtcbiAgICAgIHZhciBkYXRhID0gKHByb3RvLmRhdGEgfHwgW10pLnNsaWNlKCk7XG4gICAgICBpZiAoISgnbGVnZW5kJyBpbiBzZXR0KSkgc2V0dC5sZWdlbmQgPSBmYWxzZTtcbiAgICAgIGlmICghKCd6LWluZGV4JyBpbiBzZXR0KSkgc2V0dFsnei1pbmRleCddID0gMTAwO1xuICAgICAgc2V0dC4kc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgc2V0dC4kc3RhdGUgPSAnd2lwJztcbiAgICAgIHZhciBzaWRlID0gZ3JpZF9pZCA/ICdvZmZjaGFydCcgOiAnb25jaGFydCc7XG4gICAgICB2YXIgaWQgPSB0aGlzLmFkZChzaWRlLCB7XG4gICAgICAgIG5hbWU6IHByb3RvLm5hbWUsXG4gICAgICAgIHR5cGU6IHR5cGUuc3BsaXQoJzonKVswXSxcbiAgICAgICAgc2V0dGluZ3M6IHNldHQsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBpZDogZ3JpZF9pZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNldHQuJHV1aWQgPSBcIlwiLmNvbmNhdChpZCwgXCItXCIpLmNvbmNhdCh1dGlscy5ub3coKSk7XG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnc2VsZWN0ZWQnLCBzZXR0LiR1dWlkKTtcbiAgICAgIHRoaXMuYWRkX3RyYXNoX2ljb24oKTtcbiAgICB9IC8vIFJlbW92ZSBzZWxlY3RlZCAvIFJlbW92ZSBhbGwsIGV0Y1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3lzdGVtX3Rvb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdGVtX3Rvb2wodHlwZSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JlbW92ZSc6XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kZWwodGhpcy5kYXRhLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlX3RyYXNoX2ljb24oKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd2luZ19tb2RlX29mZigpO1xuICAgICAgICAgICAgdGhpcy5vbl9zY3JvbGxfbG9jayhmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBBcHBseSBuZXcgb3ZlcmxheSBzZXR0aW5nc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhbmdlX3NldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZV9zZXR0aW5ncyhhcmdzKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBhcmdzWzBdO1xuICAgICAgZGVsZXRlIHNldHRpbmdzLmlkO1xuICAgICAgdmFyIGdyaWRfaWQgPSBhcmdzWzFdO1xuICAgICAgdGhpcy5tZXJnZShcIlwiLmNvbmNhdChhcmdzWzNdLCBcIi5zZXR0aW5nc1wiKSwgc2V0dGluZ3MpO1xuICAgIH0gLy8gTG9jayB0aGUgc2Nyb2xsaW5nIG1lY2hhbmlzbVxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fc2Nyb2xsX2xvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25fc2Nyb2xsX2xvY2soZmxhZykge1xuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3Njcm9sbExvY2snLCBmbGFnKTtcbiAgICB9IC8vIFdoZW4gbmV3IG9iamVjdCBpcyBzZWxlY3RlZCAvIHVuc2VsZWN0ZWRcblxuICB9LCB7XG4gICAga2V5OiBcIm9iamVjdF9zZWxlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvYmplY3Rfc2VsZWN0ZWQoYXJncykge1xuICAgICAgdmFyIHEgPSB0aGlzLmRhdGEuc2VsZWN0ZWQ7XG5cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgZHJhd2luZyBpcyBmaW5pc2hlZFxuICAgICAgICAvL2xldCByZXMgPSB0aGlzLmdldF9vbmUoYCR7cX0uc2V0dGluZ3NgKVxuICAgICAgICAvL2lmIChyZXMgJiYgcmVzLiRzdGF0ZSAhPT0gJ2ZpbmlzaGVkJykgcmV0dXJuXG4gICAgICAgIHRoaXMubWVyZ2UoXCJcIi5jb25jYXQocSwgXCIuc2V0dGluZ3NcIiksIHtcbiAgICAgICAgICAkc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZV90cmFzaF9pY29uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdzZWxlY3RlZCcsIG51bGwpO1xuICAgICAgaWYgKCFhcmdzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3NlbGVjdGVkJywgYXJnc1syXSk7XG4gICAgICB0aGlzLm1lcmdlKFwiXCIuY29uY2F0KGFyZ3NbMl0sIFwiLnNldHRpbmdzXCIpLCB7XG4gICAgICAgICRzZWxlY3RlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZF90cmFzaF9pY29uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZF90cmFzaF9pY29uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZF90cmFzaF9pY29uKCkge1xuICAgICAgdmFyIHR5cGUgPSAnU3lzdGVtOlJlbW92ZSc7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEudG9vbHMuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50eXBlID09PSB0eXBlO1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGEudG9vbHMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGljb246IGljb25zX25hbWVzcGFjZU9iamVjdFtcInRyYXNoLnBuZ1wiXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZV90cmFzaF9pY29uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZV90cmFzaF9pY29uKCkge1xuICAgICAgLy8gVE9ETzogRG9lcyBub3QgY2FsbCBUb29sYmFyIHJlbmRlciAoZGlzdHIgdmVyc2lvbilcbiAgICAgIHZhciB0eXBlID0gJ1N5c3RlbTpSZW1vdmUnO1xuICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMuZGF0YS50b29scywgdGhpcy5kYXRhLnRvb2xzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50eXBlICE9PSB0eXBlO1xuICAgICAgfSkpO1xuICAgIH0gLy8gU2V0IG92ZXJsYXkgZGF0YSBmcm9tIHRoZSB3ZWItd29ya2VyXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9vdmVybGF5X2RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25fb3ZlcmxheV9kYXRhKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLmdldCgnLicpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHguc2V0dGluZ3MuJHN5bnRoKSBfdGhpczQuZGVsKFwiXCIuY29uY2F0KHguaWQpKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IGRjX2V2ZW50c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEpLFxuICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3YgPSBfc3RlcDYudmFsdWU7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0X29uZShcIlwiLmNvbmNhdChvdi5pZCkpO1xuXG4gICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgdGhpcy50di4kc2V0KG9iaiwgJ2xvYWRpbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoIW92LmRhdGEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgb2JqLmRhdGEgPSBvdi5kYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb3YubmV3X292cykgY29udGludWU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpZCBpbiBvdi5uZXdfb3ZzLm9uY2hhcnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRfb25lKFwib25jaGFydC5cIi5jb25jYXQoaWQpKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkZCgnb25jaGFydCcsIG92Lm5ld19vdnMub25jaGFydFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGlkIGluIG92Lm5ld19vdnMub2ZmY2hhcnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRfb25lKFwib2ZmY2hhcnQuXCIuY29uY2F0KGlkKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGQoJ29mZmNoYXJ0Jywgb3YubmV3X292cy5vZmZjaGFydFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICB9XG4gICAgfSAvLyBQdXNoIG92ZXJsYXkgdXBkYXRlcyBmcm9tIHRoZSB3ZWItd29ya2VyXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9vdmVybGF5X3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9vdmVybGF5X3VwZGF0ZShkYXRhKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNyA9IGRjX2V2ZW50c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEpLFxuICAgICAgICAgIF9zdGVwNztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3YgPSBfc3RlcDcudmFsdWU7XG4gICAgICAgICAgaWYgKCFvdi5kYXRhKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXRfb25lKFwiXCIuY29uY2F0KG92LmlkKSk7XG5cbiAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICB0aGlzLmZhc3RfbWVyZ2Uob2JqLmRhdGEsIG92LmRhdGEsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjcuZigpO1xuICAgICAgfVxuICAgIH0gLy8gQ2xlYW4tdXAgdW5maW5pc2hlZCBidXNpbmVzcyAodG9vbHMpXG5cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVfZGVzdHJveSgpIHtcbiAgICAgIHZhciBmID0gZnVuY3Rpb24gZih4KSB7XG4gICAgICAgIHJldHVybiAheC5zZXR0aW5ncy4kc3RhdGUgfHwgeC5zZXR0aW5ncy4kc3RhdGUgPT09ICdmaW5pc2hlZCc7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmRhdGEub25jaGFydCA9IHRoaXMuZGF0YS5vbmNoYXJ0LmZpbHRlcihmKTtcbiAgICAgIHRoaXMuZGF0YS5vZmZjaGFydCA9IHRoaXMuZGF0YS5vZmZjaGFydC5maWx0ZXIoZik7XG4gICAgICB0aGlzLmRyYXdpbmdfbW9kZV9vZmYoKTtcbiAgICAgIHRoaXMub25fc2Nyb2xsX2xvY2soZmFsc2UpO1xuICAgICAgdGhpcy5vYmplY3Rfc2VsZWN0ZWQoW10pO1xuICAgICAgdGhpcy53dy5kZXN0cm95KCk7XG4gICAgfSAvLyBHZXQgb3ZlcmxheSBieSBncmlkLWxheWVyIGlkXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRfb3ZlcmxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfb3ZlcmxheShvYmopIHtcbiAgICAgIHZhciBpZCA9IG9iai5pZCB8fCBcImdcIi5jb25jYXQob2JqLmdyaWRfaWQsIFwiX1wiKS5jb25jYXQob2JqLmxheWVyX2lkKTtcbiAgICAgIHZhciBkY2lkID0gb2JqLnV1aWQgfHwgdGhpcy5nbGRjW2lkXTtcbiAgICAgIHJldHVybiB0aGlzLmdldF9vbmUoXCJcIi5jb25jYXQoZGNpZCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEQ0V2ZW50cztcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy9kY19jb3JlLmpzXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBkY19jb3JlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBkY19jb3JlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBkY19jb3JlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gZGNfY29yZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gZGNfY29yZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gZGNfY29yZV9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBkY19jb3JlX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBkY19jb3JlX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGRjX2NvcmVfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLy8gRGF0YUN1YmUgXCJwcml2YXRlXCIgbWV0aG9kc1xuXG5cblxuXG52YXIgRENDb3JlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRENFdmVudHMpIHtcbiAgX2luaGVyaXRzKERDQ29yZSwgX0RDRXZlbnRzKTtcblxuICB2YXIgX3N1cGVyID0gZGNfY29yZV9jcmVhdGVTdXBlcihEQ0NvcmUpO1xuXG4gIGZ1bmN0aW9uIERDQ29yZSgpIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBEQ0NvcmUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoRENDb3JlLCBbe1xuICAgIGtleTogXCJpbml0X3R2anNcIixcbiAgICB2YWx1ZTogLy8gU2V0IFRWIGluc3RhbmNlIChvbmNlKS4gQ2FsbGVkIGJ5IFRyYWRpbmdWdWUgaXRzZWxmXG4gICAgZnVuY3Rpb24gaW5pdF90dmpzKCRyb290KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMudHYpIHtcbiAgICAgICAgdGhpcy50diA9ICRyb290O1xuICAgICAgICB0aGlzLmluaXRfZGF0YSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZV9pZHMoKTsgLy8gTGlzdGVuIHRvIGFsbCBzZXR0aW5nIGNoYW5nZXNcbiAgICAgICAgLy8gVE9ETzogd29ya3Mgb25seSB3aXRoIG1lcmdlKClcblxuICAgICAgICB0aGlzLnR2LiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmdldF9ieV9xdWVyeSgnLnNldHRpbmdzJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChuLCBwKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm9uX3NldHRpbmdzKG4sIHApO1xuICAgICAgICB9KTsgLy8gTGlzdGVuIHRvIGFsbCBpbmRpY2VzIGNoYW5nZXNcblxuICAgICAgICB0aGlzLnR2LiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmdldCgnLicpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHguc2V0dGluZ3MuJHV1aWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChuLCBwKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm9uX2lkc19jaGFuZ2VkKG4sIHApO1xuICAgICAgICB9KTsgLy8gV2F0Y2ggZm9yIGFsbCAnZGF0YXNldHMnIGNoYW5nZXNcblxuICAgICAgICB0aGlzLnR2LiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmdldCgnZGF0YXNldHMnKTtcbiAgICAgICAgfSwgRGF0YXNldC53YXRjaGVyLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0gLy8gSW5pdCBEYXRhIFN0cnVjdHVyZSB2MS4xXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0X2RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdF9kYXRhKCRyb290KSB7XG4gICAgICBpZiAoISgnY2hhcnQnIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ2NoYXJ0Jywge1xuICAgICAgICAgIHR5cGU6ICdDYW5kbGVzJyxcbiAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEub2hsY3YgfHwgW11cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKCdvbmNoYXJ0JyBpbiB0aGlzLmRhdGEpKSB7XG4gICAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdvbmNoYXJ0JywgW10pO1xuICAgICAgfVxuXG4gICAgICBpZiAoISgnb2ZmY2hhcnQnIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ29mZmNoYXJ0JywgW10pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5jaGFydC5zZXR0aW5ncykge1xuICAgICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLmNoYXJ0LCAnc2V0dGluZ3MnLCB7fSk7XG4gICAgICB9IC8vIFJlbW92ZSBvaGxjdiBjdXogd2UgaGF2ZSBEYXRhIHYxLjFeXG5cblxuICAgICAgZGVsZXRlIHRoaXMuZGF0YS5vaGxjdjtcblxuICAgICAgaWYgKCEoJ2RhdGFzZXRzJyBpbiB0aGlzLmRhdGEpKSB7XG4gICAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdkYXRhc2V0cycsIFtdKTtcbiAgICAgIH0gLy8gSW5pdCBkYXRhc2V0IHByb3hpZXNcblxuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gZGNfY29yZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZGF0YS5kYXRhc2V0cyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGRzID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKCF0aGlzLmRzcykgdGhpcy5kc3MgPSB7fTtcbiAgICAgICAgICB0aGlzLmRzc1tkcy5pZF0gPSBuZXcgRGF0YXNldCh0aGlzLCBkcyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9IC8vIFJhbmdlIGNoYW5nZSBjYWxsYmFjayAoY2FsbGVkIGJ5IFRyYWRpbmdWdWUpXG4gICAgLy8gVE9ETzogaW1wcm92ZSAocmVsaWFibGl0eSArIGNodW5rIHdpdGggbGltaXRlZCBzaXplKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VfY2hhbmdlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JhbmdlX2NoYW5nZWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yX2RlZmF1bHQoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmFuZ2UsIHRmLCBjaGVjaykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgZmlyc3QsIHByb207XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvcl9kZWZhdWx0KCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2sgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLmRhdGEuY2hhcnQuZGF0YVswXVswXTtcblxuICAgICAgICAgICAgICAgIGlmICghKHJhbmdlWzBdIDwgZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5wYXVzZSgyNTApO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAvLyBMb2FkIGJpZ2dlciBjaHVua3NcbiAgICAgICAgICAgICAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCk7IC8vIGNvcHlcblxuICAgICAgICAgICAgICAgIHJhbmdlWzBdID0gTWF0aC5mbG9vcihyYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBNYXRoLmZsb29yKGZpcnN0KTtcbiAgICAgICAgICAgICAgICBwcm9tID0gdGhpcy5sb2FkZXIocmFuZ2UsIHRmLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2sgd2F5XG4gICAgICAgICAgICAgICAgICBfdGhpczIuY2h1bmtfbG9hZGVkKGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEocHJvbSAmJiBwcm9tLnRoZW4pKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9tO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAuY2h1bmtfbG9hZGVkLmNhbGwoX2NvbnRleHQudDAsIF9jb250ZXh0LnQxKTtcblxuICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgIGlmICghY2hlY2spIHRoaXMubGFzdF9jaHVuayA9IFtyYW5nZSwgdGZdO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJhbmdlX2NoYW5nZWQoX3gsIF94MiwgX3gzKSB7XG4gICAgICAgIHJldHVybiBfcmFuZ2VfY2hhbmdlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2VfY2hhbmdlZDtcbiAgICB9KCkgLy8gQSBuZXcgY2h1bmsgb2YgZGF0YSBpcyBsb2FkZWRcbiAgICAvLyBUT0RPOiBidWxsZXRwcm9vZiBmZXRjaFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2h1bmtfbG9hZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNodW5rX2xvYWRlZChkYXRhKSB7XG4gICAgICAvLyBVcGRhdGVzIG9ubHkgY2FuZGxlc3RpY2sgZGF0YSwgb3JcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHRoaXMubWVyZ2UoJ2NoYXJ0LmRhdGEnLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJ1bmNoIG9mIG92ZXJsYXlzLCBpbmNsdWRpbmcgY2hhcnQuZGF0YVxuICAgICAgICBmb3IgKHZhciBrIGluIGRhdGEpIHtcbiAgICAgICAgICB0aGlzLm1lcmdlKGssIGRhdGFba10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5sYXN0X2NodW5rKSB7XG4gICAgICAgIHRoaXMucmFuZ2VfY2hhbmdlZC5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5sYXN0X2NodW5rKS5jb25jYXQoW3RydWVdKSk7XG4gICAgICAgIHRoaXMubGFzdF9jaHVuayA9IG51bGw7XG4gICAgICB9XG4gICAgfSAvLyBVcGRhdGUgaWRzIGZvciBhbGwgb3ZlcmxheXNcblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZV9pZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlX2lkcygpIHtcbiAgICAgIHRoaXMuZGF0YS5jaGFydC5pZCA9IFwiY2hhcnQuXCIuY29uY2F0KHRoaXMuZGF0YS5jaGFydC50eXBlKTtcbiAgICAgIHZhciBjb3VudCA9IHt9OyAvLyBncmlkX2lkLGxheWVyX2lkID0+IERDIGlkIG1hcHBpbmdcblxuICAgICAgdGhpcy5nbGRjID0ge30sIHRoaXMuZGNnbCA9IHt9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IGRjX2NvcmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmRhdGEub25jaGFydCksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvdiA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIGlmIChjb3VudFtvdi50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb3VudFtvdi50eXBlXSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGkgPSBjb3VudFtvdi50eXBlXSsrO1xuICAgICAgICAgIG92LmlkID0gXCJvbmNoYXJ0LlwiLmNvbmNhdChvdi50eXBlKS5jb25jYXQoaSk7XG4gICAgICAgICAgaWYgKCFvdi5uYW1lKSBvdi5uYW1lID0gb3YudHlwZSArIFwiIFwiLmNvbmNhdChpKTtcbiAgICAgICAgICBpZiAoIW92LnNldHRpbmdzKSB0aGlzLnR2LiRzZXQob3YsICdzZXR0aW5ncycsIHt9KTsgLy8gZ3JpZF9pZCxsYXllcl9pZCA9PiBEQyBpZCBtYXBwaW5nXG5cbiAgICAgICAgICB0aGlzLmdsZGNbXCJnMF9cIi5jb25jYXQob3YudHlwZSwgXCJfXCIpLmNvbmNhdChpKV0gPSBvdi5pZDtcbiAgICAgICAgICB0aGlzLmRjZ2xbb3YuaWRdID0gXCJnMF9cIi5jb25jYXQob3YudHlwZSwgXCJfXCIpLmNvbmNhdChpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIGNvdW50ID0ge307XG4gICAgICB2YXIgZ3JpZHMgPSBbe31dO1xuICAgICAgdmFyIGdpZCA9IDA7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gZGNfY29yZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZGF0YS5vZmZjaGFydCksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvdiA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIGlmIChjb3VudFtvdi50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb3VudFtvdi50eXBlXSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9pID0gY291bnRbb3YudHlwZV0rKztcblxuICAgICAgICAgIG92LmlkID0gXCJvZmZjaGFydC5cIi5jb25jYXQob3YudHlwZSkuY29uY2F0KF9pKTtcbiAgICAgICAgICBpZiAoIW92Lm5hbWUpIG92Lm5hbWUgPSBvdi50eXBlICsgXCIgXCIuY29uY2F0KF9pKTtcbiAgICAgICAgICBpZiAoIW92LnNldHRpbmdzKSB0aGlzLnR2LiRzZXQob3YsICdzZXR0aW5ncycsIHt9KTsgLy8gZ3JpZF9pZCxsYXllcl9pZCA9PiBEQyBpZCBtYXBwaW5nXG5cbiAgICAgICAgICBnaWQrKztcbiAgICAgICAgICB2YXIgcmdpZCA9IChvdi5ncmlkIHx8IHt9KS5pZCB8fCBnaWQ7IC8vIHJlYWwgZ3JpZF9pZFxuICAgICAgICAgIC8vIFdoZW4gd2UgbWVyZ2UgZ3JpZCwgc2tpcCArK1xuXG4gICAgICAgICAgaWYgKChvdi5ncmlkIHx8IHt9KS5pZCkgZ2lkLS07XG4gICAgICAgICAgaWYgKCFncmlkc1tyZ2lkXSkgZ3JpZHNbcmdpZF0gPSB7fTtcblxuICAgICAgICAgIGlmIChncmlkc1tyZ2lkXVtvdi50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBncmlkc1tyZ2lkXVtvdi50eXBlXSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJpID0gZ3JpZHNbcmdpZF1bb3YudHlwZV0rKztcbiAgICAgICAgICB0aGlzLmdsZGNbXCJnXCIuY29uY2F0KHJnaWQsIFwiX1wiKS5jb25jYXQob3YudHlwZSwgXCJfXCIpLmNvbmNhdChyaSldID0gb3YuaWQ7XG4gICAgICAgICAgdGhpcy5kY2dsW292LmlkXSA9IFwiZ1wiLmNvbmNhdChyZ2lkLCBcIl9cIikuY29uY2F0KG92LnR5cGUsIFwiX1wiKS5jb25jYXQocmkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cbiAgICB9IC8vIFRPRE86IGNoYXJ0IHJlZmluZSAoZnJvbSB0aGUgZXhjaGFuZ2UgY2hhcnQpXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVfY2FuZGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZV9jYW5kbGUoZGF0YSkge1xuICAgICAgdmFyIG9obGN2ID0gdGhpcy5kYXRhLmNoYXJ0LmRhdGE7XG4gICAgICB2YXIgbGFzdCA9IG9obGN2W29obGN2Lmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGNhbmRsZSA9IGRhdGFbJ2NhbmRsZSddO1xuICAgICAgdmFyIHRmID0gdGhpcy50di4kcmVmcy5jaGFydC5pbnRlcnZhbF9tcztcbiAgICAgIHZhciB0X25leHQgPSBsYXN0WzBdICsgdGY7XG4gICAgICB2YXIgbm93ID0gZGF0YS50IHx8IHV0aWxzLm5vdygpO1xuICAgICAgdmFyIHQgPSBub3cgPj0gdF9uZXh0ID8gbm93IC0gbm93ICUgdGYgOiBsYXN0WzBdOyAvLyBVcGRhdGUgdGhlIGVudGlyZSBjYW5kbGVcblxuICAgICAgaWYgKGNhbmRsZS5sZW5ndGggPj0gNikge1xuICAgICAgICB0ID0gY2FuZGxlWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGxlID0gW3RdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2FuZGxlKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWdnLnB1c2goJ29obGN2JywgY2FuZGxlKTtcbiAgICAgIHRoaXMudXBkYXRlX292ZXJsYXlzKGRhdGEsIHQsIHRmKTtcbiAgICAgIHJldHVybiB0ID49IHRfbmV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlX3RpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlX3RpY2soZGF0YSkge1xuICAgICAgdmFyIG9obGN2ID0gdGhpcy5kYXRhLmNoYXJ0LmRhdGE7XG4gICAgICB2YXIgbGFzdCA9IG9obGN2W29obGN2Lmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHRpY2sgPSBkYXRhWydwcmljZSddO1xuICAgICAgdmFyIHZvbHVtZSA9IGRhdGFbJ3ZvbHVtZSddIHx8IDA7XG4gICAgICB2YXIgdGYgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0LmludGVydmFsX21zO1xuXG4gICAgICBpZiAoIXRmKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ0RlZmluZSB0aGUgbWFpbiB0aW1lZnJhbWUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vdyA9IGRhdGEudCB8fCB1dGlscy5ub3coKTtcbiAgICAgIGlmICghbGFzdCkgbGFzdCA9IFtub3cgLSBub3cgJSB0Zl07XG4gICAgICB2YXIgdF9uZXh0ID0gbGFzdFswXSArIHRmO1xuICAgICAgdmFyIHQgPSBub3cgPj0gdF9uZXh0ID8gbm93IC0gbm93ICUgdGYgOiBsYXN0WzBdO1xuXG4gICAgICBpZiAoKHQgPj0gdF9uZXh0IHx8ICFvaGxjdi5sZW5ndGgpICYmIHRpY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBBbmQgbmV3IHplcm8taGVpZ2h0IGNhbmRsZVxuICAgICAgICB2YXIgbmMgPSBbdCwgdGljaywgdGljaywgdGljaywgdGljaywgdm9sdW1lXTtcbiAgICAgICAgdGhpcy5hZ2cucHVzaCgnb2hsY3YnLCBuYywgdGYpO1xuICAgICAgICBvaGxjdi5wdXNoKG5jKTtcbiAgICAgICAgdGhpcy5zY3JvbGxfdG8odCk7XG4gICAgICB9IGVsc2UgaWYgKHRpY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBVcGRhdGUgYW4gZXhpc3Rpbmcgb25lXG4gICAgICAgIC8vIFRPRE86IG1ha2UgYSBzZXBhcmF0ZSBjbGFzcyBTYW1wbGVyXG4gICAgICAgIGxhc3RbMl0gPSBNYXRoLm1heCh0aWNrLCBsYXN0WzJdKTtcbiAgICAgICAgbGFzdFszXSA9IE1hdGgubWluKHRpY2ssIGxhc3RbM10pO1xuICAgICAgICBsYXN0WzRdID0gdGljaztcbiAgICAgICAgbGFzdFs1XSArPSB2b2x1bWU7XG4gICAgICAgIHRoaXMuYWdnLnB1c2goJ29obGN2JywgbGFzdCwgdGYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZV9vdmVybGF5cyhkYXRhLCB0LCB0Zik7XG4gICAgICByZXR1cm4gdCA+PSB0X25leHQ7XG4gICAgfSAvLyBVcGRhdGVzIGFsbCBvdmVybGF5cyB3aXRoIGdpdmVuIHZhbHVlcy5cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZV9vdmVybGF5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVfb3ZlcmxheXMoZGF0YSwgdCwgdGYpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gZGF0YSkge1xuICAgICAgICBpZiAoayA9PT0gJ3ByaWNlJyB8fCBrID09PSAndm9sdW1lJyB8fCBrID09PSAnY2FuZGxlJyB8fCBrID09PSAndCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrLmluY2x1ZGVzKCdkYXRhc2V0cy4nKSkge1xuICAgICAgICAgIHRoaXMuYWdnLnB1c2goaywgZGF0YVtrXSwgdGYpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGFba10pKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IFtkYXRhW2tdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSBkYXRhW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrLmluY2x1ZGVzKCcuZGF0YScpKSBrICs9ICcuZGF0YSc7XG4gICAgICAgIHRoaXMuYWdnLnB1c2goaywgW3RdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmFsKSksIHRmKTtcbiAgICAgIH1cbiAgICB9IC8vIFJldHVybnMgYXJyYXkgb2Ygb2JqZWN0cyBtYXRjaGluZyBxdWVyeS5cbiAgICAvLyBPYmplY3QgY29udGFpbnMgeyBwYXJlbnQsIGluZGV4LCB2YWx1ZSB9XG4gICAgLy8gVE9ETzogcXVlcnkgY2FjaGluZ1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0X2J5X3F1ZXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9ieV9xdWVyeShxdWVyeSwgY2h1Y2spIHtcbiAgICAgIHZhciB0dXBsZSA9IHF1ZXJ5LnNwbGl0KCcuJyk7XG5cbiAgICAgIHN3aXRjaCAodHVwbGVbMF0pIHtcbiAgICAgICAgY2FzZSAnY2hhcnQnOlxuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNoYXJ0X2FzX3Bpdih0dXBsZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnb25jaGFydCc6XG4gICAgICAgIGNhc2UgJ29mZmNoYXJ0JzpcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLnF1ZXJ5X3NlYXJjaChxdWVyeSwgdHVwbGUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RhdGFzZXRzJzpcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLnF1ZXJ5X3NlYXJjaChxdWVyeSwgdHVwbGUpO1xuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBkY19jb3JlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocmVzdWx0KSxcbiAgICAgICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciByID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmIChyLmkgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIHIudiA9IHRoaXMuZHNzW3IucC5pZF0uZGF0YSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvKiBTaG91bGQgZ2V0KCcuJykgcmV0dXJuIGFsc28gdGhlIGNoYXJ0PyAqL1xuXG4gICAgICAgICAgLypsZXQgY2ggPSB0aGlzLmNoYXJ0X2FzX3F1ZXJ5KFtcbiAgICAgICAgICAgICAgJ2NoYXJ0JyxcbiAgICAgICAgICAgICAgdHVwbGVbMV1cbiAgICAgICAgICBdKSovXG4gICAgICAgICAgdmFyIG9uID0gdGhpcy5xdWVyeV9zZWFyY2gocXVlcnksIFsnb25jaGFydCcsIHR1cGxlWzBdLCB0dXBsZVsxXV0pO1xuICAgICAgICAgIHZhciBvZmYgPSB0aGlzLnF1ZXJ5X3NlYXJjaChxdWVyeSwgWydvZmZjaGFydCcsIHR1cGxlWzBdLCB0dXBsZVsxXV0pO1xuICAgICAgICAgIHJlc3VsdCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkob24pLCBfdG9Db25zdW1hYmxlQXJyYXkob2ZmKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiAhKHgudiB8fCB7fSkubG9ja2VkIHx8IGNodWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoYXJ0X2FzX3BpdlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFydF9hc19waXYodHVwbGUpIHtcbiAgICAgIHZhciBmaWVsZCA9IHR1cGxlWzFdO1xuICAgICAgaWYgKGZpZWxkKSByZXR1cm4gW3tcbiAgICAgICAgcDogdGhpcy5kYXRhLmNoYXJ0LFxuICAgICAgICBpOiBmaWVsZCxcbiAgICAgICAgdjogdGhpcy5kYXRhLmNoYXJ0W2ZpZWxkXVxuICAgICAgfV07ZWxzZSByZXR1cm4gW3tcbiAgICAgICAgcDogdGhpcy5kYXRhLFxuICAgICAgICBpOiAnY2hhcnQnLFxuICAgICAgICB2OiB0aGlzLmRhdGEuY2hhcnRcbiAgICAgIH1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWVyeV9zZWFyY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcXVlcnlfc2VhcmNoKHF1ZXJ5LCB0dXBsZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBzaWRlID0gdHVwbGVbMF07XG4gICAgICB2YXIgcGF0aCA9IHR1cGxlWzFdIHx8ICcnO1xuICAgICAgdmFyIGZpZWxkID0gdHVwbGVbMl07XG4gICAgICB2YXIgYXJyID0gdGhpcy5kYXRhW3NpZGVdLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5pZCA9PT0gcXVlcnkgfHwgeC5pZCAmJiB4LmlkLmluY2x1ZGVzKHBhdGgpIHx8IHgubmFtZSA9PT0gcXVlcnkgfHwgeC5uYW1lICYmIHgubmFtZS5pbmNsdWRlcyhwYXRoKSB8fCBxdWVyeS5pbmNsdWRlcygoeC5zZXR0aW5ncyB8fCB7fSkuJHV1aWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwOiB4LFxuICAgICAgICAgICAgaTogZmllbGQsXG4gICAgICAgICAgICB2OiB4W2ZpZWxkXVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHA6IF90aGlzMy5kYXRhW3NpZGVdLFxuICAgICAgICAgIGk6IF90aGlzMy5kYXRhW3NpZGVdLmluZGV4T2YoeCksXG4gICAgICAgICAgdjogeFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlX29iamVjdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2Vfb2JqZWN0cyhvYmosIGRhdGEsIG5ld19vYmopIHtcbiAgICAgIGlmIChuZXdfb2JqID09PSB2b2lkIDApIHtcbiAgICAgICAgbmV3X29iaiA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gZ2V0IFZ1ZSB0byB1cGRhdGUgYWxsIHN0dWZmXG4gICAgICAvLyByZWFjdGl2ZWx5IGlzIHRvIGNyZWF0ZSBhIGJyYW5kIG5ldyBvYmplY3QuXG4gICAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIHNpbXBsZXIgYXBwcm9hY2g/XG4gICAgICBPYmplY3QuYXNzaWduKG5ld19vYmosIG9iai52KTtcbiAgICAgIE9iamVjdC5hc3NpZ24obmV3X29iaiwgZGF0YSk7XG4gICAgICB0aGlzLnR2LiRzZXQob2JqLnAsIG9iai5pLCBuZXdfb2JqKTtcbiAgICB9IC8vIE1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgc2VyaWVzXG5cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZV90c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZV90cyhvYmosIGRhdGEpIHtcbiAgICAgIC8vIEFzc3VtZSB0aGF0IGJvdGggYXJyYXlzIGFyZSBwcmUtc29ydGVkXG4gICAgICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm4gb2JqLnY7XG4gICAgICB2YXIgcjEgPSBbb2JqLnZbMF1bMF0sIG9iai52W29iai52Lmxlbmd0aCAtIDFdWzBdXTtcbiAgICAgIHZhciByMiA9IFtkYXRhWzBdWzBdLCBkYXRhW2RhdGEubGVuZ3RoIC0gMV1bMF1dOyAvLyBPdmVybGFwXG5cbiAgICAgIHZhciBvID0gW01hdGgubWF4KHIxWzBdLCByMlswXSksIE1hdGgubWluKHIxWzFdLCByMlsxXSldO1xuXG4gICAgICBpZiAob1sxXSA+PSBvWzBdKSB7XG4gICAgICAgIHZhciBfb2JqJHYsIF9kYXRhO1xuXG4gICAgICAgIHZhciBfdGhpcyR0c19vdmVybGFwID0gdGhpcy50c19vdmVybGFwKG9iai52LCBkYXRhLCBvKSxcbiAgICAgICAgICAgIG9kID0gX3RoaXMkdHNfb3ZlcmxhcC5vZCxcbiAgICAgICAgICAgIGQxID0gX3RoaXMkdHNfb3ZlcmxhcC5kMSxcbiAgICAgICAgICAgIGQyID0gX3RoaXMkdHNfb3ZlcmxhcC5kMjtcblxuICAgICAgICAoX29iaiR2ID0gb2JqLnYpLnNwbGljZS5hcHBseShfb2JqJHYsIF90b0NvbnN1bWFibGVBcnJheShkMSkpO1xuXG4gICAgICAgIChfZGF0YSA9IGRhdGEpLnNwbGljZS5hcHBseShfZGF0YSwgX3RvQ29uc3VtYWJsZUFycmF5KGQyKSk7IC8vIERzdCA9PT0gT3ZlcmxhcCA9PT0gU3JjXG5cblxuICAgICAgICBpZiAoIW9iai52Lmxlbmd0aCAmJiAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnR2LiRzZXQob2JqLnAsIG9iai5pLCBvZCk7XG4gICAgICAgICAgcmV0dXJuIG9iai52O1xuICAgICAgICB9IC8vIElmIHNyYyBpcyB0b3RhbGx5IGNvbnRhaW5lZCBpbiBkc3RcblxuXG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBkYXRhID0gb2JqLnYuc3BsaWNlKGQxWzBdKTtcbiAgICAgICAgfSAvLyBJZiBkc3QgaXMgdG90YWxseSBjb250YWluZWQgaW4gc3JjXG5cblxuICAgICAgICBpZiAoIW9iai52Lmxlbmd0aCkge1xuICAgICAgICAgIG9iai52ID0gZGF0YS5zcGxpY2UoZDJbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50di4kc2V0KG9iai5wLCBvYmouaSwgdGhpcy5jb21iaW5lKG9iai52LCBvZCwgZGF0YSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50di4kc2V0KG9iai5wLCBvYmouaSwgdGhpcy5jb21iaW5lKG9iai52LCBbXSwgZGF0YSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqLnY7XG4gICAgfSAvLyBUT0RPOiByZXZpZXcgcGVyZm9ybWFuY2UsIG1vdmUgdG8gd29ya2VyXG5cbiAgfSwge1xuICAgIGtleTogXCJ0c19vdmVybGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRzX292ZXJsYXAoYXJyMSwgYXJyMiwgcmFuZ2UpIHtcbiAgICAgIHZhciB0MSA9IHJhbmdlWzBdO1xuICAgICAgdmFyIHQyID0gcmFuZ2VbMV07XG4gICAgICB2YXIgdHMgPSB7fTsgLy8gdGltZXN0YW1wIG1hcFxuXG4gICAgICB2YXIgYTEgPSBhcnIxLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFswXSA+PSB0MSAmJiB4WzBdIDw9IHQyO1xuICAgICAgfSk7XG4gICAgICB2YXIgYTIgPSBhcnIyLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFswXSA+PSB0MSAmJiB4WzBdIDw9IHQyO1xuICAgICAgfSk7IC8vIEluZGljZXMgb2Ygc2VnbWVudHNcblxuICAgICAgdmFyIGlkMTEgPSBhcnIxLmluZGV4T2YoYTFbMF0pO1xuICAgICAgdmFyIGlkMTIgPSBhcnIxLmluZGV4T2YoYTFbYTEubGVuZ3RoIC0gMV0pO1xuICAgICAgdmFyIGlkMjEgPSBhcnIyLmluZGV4T2YoYTJbMF0pO1xuICAgICAgdmFyIGlkMjIgPSBhcnIyLmluZGV4T2YoYTJbYTIubGVuZ3RoIC0gMV0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGExLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRzW2ExW2ldWzBdXSA9IGExW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRzW2EyW2ldWzBdXSA9IGEyW2ldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHNfc29ydGVkID0gT2JqZWN0LmtleXModHMpLnNvcnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9kOiB0c19zb3J0ZWQubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHRzW3hdO1xuICAgICAgICB9KSxcbiAgICAgICAgZDE6IFtpZDExLCBpZDEyIC0gaWQxMSArIDFdLFxuICAgICAgICBkMjogW2lkMjEsIGlkMjIgLSBpZDIxICsgMV1cbiAgICAgIH07XG4gICAgfSAvLyBDb21iaW5lIHBhcnRzIHRvZ2V0aGVyOlxuICAgIC8vIChkZXN0aW5hdGlvbiwgb3ZlcmxhcCwgc291cmNlKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tYmluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21iaW5lKGRzdCwgbywgc3JjKSB7XG4gICAgICBmdW5jdGlvbiBsYXN0KGFycikge1xuICAgICAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkc3QubGVuZ3RoKSB7XG4gICAgICAgIGRzdCA9IG87XG4gICAgICAgIG8gPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzcmMubGVuZ3RoKSB7XG4gICAgICAgIHNyYyA9IG87XG4gICAgICAgIG8gPSBbXTtcbiAgICAgIH0gLy8gVGhlIG92ZXJsYXAgcmlnaHQgaW4gdGhlIG1pZGRsZVxuXG5cbiAgICAgIGlmIChzcmNbMF1bMF0gPj0gZHN0WzBdWzBdICYmIGxhc3Qoc3JjKSA8PSBsYXN0KGRzdCkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZHN0LCBvKTsgLy8gVGhlIG92ZXJsYXAgaXMgb24gdGhlIHJpZ2h0XG4gICAgICB9IGVsc2UgaWYgKGxhc3Qoc3JjKSA+IGxhc3QoZHN0KSkge1xuICAgICAgICAvLyBQc2goLi4uKSBpcyBmYXN0ZXIgYnV0IGNhbiBvdmVyZmxvdyB0aGUgc3RhY2tcbiAgICAgICAgaWYgKG8ubGVuZ3RoIDwgMTAwMDAwICYmIHNyYy5sZW5ndGggPCAxMDAwMDApIHtcbiAgICAgICAgICB2YXIgX2RzdDtcblxuICAgICAgICAgIChfZHN0ID0gZHN0KS5wdXNoLmFwcGx5KF9kc3QsIF90b0NvbnN1bWFibGVBcnJheShvKS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHNyYykpKTtcblxuICAgICAgICAgIHJldHVybiBkc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRzdC5jb25jYXQobywgc3JjKTtcbiAgICAgICAgfSAvLyBUaGUgb3ZlcmxhcCBpcyBvbiB0aGUgbGVmdFxuXG4gICAgICB9IGVsc2UgaWYgKHNyY1swXVswXSA8IGRzdFswXVswXSkge1xuICAgICAgICAvLyBQdXNoKC4uLikgaXMgZmFzdGVyIGJ1dCBjYW4gb3ZlcmZsb3cgdGhlIHN0YWNrXG4gICAgICAgIGlmIChvLmxlbmd0aCA8IDEwMDAwMCAmJiBzcmMubGVuZ3RoIDwgMTAwMDAwKSB7XG4gICAgICAgICAgdmFyIF9zcmM7XG5cbiAgICAgICAgICAoX3NyYyA9IHNyYykucHVzaC5hcHBseShfc3JjLCBfdG9Db25zdW1hYmxlQXJyYXkobykuY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShkc3QpKSk7XG5cbiAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzcmMuY29uY2F0KG8sIGRzdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9IC8vIFNpbXBsZSBkYXRhLXBvaW50IG1lcmdlIChmYXN0ZXIpXG5cbiAgfSwge1xuICAgIGtleTogXCJmYXN0X21lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhc3RfbWVyZ2UoZGF0YSwgcG9pbnQsIG1haW4pIHtcbiAgICAgIGlmIChtYWluID09PSB2b2lkIDApIHtcbiAgICAgICAgbWFpbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuICAgICAgdmFyIGxhc3RfdCA9IChkYXRhW2RhdGEubGVuZ3RoIC0gMV0gfHwgW10pWzBdO1xuICAgICAgdmFyIHVwZF90ID0gcG9pbnRbMF07XG5cbiAgICAgIGlmICghZGF0YS5sZW5ndGggfHwgdXBkX3QgPiBsYXN0X3QpIHtcbiAgICAgICAgZGF0YS5wdXNoKHBvaW50KTtcblxuICAgICAgICBpZiAobWFpbiAmJiB0aGlzLnNldHQuYXV0b19zY3JvbGwpIHtcbiAgICAgICAgICB0aGlzLnNjcm9sbF90byh1cGRfdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodXBkX3QgPT09IGxhc3RfdCkge1xuICAgICAgICBpZiAobWFpbikge1xuICAgICAgICAgIHRoaXMudHYuJHNldChkYXRhLCBkYXRhLmxlbmd0aCAtIDEsIHBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JvbGxfdG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsX3RvKHQpIHtcbiAgICAgIGlmICh0aGlzLnR2LiRyZWZzLmNoYXJ0LmN1cnNvci5sb2NrZWQpIHJldHVybjtcbiAgICAgIHZhciBsYXN0ID0gdGhpcy50di4kcmVmcy5jaGFydC5sYXN0X2NhbmRsZTtcbiAgICAgIGlmICghbGFzdCkgcmV0dXJuO1xuICAgICAgdmFyIHRsID0gbGFzdFswXTtcbiAgICAgIHZhciBkID0gdGhpcy50di5nZXRSYW5nZSgpWzFdIC0gdGw7XG4gICAgICBpZiAoZCA+IDApIHRoaXMudHZbXCJnb3RvXCJdKHQgKyBkKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRENDb3JlO1xufShEQ0V2ZW50cyk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvc2V0dF9wcm94eS5qc1xuLy8gU2VuZHMgYWxsIGRjLnNldHQgY2hhbmdlcyB0byB0aGUgd2ViLXdvcmtlclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBmdW5jdGlvbiBzZXR0X3Byb3h5KHNldHQsIHd3KSB7XG4gIHZhciBoID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KHNldHQsIGspIHtcbiAgICAgIHJldHVybiBzZXR0W2tdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc2V0dCwgaywgdikge1xuICAgICAgc2V0dFtrXSA9IHY7XG4gICAgICB3dy5qdXN0KCd1cGRhdGUtZGMtc2V0dGluZ3MnLCBzZXR0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgd3cuanVzdCgndXBkYXRlLWRjLXNldHRpbmdzJywgc2V0dCk7XG4gIHJldHVybiBuZXcgUHJveHkoc2V0dCwgaCk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy9hZ2dfdG9vbC5qc1xuXG5cbi8vIFRpY2sgYWdncmVnYXRpb25cblxuXG52YXIgQWdnVG9vbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFnZ1Rvb2woZGMsIF9pbnQpIHtcbiAgICBpZiAoX2ludCA9PT0gdm9pZCAwKSB7XG4gICAgICBfaW50ID0gMTAwO1xuICAgIH1cblxuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFnZ1Rvb2wpO1xuXG4gICAgdGhpcy5zeW1ib2xzID0ge307XG4gICAgdGhpc1tcImludFwiXSA9IF9pbnQ7IC8vIEl0YXJ2YWwgaW4gbXNcblxuICAgIHRoaXMuZGMgPSBkYztcbiAgICB0aGlzLnN0X2lkID0gbnVsbDtcbiAgICB0aGlzLmRhdGFfY2hhbmdlZCA9IGZhbHNlO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoQWdnVG9vbCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHN5bSwgdXBkLCB0Zikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gU3RhcnQgYXV0byB1cGRhdGVzXG4gICAgICBpZiAoIXRoaXMuc3RfaWQpIHtcbiAgICAgICAgdGhpcy5zdF9pZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRmID0gcGFyc2VJbnQodGYpO1xuICAgICAgdmFyIG9sZCA9IHRoaXMuc3ltYm9sc1tzeW1dO1xuICAgICAgdmFyIHQgPSB1dGlscy5ub3coKTtcbiAgICAgIHZhciBpc2RzID0gc3ltLmluY2x1ZGVzKCdkYXRhc2V0cy4nKTtcbiAgICAgIHRoaXMuZGF0YV9jaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKCFvbGQpIHtcbiAgICAgICAgdGhpcy5zeW1ib2xzW3N5bV0gPSB7XG4gICAgICAgICAgdXBkOiB1cGQsXG4gICAgICAgICAgdDogdCxcbiAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh1cGRbMF0gPj0gb2xkLnVwZFswXSArIHRmICYmICFpc2RzKSB7XG4gICAgICAgIC8vIFJlZmluZSB0aGUgcHJldmlvdXMgZGF0YSBwb2ludFxuICAgICAgICB0aGlzLnJlZmluZShzeW0sIG9sZC51cGQuc2xpY2UoKSk7XG4gICAgICAgIHRoaXMuc3ltYm9sc1tzeW1dID0ge1xuICAgICAgICAgIHVwZDogdXBkLFxuICAgICAgICAgIHQ6IHQsXG4gICAgICAgICAgZGF0YTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRpY2sgdXBkYXRlcyB0aGUgY3VycmVudFxuICAgICAgICB0aGlzLnN5bWJvbHNbc3ltXS51cGQgPSB1cGQ7XG4gICAgICAgIHRoaXMuc3ltYm9sc1tzeW1dLnQgPSB0O1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNkcykge1xuICAgICAgICB0aGlzLnN5bWJvbHNbc3ltXS5kYXRhLnB1c2godXBkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgb3V0ID0ge307XG5cbiAgICAgIGZvciAodmFyIHN5bSBpbiB0aGlzLnN5bWJvbHMpIHtcbiAgICAgICAgdmFyIHVwZCA9IHRoaXMuc3ltYm9sc1tzeW1dLnVwZDtcblxuICAgICAgICBzd2l0Y2ggKHN5bSkge1xuICAgICAgICAgIGNhc2UgJ29obGN2JzpcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYy5kYXRhLmNoYXJ0LmRhdGE7XG4gICAgICAgICAgICB0aGlzLmRjLmZhc3RfbWVyZ2UoZGF0YSwgdXBkKTtcbiAgICAgICAgICAgIG91dC5vaGxjdiA9IGRhdGEuc2xpY2UoLTIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHN5bS5pbmNsdWRlcygnZGF0YXNldHMuJykpIHtcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVfZHMoc3ltLCBvdXQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRjLmdldF9vbmUoXCJcIi5jb25jYXQoc3ltKSk7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5kYy5mYXN0X21lcmdlKGRhdGEsIHVwZCwgZmFsc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVE9ETzogZmlsbCBnYXBzXG5cblxuICAgICAgaWYgKHRoaXMuZGF0YV9jaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuZGMud3cuanVzdCgndXBkYXRlLWRhdGEnLCBvdXQpO1xuICAgICAgICB0aGlzLmRhdGFfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi51cGRhdGUoKTtcbiAgICAgIH0sIHRoaXNbXCJpbnRcIl0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWZpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmaW5lKHN5bSwgdXBkKSB7XG4gICAgICBpZiAoc3ltID09PSAnb2hsY3YnKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYy5kYXRhLmNoYXJ0LmRhdGE7XG4gICAgICAgIHRoaXMuZGMuZmFzdF9tZXJnZShkYXRhLCB1cGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRjLmdldF9vbmUoXCJcIi5jb25jYXQoc3ltKSk7XG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuICAgICAgICB0aGlzLmRjLmZhc3RfbWVyZ2UoZGF0YSwgdXBkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZV9kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVfZHMoc3ltLCBvdXQpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5zeW1ib2xzW3N5bV0uZGF0YTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIG91dFtzeW1dID0gZGF0YTtcbiAgICAgICAgdGhpcy5zeW1ib2xzW3N5bV0uZGF0YSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuc3ltYm9scyA9IHt9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBZ2dUb29sO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL2RhdGFjdWJlLmpzXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZGF0YWN1YmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IGRhdGFjdWJlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBkYXRhY3ViZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGRhdGFjdWJlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBkYXRhY3ViZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gZGF0YWN1YmVfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gZGF0YWN1YmVfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGRhdGFjdWJlX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGRhdGFjdWJlX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8vIE1haW4gRGF0YUhlbHBlciBjbGFzcy4gQSBjb250YWluZXIgZm9yIGRhdGEsXG4vLyB3aGljaCB3b3JrcyBhcyBhIHByb3h5IGFuZCBDUlVEIGludGVyZmFjZVxuXG5cblxuIC8vIEludGVyZmFjZSBtZXRob2RzLiBQcml2YXRlIG1ldGhvZHMgaW4gZGNfY29yZS5qc1xuXG52YXIgRGF0YUN1YmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EQ0NvcmUpIHtcbiAgX2luaGVyaXRzKERhdGFDdWJlLCBfRENDb3JlKTtcblxuICB2YXIgX3N1cGVyID0gZGF0YWN1YmVfY3JlYXRlU3VwZXIoRGF0YUN1YmUpO1xuXG4gIGZ1bmN0aW9uIERhdGFDdWJlKGRhdGEsIHNldHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBkYXRhID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNldHQgPT09IHZvaWQgMCkge1xuICAgICAgc2V0dCA9IHt9O1xuICAgIH1cblxuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFDdWJlKTtcblxuICAgIHZhciBkZWZfc2V0dCA9IHtcbiAgICAgIGFnZ3JlZ2F0aW9uOiAxMDAsXG4gICAgICAvLyBVcGRhdGUgYWdncmVnYXRpb24gaW50ZXJ2YWxcbiAgICAgIHNjcmlwdF9kZXB0aDogMCxcbiAgICAgIC8vIDAgPT09IEV4ZWMgb24gYWxsIGRhdGFcbiAgICAgIGF1dG9fc2Nyb2xsOiB0cnVlLFxuICAgICAgLy8gQXV0byBzY3JvbGwgdG8gYSBuZXcgY2FuZGxlXG4gICAgICBzY3JpcHRzOiB0cnVlLFxuICAgICAgLy8gRW5hYmxlIG92ZXJsYXlzIHNjcmlwdHMsXG4gICAgICB3d19yYW1fbGltaXQ6IDAsXG4gICAgICAvLyBXZWJXb3JrZXIgUkFNIGxpbWl0IChNQilcbiAgICAgIG5vZGVfdXJsOiBudWxsLFxuICAgICAgLy8gVXNlIG5vZGUuanMgaW5zdGVhZCBvZiBXV1xuICAgICAgc2hpZnRfbWVhc3VyZTogdHJ1ZSAvLyBEcmF3IG1lYXN1cm1lbnQgc2hpZnQrY2xpY2tcblxuICAgIH07XG4gICAgc2V0dCA9IE9iamVjdC5hc3NpZ24oZGVmX3NldHQsIHNldHQpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuc2V0dCA9IHNldHQ7XG4gICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgX3RoaXMuc2V0dCA9IHNldHRfcHJveHkoc2V0dCwgX3RoaXMud3cpO1xuICAgIF90aGlzLmFnZyA9IG5ldyBBZ2dUb29sKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBzZXR0LmFnZ3JlZ2F0aW9uKTtcbiAgICBfdGhpcy5zZV9zdGF0ZSA9IHt9OyAvL3RoaXMuYWdnLnVwZGF0ZSA9IHRoaXMuYWdnX3VwZGF0ZS5iaW5kKHRoaXMpXG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gQWRkIG5ldyBvdmVybGF5XG5cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhEYXRhQ3ViZSwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChzaWRlLCBvdmVybGF5KSB7XG4gICAgICBpZiAoc2lkZSAhPT0gJ29uY2hhcnQnICYmIHNpZGUgIT09ICdvZmZjaGFydCcgJiYgc2lkZSAhPT0gJ2RhdGFzZXRzJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YVtzaWRlXS5wdXNoKG92ZXJsYXkpO1xuICAgICAgdGhpcy51cGRhdGVfaWRzKCk7XG4gICAgICByZXR1cm4gb3ZlcmxheS5pZDtcbiAgICB9IC8vIEdldCBhbGwgb2JqZWN0cyBtYXRjaGluZyB0aGUgcXVlcnlcblxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQocXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldF9ieV9xdWVyeShxdWVyeSkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnY7XG4gICAgICB9KTtcbiAgICB9IC8vIEdldCBmaXJzdCBvYmplY3QgbWF0Y2hpbmcgdGhlIHF1ZXJ5XG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRfb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9vbmUocXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldF9ieV9xdWVyeShxdWVyeSkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnY7XG4gICAgICB9KVswXTtcbiAgICB9IC8vIFNldCBkYXRhIChyZWFjdGl2ZWx5KVxuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChxdWVyeSwgZGF0YSkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldF9ieV9xdWVyeShxdWVyeSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBkYXRhY3ViZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9iamVjdHMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvYmogPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgaSA9IG9iai5pICE9PSB1bmRlZmluZWQgPyBvYmouaSA6IG9iai5wLmluZGV4T2Yob2JqLnYpO1xuXG4gICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnR2LiRzZXQob2JqLnAsIGksIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZV9pZHMoKTtcbiAgICB9IC8vIE1lcmdlIG9iamVjdCBvciBhcnJheSAocmVhY3RpdmVseSlcblxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKHF1ZXJ5LCBkYXRhKSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0X2J5X3F1ZXJ5KHF1ZXJ5KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBkYXRhY3ViZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9iamVjdHMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb2JqID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLnYpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIGNvbnRpbnVlOyAvLyBJZiBhcnJheSBpcyBhIHRpbWVzZXJpZXMsIG1lcmdlIGl0IGJ5IHRpbWVzdGFtcFxuICAgICAgICAgICAgLy8gZWxzZSBtZXJnZSBieSBpdGVtIGluZGV4XG5cbiAgICAgICAgICAgIGlmIChvYmoudlswXSAmJiBvYmoudlswXS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICB0aGlzLm1lcmdlX3RzKG9iaiwgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm1lcmdlX29iamVjdHMob2JqLCBkYXRhLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2ZfdHlwZW9mKG9iai52KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVyZ2Vfb2JqZWN0cyhvYmosIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlX2lkcygpO1xuICAgIH0gLy8gUmVtb3ZlIGFuIG92ZXJsYXkgYnkgcXVlcnkgKGlkL3R5cGUvbmFtZS8uLi4pXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsKHF1ZXJ5KSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0X2J5X3F1ZXJ5KHF1ZXJ5KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBkYXRhY3ViZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9iamVjdHMpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb2JqID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIC8vIEZpbmQgY3VycmVudCBpbmRleCBvZiB0aGUgZmllbGQgKGlmIG5vdCBkZWZpbmVkKVxuICAgICAgICAgIHZhciBpID0gdHlwZW9mIG9iai5pICE9PSAnbnVtYmVyJyA/IG9iai5pIDogb2JqLnAuaW5kZXhPZihvYmoudik7XG5cbiAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudHYuJGRlbGV0ZShvYmoucCwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVfaWRzKCk7XG4gICAgfSAvLyBVcGRhdGUvYXBwZW5kIGRhdGEgcG9pbnQsIGRlcGVuZGluZyBvbiB0aW1lc3RhbXBcblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoZGF0YSkge1xuICAgICAgaWYgKGRhdGFbJ2NhbmRsZSddKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZV9jYW5kbGUoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVfdGljayhkYXRhKTtcbiAgICAgIH1cbiAgICB9IC8vIExvY2sgb3ZlcmxheXMgZnJvbSBiZWluZyBwdWxsZWQgYnkgcXVlcnlfc2VhcmNoXG4gICAgLy8gVE9ETzogc3ViamVjdCB0byByZXZpZXdcblxuICB9LCB7XG4gICAga2V5OiBcImxvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jayhxdWVyeSkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldF9ieV9xdWVyeShxdWVyeSk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHgudiAmJiB4LnYuaWQgJiYgeC52LnR5cGUpIHtcbiAgICAgICAgICB4LnYubG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBVbmxvY2sgb3ZlcmxheXMgZnJvbSBiZWluZyBwdWxsZWQgYnkgcXVlcnlfc2VhcmNoXG4gICAgLy9cblxuICB9LCB7XG4gICAga2V5OiBcInVubG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmxvY2socXVlcnkpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRfYnlfcXVlcnkocXVlcnksIHRydWUpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh4LnYgJiYgeC52LmlkICYmIHgudi50eXBlKSB7XG4gICAgICAgICAgeC52LmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFNob3cgaW5kaWNhdG9yXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3cocXVlcnkpIHtcbiAgICAgIGlmIChxdWVyeSA9PT0gJ29mZmNoYXJ0JyB8fCBxdWVyeSA9PT0gJ29uY2hhcnQnKSB7XG4gICAgICAgIHF1ZXJ5ICs9ICcuJztcbiAgICAgIH0gZWxzZSBpZiAocXVlcnkgPT09ICcuJykge1xuICAgICAgICBxdWVyeSA9ICcnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lcmdlKHF1ZXJ5ICsgJy5zZXR0aW5ncycsIHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSAvLyBIaWRlIGluZGljYXRvclxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKHF1ZXJ5KSB7XG4gICAgICBpZiAocXVlcnkgPT09ICdvZmZjaGFydCcgfHwgcXVlcnkgPT09ICdvbmNoYXJ0Jykge1xuICAgICAgICBxdWVyeSArPSAnLic7XG4gICAgICB9IGVsc2UgaWYgKHF1ZXJ5ID09PSAnLicpIHtcbiAgICAgICAgcXVlcnkgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZXJnZShxdWVyeSArICcuc2V0dGluZ3MnLCB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IC8vIFNldCBkYXRhIGxvYWRlciBjYWxsYmFja1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25yYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbnJhbmdlKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5sb2FkZXIgPSBjYWxsYmFjaztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnR2LnNldF9sb2FkZXIoY2FsbGJhY2sgPyBfdGhpczIgOiBudWxsKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhQ3ViZTtcbn0oRENDb3JlKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL2ludGVyZmFjZS5qc1xuLy8gSHRtbCBpbnRlcmZhY2UsIHNob3duIG9uIHRvcCBvZiB0aGUgZ3JpZC5cbi8vIENhbiBiZSBzdGF0aWMgKGEgdG9vbHRpcCkgb3IgaW50ZXJhY3RpdmUsXG4vLyBlLmcuIGEgY29udHJvbCBwYW5lbC5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbWl4aW5zX2ludGVyZmFjZSA9ICh7XG4gIHByb3BzOiBbJ3V4JywgJ3VwZGF0ZXInLCAnY29sb3JzJywgJ3dyYXBwZXInXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLl8kZW1pdCA9IHRoaXMuJGVtaXQ7XG4gICAgdGhpcy4kZW1pdCA9IHRoaXMuY3VzdG9tX2V2ZW50O1xuICAgIGlmICh0aGlzLmluaXQpIHRoaXMuaW5pdCgpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogJ2Nsb3NlLWludGVyZmFjZScsXG4gICAgICAgIGFyZ3M6IFt0aGlzLiRwcm9wcy51eC51dWlkXVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBUT0RPOiBlbWl0IGFsbCB0aGUgd2F5IHRvIHRoZSB1eGxpc3RcbiAgICAvLyBhZGQgYXBwbHkgdGhlIGNoYW5nZXMgdGhlcmVcbiAgICBtb2RpZnk6IGZ1bmN0aW9uIG1vZGlmeShvYmopIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6ICdtb2RpZnktaW50ZXJmYWNlJyxcbiAgICAgICAgYXJnczogW3RoaXMuJHByb3BzLnV4LnV1aWQsIG9ial1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY3VzdG9tX2V2ZW50OiBmdW5jdGlvbiBjdXN0b21fZXZlbnQoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zcGxpdCgnOicpWzBdID09PSAnaG9vaycpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy51eC5vdmVybGF5O1xuICAgIH0sXG4gICAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdmVybGF5LmxheW91dDtcbiAgICB9LFxuICAgIHV4cjogZnVuY3Rpb24gdXhyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnV4O1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2luZGV4LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcHJpbWl0aXZlcyA9IHtcbiAgQ2FuZGxlOiBDYW5kbGVFeHQsXG4gIFZvbGJhcjogVm9sYmFyRXh0LFxuICBMaW5lOiBMaW5lLFxuICBQaW46IFBpbixcbiAgUHJpY2U6IFByaWNlLFxuICBSYXk6IFJheSxcbiAgU2VnOiBTZWdcbn07XG5cblRyYWRpbmdWdWUuaW5zdGFsbCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgVnVlLmNvbXBvbmVudChUcmFkaW5nVnVlLm5hbWUsIFRyYWRpbmdWdWUpO1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVHJhZGluZ1Z1ZSk7XG4gIHdpbmRvdy5UcmFkaW5nVnVlTGliID0ge1xuICAgIFRyYWRpbmdWdWU6IFRyYWRpbmdWdWUsXG4gICAgT3ZlcmxheTogb3ZlcmxheSxcbiAgICBVdGlsczogdXRpbHMsXG4gICAgQ29uc3RhbnRzOiBjb25zdGFudHMsXG4gICAgQ2FuZGxlOiBDYW5kbGVFeHQsXG4gICAgVm9sYmFyOiBWb2xiYXJFeHQsXG4gICAgbGF5b3V0X2NudjogbGF5b3V0X2NudixcbiAgICBsYXlvdXRfdm9sOiBsYXlvdXRfdm9sLFxuICAgIERhdGFDdWJlOiBEYXRhQ3ViZSxcbiAgICBUb29sOiB0b29sLFxuICAgIEludGVyZmFjZTogbWl4aW5zX2ludGVyZmFjZSxcbiAgICBwcmltaXRpdmVzOiBwcmltaXRpdmVzXG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgc3JjID0gKFRyYWRpbmdWdWUpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MTg6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi8qIEFuaXQtYm9vc3RyYXAgdGFjdGl4ICovXFxuLnRyYWRpbmctdnVlICosIDo6YWZ0ZXIsIDo6YmVmb3JlIHtcXG4gICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxufVxcbi50cmFkaW5nLXZ1ZSBpbWcge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogaW5pdGlhbDtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTc2OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHJhZGluZy12dWUtYm90YmFyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlICFpbXBvcnRhbnQ7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ0OTpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnQtdnVlLWxidG4tZ3JwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDAuNWVtO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMDg6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50dmpzLWl0ZW0tbGlzdCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIG1hcmdpbi10b3A6IC01cHg7XFxufVxcbi50dmpzLWl0ZW0tbGlzdC1pdGVtIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZy1yaWdodDogMjBweDtcXG4gICAgZm9udC1zaXplOiAxLjE1ZW07XFxuICAgIGxldHRlci1zcGFjaW5nOiAwLjA1ZW07XFxufVxcbi50dmpzLWl0ZW0tbGlzdC1pdGVtOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzc2ODc4MzE5O1xcbn1cXG4udHZqcy1pdGVtLWxpc3QtaXRlbSAqIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlICFpbXBvcnRhbnQ7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4ODpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnRyYWRpbmctdnVlLWxlZ2VuZCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgei1pbmRleDogMTAwO1xcbiAgICBmb250LXNpemU6IDEuMjVlbTtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcXG59XFxuQG1lZGlhIChtaW4tcmVzb2x1dGlvbjogMngpIHtcXG4udHJhZGluZy12dWUtbGVnZW5kIHtcXG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxufVxcbn1cXG4udHJhZGluZy12dWUtb2hsY3Yge1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgbWFyZ2luLWJvdHRvbTogMC41ZW07XFxufVxcbi50LXZ1ZS1sc3BhbiB7XFxuICAgIGZvbnQtdmFyaWFudC1udW1lcmljOiB0YWJ1bGFyLW51bXM7XFxuICAgIGZvbnQtc2l6ZTogMC45NWVtO1xcbiAgICBjb2xvcjogIzk5OTk5OTsgLyogVE9ETzogbW92ZSA9PiBwYXJhbXMgKi9cXG4gICAgbWFyZ2luLWxlZnQ6IDAuMWVtO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDAuMmVtO1xcbn1cXG4udC12dWUtdGl0bGUge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDAuMjVlbTtcXG4gICAgZm9udC1zaXplOiAxLjQ1ZW07XFxufVxcbi50LXZ1ZS1pbmQge1xcbiAgICBtYXJnaW4tbGVmdDogMC4yZW07XFxuICAgIG1hcmdpbi1ib3R0b206IDAuNWVtO1xcbiAgICBmb250LXNpemU6IDEuMGVtO1xcbiAgICBtYXJnaW4tdG9wOiAwLjNlbTtcXG59XFxuLnQtdnVlLWl2YWx1ZSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwLjVlbTtcXG59XFxuLnQtdnVlLXVua25vd24ge1xcbiAgICBjb2xvcjogIzk5OTk5OTsgLyogVE9ETzogbW92ZSA9PiBwYXJhbXMgKi9cXG59XFxuLnR2anMtYXBwZWFyLWVudGVyLWFjdGl2ZSxcXG4udHZqcy1hcHBlYXItbGVhdmUtYWN0aXZlXFxue1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cyBlYXNlO1xcbn1cXG4udHZqcy1hcHBlYXItZW50ZXIsIC50dmpzLWFwcGVhci1sZWF2ZS10b1xcbntcXG4gICAgb3BhY2l0eTogMDtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIzOlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udC12dWUtbGJ0biB7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NjE6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50cmFkaW5nLXZ1ZS1zZWN0aW9uIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE2ODpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnR2anMtc3Bpbm5lciB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB3aWR0aDogMjBweDtcXG4gICAgaGVpZ2h0OiAxNnB4O1xcbiAgICBtYXJnaW46IC00cHggMHB4IC0xcHggMHB4O1xcbiAgICBvcGFjaXR5OiAwLjc7XFxufVxcbi50dmpzLXNwaW5uZXIgZGl2IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDhweDtcXG4gICAgd2lkdGg6IDRweDtcXG4gICAgaGVpZ2h0OiA0cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDEsIDEsIDEsIDEpO1xcbn1cXG4udHZqcy1zcGlubmVyIGRpdjpudGgtY2hpbGQoMSkge1xcbiAgICBsZWZ0OiAycHg7XFxuICAgIGFuaW1hdGlvbjogdHZqcy1zcGlubmVyMSAwLjZzIGluZmluaXRlO1xcbiAgICBvcGFjaXR5OiAwLjk7XFxufVxcbi50dmpzLXNwaW5uZXIgZGl2Om50aC1jaGlsZCgyKSB7XFxuICAgIGxlZnQ6IDJweDtcXG4gICAgYW5pbWF0aW9uOiB0dmpzLXNwaW5uZXIyIDAuNnMgaW5maW5pdGU7XFxufVxcbi50dmpzLXNwaW5uZXIgZGl2Om50aC1jaGlsZCgzKSB7XFxuICAgIGxlZnQ6IDlweDtcXG4gICAgYW5pbWF0aW9uOiB0dmpzLXNwaW5uZXIyIDAuNnMgaW5maW5pdGU7XFxufVxcbi50dmpzLXNwaW5uZXIgZGl2Om50aC1jaGlsZCg0KSB7XFxuICAgIGxlZnQ6IDE2cHg7XFxuICAgIGFuaW1hdGlvbjogdHZqcy1zcGlubmVyMyAwLjZzIGluZmluaXRlO1xcbiAgICBvcGFjaXR5OiAwLjk7XFxufVxcbkBrZXlmcmFtZXMgdHZqcy1zcGlubmVyMSB7XFxuMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG59XFxuMTAwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbn1cXG59XFxuQGtleWZyYW1lcyB0dmpzLXNwaW5uZXIzIHtcXG4wJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbn1cXG4xMDAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxufVxcbn1cXG5Aa2V5ZnJhbWVzIHR2anMtc3Bpbm5lcjIge1xcbjAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApO1xcbn1cXG4xMDAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDdweCwgMCk7XFxufVxcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnR2anMtZHJpZnQtZW50ZXItYWN0aXZlIHtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xcbn1cXG4udHZqcy1kcmlmdC1sZWF2ZS1hY3RpdmUge1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjhzIGN1YmljLWJlemllcigxLjAsIDAuNSwgMC44LCAxLjApO1xcbn1cXG4udHZqcy1kcmlmdC1lbnRlciwgLnR2anMtZHJpZnQtbGVhdmUtdG9cXG57XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMHB4KTtcXG4gICAgb3BhY2l0eTogMDtcXG59XFxuLnR2anMtdGhlLXRpcCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDIwMHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHotaW5kZXg6IDEwMDAxO1xcbiAgICBjb2xvcjogI2ZmZmZmZjtcXG4gICAgZm9udC1zaXplOiAxLjVlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuMTVlbTtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICByaWdodDogNzBweDtcXG4gICAgdG9wOiAxMHB4O1xcbiAgICB0ZXh0LXNoYWRvdzogMXB4IDFweCBibGFjaztcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTM1OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHJhZGluZy12dWUtdG9vbGJhciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgYmxhY2s7XFxuICAgIHotaW5kZXg6IDEwMTtcXG4gICAgcGFkZGluZy10b3A6IDNweDtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3OTpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnRyYWRpbmctdnVlLXRiaXRlbSB7XFxufVxcbi50cmFkaW5nLXZ1ZS10Yml0ZW06aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzY4NzgzMTk7XFxufVxcbi50cmFkaW5nLXZ1ZS10Yml0ZW0tZXhwIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICByaWdodDogLTNweDtcXG4gICAgcGFkZGluZzogMTguNXB4IDVweDtcXG4gICAgZm9udC1zdHJldGNoOiBleHRyYS1jb25kZW5zZWQ7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVYKDAuNik7XFxuICAgIGZvbnQtc2l6ZTogMC42ZW07XFxuICAgIG9wYWNpdHk6IDAuMDtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIGxpbmUtaGVpZ2h0OiAwO1xcbn1cXG4udHJhZGluZy12dWUtdGJpdGVtOmhvdmVyXFxuLnRyYWRpbmctdnVlLXRiaXRlbS1leHAge1xcbiAgICBvcGFjaXR5OiAwLjU7XFxufVxcbi50cmFkaW5nLXZ1ZS10Yml0ZW0tZXhwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzc2ODc4MzMwO1xcbiAgICBvcGFjaXR5OiAwLjkgIWltcG9ydGFudDtcXG59XFxuLnRyYWRpbmctdnVlLXRiaWNvbiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLnRyYWRpbmctdnVlLXRiaXRlbS5zZWxlY3RlZC1pdGVtID4gLnRyYWRpbmctdnVlLXRiaWNvbixcXG4udHZqcy1pdGVtLWxpc3QtaXRlbS5zZWxlY3RlZC1pdGVtID4gLnRyYWRpbmctdnVlLXRiaWNvbiB7XFxuICAgICBmaWx0ZXI6IGJyaWdodG5lc3MoMS40NSkgc2VwaWEoMSkgaHVlLXJvdGF0ZSg5MGRlZykgc2F0dXJhdGUoNC41KSAhaW1wb3J0YW50O1xcbn1cXG4udHZqcy1waXhlbGF0ZWQge1xcbiAgICAtbXMtaW50ZXJwb2xhdGlvbi1tb2RlOiBuZWFyZXN0LW5laWdoYm9yO1xcbiAgICBpbWFnZS1yZW5kZXJpbmc6IC13ZWJraXQtb3B0aW1pemUtY29udHJhc3Q7XFxuICAgIGltYWdlLXJlbmRlcmluZzogLXdlYmtpdC1jcmlzcC1lZGdlcztcXG4gICAgaW1hZ2UtcmVuZGVyaW5nOiAtbW96LWNyaXNwLWVkZ2VzO1xcbiAgICBpbWFnZS1yZW5kZXJpbmc6IC1vLWNyaXNwLWVkZ2VzO1xcbiAgICBpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDtcXG59XFxuXFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50cmFkaW5nLXZ1ZS11eC13cmFwcGVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbn1cXG4udHZqcy11eC13cmFwcGVyLXBpbiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDlweDtcXG4gICAgaGVpZ2h0OiA5cHg7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzIzYTc3NjtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgbWFyZ2luLWxlZnQ6IC02cHg7XFxuICAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG4udHZqcy11eC13cmFwcGVyLWhlYWQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGhlaWdodDogMjNweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxufVxcbi50dmpzLXV4LXdyYXBwZXItY2xvc2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAxMXB4O1xcbiAgICBoZWlnaHQ6IDExcHg7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxuICAgIGxpbmUtaGVpZ2h0OiAwLjVlbTtcXG4gICAgcGFkZGluZzogMXB4IDFweCAxcHggMXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgICByaWdodDogNXB4O1xcbiAgICB0b3A6IDVweDtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgei1pbmRleDogMTAwO1xcbn1cXG4udHZqcy11eC13cmFwcGVyLWNsb3NlLWhiIHtcXG59XFxuLnR2anMtdXgtd3JhcHBlci1jbG9zZTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRjYwNUMgIWltcG9ydGFudDtcXG4gICAgY29sb3I6ICM2OTIzMjQgIWltcG9ydGFudDtcXG59XFxuLnR2anMtdXgtd3JhcHBlci1mdWxsIHtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgzOlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy13aWRnZXRzIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiAxMDAwO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjQ1OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0MDpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiEgSGFtbWVyLkpTIC0gdjIuMC43IC0gMjAxNi0wNC0yMlxuICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSm9yaWsgVGFuZ2VsZGVyO1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xudmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgbm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZEZuKGZuLCBjb250ZXh0KSwgdGltZW91dCk7XG59XG5cbi8qKlxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvYmouZm9yRWFjaCkge1xuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gJ0RFUFJFQ0FURUQgTUVUSE9EOiAnICsgbmFtZSArICdcXG4nICsgbWVzc2FnZSArICcgQVQgXFxuJztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG5cbiAgICAgICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG52YXIgYXNzaWduO1xuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgZXh0ZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIG1lcmdlID0gZGVwcmVjYXRlKGZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICAgIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICAgIGNoaWxkUDtcblxuICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICAgIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGFzc2lnbihjaGlsZFAsIHByb3BlcnRpZXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHsqfSB2YWwxXG4gKiBAcGFyYW0geyp9IHZhbDJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBpZlVuZGVmaW5lZCh2YWwxLCB2YWwyKSB7XG4gICAgcmV0dXJuICh2YWwxID09PSB1bmRlZmluZWQpID8gdmFsMiA6IHZhbDE7XG59XG5cbi8qKlxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gKiBAbWV0aG9kIGhhc1BhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xufVxuXG4vKipcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAqL1xuZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCkgfHwgKCFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59XG5cbi8qKlxuICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbn1cblxuLyoqXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG4gICAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAqL1xuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICAgIHZhciBwcmVmaXgsIHByb3A7XG4gICAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgICAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBnZXQgYSB1bmlxdWUgaWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gKi9cbnZhciBfdW5pcXVlSWQgPSAxO1xuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIF91bmlxdWVJZCsrO1xufVxuXG4vKipcbiAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RG9jdW1lbnRWaWV3fFdpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICAgIHJldHVybiAoZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93KTtcbn1cblxudmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcblxudmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG52YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbnZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbnZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xuXG52YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xuXG52YXIgSU5QVVRfU1RBUlQgPSAxO1xudmFyIElOUFVUX01PVkUgPSAyO1xudmFyIElOUFVUX0VORCA9IDQ7XG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcblxudmFyIERJUkVDVElPTl9OT05FID0gMTtcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG5cbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xudmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcblxudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcbnZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xuXG4gICAgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuICAgIHRoaXMuZG9tSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuXG59XG5cbklucHV0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHsgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gICAgdmFyIFR5cGU7XG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgIGlmIChpbnB1dENsYXNzKSB7XG4gICAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgICAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgICAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChUeXBlKShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xufVxuXG4vKipcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBpc0ZpcnN0ID0gKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuICAgIHZhciBpc0ZpbmFsID0gKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuXG4gICAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gICAgfVxuXG4gICAgLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcbiAgICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7XG5cbiAgICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcbiAgICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTtcblxuICAgIC8vIGVtaXQgc2VjcmV0IGV2ZW50XG4gICAgbWFuYWdlci5lbWl0KCdoYW1tZXIuaW5wdXQnLCBpbnB1dCk7XG5cbiAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gICAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xufVxuXG4vKipcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICAgIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cbiAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuICAgIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dDtcbiAgICB2YXIgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcbiAgICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG5cbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcblxuICAgIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuXG4gICAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICAgIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG5cbiAgICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSAoYWJzKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyhvdmVyYWxsVmVsb2NpdHkueSkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcblxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gICAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcblxuICAgIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogKChpbnB1dC5wb2ludGVycy5sZW5ndGggPlxuICAgICAgICBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycykgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyk7XG5cbiAgICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpO1xuXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcbiAgICB9XG4gICAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgICAgICB9O1xuXG4gICAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgICAgIHk6IGNlbnRlci55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG5cbi8qKlxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQsXG4gICAgICAgIGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wLFxuICAgICAgICB2ZWxvY2l0eSwgdmVsb2NpdHlYLCB2ZWxvY2l0eVksIGRpcmVjdGlvbjtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfQ0FOQ0VMICYmIChkZWx0YVRpbWUgPiBDT01QVVRFX0lOVEVSVkFMIHx8IGxhc3QudmVsb2NpdHkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgICB2YXIgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgdmVsb2NpdHlYID0gdi54O1xuICAgICAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgICAgIHZlbG9jaXR5ID0gKGFicyh2LngpID4gYWJzKHYueSkpID8gdi54IDogdi55O1xuICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgICAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gICAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cblxuLyoqXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5mdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgICBwb2ludGVyc1tpXSA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxuICAgICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICAgICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgICAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgICAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICB9O1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICAgIH1cblxuICAgIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XG4gICAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICogQHBhcmFtIHtPYmplY3R9IHAyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gKi9cbmZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gICAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xuXG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcblxuLyoqXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gTW91c2VJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcblxuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbn07XG5cbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4vLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbn1cblxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICAgICAgdmFyIGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICB9XG5cbiAgICB2YXIgaSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgLy8gY29sbGVjdCB0b3VjaGVzXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgICBdO1xufVxuXG4vKipcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG52YXIgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuXG4gICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgIHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcbn1cblxuaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBpc1RvdWNoID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKSxcbiAgICAgICAgICAgIGlzTW91c2UgPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0UpO1xuXG4gICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHJlY29yZCB0b3VjaGVzIHRvICBkZS1kdXBlIHN5bnRoZXRpYyBtb3VzZSBldmVudFxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgcmVjb3JkVG91Y2hlcy5jYWxsKHRoaXMsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hlcyhldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXTtcblxuICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuICAgICAgICB2YXIgbGFzdFRvdWNoID0ge3g6IHRvdWNoLmNsaWVudFgsIHk6IHRvdWNoLmNsaWVudFl9O1xuICAgICAgICB0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcbiAgICAgICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgICAgIHZhciByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobGFzdFRvdWNoKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuICAgIHZhciB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFgsIHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdC54KSwgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcbiAgICAgICAgaWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xudmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG5cbi8qKlxuICogVG91Y2ggQWN0aW9uXG4gKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xufVxuXG5Ub3VjaEFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHRzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcblxuICAgICAgICAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xuICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgICAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAgICAgLy9kbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcblxuICAgICAgICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbihzcmNFdmVudCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAgIC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gICAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRvdWNoTWFwID0ge307XG4gICAgdmFyIGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICAgIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICAgICAgdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luZG93LkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNoTWFwO1xufVxuXG4vKipcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gKlxuICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAqXG4gKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICpcbiAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAqICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gKi9cbnZhciBTVEFURV9QT1NTSUJMRSA9IDE7XG52YXIgU1RBVEVfQkVHQU4gPSAyO1xudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xudmFyIFNUQVRFX0VOREVEID0gODtcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG52YXIgU1RBVEVfRkFJTEVEID0gMzI7XG5cbi8qKlxuICogUmVjb2duaXplclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcblxuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xufVxuXG5SZWNvZ25pemVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZGVmYXVsdHM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG4gICAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcbiAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHsgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICAgICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgICAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICB0cnlFbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuIHdlIGVtaXQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuRW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICAgICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduKHt9LCBpbnB1dERhdGEpO1xuXG4gICAgICAgIC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuICAgICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpO1xuXG4gICAgICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0RGF0YSkgeyB9LCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkgeyB9XG59O1xuXG4vKipcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICogQHBhcmFtIHtDb25zdH0gc3RhdGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gKi9cbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICAgIHJldHVybiAnY2FuY2VsJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XG4gICAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgICAgIHJldHVybiAnZG93bic7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQKSB7XG4gICAgICAgIHJldHVybiAndXAnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICovXG5mdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICAgIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xufVxuXG4vKipcbiAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBBdHRyUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoQXR0clJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgICAqL1xuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xuXG4gICAgICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgICAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xuXG4gICAgICAgIC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcbiAgICAgICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGFuXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQYW5SZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnBYID0gbnVsbDtcbiAgICB0aGlzLnBZID0gbnVsbDtcbn1cblxuaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH0sXG5cbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICAvLyBsb2NrIHRvIGF4aXM/XG4gICAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeCA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh4IDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHggIT0gdGhpcy5wWDtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAoISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcblxuICAgICAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQaW5jaFxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChQaW5jaFJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFByZXNzXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbn1cblxuaW5oZXJpdChQcmVzc1JlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFByZXNzUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGltZTogMjUxLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgICB0aHJlc2hvbGQ6IDkgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTd2lwZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBTd2lwZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJlxuICAgICAgICAgICAgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmXG4gICAgICAgICAgICBpbnB1dC5tYXhQb2ludGVycyA9PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiZcbiAgICAgICAgICAgIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn1cblxuaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3RhcCcsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0YXBzOiAxLFxuICAgICAgICBpbnRlcnZhbDogMzAwLCAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICAgIHRocmVzaG9sZDogOSwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gKGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsKSA6IHRydWU7XG4gICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbW1lcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5yZWNvZ25pemVycyA9IGlmVW5kZWZpbmVkKG9wdGlvbnMucmVjb2duaXplcnMsIEhhbW1lci5kZWZhdWx0cy5wcmVzZXQpO1xuICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuSGFtbWVyLlZFUlNJT04gPSAnMi4wLjcnO1xuXG4vKipcbiAqIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBuYW1lc3BhY2VcbiAqL1xuSGFtbWVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICAgKi9cbiAgICB0b3VjaEFjdGlvbjogVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZW5hYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG4gICAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0VGFyZ2V0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogZm9yY2UgYW4gaW5wdXQgY2xhc3NcbiAgICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRDbGFzczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxuICAgICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHByZXNldDogW1xuICAgICAgICAvLyBSZWNvZ25pemVyQ2xhc3MsIG9wdGlvbnMsIFtyZWNvZ25pemVXaXRoLCAuLi5dLCBbcmVxdWlyZUZhaWx1cmUsIC4uLl1cbiAgICAgICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfV0sXG4gICAgICAgIFtQaW5jaFJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfSwgWydyb3RhdGUnXV0sXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfV0sXG4gICAgICAgIFtQYW5SZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH0sIFsnc3dpcGUnXV0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHtldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDJ9LCBbJ3RhcCddXSxcbiAgICAgICAgW1ByZXNzUmVjb2duaXplcl1cbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIGNzc1Byb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaFNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcbiAgICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudFpvb21pbmc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgICAqL1xuICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gICAgfVxufTtcblxudmFyIFNUT1AgPSAxO1xudmFyIEZPUkNFRF9TVE9QID0gMjtcblxuLyoqXG4gKiBNYW5hZ2VyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBIYW1tZXIuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgdGhpcy50b3VjaEFjdGlvbiA9IG5ldyBUb3VjaEFjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xufVxuXG5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXI7XG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuICAgICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgICAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ3JlbW92ZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcblxuICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbmQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG4gICAgICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS50eXBlID0gZXZlbnQ7XG4gICAgICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByb3A7XG4gICAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCAnJztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYWRkKSB7XG4gICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICB9XG59XG5cbi8qKlxuICogdHJpZ2dlciBkb20gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG5cbmFzc2lnbihIYW1tZXIsIHtcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQ6IElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcblxuICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcblxuICAgIERJUkVDVElPTl9OT05FOiBESVJFQ1RJT05fTk9ORSxcbiAgICBESVJFQ1RJT05fTEVGVDogRElSRUNUSU9OX0xFRlQsXG4gICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXG4gICAgRElSRUNUSU9OX1VQOiBESVJFQ1RJT05fVVAsXG4gICAgRElSRUNUSU9OX0RPV046IERJUkVDVElPTl9ET1dOLFxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICBESVJFQ1RJT05fVkVSVElDQUw6IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICBESVJFQ1RJT05fQUxMOiBESVJFQ1RJT05fQUxMLFxuXG4gICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICBJbnB1dDogSW5wdXQsXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxuXG4gICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcbiAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxuXG4gICAgUmVjb2duaXplcjogUmVjb2duaXplcixcbiAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXG4gICAgVGFwOiBUYXBSZWNvZ25pemVyLFxuICAgIFBhbjogUGFuUmVjb2duaXplcixcbiAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxuICAgIFBpbmNoOiBQaW5jaFJlY29nbml6ZXIsXG4gICAgUm90YXRlOiBSb3RhdGVSZWNvZ25pemVyLFxuICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXG5cbiAgICBvbjogYWRkRXZlbnRMaXN0ZW5lcnMsXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICBlYWNoOiBlYWNoLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBpbmhlcml0OiBpbmhlcml0LFxuICAgIGJpbmRGbjogYmluZEZuLFxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxufSk7XG5cbi8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4vLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cbnZhciBmcmVlR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbmZyZWVHbG9iYWwuSGFtbWVyID0gSGFtbWVyO1xuXG5pZiAodHJ1ZSkge1xuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgfSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbn0gZWxzZSB7fVxuXG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4MTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8qXG4gKiBIYW1zdGVyLmpzIHYxLjEuMlxuICogKGMpIDIwMTMgTW9ub3NwYWNlZCBodHRwOi8vbW9ub3NwYWNlZC5jb21cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50KXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBIYW1zdGVyXG4gKiB1c2UgdGhpcyB0byBjcmVhdGUgaW5zdGFuY2VzXG4gKiBAcmV0dXJucyB7SGFtc3Rlci5JbnN0YW5jZX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSGFtc3RlciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBIYW1zdGVyLkluc3RhbmNlKGVsZW1lbnQpO1xufTtcblxuLy8gZGVmYXVsdCBldmVudCBuYW1lXG5IYW1zdGVyLlNVUFBPUlQgPSAnd2hlZWwnO1xuXG4vLyBkZWZhdWx0IERPTSBtZXRob2RzXG5IYW1zdGVyLkFERF9FVkVOVCA9ICdhZGRFdmVudExpc3RlbmVyJztcbkhhbXN0ZXIuUkVNT1ZFX0VWRU5UID0gJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuSGFtc3Rlci5QUkVGSVggPSAnJztcblxuLy8gdW50aWwgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMgaGF2ZSBiZWVuIGZpeGVkLi4uXG5IYW1zdGVyLlJFQURZID0gZmFsc2U7XG5cbkhhbXN0ZXIuSW5zdGFuY2UgPSBmdW5jdGlvbihlbGVtZW50KXtcbiAgaWYgKCFIYW1zdGVyLlJFQURZKSB7XG4gICAgLy8gZml4IGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzXG4gICAgSGFtc3Rlci5ub3JtYWxpc2UuYnJvd3NlcigpO1xuXG4gICAgLy8gSGFtc3RlciBpcyByZWFkeS4uLiFcbiAgICBIYW1zdGVyLlJFQURZID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgLy8gc3RvcmUgYXR0YWNoZWQgZXZlbnQgaGFuZGxlcnNcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xuXG4gIC8vIHJldHVybiBpbnN0YW5jZVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogY3JlYXRlIG5ldyBoYW1zdGVyIGluc3RhbmNlXG4gKiBhbGwgbWV0aG9kcyBzaG91bGQgcmV0dXJuIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHNvIGl0IGlzIGNoYWluYWJsZS5cbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICAgICAgZWxlbWVudFxuICogQHJldHVybnMge0hhbXN0ZXIuSW5zdGFuY2V9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuSGFtc3Rlci5JbnN0YW5jZS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBiaW5kIGV2ZW50cyB0byB0aGUgaW5zdGFuY2VcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgICAgdXNlQ2FwdHVyZVxuICAgKiBAcmV0dXJucyB7SGFtc3Rlci5JbnN0YW5jZX1cbiAgICovXG4gIHdoZWVsOiBmdW5jdGlvbiBvbkV2ZW50KGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICAgIEhhbXN0ZXIuZXZlbnQuYWRkKHRoaXMsIEhhbXN0ZXIuU1VQUE9SVCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cbiAgICAvLyBoYW5kbGUgTW96TW91c2VQaXhlbFNjcm9sbCBpbiBvbGRlciBGaXJlZm94XG4gICAgaWYgKEhhbXN0ZXIuU1VQUE9SVCA9PT0gJ0RPTU1vdXNlU2Nyb2xsJykge1xuICAgICAgSGFtc3Rlci5ldmVudC5hZGQodGhpcywgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogdW5iaW5kIGV2ZW50cyB0byB0aGUgaW5zdGFuY2VcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgICAgdXNlQ2FwdHVyZVxuICAgKiBAcmV0dXJucyB7SGFtc3Rlci5JbnN0YW5jZX1cbiAgICovXG4gIHVud2hlZWw6IGZ1bmN0aW9uIG9mZkV2ZW50KGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICAgIC8vIGlmIG5vIGhhbmRsZXIgYXJndW1lbnQsXG4gICAgLy8gdW5iaW5kIHRoZSBsYXN0IGJvdW5kIGhhbmRsZXIgKGlmIGV4aXN0cylcbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkICYmIChoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5zbGljZSgtMSlbMF0pKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlci5vcmlnaW5hbDtcbiAgICB9XG5cbiAgICBIYW1zdGVyLmV2ZW50LnJlbW92ZSh0aGlzLCBIYW1zdGVyLlNVUFBPUlQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXG4gICAgLy8gaGFuZGxlIE1vek1vdXNlUGl4ZWxTY3JvbGwgaW4gb2xkZXIgRmlyZWZveFxuICAgIGlmIChIYW1zdGVyLlNVUFBPUlQgPT09ICdET01Nb3VzZVNjcm9sbCcpIHtcbiAgICAgIEhhbXN0ZXIuZXZlbnQucmVtb3ZlKHRoaXMsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbkhhbXN0ZXIuZXZlbnQgPSB7XG4gIC8qKlxuICAgKiBjcm9zcy1icm93c2VyICdhZGRXaGVlbExpc3RlbmVyJ1xuICAgKiBAcGFyYW0gICB7SW5zdGFuY2V9ICAgIGhhbXN0ZXJcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICBldmVudE5hbWVcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgICAgdXNlQ2FwdHVyZVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiBhZGQoaGFtc3RlciwgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKXtcbiAgICAvLyBzdG9yZSB0aGUgb3JpZ2luYWwgaGFuZGxlclxuICAgIHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xuXG4gICAgLy8gcmVkZWZpbmUgdGhlIGhhbmRsZXJcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24ob3JpZ2luYWxFdmVudCl7XG5cbiAgICAgIGlmICghb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBvcmlnaW5hbEV2ZW50ID0gd2luZG93LmV2ZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgYSBub3JtYWxpc2VkIGV2ZW50IG9iamVjdCxcbiAgICAgIC8vIGFuZCBub3JtYWxpc2UgXCJkZWx0YXNcIiBvZiB0aGUgbW91c2Ugd2hlZWxcbiAgICAgIHZhciBldmVudCA9IEhhbXN0ZXIubm9ybWFsaXNlLmV2ZW50KG9yaWdpbmFsRXZlbnQpLFxuICAgICAgICAgIGRlbHRhID0gSGFtc3Rlci5ub3JtYWxpc2UuZGVsdGEob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgIC8vIGZpcmUgdGhlIG9yaWdpbmFsIGhhbmRsZXIgd2l0aCBub3JtYWxpc2VkIGFyZ3VtZW50c1xuICAgICAgcmV0dXJuIG9yaWdpbmFsSGFuZGxlcihldmVudCwgZGVsdGFbMF0sIGRlbHRhWzFdLCBkZWx0YVsyXSk7XG5cbiAgICB9O1xuXG4gICAgLy8gY3Jvc3MtYnJvd3NlciBhZGRFdmVudExpc3RlbmVyXG4gICAgaGFtc3Rlci5lbGVtZW50W0hhbXN0ZXIuQUREX0VWRU5UXShIYW1zdGVyLlBSRUZJWCArIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG5cbiAgICAvLyBzdG9yZSBvcmlnaW5hbCBhbmQgbm9ybWFsaXNlZCBoYW5kbGVycyBvbiB0aGUgaW5zdGFuY2VcbiAgICBoYW1zdGVyLmhhbmRsZXJzLnB1c2goe1xuICAgICAgb3JpZ2luYWw6IG9yaWdpbmFsSGFuZGxlcixcbiAgICAgIG5vcm1hbGlzZWQ6IGhhbmRsZXJcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogcmVtb3ZlV2hlZWxMaXN0ZW5lclxuICAgKiBAcGFyYW0gICB7SW5zdGFuY2V9ICAgIGhhbXN0ZXJcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICBldmVudE5hbWVcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgICAgdXNlQ2FwdHVyZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoaGFtc3RlciwgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKXtcbiAgICAvLyBmaW5kIHRoZSBub3JtYWxpc2VkIGhhbmRsZXIgb24gdGhlIGluc3RhbmNlXG4gICAgdmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXIsXG4gICAgICAgIGxvb2t1cCA9IHt9LFxuICAgICAgICBoYW5kbGVycztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaGFtc3Rlci5oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgbG9va3VwW2hhbXN0ZXIuaGFuZGxlcnNbaV0ub3JpZ2luYWxdID0gaGFtc3Rlci5oYW5kbGVyc1tpXTtcbiAgICB9XG4gICAgaGFuZGxlcnMgPSBsb29rdXBbb3JpZ2luYWxIYW5kbGVyXTtcbiAgICBoYW5kbGVyID0gaGFuZGxlcnMubm9ybWFsaXNlZDtcblxuICAgIC8vIGNyb3NzLWJyb3dzZXIgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgIGhhbXN0ZXIuZWxlbWVudFtIYW1zdGVyLlJFTU9WRV9FVkVOVF0oSGFtc3Rlci5QUkVGSVggKyBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xuXG4gICAgLy8gcmVtb3ZlIG9yaWdpbmFsIGFuZCBub3JtYWxpc2VkIGhhbmRsZXJzIGZyb20gdGhlIGluc3RhbmNlXG4gICAgZm9yICh2YXIgaCBpbiBoYW1zdGVyLmhhbmRsZXJzKSB7XG4gICAgICBpZiAoaGFtc3Rlci5oYW5kbGVyc1toXSA9PSBoYW5kbGVycykge1xuICAgICAgICBoYW1zdGVyLmhhbmRsZXJzLnNwbGljZShoLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIHRoZXNlIGhvbGQgdGhlIGxvd2VzdCBkZWx0YXMsXG4gKiB1c2VkIHRvIG5vcm1hbGlzZSB0aGUgZGVsdGEgdmFsdWVzXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG52YXIgbG93ZXN0RGVsdGEsXG4gICAgbG93ZXN0RGVsdGFYWTtcblxuSGFtc3Rlci5ub3JtYWxpc2UgPSB7XG4gIC8qKlxuICAgKiBmaXggYnJvd3NlciBpbmNvbnNpc3RlbmNpZXNcbiAgICovXG4gIGJyb3dzZXI6IGZ1bmN0aW9uIG5vcm1hbGlzZUJyb3dzZXIoKXtcbiAgICAvLyBkZXRlY3QgZGVwcmVjYXRlZCB3aGVlbCBldmVudHNcbiAgICBpZiAoISgnb253aGVlbCcgaW4gZG9jdW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID49IDkpKSB7XG4gICAgICBIYW1zdGVyLlNVUFBPUlQgPSBkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnbW91c2V3aGVlbCcgOiAvLyB3ZWJraXQgYW5kIElFIDwgOSBzdXBwb3J0IGF0IGxlYXN0IFwibW91c2V3aGVlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE9NTW91c2VTY3JvbGwnOyAvLyBhc3N1bWUgcmVtYWluaW5nIGJyb3dzZXJzIGFyZSBvbGRlciBGaXJlZm94XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IGRlcHJlY2F0ZWQgZXZlbnQgbW9kZWxcbiAgICBpZiAoIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAvLyBhc3N1bWUgSUUgPCA5XG4gICAgICBIYW1zdGVyLkFERF9FVkVOVCA9ICdhdHRhY2hFdmVudCc7XG4gICAgICBIYW1zdGVyLlJFTU9WRV9FVkVOVCA9ICdkZXRhY2hFdmVudCc7XG4gICAgICBIYW1zdGVyLlBSRUZJWCA9ICdvbic7XG4gICAgfVxuXG4gIH0sXG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIG5vcm1hbGlzZWQgZXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgb3JpZ2luYWxFdmVudFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAgICAgIGV2ZW50XG4gICAqL1xuICAgZXZlbnQ6IGZ1bmN0aW9uIG5vcm1hbGlzZUV2ZW50KG9yaWdpbmFsRXZlbnQpe1xuICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3RcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgIHRhcmdldDogb3JpZ2luYWxFdmVudC50YXJnZXQgfHwgb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50LFxuICAgICAgICAgIHR5cGU6ICd3aGVlbCcsXG4gICAgICAgICAgZGVsdGFNb2RlOiBvcmlnaW5hbEV2ZW50LnR5cGUgPT09ICdNb3pNb3VzZVBpeGVsU2Nyb2xsJyA/IDAgOiAxLFxuICAgICAgICAgIGRlbHRhWDogMCxcbiAgICAgICAgICBkZWx0YVo6IDAsXG4gICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQuY2FuY2VsQnViYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRlbHRhWSAoYW5kIGRlbHRhWCkgYWNjb3JkaW5nIHRvIHRoZSBldmVudFxuXG4gICAgLy8gJ21vdXNld2hlZWwnXG4gICAgaWYgKG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgZXZlbnQuZGVsdGFZID0gLSAxLzQwICogb3JpZ2luYWxFdmVudC53aGVlbERlbHRhO1xuICAgIH1cbiAgICAvLyB3ZWJraXRcbiAgICBpZiAob3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCkge1xuICAgICAgZXZlbnQuZGVsdGFYID0gLSAxLzQwICogb3JpZ2luYWxFdmVudC53aGVlbERlbHRhWDtcbiAgICB9XG5cbiAgICAvLyAnRG9tTW91c2VTY3JvbGwnXG4gICAgaWYgKG9yaWdpbmFsRXZlbnQuZGV0YWlsKSB7XG4gICAgICBldmVudC5kZWx0YVkgPSBvcmlnaW5hbEV2ZW50LmRldGFpbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIG5vcm1hbGlzZSAnZGVsdGFzJyBvZiB0aGUgbW91c2Ugd2hlZWxcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBvcmlnaW5hbEV2ZW50XG4gICAqIEByZXR1cm5zIHtBcnJheX0gICAgICAgZGVsdGFzXG4gICAqL1xuICBkZWx0YTogZnVuY3Rpb24gbm9ybWFsaXNlRGVsdGEob3JpZ2luYWxFdmVudCl7XG4gICAgdmFyIGRlbHRhID0gMCxcbiAgICAgIGRlbHRhWCA9IDAsXG4gICAgICBkZWx0YVkgPSAwLFxuICAgICAgYWJzRGVsdGEgPSAwLFxuICAgICAgYWJzRGVsdGFYWSA9IDAsXG4gICAgICBmbjtcblxuICAgIC8vIG5vcm1hbGlzZSBkZWx0YXMgYWNjb3JkaW5nIHRvIHRoZSBldmVudFxuXG4gICAgLy8gJ3doZWVsJyBldmVudFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LmRlbHRhWSkge1xuICAgICAgZGVsdGFZID0gb3JpZ2luYWxFdmVudC5kZWx0YVkgKiAtMTtcbiAgICAgIGRlbHRhICA9IGRlbHRhWTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQuZGVsdGFYKSB7XG4gICAgICBkZWx0YVggPSBvcmlnaW5hbEV2ZW50LmRlbHRhWDtcbiAgICAgIGRlbHRhICA9IGRlbHRhWCAqIC0xO1xuICAgIH1cblxuICAgIC8vICdtb3VzZXdoZWVsJyBldmVudFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgIGRlbHRhID0gb3JpZ2luYWxFdmVudC53aGVlbERlbHRhO1xuICAgIH1cbiAgICAvLyB3ZWJraXRcbiAgICBpZiAob3JpZ2luYWxFdmVudC53aGVlbERlbHRhWSkge1xuICAgICAgZGVsdGFZID0gb3JpZ2luYWxFdmVudC53aGVlbERlbHRhWTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVgpIHtcbiAgICAgIGRlbHRhWCA9IG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVggKiAtMTtcbiAgICB9XG5cbiAgICAvLyAnRG9tTW91c2VTY3JvbGwnIGV2ZW50XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQuZGV0YWlsKSB7XG4gICAgICBkZWx0YSA9IG9yaWdpbmFsRXZlbnQuZGV0YWlsICogLTE7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcmV0dXJuIE5hTlxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciBsb3dlc3QgZGVsdGEgdG8gbm9ybWFsaXplIHRoZSBkZWx0YSB2YWx1ZXNcbiAgICBhYnNEZWx0YSA9IE1hdGguYWJzKGRlbHRhKTtcbiAgICBpZiAoIWxvd2VzdERlbHRhIHx8IGFic0RlbHRhIDwgbG93ZXN0RGVsdGEpIHtcbiAgICAgIGxvd2VzdERlbHRhID0gYWJzRGVsdGE7XG4gICAgfVxuICAgIGFic0RlbHRhWFkgPSBNYXRoLm1heChNYXRoLmFicyhkZWx0YVkpLCBNYXRoLmFicyhkZWx0YVgpKTtcbiAgICBpZiAoIWxvd2VzdERlbHRhWFkgfHwgYWJzRGVsdGFYWSA8IGxvd2VzdERlbHRhWFkpIHtcbiAgICAgIGxvd2VzdERlbHRhWFkgPSBhYnNEZWx0YVhZO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZGVsdGFzIHRvIHdob2xlIG51bWJlcnNcbiAgICBmbiA9IGRlbHRhID4gMCA/ICdmbG9vcicgOiAnY2VpbCc7XG4gICAgZGVsdGEgID0gTWF0aFtmbl0oZGVsdGEgLyBsb3dlc3REZWx0YSk7XG4gICAgZGVsdGFYID0gTWF0aFtmbl0oZGVsdGFYIC8gbG93ZXN0RGVsdGFYWSk7XG4gICAgZGVsdGFZID0gTWF0aFtmbl0oZGVsdGFZIC8gbG93ZXN0RGVsdGFYWSk7XG5cbiAgICByZXR1cm4gW2RlbHRhLCBkZWx0YVgsIGRlbHRhWV07XG4gIH1cbn07XG5cbmlmICh0eXBlb2Ygd2luZG93LmRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB3aW5kb3cuZGVmaW5lLmFtZCkge1xuICAvLyBBTURcbiAgd2luZG93LmRlZmluZSgnaGFtc3RlcicsIFtdLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBIYW1zdGVyO1xuICB9KTtcbn0gZWxzZSBpZiAodHJ1ZSkge1xuICAvLyBDb21tb25KU1xuICBtb2R1bGUuZXhwb3J0cyA9IEhhbXN0ZXI7XG59IGVsc2Uge31cblxufSkod2luZG93LCB3aW5kb3cuZG9jdW1lbnQpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NjE6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187Ly8gQ29weXJpZ2h0IChjKSAyMDEzIFBpZXJveHkgPHBpZXJveHlAcGllcm94eS5uZXQ+XG4vLyBUaGlzIHdvcmsgaXMgZnJlZS4gWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuLy8gdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBXVEZQTCwgVmVyc2lvbiAyXG4vLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgTElDRU5TRS50eHQgb3IgaHR0cDovL3d3dy53dGZwbC5uZXQvXG4vL1xuLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHRoZSBob21lIHBhZ2U6XG4vLyBodHRwOi8vcGllcm94eS5uZXQvYmxvZy9wYWdlcy9sei1zdHJpbmcvdGVzdGluZy5odG1sXG4vL1xuLy8gTFotYmFzZWQgY29tcHJlc3Npb24gYWxnb3JpdGhtLCB2ZXJzaW9uIDEuNC40XG52YXIgTFpTdHJpbmcgPSAoZnVuY3Rpb24oKSB7XG5cbi8vIHByaXZhdGUgcHJvcGVydHlcbnZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBrZXlTdHJCYXNlNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG52YXIga2V5U3RyVXJpU2FmZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLSRcIjtcbnZhciBiYXNlUmV2ZXJzZURpYyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRCYXNlVmFsdWUoYWxwaGFiZXQsIGNoYXJhY3Rlcikge1xuICBpZiAoIWJhc2VSZXZlcnNlRGljW2FscGhhYmV0XSkge1xuICAgIGJhc2VSZXZlcnNlRGljW2FscGhhYmV0XSA9IHt9O1xuICAgIGZvciAodmFyIGk9MCA7IGk8YWxwaGFiZXQubGVuZ3RoIDsgaSsrKSB7XG4gICAgICBiYXNlUmV2ZXJzZURpY1thbHBoYWJldF1bYWxwaGFiZXQuY2hhckF0KGkpXSA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlUmV2ZXJzZURpY1thbHBoYWJldF1bY2hhcmFjdGVyXTtcbn1cblxudmFyIExaU3RyaW5nID0ge1xuICBjb21wcmVzc1RvQmFzZTY0IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgIHZhciByZXMgPSBMWlN0cmluZy5fY29tcHJlc3MoaW5wdXQsIDYsIGZ1bmN0aW9uKGEpe3JldHVybiBrZXlTdHJCYXNlNjQuY2hhckF0KGEpO30pO1xuICAgIHN3aXRjaCAocmVzLmxlbmd0aCAlIDQpIHsgLy8gVG8gcHJvZHVjZSB2YWxpZCBCYXNlNjRcbiAgICBkZWZhdWx0OiAvLyBXaGVuIGNvdWxkIHRoaXMgaGFwcGVuID9cbiAgICBjYXNlIDAgOiByZXR1cm4gcmVzO1xuICAgIGNhc2UgMSA6IHJldHVybiByZXMrXCI9PT1cIjtcbiAgICBjYXNlIDIgOiByZXR1cm4gcmVzK1wiPT1cIjtcbiAgICBjYXNlIDMgOiByZXR1cm4gcmVzK1wiPVwiO1xuICAgIH1cbiAgfSxcblxuICBkZWNvbXByZXNzRnJvbUJhc2U2NCA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICBpZiAoaW5wdXQgPT0gXCJcIikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIExaU3RyaW5nLl9kZWNvbXByZXNzKGlucHV0Lmxlbmd0aCwgMzIsIGZ1bmN0aW9uKGluZGV4KSB7IHJldHVybiBnZXRCYXNlVmFsdWUoa2V5U3RyQmFzZTY0LCBpbnB1dC5jaGFyQXQoaW5kZXgpKTsgfSk7XG4gIH0sXG5cbiAgY29tcHJlc3NUb1VURjE2IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBMWlN0cmluZy5fY29tcHJlc3MoaW5wdXQsIDE1LCBmdW5jdGlvbihhKXtyZXR1cm4gZihhKzMyKTt9KSArIFwiIFwiO1xuICB9LFxuXG4gIGRlY29tcHJlc3NGcm9tVVRGMTY6IGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XG4gICAgaWYgKGNvbXByZXNzZWQgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgaWYgKGNvbXByZXNzZWQgPT0gXCJcIikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIExaU3RyaW5nLl9kZWNvbXByZXNzKGNvbXByZXNzZWQubGVuZ3RoLCAxNjM4NCwgZnVuY3Rpb24oaW5kZXgpIHsgcmV0dXJuIGNvbXByZXNzZWQuY2hhckNvZGVBdChpbmRleCkgLSAzMjsgfSk7XG4gIH0sXG5cbiAgLy9jb21wcmVzcyBpbnRvIHVpbnQ4YXJyYXkgKFVDUy0yIGJpZyBlbmRpYW4gZm9ybWF0KVxuICBjb21wcmVzc1RvVWludDhBcnJheTogZnVuY3Rpb24gKHVuY29tcHJlc3NlZCkge1xuICAgIHZhciBjb21wcmVzc2VkID0gTFpTdHJpbmcuY29tcHJlc3ModW5jb21wcmVzc2VkKTtcbiAgICB2YXIgYnVmPW5ldyBVaW50OEFycmF5KGNvbXByZXNzZWQubGVuZ3RoKjIpOyAvLyAyIGJ5dGVzIHBlciBjaGFyYWN0ZXJcblxuICAgIGZvciAodmFyIGk9MCwgVG90YWxMZW49Y29tcHJlc3NlZC5sZW5ndGg7IGk8VG90YWxMZW47IGkrKykge1xuICAgICAgdmFyIGN1cnJlbnRfdmFsdWUgPSBjb21wcmVzc2VkLmNoYXJDb2RlQXQoaSk7XG4gICAgICBidWZbaSoyXSA9IGN1cnJlbnRfdmFsdWUgPj4+IDg7XG4gICAgICBidWZbaSoyKzFdID0gY3VycmVudF92YWx1ZSAlIDI1NjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcblxuICAvL2RlY29tcHJlc3MgZnJvbSB1aW50OGFycmF5IChVQ1MtMiBiaWcgZW5kaWFuIGZvcm1hdClcbiAgZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OmZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XG4gICAgaWYgKGNvbXByZXNzZWQ9PT1udWxsIHx8IGNvbXByZXNzZWQ9PT11bmRlZmluZWQpe1xuICAgICAgICByZXR1cm4gTFpTdHJpbmcuZGVjb21wcmVzcyhjb21wcmVzc2VkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYnVmPW5ldyBBcnJheShjb21wcmVzc2VkLmxlbmd0aC8yKTsgLy8gMiBieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgICAgIGZvciAodmFyIGk9MCwgVG90YWxMZW49YnVmLmxlbmd0aDsgaTxUb3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgYnVmW2ldPWNvbXByZXNzZWRbaSoyXSoyNTYrY29tcHJlc3NlZFtpKjIrMV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGJ1Zi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZihjKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gTFpTdHJpbmcuZGVjb21wcmVzcyhyZXN1bHQuam9pbignJykpO1xuXG4gICAgfVxuXG4gIH0sXG5cblxuICAvL2NvbXByZXNzIGludG8gYSBzdHJpbmcgdGhhdCBpcyBhbHJlYWR5IFVSSSBlbmNvZGVkXG4gIGNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgcmV0dXJuIExaU3RyaW5nLl9jb21wcmVzcyhpbnB1dCwgNiwgZnVuY3Rpb24oYSl7cmV0dXJuIGtleVN0clVyaVNhZmUuY2hhckF0KGEpO30pO1xuICB9LFxuXG4gIC8vZGVjb21wcmVzcyBmcm9tIGFuIG91dHB1dCBvZiBjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudFxuICBkZWNvbXByZXNzRnJvbUVuY29kZWRVUklDb21wb25lbnQ6ZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgIGlmIChpbnB1dCA9PSBcIlwiKSByZXR1cm4gbnVsbDtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLyAvZywgXCIrXCIpO1xuICAgIHJldHVybiBMWlN0cmluZy5fZGVjb21wcmVzcyhpbnB1dC5sZW5ndGgsIDMyLCBmdW5jdGlvbihpbmRleCkgeyByZXR1cm4gZ2V0QmFzZVZhbHVlKGtleVN0clVyaVNhZmUsIGlucHV0LmNoYXJBdChpbmRleCkpOyB9KTtcbiAgfSxcblxuICBjb21wcmVzczogZnVuY3Rpb24gKHVuY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBMWlN0cmluZy5fY29tcHJlc3ModW5jb21wcmVzc2VkLCAxNiwgZnVuY3Rpb24oYSl7cmV0dXJuIGYoYSk7fSk7XG4gIH0sXG4gIF9jb21wcmVzczogZnVuY3Rpb24gKHVuY29tcHJlc3NlZCwgYml0c1BlckNoYXIsIGdldENoYXJGcm9tSW50KSB7XG4gICAgaWYgKHVuY29tcHJlc3NlZCA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICB2YXIgaSwgdmFsdWUsXG4gICAgICAgIGNvbnRleHRfZGljdGlvbmFyeT0ge30sXG4gICAgICAgIGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlPSB7fSxcbiAgICAgICAgY29udGV4dF9jPVwiXCIsXG4gICAgICAgIGNvbnRleHRfd2M9XCJcIixcbiAgICAgICAgY29udGV4dF93PVwiXCIsXG4gICAgICAgIGNvbnRleHRfZW5sYXJnZUluPSAyLCAvLyBDb21wZW5zYXRlIGZvciB0aGUgZmlyc3QgZW50cnkgd2hpY2ggc2hvdWxkIG5vdCBjb3VudFxuICAgICAgICBjb250ZXh0X2RpY3RTaXplPSAzLFxuICAgICAgICBjb250ZXh0X251bUJpdHM9IDIsXG4gICAgICAgIGNvbnRleHRfZGF0YT1bXSxcbiAgICAgICAgY29udGV4dF9kYXRhX3ZhbD0wLFxuICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb249MCxcbiAgICAgICAgaWk7XG5cbiAgICBmb3IgKGlpID0gMDsgaWkgPCB1bmNvbXByZXNzZWQubGVuZ3RoOyBpaSArPSAxKSB7XG4gICAgICBjb250ZXh0X2MgPSB1bmNvbXByZXNzZWQuY2hhckF0KGlpKTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRleHRfZGljdGlvbmFyeSxjb250ZXh0X2MpKSB7XG4gICAgICAgIGNvbnRleHRfZGljdGlvbmFyeVtjb250ZXh0X2NdID0gY29udGV4dF9kaWN0U2l6ZSsrO1xuICAgICAgICBjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZVtjb250ZXh0X2NdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dF93YyA9IGNvbnRleHRfdyArIGNvbnRleHRfYztcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGV4dF9kaWN0aW9uYXJ5LGNvbnRleHRfd2MpKSB7XG4gICAgICAgIGNvbnRleHRfdyA9IGNvbnRleHRfd2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlLGNvbnRleHRfdykpIHtcbiAgICAgICAgICBpZiAoY29udGV4dF93LmNoYXJDb2RlQXQoMCk8MjU2KSB7XG4gICAgICAgICAgICBmb3IgKGk9MCA7IGk8Y29udGV4dF9udW1CaXRzIDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKTtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gY29udGV4dF93LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBmb3IgKGk9MCA7IGk8OCA7IGkrKykge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCAodmFsdWUmMSk7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSAxO1xuICAgICAgICAgICAgZm9yIChpPTAgOyBpPGNvbnRleHRfbnVtQml0cyA7IGkrKykge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCB2YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PWJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgZm9yIChpPTAgOyBpPDE2IDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8ICh2YWx1ZSYxKTtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbi0tO1xuICAgICAgICAgIGlmIChjb250ZXh0X2VubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbiA9IE1hdGgucG93KDIsIGNvbnRleHRfbnVtQml0cyk7XG4gICAgICAgICAgICBjb250ZXh0X251bUJpdHMrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlW2NvbnRleHRfd107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0X2RpY3Rpb25hcnlbY29udGV4dF93XTtcbiAgICAgICAgICBmb3IgKGk9MCA7IGk8Y29udGV4dF9udW1CaXRzIDsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCAodmFsdWUmMSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dF9lbmxhcmdlSW4tLTtcbiAgICAgICAgaWYgKGNvbnRleHRfZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbiA9IE1hdGgucG93KDIsIGNvbnRleHRfbnVtQml0cyk7XG4gICAgICAgICAgY29udGV4dF9udW1CaXRzKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHdjIHRvIHRoZSBkaWN0aW9uYXJ5LlxuICAgICAgICBjb250ZXh0X2RpY3Rpb25hcnlbY29udGV4dF93Y10gPSBjb250ZXh0X2RpY3RTaXplKys7XG4gICAgICAgIGNvbnRleHRfdyA9IFN0cmluZyhjb250ZXh0X2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE91dHB1dCB0aGUgY29kZSBmb3Igdy5cbiAgICBpZiAoY29udGV4dF93ICE9PSBcIlwiKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlLGNvbnRleHRfdykpIHtcbiAgICAgICAgaWYgKGNvbnRleHRfdy5jaGFyQ29kZUF0KDApPDI1Nikge1xuICAgICAgICAgIGZvciAoaT0wIDsgaTxjb250ZXh0X251bUJpdHMgOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gY29udGV4dF93LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZm9yIChpPTAgOyBpPDggOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8ICh2YWx1ZSYxKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgICBmb3IgKGk9MCA7IGk8Y29udGV4dF9udW1CaXRzIDsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gY29udGV4dF93LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZm9yIChpPTAgOyBpPDE2IDsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCAodmFsdWUmMSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0X2VubGFyZ2VJbi0tO1xuICAgICAgICBpZiAoY29udGV4dF9lbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluID0gTWF0aC5wb3coMiwgY29udGV4dF9udW1CaXRzKTtcbiAgICAgICAgICBjb250ZXh0X251bUJpdHMrKztcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGVbY29udGV4dF93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gY29udGV4dF9kaWN0aW9uYXJ5W2NvbnRleHRfd107XG4gICAgICAgIGZvciAoaT0wIDsgaTxjb250ZXh0X251bUJpdHMgOyBpKyspIHtcbiAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCAodmFsdWUmMSk7XG4gICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgIH1cblxuXG4gICAgICB9XG4gICAgICBjb250ZXh0X2VubGFyZ2VJbi0tO1xuICAgICAgaWYgKGNvbnRleHRfZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgY29udGV4dF9lbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBjb250ZXh0X251bUJpdHMpO1xuICAgICAgICBjb250ZXh0X251bUJpdHMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYXJrIHRoZSBlbmQgb2YgdGhlIHN0cmVhbVxuICAgIHZhbHVlID0gMjtcbiAgICBmb3IgKGk9MCA7IGk8Y29udGV4dF9udW1CaXRzIDsgaSsrKSB7XG4gICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSkgfCAodmFsdWUmMSk7XG4gICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIHRoZSBsYXN0IGNoYXJcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpO1xuICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbHNlIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dF9kYXRhLmpvaW4oJycpO1xuICB9LFxuXG4gIGRlY29tcHJlc3M6IGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XG4gICAgaWYgKGNvbXByZXNzZWQgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgaWYgKGNvbXByZXNzZWQgPT0gXCJcIikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIExaU3RyaW5nLl9kZWNvbXByZXNzKGNvbXByZXNzZWQubGVuZ3RoLCAzMjc2OCwgZnVuY3Rpb24oaW5kZXgpIHsgcmV0dXJuIGNvbXByZXNzZWQuY2hhckNvZGVBdChpbmRleCk7IH0pO1xuICB9LFxuXG4gIF9kZWNvbXByZXNzOiBmdW5jdGlvbiAobGVuZ3RoLCByZXNldFZhbHVlLCBnZXROZXh0VmFsdWUpIHtcbiAgICB2YXIgZGljdGlvbmFyeSA9IFtdLFxuICAgICAgICBuZXh0LFxuICAgICAgICBlbmxhcmdlSW4gPSA0LFxuICAgICAgICBkaWN0U2l6ZSA9IDQsXG4gICAgICAgIG51bUJpdHMgPSAzLFxuICAgICAgICBlbnRyeSA9IFwiXCIsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBpLFxuICAgICAgICB3LFxuICAgICAgICBiaXRzLCByZXNiLCBtYXhwb3dlciwgcG93ZXIsXG4gICAgICAgIGMsXG4gICAgICAgIGRhdGEgPSB7dmFsOmdldE5leHRWYWx1ZSgwKSwgcG9zaXRpb246cmVzZXRWYWx1ZSwgaW5kZXg6MX07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICBkaWN0aW9uYXJ5W2ldID0gaTtcbiAgICB9XG5cbiAgICBiaXRzID0gMDtcbiAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsMik7XG4gICAgcG93ZXI9MTtcbiAgICB3aGlsZSAocG93ZXIhPW1heHBvd2VyKSB7XG4gICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICB9XG4gICAgICBiaXRzIHw9IChyZXNiPjAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgIHBvd2VyIDw8PSAxO1xuICAgIH1cblxuICAgIHN3aXRjaCAobmV4dCA9IGJpdHMpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsOCk7XG4gICAgICAgICAgcG93ZXI9MTtcbiAgICAgICAgICB3aGlsZSAocG93ZXIhPW1heHBvd2VyKSB7XG4gICAgICAgICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzIHw9IChyZXNiPjAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgYyA9IGYoYml0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiwxNik7XG4gICAgICAgICAgcG93ZXI9MTtcbiAgICAgICAgICB3aGlsZSAocG93ZXIhPW1heHBvd2VyKSB7XG4gICAgICAgICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzIHw9IChyZXNiPjAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgYyA9IGYoYml0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZGljdGlvbmFyeVszXSA9IGM7XG4gICAgdyA9IGM7XG4gICAgcmVzdWx0LnB1c2goYyk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChkYXRhLmluZGV4ID4gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuXG4gICAgICBiaXRzID0gMDtcbiAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMixudW1CaXRzKTtcbiAgICAgIHBvd2VyPTE7XG4gICAgICB3aGlsZSAocG93ZXIhPW1heHBvd2VyKSB7XG4gICAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICB9XG4gICAgICAgIGJpdHMgfD0gKHJlc2I+MCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjID0gYml0cykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLDgpO1xuICAgICAgICAgIHBvd2VyPTE7XG4gICAgICAgICAgd2hpbGUgKHBvd2VyIT1tYXhwb3dlcikge1xuICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cyB8PSAocmVzYj4wID8gMSA6IDApICogcG93ZXI7XG4gICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWN0aW9uYXJ5W2RpY3RTaXplKytdID0gZihiaXRzKTtcbiAgICAgICAgICBjID0gZGljdFNpemUtMTtcbiAgICAgICAgICBlbmxhcmdlSW4tLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiwxNik7XG4gICAgICAgICAgcG93ZXI9MTtcbiAgICAgICAgICB3aGlsZSAocG93ZXIhPW1heHBvd2VyKSB7XG4gICAgICAgICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzIHw9IChyZXNiPjAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaWN0aW9uYXJ5W2RpY3RTaXplKytdID0gZihiaXRzKTtcbiAgICAgICAgICBjID0gZGljdFNpemUtMTtcbiAgICAgICAgICBlbmxhcmdlSW4tLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICBlbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBudW1CaXRzKTtcbiAgICAgICAgbnVtQml0cysrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGljdGlvbmFyeVtjXSkge1xuICAgICAgICBlbnRyeSA9IGRpY3Rpb25hcnlbY107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYyA9PT0gZGljdFNpemUpIHtcbiAgICAgICAgICBlbnRyeSA9IHcgKyB3LmNoYXJBdCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuXG4gICAgICAvLyBBZGQgdytlbnRyeVswXSB0byB0aGUgZGljdGlvbmFyeS5cbiAgICAgIGRpY3Rpb25hcnlbZGljdFNpemUrK10gPSB3ICsgZW50cnkuY2hhckF0KDApO1xuICAgICAgZW5sYXJnZUluLS07XG5cbiAgICAgIHcgPSBlbnRyeTtcblxuICAgICAgaWYgKGVubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgIGVubGFyZ2VJbiA9IE1hdGgucG93KDIsIG51bUJpdHMpO1xuICAgICAgICBudW1CaXRzKys7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cbn07XG4gIHJldHVybiBMWlN0cmluZztcbn0pKCk7XG5cbmlmICh0cnVlKSB7XG4gICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gTFpTdHJpbmc7IH0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG59IGVsc2Uge31cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjY2OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgOiAwXG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg2Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDE4KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCI1NTBiNDdhYlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3Nik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiMWIzNGJmZWJcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gODg2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDkpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjk4OTVkM2E2XCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA4KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCI4MTM5MDM2YVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MDA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4OCk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiMWRiMDFjMGJcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTY5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjMpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjY4ZjI0M2VhXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDExOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjEpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjEyZDIzMDlkXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY4KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCI1YjYyMDYwNVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Nzc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCIxNDNkZmZhYlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzNSk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiZjMyZmQzNmVcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTAxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzkpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjYwNGJmNWVmXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDU2NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjIxZmRlNTczXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4Myk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiZmQ4MzY4OWVcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJaXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGFkZFN0eWxlc0NsaWVudClcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cblxuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZSk7XG4vKioqKioqLyBcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGRvZXNuJ3QgdGVsbCBhYm91dCBpdCdzIHRvcC1sZXZlbCBkZWNsYXJhdGlvbnMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODUxKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFkaW5nLXZ1ZS5qcy5tYXAiLCIvKiFcbiAqIFRWSlMgT3ZlcmxheXMgLSB2MC41LjAgLSBGcmkgSnVsIDA5IDIwMjFcbiAqICAgICBodHRwczovL2dpdGh1Yi5jb20vdHZqc3gvdHJhZGluZy12dWUtanNcbiAqICAgICBDb3B5cmlnaHQgKGMpIDIwMjAgYzQ1MSBDb2RlJ3MgQWxsIFJpZ2h0O1xuICogICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICghcm9vdFsndHJhZGluZy12dWUtanMnXSkge1xuICAgICAgICByb290Wyd0cmFkaW5nLXZ1ZS1qcyddID0gcm9vdFsnVHJhZGluZ1Z1ZUpzJ11cbiAgICB9XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInRyYWRpbmctdnVlLWpzXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInRyYWRpbmctdnVlLWpzXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlR2anNPdmVybGF5c1wiXSA9IGZhY3RvcnkocmVxdWlyZShcInRyYWRpbmctdnVlLWpzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJUdmpzT3ZlcmxheXNcIl0gPSBmYWN0b3J5KHJvb3RbXCJ0cmFkaW5nLXZ1ZS1qc1wiXSk7XG59KShzZWxmLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX185NTRfXykge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gOTU0OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX185NTRfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4oKCkgPT4ge1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwiQUxNQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQUxNQSksXG4gIFwiQVRSXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBVFIpLFxuICBcIkFUUnBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFUUnApLFxuICBcIkFyZWE1MVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQXJlYTUxKSxcbiAgXCJCQlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQkIpLFxuICBcIkJCV1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQkJXKSxcbiAgXCJDQ0lcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENDSSksXG4gIFwiQ01PXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDTU8pLFxuICBcIkNPR1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ09HKSxcbiAgXCJESGlzdG9ncmFtXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBESGlzdG9ncmFtKSxcbiAgXCJETUlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERNSSksXG4gIFwiRU1BXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFTUEpLFxuICBcIkhNQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSE1BKSxcbiAgXCJIaXN0b2dyYW1cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEhpc3RvZ3JhbSksXG4gIFwiSWNoaVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSWNoaSksXG4gIFwiSWNoaW1va3VcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEljaGltb2t1KSxcbiAgXCJLQ1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gS0MpLFxuICBcIktDV1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gS0NXKSxcbiAgXCJMb25nU2hvcnRUcmFkZXNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExvbmdTaG9ydFRyYWRlcyksXG4gIFwiTUFDRFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTUFDRCksXG4gIFwiTUZJXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNRkkpLFxuICBcIk1PTVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTU9NKSxcbiAgXCJNYXJrZXJzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNYXJrZXJzKSxcbiAgXCJQbG90Q3Jvc3NcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBsb3RDcm9zcyksXG4gIFwiUk9DXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBST0MpLFxuICBcIlJTSVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUlNJKSxcbiAgXCJSaWJib25cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJpYmJvbiksXG4gIFwiU0FSXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTQVIpLFxuICBcIlNNQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU01BKSxcbiAgXCJTV01BXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTV01BKSxcbiAgXCJTdG9jaFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3RvY2gpLFxuICBcIlRTSVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVFNJKSxcbiAgXCJUcmFkZXNQbHVzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUcmFkZXNQbHVzKSxcbiAgXCJWV01BXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWV01BKSxcbiAgXCJXaWxsaWFtc1JcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFdpbGxpYW1zUiksXG4gIFwiWE9obGNCYXJzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBYT2hsY0JhcnMpLFxuICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW5kZXhfcHJvZClcbn0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwidHJhZGluZy12dWUtanNcIlxudmFyIGV4dGVybmFsX3RyYWRpbmdfdnVlX2pzXyA9IF9fd2VicGFja19yZXF1aXJlX18oOTU0KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQUxNQS9BTE1BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBTE1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0FMTUEnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0FybmF1ZCBMZWdvdXggTW92aW5nIEF2ZXJhZ2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnQUxNQSAkbGVuZ3RoICRvZmZzZXQgJHNpZ21hJyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzU1OWRlMCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQUxNQSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDEwLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgZGVmOiAwLjksXG4gICAgICAgICAgICB0ZXh0OiAnT2Zmc2V0J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2lnbWE6IHtcbiAgICAgICAgICAgIGRlZjogNSxcbiAgICAgICAgICAgIHRleHQ6ICdTaWdtYSdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbWEoY2xvc2UsIGxlbmd0aCwgb2Zmc2V0LCBzaWdtYSlbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9BTE1BL0FMTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQUxNQV9BTE1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEFMTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcbi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9BTE1BL0FMTUEudnVlXG52YXIgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEFMTUFfQUxNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQUxNQS9BTE1BLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFMTUEgPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9BVFIvQVRSLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBVFJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQVRSJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdBdmVyYWdlIFRydWUgUmFuZ2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnQVRSICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2U1MjQ2OCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQVRSJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTUsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXRyKGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9BVFIvQVRSLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFUUl9BVFJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQVRSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQVRSL0FUUi52dWVcbnZhciBBVFJfcmVuZGVyLCBBVFJfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQVRSX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQVRSX0FUUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQVRSX3JlbmRlcixcbiAgQVRSX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQVRSX2FwaTsgfVxuQVRSX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0FUUi9BVFIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQVRSID0gKEFUUl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0FUUnAvQVRScC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQVRScHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdBVFJwJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdBdmVyYWdlIFRydWUgUmFuZ2UsICUnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnQVRSJSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNmNDQzMzYnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0FUUnAnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxNSxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxMDAgKiBhdHIobGVuZ3RoKVswXSAvIGNsb3NlWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQVRScC9BVFJwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFUUnBfQVRScHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChBVFJwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQVRScC9BVFJwLnZ1ZVxudmFyIEFUUnBfcmVuZGVyLCBBVFJwX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEFUUnBfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBBVFJwX0FUUnB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEFUUnBfcmVuZGVyLFxuICBBVFJwX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQVRScF9hcGk7IH1cbkFUUnBfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQVRScC9BVFJwLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFUUnAgPSAoQVRScF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0FyZWE1MS9BcmVhNTEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFyZWE1MXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdBcmVhNTEnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ/Cfkb0nLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnR3JhZGllbnQgYXJlYSBjaGFydCdcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBkYXRhID0gdGhpcy4kcHJvcHMuZGF0YTtcbiAgICAgIHZhciBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgbGF5b3V0LmhlaWdodCk7XG4gICAgICBncmQuYWRkQ29sb3JTdG9wKDAsIHRoaXMuYmFjazEpO1xuICAgICAgZ3JkLmFkZENvbG9yU3RvcCgxLCB0aGlzLmJhY2syKTsgLy8gTGluZVxuXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG4gICAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7IC8vIEFyZWFcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyZDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHZhciBwMCA9IChkYXRhWzBdIHx8IFtdKVswXTtcbiAgICAgIHZhciBwTiA9IChkYXRhW2RhdGEubGVuZ3RoIC0gMV0gfHwgW10pWzBdO1xuICAgICAgY3R4LmxpbmVUbyhsYXlvdXQudDJzY3JlZW4ocDApLCBsYXlvdXQuaGVpZ2h0KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3ggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG5cbiAgICAgICAgICB2YXIgX3kgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXSk7XG5cbiAgICAgICAgICBjdHgubGluZVRvKF94LCBfeSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHgubGluZVRvKGxheW91dC50MnNjcmVlbihwTiksIGxheW91dC5oZWlnaHQpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydBcmVhNTEnXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvcl07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAxLjI1O1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCAnIzJmZDY4Zic7XG4gICAgfSxcbiAgICBiYWNrMTogZnVuY3Rpb24gYmFjazEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhY2sxIHx8IHRoaXMuY29sb3IgKyAnMTUnO1xuICAgIH0sXG4gICAgYmFjazI6IGZ1bmN0aW9uIGJhY2syKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYWNrMiB8fCB0aGlzLmNvbG9yICsgJzAxJztcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9BcmVhNTEvQXJlYTUxLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFyZWE1MV9BcmVhNTF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQXJlYTUxdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQXJlYTUxL0FyZWE1MS52dWVcbnZhciBBcmVhNTFfcmVuZGVyLCBBcmVhNTFfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQXJlYTUxX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQXJlYTUxX0FyZWE1MXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQXJlYTUxX3JlbmRlcixcbiAgQXJlYTUxX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQXJlYTUxX2FwaTsgfVxuQXJlYTUxX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0FyZWE1MS9BcmVhNTEudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQXJlYTUxID0gKEFyZWE1MV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0JCL0JCLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCQnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdCQicsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnQm9sbGluZ2VyIEJhbmRzJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0JCICRsZW5ndGggJHN0ZGRldicsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyMyY2M2YzlhYicsXG4gICAgICAgICAgICBzaG93TWlkOiB0cnVlLFxuICAgICAgICAgICAgYmFja0NvbG9yOiAnIzJjYzZjOTBhJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydCQiddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDIxLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0ZGRldjoge1xuICAgICAgICAgICAgZGVmOiAyLFxuICAgICAgICAgICAgdGV4dDogJ1N0ZERldidcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ0NoYW5uZWwnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBbbSwgaCwgbF0gPSBiYihjbG9zZSwgbGVuZ3RoLCBzdGRkZXYpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2hbMF0sIG1bMF0sIGxbMF1dXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQkIvQkIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQkJfQkJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQkJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9CQi9CQi52dWVcbnZhciBCQl9yZW5kZXIsIEJCX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEJCX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQkJfQkJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEJCX3JlbmRlcixcbiAgQkJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBCQl9hcGk7IH1cbkJCX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0JCL0JCLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJCID0gKEJCX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQkJXL0JCVy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQkJXdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0JCVycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnQm9sbGluZ2VyIEJhbmRzIFdpZHRoJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0JCVyAkbGVuZ3RoICRzdGRkZXYnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzJjYzZjOWFiJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydCQlcnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAyMSxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGRkZXY6IHtcbiAgICAgICAgICAgIGRlZjogMixcbiAgICAgICAgICAgIHRleHQ6ICdTdGREZXYnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYncoY2xvc2UsIGxlbmd0aCwgc3RkZGV2KVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0JCVy9CQlcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQkJXX0JCV3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChCQld2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9CQlcvQkJXLnZ1ZVxudmFyIEJCV19yZW5kZXIsIEJCV19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBCQldfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBCQldfQkJXdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBCQldfcmVuZGVyLFxuICBCQldfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBCQldfYXBpOyB9XG5CQldfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQkJXL0JCVy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCQlcgPSAoQkJXX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQ0NJL0NDSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ0NJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0NDSScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnQ29tbW9kaXR5IENoYW5uZWwgSW5kZXgnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnQ0NJICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2UyOGEzZGVlJyxcbiAgICAgICAgICAgIGJhY2tDb2xvcjogJyNlMjhhM2QxMScsXG4gICAgICAgICAgICBiYW5kQ29sb3I6ICcjYWFhYWFhJyxcbiAgICAgICAgICAgIHVwcGVyOiAxMDAsXG4gICAgICAgICAgICBsb3dlcjogLTEwMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydDQ0knXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAyMSxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdSYW5nZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcInJldHVybiBjY2koY2xvc2UsIGxlbmd0aClbMF1cIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0NDSS9DQ0kudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ0NJX0NDSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDQ0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9DQ0kvQ0NJLnZ1ZVxudmFyIENDSV9yZW5kZXIsIENDSV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBDQ0lfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBDQ0lfQ0NJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDQ0lfcmVuZGVyLFxuICBDQ0lfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBDQ0lfYXBpOyB9XG5DQ0lfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQ0NJL0NDSS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDQ0kgPSAoQ0NJX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQ01PL0NNTy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ01PdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0NNTycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnQ2hhbmRlIE1vbWVudHVtIE9zY2lsbGF0b3InLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnQ01PICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzU1OWRlMCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQ01PJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTAsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwicmV0dXJuIGNtbyhjbG9zZSwgbGVuZ3RoKVswXVwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQ01PL0NNTy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDTU9fQ01PdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKENNT3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0NNTy9DTU8udnVlXG52YXIgQ01PX3JlbmRlciwgQ01PX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIENNT19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIENNT19DTU92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIENNT19yZW5kZXIsXG4gIENNT19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIENNT19hcGk7IH1cbkNNT19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9DTU8vQ01PLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENNTyA9IChDTU9fY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9DT0cvQ09HLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDT0d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ09HJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdDZW50ZXIgb2YgR3Jhdml0eScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdDT0cgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjNTU5ZGUwJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydDT0cnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxMCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJyZXR1cm4gY29nKGNsb3NlLCBsZW5ndGgpWzBdXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9DT0cvQ09HLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENPR19DT0d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ09HdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQ09HL0NPRy52dWVcbnZhciBDT0dfcmVuZGVyLCBDT0dfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQ09HX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQ09HX0NPR3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQ09HX3JlbmRlcixcbiAgQ09HX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQ09HX2FwaTsgfVxuQ09HX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0NPRy9DT0cudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ09HID0gKENPR19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0RIaXN0b2dyYW0vREhpc3RvZ3JhbS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6IFwiREhpc3RvZ3JhbVwiLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogXCJBY2lkM2Nyb2NvXCIsXG4gICAgICAgIHZlcnNpb246IFwiMS4wLjBcIixcbiAgICAgICAgZGVzYzogXCJEb3VibGUgSGlzdG9ncmFtIFBsb3RcIixcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogXCJESGlzdG9ncmFtXCIsXG4gICAgICAgICAgc2lkZTogXCJvZmZjaGFydFwiLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBoaXN0V2lkdGg6IDQsXG4gICAgICAgICAgICB0aHJlc2hvbGRTaXplOiAwLFxuICAgICAgICAgICAgcG9zQ29sb3I6IFwiIzM1YTc3NlwiLFxuICAgICAgICAgICAgbmVnQ29sb3I6IFwiI2U1NDE1MFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmhpc3Rfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBiYXNlID0gbGF5b3V0LiQyc2NyZWVuKDApICsgMC41O1xuICAgICAgdmFyIG9mZiA9IHRoaXMuaGlzdF93aWR0aCAlIDIgPyAwIDogMC41OyAvLyBDb2xvciBjaGFuZ2VkXG5cbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBwb3NfdmFsdWUgPSBwWzFdO1xuICAgICAgICAgIHZhciBuZWdfdmFsdWUgPSBwWzJdO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pIC0gb2ZmO1xuICAgICAgICAgIHZhciB5MSA9IGxheW91dC4kMnNjcmVlbihwb3NfdmFsdWUpIC0gMC41O1xuICAgICAgICAgIHZhciB5MiA9IGxheW91dC4kMnNjcmVlbihuZWdfdmFsdWUpIC0gMC41O1xuXG4gICAgICAgICAgaWYgKHBvc192YWx1ZSA+IHRoaXMudGhyZXNob2xkX3NpemUpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMucG9zX2NvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCBiYXNlKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeTEpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWdfdmFsdWUgPCAtdGhpcy50aHJlc2hvbGRfc2l6ZSkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5uZWdfY29sb3I7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIGJhc2UpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5Mik7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFtcIkRIaXN0b2dyYW1cIl07XG4gICAgfSxcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCh2YWx1ZXMpIHtcbiAgICAgIHZhciB4cyA9IHZhbHVlcy5zbGljZSgxLCAzKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudG9GaXhlZChNYXRoLmFicyh4KSA+IDAuMDAxID8gNCA6IDgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmFsdWU6IHhzWzBdLFxuICAgICAgICBjb2xvcjogdGhpcy5wb3NfY29sb3JcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IHhzWzFdLFxuICAgICAgICBjb2xvcjogdGhpcy5uZWdfY29sb3JcbiAgICAgIH1dO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBoaXN0X3dpZHRoOiBmdW5jdGlvbiBoaXN0X3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5oaXN0V2lkdGggfHwgNDtcbiAgICB9LFxuICAgIHRocmVzaG9sZF9zaXplOiBmdW5jdGlvbiB0aHJlc2hvbGRfc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQudGhyZXNob2xkU2l6ZSB8fCAwO1xuICAgIH0sXG4gICAgcG9zX2NvbG9yOiBmdW5jdGlvbiBwb3NfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnBvc0NvbG9yIHx8IFwiIzM1YTc3NlwiO1xuICAgIH0sXG4gICAgbmVnX2NvbG9yOiBmdW5jdGlvbiBuZWdfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lm5lZ0NvbG9yIHx8IFwiI2U1NDE1MFwiO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0RIaXN0b2dyYW0vREhpc3RvZ3JhbS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBESGlzdG9ncmFtX0RIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0RIaXN0b2dyYW0vREhpc3RvZ3JhbS52dWVcbnZhciBESGlzdG9ncmFtX3JlbmRlciwgREhpc3RvZ3JhbV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBESGlzdG9ncmFtX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgREhpc3RvZ3JhbV9ESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBESGlzdG9ncmFtX3JlbmRlcixcbiAgREhpc3RvZ3JhbV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIERIaXN0b2dyYW1fYXBpOyB9XG5ESGlzdG9ncmFtX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0RIaXN0b2dyYW0vREhpc3RvZ3JhbS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBESGlzdG9ncmFtID0gKERIaXN0b2dyYW1fY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9ETUkvRE1JLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBETUl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnRE1JJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdEaXJlY3Rpb25hbCBNb3ZlbWVudCBJbmRleCcsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdETUkgJGxlbmd0aCAkc21vb3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcnM6IFtcIiNlZjEzNjBcIiwgXCIjMzc4MmYyXCIsIFwiI2Y0ODcwOVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydETUknXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxNSxcbiAgICAgICAgICAgIHRleHQ6ICdESSBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgIGRlZjogMTUsXG4gICAgICAgICAgICB0ZXh0OiAnQURYIFNtb3RoaW5nJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lcydcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgbGV0IFthZHgsIGRwLCBkbl0gPSBkbWkobGVuZ3RoLCBzbW9vdGgpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FkeFswXSwgZHBbMF0sIGRuWzBdXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0RNSS9ETUkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRE1JX0RNSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChETUl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9ETUkvRE1JLnZ1ZVxudmFyIERNSV9yZW5kZXIsIERNSV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBETUlfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBETUlfRE1JdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBETUlfcmVuZGVyLFxuICBETUlfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBETUlfYXBpOyB9XG5ETUlfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvRE1JL0RNSS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBETUkgPSAoRE1JX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvRU1BL0VNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRU1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0VNQScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnRXhwb25lbnRpYWwgTW92aW5nIEF2ZXJhZ2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnRU1BICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjZjc4OTBjJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydFTUEnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxMixcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbWEoY2xvc2UsIGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9FTUEvRU1BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEVNQV9FTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoRU1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvRU1BL0VNQS52dWVcbnZhciBFTUFfcmVuZGVyLCBFTUFfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgRU1BX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgRU1BX0VNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgRU1BX3JlbmRlcixcbiAgRU1BX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgRU1BX2FwaTsgfVxuRU1BX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0VNQS9FTUEudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRU1BID0gKEVNQV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0hNQS9ITUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEhNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdITUEnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0h1bGwgTW92aW5nIEF2ZXJhZ2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnSE1BICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjM2FmNDc1J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydITUEnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxMCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBobWEoY2xvc2UsIGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9ITUEvSE1BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEhNQV9ITUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoSE1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvSE1BL0hNQS52dWVcbnZhciBITUFfcmVuZGVyLCBITUFfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgSE1BX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgSE1BX0hNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgSE1BX3JlbmRlcixcbiAgSE1BX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgSE1BX2FwaTsgfVxuSE1BX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0hNQS9ITUEudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSE1BID0gKEhNQV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0hpc3RvZ3JhbS9IaXN0b2dyYW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdIaXN0b2dyYW0nLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0hpc3RvZ3JhbSBwbG90J1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgYmFzZSA9IGxheW91dC4kMnNjcmVlbigwKSArIDAuNTtcbiAgICAgIHZhciBvZmYgPSB0aGlzLmxpbmVfd2lkdGggJSAyID8gMCA6IDAuNTsgLy8gQ29sb3IgY2hhbmdlZFxuXG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pIC0gb2ZmO1xuICAgICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0pIC0gMC41O1xuICAgICAgICAgIHZhciBfY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHBbMl0pIHtcbiAgICAgICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT09IHBbMl0pIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICBfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBbMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT09IHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICBfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGFuZ2VkKSBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCBiYXNlKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydIaXN0b2dyYW0nXTtcbiAgICB9LFxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKHZhbHVlcykge1xuICAgICAgdmFyIHggPSB2YWx1ZXNbMV07XG5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ID0geC50b0ZpeGVkKE1hdGguYWJzKHgpID4gMC4wMDEgPyA0IDogOCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgY29sb3I6IHZhbHVlc1syXSB8fCB0aGlzLmNvbG9yXG4gICAgICB9XTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDI7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuJHByb3BzLm51bSAlIDU7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8IHRoaXMuQ09MT1JTW25dO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQ09MT1JTOiBbJyM4ODg4ODgnLCAnIzQyYjI4YScsICcjNTY5MWNlJywgJyM2MTJmZjknLCAnI2Q1MGI5MCcsICcjZmYyMzE2J11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9IaXN0b2dyYW0vSGlzdG9ncmFtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEhpc3RvZ3JhbV9IaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvSGlzdG9ncmFtL0hpc3RvZ3JhbS52dWVcbnZhciBIaXN0b2dyYW1fcmVuZGVyLCBIaXN0b2dyYW1fc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgSGlzdG9ncmFtX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgSGlzdG9ncmFtX0hpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgSGlzdG9ncmFtX3JlbmRlcixcbiAgSGlzdG9ncmFtX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgSGlzdG9ncmFtX2FwaTsgfVxuSGlzdG9ncmFtX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0hpc3RvZ3JhbS9IaXN0b2dyYW0udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSGlzdG9ncmFtID0gKEhpc3RvZ3JhbV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0ljaGkvSWNoaS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBDbG91ZCByZW5kZXJlci4gKEljaGltb2t1KVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEljaGl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnSWNoaScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdJY2hpbW9rdSBDbG91ZCBiYXNlZCBvbiBzY3JpcHRzJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHByb3BzLmRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHRoaXMubWFwcCh0aGlzLiRwcm9wcy5kYXRhW2ldKTtcbiAgICAgICAgdmFyIHAyID0gdGhpcy5tYXBwKHRoaXMuJHByb3BzLmRhdGFbaSArIDFdKTtcbiAgICAgICAgaWYgKCFwMikgY29udGludWU7XG4gICAgICAgIGlmIChwMS55MSAhPT0gcDEueTEpIGNvbnRpbnVlOyAvLyBGaXggTmFOXG4gICAgICAgIC8vIEJhY2tncm91bmRcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBwMS55MSA8IHAxLnkyID8gdGhpcy5iYWNrMSA6IHRoaXMuYmFjazI7XG4gICAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueTEpO1xuICAgICAgICBjdHgubGluZVRvKHAyLnggKyAwLjEsIHAyLnkxKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwMi54ICsgMC4xLCBwMi55Mik7XG4gICAgICAgIGN0eC5saW5lVG8ocDEueCwgcDEueTIpO1xuICAgICAgICBjdHguZmlsbCgpOyAvLyBMaW5lc1xuXG4gICAgICAgIGlmICghdGhpcy5kcmF3X2xpbmVzKSBjb250aW51ZTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yMTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55MSk7XG4gICAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueTEpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjI7XG4gICAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueTIpO1xuICAgICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkyKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWFwcDogZnVuY3Rpb24gbWFwcChwKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgcmV0dXJuIHAgJiYge1xuICAgICAgICB4OiBsYXlvdXQudDJzY3JlZW4ocFswXSksXG4gICAgICAgIHkxOiBsYXlvdXQuJDJzY3JlZW4ocFsxXSksXG4gICAgICAgIHkyOiBsYXlvdXQuJDJzY3JlZW4ocFsyXSlcbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnSWNoaSddO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yMSwgdGhpcy5jb2xvcjJdO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgQ1A6IHtcbiAgICAgICAgICAgIGRlZjogOSxcbiAgICAgICAgICAgIHRleHQ6ICdDb252ZXJzaW9uIExpbmUgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgQlA6IHtcbiAgICAgICAgICAgIGRlZjogMjYsXG4gICAgICAgICAgICB0ZXh0OiAnQmFzZSBMaW5lIExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIExTUDoge1xuICAgICAgICAgICAgZGVmOiA1MixcbiAgICAgICAgICAgIHRleHQ6ICdMYWdnaW5nIFNwYW4gMiBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBESVo6IHtcbiAgICAgICAgICAgIGRlZjogMjYsXG4gICAgICAgICAgICB0ZXh0OiAnRGlzcGxhY2VtZW50J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYmFzZUNvbG9yOiB7XG4gICAgICAgICAgICBkZWY6ICdicm93bicsXG4gICAgICAgICAgICB0ZXh0OiAnQmFzZSBMaW5lIENvbG9yJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29udmVyc2lvbkNvbG9yOiB7XG4gICAgICAgICAgICBkZWY6ICdsaWdodGJsdWUnLFxuICAgICAgICAgICAgdGV4dDogJ0NvbnZlcnNpb24gTGluZSBDb2xvcidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxhZ2dpbmdDb2xvcjoge1xuICAgICAgICAgICAgZGVmOiAnIzY2Q0M2NicsXG4gICAgICAgICAgICB0ZXh0OiAnTGFnZ2luZyBTcGFuIENvbG9yJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbmNoaWFuID0gKGxlbiwgaWQpID0+IHRzKFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Zyhsb3dlc3QobG93LCBsZW4pWzBdLCBoaWdoZXN0KGhpZ2gsIGxlbilbMF0pLCBpZFxcbiAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnZlcnNpb25MaW5lID0gZG9uY2hpYW4oQ1AsIDEpXFxuICAgICAgICAgICAgICAgICAgICBsZXQgYmFzZUxpbmUgPSBkb25jaGlhbihCUCwgMilcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWFkTGluZTEgPSB0cyhhdmcoY29udmVyc2lvbkxpbmVbMF0sIGJhc2VMaW5lWzBdKSlcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWFkTGluZTIgPSBkb25jaGlhbihMU1AsIDMpXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGFnZ2luZyA9IHRzKGNsb3NlWzBdKVxcblxcblxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0KHRoaXMsIERJWiAtIDEpXFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQobGFnZ2luZywgLURJWiArIDEpXFxuICAgICAgICAgICAgICAgICAgICBvbmNoYXJ0KFtjb252ZXJzaW9uTGluZSwgYmFzZUxpbmVdLCAnQmFzZSBMaW5lcycsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnM6IFtjb252ZXJzaW9uQ29sb3IsIGJhc2VDb2xvcl1cXG4gICAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgICAgICBvbmNoYXJ0KGxhZ2dpbmcsICdMYWdnaW5nIFNwYW4nLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGxhZ2dpbmdDb2xvclxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbGVhZExpbmUxWzBdLCBsZWFkTGluZTJbMF1dXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC43NTtcbiAgICB9LFxuICAgIGNvbG9yMTogZnVuY3Rpb24gY29sb3IxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvcjEgfHwgJ2xpZ2h0Z3JlZW4nO1xuICAgIH0sXG4gICAgY29sb3IyOiBmdW5jdGlvbiBjb2xvcjIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yMiB8fCAnb3JhbmdlJztcbiAgICB9LFxuICAgIGJhY2sxOiBmdW5jdGlvbiBiYWNrMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFjazEgfHwgJyM3OWZmOWUyMic7XG4gICAgfSxcbiAgICBiYWNrMjogZnVuY3Rpb24gYmFjazIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhY2syIHx8ICcjZWY1MzUwMjInO1xuICAgIH0sXG4gICAgZHJhd19saW5lczogZnVuY3Rpb24gZHJhd19saW5lcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZHJhd0xpbmVzO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQ09MT1JTOiBbJyM0MmIyOGEnLCAnIzU2OTFjZScsICcjNjEyZmY5JywgJyNkNTBiOTAnLCAnI2ZmMjMxNiddXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvSWNoaS9JY2hpLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEljaGlfSWNoaXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChJY2hpdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvSWNoaS9JY2hpLnZ1ZVxudmFyIEljaGlfcmVuZGVyLCBJY2hpX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEljaGlfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBJY2hpX0ljaGl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEljaGlfcmVuZGVyLFxuICBJY2hpX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgSWNoaV9hcGk7IH1cbkljaGlfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvSWNoaS9JY2hpLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEljaGkgPSAoSWNoaV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0ljaGltb2t1L0ljaGltb2t1LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vSWNoaW1va3UgSW5kaWNhdG9yIE92ZXJsYXkuIEV4cGVjdGVkIEZvcm1hdDogWyA8dGltZXN0YW1wPiwgPENvbnZlcnNpb25MaW5lPiwgPEJhc2VMaW5lPiwgPExlYWQxPiwgPExlYWQyPiwgPExhZ2dpbmc+IF1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6IFwiSWNoaW1va3VcIixcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjdHhUZW5rYW46IHt9LFxuICAgICAgY3R4S2lqdW46IHt9LFxuICAgICAgY3R4U2Vua291U3BhbkE6IHt9LFxuICAgICAgY3R4U2Vua291U3BhbkI6IHt9LFxuICAgICAgY3R4Q2hpbmtvdToge30sXG4gICAgICBjdHhGaWxsS3Vtbzoge30sXG4gICAgICB0ZW5rYW46IFtdLFxuICAgICAga2lqdW46IFtdLFxuICAgICAgc2Vua291U3BhbkE6IFtdLFxuICAgICAgc2Vua291U3BhbkI6IFtdLFxuICAgICAgY2hpbmtvdTogW10sXG4gICAgICBvZmZzZXQ6IDI2LFxuICAgICAgdGVua2FuTGluZVdpZHRoOiAxLFxuICAgICAga2lqdW5MaW5lV2lkdGg6IDEsXG4gICAgICBzZW5rb3VTcGFuQUxpbmVXaWR0aDogMSxcbiAgICAgIHNlbmtvdVNwYW5CTGluZVdpZHRoOiAxLFxuICAgICAgY2hpbmtvdUxpbmVXaWR0aDogMSxcbiAgICAgIGNvbG9yVGVua2FuOiBcIiM1MkE2MzRcIixcbiAgICAgIGNvbG9yS2lqdW46IFwiIzUyQTU5RFwiLFxuICAgICAgY29sb3JTZW5rb3VTcGFuQTogXCIjNDM4NjI1XCIsXG4gICAgICBjb2xvclNlbmtvdVNwYW5COiBcIiNiZDAwM2NcIixcbiAgICAgIGNvbG9yQ2hpbmtvdTogXCIjQkYyQTY0XCIsXG4gICAgICBjb2xvckt1bW9VcDogXCIjMDYzZjBmXCIsXG4gICAgICBjb2xvckt1bW9Eb3duOiBcIiMzOTFjMTlcIixcbiAgICAgIHNob3dUZW5rYW46IHRydWUsXG4gICAgICBzaG93S2lqdW46IHRydWUsXG4gICAgICBzaG93U2Vua291U3BhbkE6IHRydWUsXG4gICAgICBzaG93U2Vua291U3BhbkI6IHRydWUsXG4gICAgICBzaG93Q2hpbmtvdTogdHJ1ZSxcbiAgICAgIHNob3dGaWxsS3VtbzogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIHRlbmthbl9jb2xvcjogZnVuY3Rpb24gdGVua2FuX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsndGVua2FuLWNvbG9yJ10gfHwgdGhpcy5jb2xvclRlbmthbjtcbiAgICB9LFxuICAgIGtpanVuX2NvbG9yOiBmdW5jdGlvbiBraWp1bl9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ2tpanVuLWNvbG9yJ10gfHwgdGhpcy5jb2xvcktpanVuO1xuICAgIH0sXG4gICAgc2Vua291X3NwYW5BX2NvbG9yOiBmdW5jdGlvbiBzZW5rb3Vfc3BhbkFfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydzZW5rb3Vfc3BhbkFfY29sb3InXSB8fCB0aGlzLmNvbG9yU2Vua291U3BhbkE7XG4gICAgfSxcbiAgICBzZW5rb3Vfc3BhbkJfY29sb3I6IGZ1bmN0aW9uIHNlbmtvdV9zcGFuQl9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ3NlbmtvdV9zcGFuQl9jb2xvciddIHx8IHRoaXMuY29sb3JTZW5rb3VTcGFuQjtcbiAgICB9LFxuICAgIGNoaW5rb3VfY29sb3I6IGZ1bmN0aW9uIGNoaW5rb3VfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydjaGlua291X2NvbG9yJ10gfHwgdGhpcy5jb2xvckNoaW5rb3U7XG4gICAgfSxcbiAgICBrdW1vX3VwX2NvbG9yOiBmdW5jdGlvbiBrdW1vX3VwX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsna3Vtb191cF9jb2xvciddIHx8IHRoaXMuY29sb3JLdW1vVXA7XG4gICAgfSxcbiAgICBrdW1vX2Rvd25fY29sb3I6IGZ1bmN0aW9uIGt1bW9fZG93bl9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ2t1bW9fZG93bl9jb2xvciddIHx8IHRoaXMuY29sb3JLdW1vRG93bjtcbiAgICB9LFxuICAgIHRlbmthbl9saW5lX3dpZHRoOiBmdW5jdGlvbiB0ZW5rYW5fbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ3Rlbmthbl9saW5lX3dpZHRoJ10gfHwgdGhpcy50ZW5rYW5MaW5lV2lkdGg7XG4gICAgfSxcbiAgICBraWp1bl9saW5lX3dpZHRoOiBmdW5jdGlvbiBraWp1bl9saW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsna2lqdW5fbGluZV93aWR0aCddIHx8IHRoaXMua2lqdW5MaW5lV2lkdGg7XG4gICAgfSxcbiAgICBzZW5rb3Vfc3BhbkFfbGluZV93aWR0aDogZnVuY3Rpb24gc2Vua291X3NwYW5BX2xpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydzZW5rb3Vfc3BhbkFfbGluZV93aWR0aCddIHx8IHRoaXMuc2Vua291U3BhbkFMaW5lV2lkdGg7XG4gICAgfSxcbiAgICBzZW5rb3Vfc3BhbkJfbGluZV93aWR0aDogZnVuY3Rpb24gc2Vua291X3NwYW5CX2xpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydzZW5rb3Vfc3BhbkJfbGluZV93aWR0aCddIHx8IHRoaXMuc2Vua291U3BhbkJMaW5lV2lkdGg7XG4gICAgfSxcbiAgICBjaGlua291X2xpbmVfd2lkdGg6IGZ1bmN0aW9uIGNoaW5rb3VfbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ2NoaW5rb3VfbGluZV93aWR0aCddIHx8IHRoaXMuY2hpbmtvdUxpbmVXaWR0aDtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogXCJTdWRlZXAgQmF0cmFcIixcbiAgICAgICAgdmVyc2lvbjogXCIxLjAuMFwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgcHJvcHNTdWIgPSB0aGlzLiRwcm9wcy5zdWI7XG4gICAgICB0aGlzLmN0eFRlbmthbiA9IGN0eDtcbiAgICAgIHRoaXMuY3R4S2lqdW4gPSBjdHg7XG4gICAgICB0aGlzLmN0eFNlbmtvdVNwYW5BID0gY3R4O1xuICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQiA9IGN0eDtcbiAgICAgIHRoaXMuY3R4Q2hpbmtvdSA9IGN0eDtcbiAgICAgIHRoaXMuY3R4RmlsbEt1bW8gPSBjdHg7XG4gICAgICB2YXIgc3ViZGF0YSA9IHRoaXMuJHByb3BzLmRhdGEuc2xpY2UoMCwgcHJvcHNTdWIubGVuZ3RoKTtcbiAgICAgIHZhciBzdWJkYXRhU2Vua291U3BhbiA9IHRoaXMuJHByb3BzLmRhdGEuc2xpY2UoMCwgcHJvcHNTdWIubGVuZ3RoICsgdGhpcy5vZmZzZXQpO1xuICAgICAgdmFyIHN1YmRhdGFDaGlua291ID0gdGhpcy4kcHJvcHMuZGF0YS5zbGljZSgwLCBwcm9wc1N1Yi5sZW5ndGggLSB0aGlzLm9mZnNldCk7XG5cbiAgICAgIGlmICh0aGlzLnNob3dGaWxsS3Vtbykge1xuICAgICAgICB0aGlzLmN0eEZpbGxLdW1vLmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgaW5kID0gMDtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN1YmRhdGFTZW5rb3VTcGFuKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBjdXJySXRlbSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaW5kID4gMSkge1xuICAgICAgICAgICAgICB2YXIgcDEgPSB0aGlzLm1hcF9zZW5rb3Vfc3Bhbl92YWx1ZXMoc3ViZGF0YVNlbmtvdVNwYW5baW5kIC0gMV0pO1xuICAgICAgICAgICAgICB2YXIgcDIgPSB0aGlzLm1hcF9zZW5rb3Vfc3Bhbl92YWx1ZXMoY3Vyckl0ZW0pO1xuICAgICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLm1vdmVUbyhwMS54LCBwMS5zZW5rb3VTcGFuQSk7XG4gICAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIubGluZVRvKHAyLnggKyAwLjEsIHAyLnNlbmtvdVNwYW5BKTtcbiAgICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5saW5lVG8ocDIueCArIDAuMSwgcDIuc2Vua291U3BhbkIpO1xuICAgICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmxpbmVUbyhwMS54LCBwMS5zZW5rb3VTcGFuQik7XG5cbiAgICAgICAgICAgICAgaWYgKHAxLnNlbmtvdVNwYW5BID49IHAxLnNlbmtvdVNwYW5CKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5maWxsU3R5bGUgPSB0aGlzLmt1bW9fZG93bl9jb2xvcjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmZpbGxTdHlsZSA9IHRoaXMua3Vtb191cF9jb2xvcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIuZmlsbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNob3dUZW5rYW4pIHtcbiAgICAgICAgdGhpcy5jdHhUZW5rYW4uYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3ViZGF0YSksXG4gICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHBUZW5rYW4gPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN0eFRlbmthbi5zdHJva2VTdHlsZSA9IHRoaXMudGVua2FuX2NvbG9yO1xuICAgICAgICAgICAgdGhpcy5jdHhUZW5rYW4ubGluZVdpZHRoID0gdGhpcy50ZW5rYW5fbGluZV93aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY3R4VGVua2FuLmxpbmVUbyhsYXlvdXQudDJzY3JlZW4ocFRlbmthblswXSksIGxheW91dC4kMnNjcmVlbihwVGVua2FuWzFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4VGVua2FuLnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaG93S2lqdW4pIHtcbiAgICAgICAgdGhpcy5jdHhLaWp1bi5iZWdpblBhdGgoKTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdWJkYXRhKSxcbiAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcEtpanVuID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jdHhLaWp1bi5zdHJva2VTdHlsZSA9IHRoaXMua2lqdW5fY29sb3I7XG4gICAgICAgICAgICB0aGlzLmN0eEtpanVuLmxpbmVXaWR0aCA9IHRoaXMua2lqdW5fbGluZV93aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY3R4S2lqdW4ubGluZVRvKGxheW91dC50MnNjcmVlbihwS2lqdW5bMF0pLCBsYXlvdXQuJDJzY3JlZW4ocEtpanVuWzJdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4S2lqdW4uc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNob3dTZW5rb3VTcGFuQSkge1xuICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5BLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I0ID0gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN1YmRhdGFTZW5rb3VTcGFuKSxcbiAgICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcFNlbmtvdVNwYW5BID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQS5zdHJva2VTdHlsZSA9IHRoaXMuc2Vua291X3NwYW5BX2NvbG9yO1xuICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQS5saW5lV2lkdGggPSB0aGlzLnNlbmtvdV9zcGFuQV9saW5lX3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQS5saW5lVG8obGF5b3V0LnQyc2NyZWVuKHBTZW5rb3VTcGFuQVswXSksIGxheW91dC4kMnNjcmVlbihwU2Vua291U3BhbkFbM10pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQS5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29sb3JTZW5rb3VTcGFuQikge1xuICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I1ID0gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN1YmRhdGFTZW5rb3VTcGFuKSxcbiAgICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcFNlbmtvdVNwYW5CID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5zdHJva2VTdHlsZSA9IHRoaXMuc2Vua291X3NwYW5CX2NvbG9yO1xuICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5saW5lV2lkdGggPSB0aGlzLnNlbmtvdV9zcGFuQl9saW5lX3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5saW5lVG8obGF5b3V0LnQyc2NyZWVuKHBTZW5rb3VTcGFuQlswXSksIGxheW91dC4kMnNjcmVlbihwU2Vua291U3BhbkJbNF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd0NoaW5rb3UpIHtcbiAgICAgICAgdGhpcy5jdHhDaGlua291LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I2ID0gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN1YmRhdGFDaGlua291KSxcbiAgICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcENoaWtvdSA9IF9zdGVwNi52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3R4Q2hpbmtvdS5zdHJva2VTdHlsZSA9IHRoaXMuY2hpbmtvdV9jb2xvcjtcbiAgICAgICAgICAgIHRoaXMuY3R4Q2hpbmtvdS5saW5lV2lkdGggPSB0aGlzLmNoaW5rb3VfbGluZV93aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY3R4Q2hpbmtvdS5saW5lVG8obGF5b3V0LnQyc2NyZWVuKHBDaGlrb3VbMF0pLCBsYXlvdXQuJDJzY3JlZW4ocENoaWtvdVs1XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eENoaW5rb3Uuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXBfc2Vua291X3NwYW5fdmFsdWVzOiBmdW5jdGlvbiBtYXBfc2Vua291X3NwYW5fdmFsdWVzKHApIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICByZXR1cm4gcCAmJiB7XG4gICAgICAgIHg6IGxheW91dC50MnNjcmVlbihwWzBdKSxcbiAgICAgICAgc2Vua291U3BhbkE6IGxheW91dC4kMnNjcmVlbihwWzNdKSxcbiAgICAgICAgc2Vua291U3BhbkI6IGxheW91dC4kMnNjcmVlbihwWzRdKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gW1wiSWNoaW1va3VcIl07XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICB2YXIgY29sb3JzID0gW107XG4gICAgICBjb2xvcnMucHVzaCh0aGlzLnRlbmthbl9jb2xvcik7XG4gICAgICBjb2xvcnMucHVzaCh0aGlzLmtpanVuX2NvbG9yKTtcbiAgICAgIGNvbG9ycy5wdXNoKHRoaXMuc2Vua291X3NwYW5BX2NvbG9yKTtcbiAgICAgIGNvbG9ycy5wdXNoKHRoaXMuc2Vua291X3NwYW5CX2NvbG9yKTtcbiAgICAgIGNvbG9ycy5wdXNoKHRoaXMuY2hpbmtvdV9jb2xvcik7XG4gICAgICByZXR1cm4gY29sb3JzO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvSWNoaW1va3UvSWNoaW1va3UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSWNoaW1va3VfSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9JY2hpbW9rdS9JY2hpbW9rdS52dWVcbnZhciBJY2hpbW9rdV9yZW5kZXIsIEljaGltb2t1X3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEljaGltb2t1X2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgSWNoaW1va3VfSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEljaGltb2t1X3JlbmRlcixcbiAgSWNoaW1va3Vfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBJY2hpbW9rdV9hcGk7IH1cbkljaGltb2t1X2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0ljaGltb2t1L0ljaGltb2t1LnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEljaGltb2t1ID0gKEljaGltb2t1X2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvS0MvS0MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtDdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0tDJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdLZWx0bmVyIENoYW5uZWxzJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0tDICRsZW5ndGggJG11bHQnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjNGM4ZGZmYWInLFxuICAgICAgICAgICAgc2hvd01pZDogdHJ1ZSxcbiAgICAgICAgICAgIGJhY2tDb2xvcjogJyM0YzhkZmYwYSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnS0MnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAyMCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtdWx0OiB7XG4gICAgICAgICAgICBkZWY6IDEsXG4gICAgICAgICAgICB0ZXh0OiAnTXVsdGlwbGllcidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVzZV90cjoge1xuICAgICAgICAgICAgZGVmOiB0cnVlLFxuICAgICAgICAgICAgdGV4dDogJ1VzZSBUcnVlIFJhbmdlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnQ2hhbm5lbCdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgbGV0IFttLCBoLCBsXSA9IGtjKGNsb3NlLCBsZW5ndGgsIG11bHQsIHVzZV90cilcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbaFswXSwgbVswXSwgbFswXV1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9LQy9LQy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLQ19LQ3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChLQ3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0tDL0tDLnZ1ZVxudmFyIEtDX3JlbmRlciwgS0Nfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgS0NfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBLQ19LQ3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgS0NfcmVuZGVyLFxuICBLQ19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEtDX2FwaTsgfVxuS0NfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvS0MvS0MudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS0MgPSAoS0NfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9LQ1cvS0NXLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLQ1d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnS0NXJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdLZWx0bmVyIENoYW5uZWxzIFdpZHRoJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0tDVyAkbGVuZ3RoICRtdWx0JyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyM0YzhkZmZhYidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnS0NXJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMjAsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdDoge1xuICAgICAgICAgICAgZGVmOiAxLFxuICAgICAgICAgICAgdGV4dDogJ011bHRpcGxpZXInXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VfdHI6IHtcbiAgICAgICAgICAgIGRlZjogdHJ1ZSxcbiAgICAgICAgICAgIHRleHQ6ICdVc2UgVHJ1ZSBSYW5nZSdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtjdyhjbG9zZSwgbGVuZ3RoLCBtdWx0LCB1c2VfdHIpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvS0NXL0tDVy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLQ1dfS0NXdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEtDV3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0tDVy9LQ1cudnVlXG52YXIgS0NXX3JlbmRlciwgS0NXX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEtDV19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEtDV19LQ1d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEtDV19yZW5kZXIsXG4gIEtDV19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEtDV19hcGk7IH1cbktDV19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9LQ1cvS0NXLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtDVyA9IChLQ1dfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9Mb25nU2hvcnRUcmFkZXMvTG9uZ1Nob3J0VHJhZGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vTG9uZyBTaG9ydCBPdmVybGF5LiBFeHBlY3RlZCBGb3JtYXQ6IFsgPHRpbWVzdGFtcD4sIDxTaG9ydDowIExvbmc6MSBTaG9ydENvdmVyOiAyIExvbmdDb3ZlcjozPiwgPFByaWNlIENoYW5nZT4sIDxQZXJjZW50IFByaWNlIENoYW5nZT4sIDxPcGVuIFByaWNlPiwgPEhpZ2ggUHJpY2U+LCA8TG93IFByaWNlPiwgPENsb3NlIFByaWNlPiBdXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0xvbmdTaG9ydFRyYWRlcycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgZGVmYXVsdF9mb250OiBmdW5jdGlvbiBkZWZhdWx0X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gJzEycHggJyArIHRoaXMuJHByb3BzLmZvbnQuc3BsaXQoJ3B4JykucG9wKCk7XG4gICAgfSxcbiAgICBjdXJyZW5jeV9zeW1ib2w6IGZ1bmN0aW9uIGN1cnJlbmN5X3N5bWJvbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY3VycmVuY3kgfHwgJ+KCuSc7XG4gICAgfSxcbiAgICBsb25nX2NvbG9yOiBmdW5jdGlvbiBsb25nX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5sb25nQ29sb3IgfHwgJyM2M2RmODknO1xuICAgIH0sXG4gICAgc2hvcnRfY29sb3I6IGZ1bmN0aW9uIHNob3J0X2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zaG9ydENvbG9yIHx8ICcjZmZkNTgxJztcbiAgICB9LFxuICAgIGxvbmdfY292ZXJfY29sb3I6IGZ1bmN0aW9uIGxvbmdfY292ZXJfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxvbmdDb3ZlckNvbG9yIHx8ICcjZmM3ZTJmJztcbiAgICB9LFxuICAgIHNob3J0X2NvdmVyX2NvbG9yOiBmdW5jdGlvbiBzaG9ydF9jb3Zlcl9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2hvcnRDb3ZlckNvbG9yIHx8ICcjZmY2YmQ2JztcbiAgICB9LFxuICAgIGxhYmVsX2NvbG9yOiBmdW5jdGlvbiBsYWJlbF9jb2xvcigpIHtcbiAgICAgIHJldHVybiAnIzRCRUNGOSc7XG4gICAgfSxcbiAgICBtYXJrZXJfc2l6ZTogZnVuY3Rpb24gbWFya2VyX3NpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lm1hcmtlclNpemUgfHwgNTtcbiAgICB9LFxuICAgIHNob3dfbGFiZWw6IGZ1bmN0aW9uIHNob3dfbGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNob3dMYWJlbCAhPT0gZmFsc2U7XG4gICAgfSxcbiAgICBuZXdfZm9udDogZnVuY3Rpb24gbmV3X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmZvbnQgfHwgdGhpcy5kZWZhdWx0X2ZvbnQ7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdWRlZXAgQmF0cmEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjEnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICBjdHgubGluZVdpZHRoID0gMS41O1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgdHJhZGVUaW1lID0gcFswXTtcbiAgICAgICAgICB2YXIgbG9uZ1Nob3J0RW50cnlFeGl0ID0gcFsxXTtcbiAgICAgICAgICB2YXIgcHJpY2VDaGFuZ2UgPSBwWzJdO1xuICAgICAgICAgIHZhciBwZXJjZW50UHJpY2VDaGFuZ2UgPSBwWzNdO1xuICAgICAgICAgIHZhciBvcGVuUHJpY2UgPSBwWzRdO1xuICAgICAgICAgIHZhciBoaWdoUHJpY2UgPSBwWzVdO1xuICAgICAgICAgIHZhciBsb3dQcmljZSA9IHBbNl07XG4gICAgICAgICAgdmFyIGNsb3NlUHJpY2UgPSBwWzddO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHRyYWRlVGltZSk7XG4gICAgICAgICAgdmFyIGxvd1ByaWNlWSA9IGxheW91dC4kMnNjcmVlbihsb3dQcmljZSk7XG4gICAgICAgICAgdmFyIGhpZ2hQcmljZVkgPSBsYXlvdXQuJDJzY3JlZW4oaGlnaFByaWNlKTtcblxuICAgICAgICAgIHN3aXRjaCAobG9uZ1Nob3J0RW50cnlFeGl0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuZmlsbGVkQXJyb3dEb3duRmlsbGVkQm90dG9tKGN0eCwgeCwgaGlnaFByaWNlWSAtIDI1LCA1LCA1LCAzLCAyMCwgdGhpcy5zaG9ydF9jb2xvcik7XG4gICAgICAgICAgICAgIHRoaXMuZHJhd19sYWJlbChjdHgsIHggKyAzMCwgaGlnaFByaWNlWSAtIDM1LCB0aGlzLmN1cnJlbmN5X3N5bWJvbCArIGNsb3NlUHJpY2UpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB0aGlzLmZpbGxlZEFycm93VXBGaWxsZWRCb3R0b20oY3R4LCB4LCBsb3dQcmljZVkgKyAyMCwgNSwgNSwgMywgMjAsIHRoaXMubG9uZ19jb2xvcik7XG4gICAgICAgICAgICAgIHRoaXMuZHJhd19sYWJlbChjdHgsIHggKyAzMCwgbG93UHJpY2VZICsgNDAsIHRoaXMuY3VycmVuY3lfc3ltYm9sICsgY2xvc2VQcmljZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHRoaXMudXBUcmlhbmdsZShjdHgsIHgsIGxvd1ByaWNlWSArIDI1LCA1LCA3LCB0aGlzLnNob3J0X2NvdmVyX2NvbG9yKTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5zaG93X2xhYmVsICYmIHByaWNlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3X2xhYmVsKGN0eCwgeCwgbG93UHJpY2VZICsgNTAsIHByaWNlQ2hhbmdlICsgXCIgKFwiICsgcGVyY2VudFByaWNlQ2hhbmdlICsgXCIpXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgdGhpcy5kb3duVHJpYW5nbGUoY3R4LCB4LCBoaWdoUHJpY2VZIC0gMjUsIDUsIDcsIHRoaXMubG9uZ19jb3Zlcl9jb2xvcik7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd19sYWJlbCAmJiBwcmljZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd19sYWJlbChjdHgsIHgsIGhpZ2hQcmljZVkgLSA0NSwgcHJpY2VDaGFuZ2UgKyBcIiAoXCIgKyBwZXJjZW50UHJpY2VDaGFuZ2UgKyBcIilcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgfSAvLyB0aGlzLnNpbXBsZUFycm93VXAoY3R4LCB4LCB6IC0gMjUsICcjODRlNWIxJylcbiAgICAgICAgICAvLyB0aGlzLnNpbXBsZUFycm93RG93bihjdHgsIHgsIHogLSAyNSwgJyM4NGU1YjEnKVxuICAgICAgICAgIC8vIHRoaXMuZmlsbGVkQXJyb3dVcChjdHgsIHgsIHogLSAyNSwgNSwgNSwgMjAsICcjODRlNWIxJylcbiAgICAgICAgICAvLyB0aGlzLmZpbGxlZERvd25BcnJvdyhjdHgsIHgsIHogLSAyNSwgNSwgNSwgMjAsICcjODRlNWIxJylcbiAgICAgICAgICAvLyB0aGlzLmZpbGxlZEFycm93VXBGaWxsZWRCb3R0b20oY3R4LCB4LCB6IC0gMjUsIDUsIDUsIDMsIDIwLCAnIzg0ZTViMScpXG4gICAgICAgICAgLy8gdGhpcy5maWxsZWRBcnJvd0Rvd25GaWxsZWRCb3R0b20oY3R4LCB4LCB6IC0gMjUsIDUsIDUsIDMsIDIwLCAnIzg0ZTViMScpXG4gICAgICAgICAgLy8gdGhpcy51cFRyaWFuZ2xlKGN0eCwgeCwgei02MCwgNSwgNywgJyM4NGU1YjEnKVxuICAgICAgICAgIC8vIHRoaXMuZG93blRyaWFuZ2xlKGN0eCwgeCwgeiAtIDI1LCA1LCA3LCAnIzg0ZTViMScpXG5cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhd19sYWJlbDogZnVuY3Rpb24gZHJhd19sYWJlbChjdHgsIHgsIHksIGxhYmVsVGV4dCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxfY29sb3I7XG4gICAgICBjdHguZm9udCA9IHRoaXMubmV3X2ZvbnQ7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjdHguZmlsbFRleHQobGFiZWxUZXh0LCB4LCB5KTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydMb25nU2hvcnRUcmFkZXMnXTtcbiAgICB9LFxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKHZhbHVlcykge1xuICAgICAgc3dpdGNoICh2YWx1ZXNbMV0pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHZhciBwb3MgPSAnU2hvcnQnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwb3MgPSAnTG9uZyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHBvcyA9ICdTaG9ydCBDb3Zlcic7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHBvcyA9ICdMb25nIENvdmVyJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHBvcyA9ICdVbmtub3duJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZhbHVlOiBwb3NcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlc1syXS50b0ZpeGVkKDQpLFxuICAgICAgICBjb2xvcjogdGhpcy4kcHJvcHMuY29sb3JzLmNvbG9yVGV4dFxuICAgICAgfV0uY29uY2F0KHZhbHVlc1szXSA/IFt7XG4gICAgICAgIHZhbHVlOiB2YWx1ZXNbM11cbiAgICAgIH1dIDogW10pO1xuICAgIH0sXG4gICAgc2ltcGxlQXJyb3dVcDogZnVuY3Rpb24gc2ltcGxlQXJyb3dVcChjdHgsIHgsIHksIGNvbG9yKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIDUsIHkgKyA1KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyA1LCB5ICsgNSk7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgMTUpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgc2ltcGxlQXJyb3dEb3duOiBmdW5jdGlvbiBzaW1wbGVBcnJvd0Rvd24oY3R4LCB4LCB5LCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubW92ZVRvKHggLSA1LCB5IC0gNSk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgNSwgeSAtIDUpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSAtIDE1KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIGZpbGxlZEFycm93VXA6IGZ1bmN0aW9uIGZpbGxlZEFycm93VXAoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0gd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHgsIHkgKyBkZXB0aCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgZmlsbGVkRG93bkFycm93OiBmdW5jdGlvbiBmaWxsZWREb3duQXJyb3coY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0gd2lkdGgsIHkgLSBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5IC0gaGVpZ2h0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHgsIHkgLSBkZXB0aCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgZmlsbGVkQXJyb3dVcEZpbGxlZEJvdHRvbTogZnVuY3Rpb24gZmlsbGVkQXJyb3dVcEZpbGxlZEJvdHRvbShjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJvdHRvbSwgZGVwdGgsIGNvbG9yKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LnJlY3QoeCAtIGJvdHRvbSAvIDIsIHkgKyBoZWlnaHQsIGJvdHRvbSwgZGVwdGgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIGZpbGxlZEFycm93RG93bkZpbGxlZEJvdHRvbTogZnVuY3Rpb24gZmlsbGVkQXJyb3dEb3duRmlsbGVkQm90dG9tKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYm90dG9tLCBkZXB0aCwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0gd2lkdGgsIHkgLSBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5IC0gaGVpZ2h0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgucmVjdCh4IC0gYm90dG9tIC8gMiwgeSAtIGhlaWdodCAtIGRlcHRoLCBib3R0b20sIGRlcHRoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcbiAgICB1cFRyaWFuZ2xlOiBmdW5jdGlvbiB1cFRyaWFuZ2xlKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0gd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcbiAgICBkb3duVHJpYW5nbGU6IGZ1bmN0aW9uIGRvd25UcmlhbmdsZShjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHdpZHRoLCB5IC0gaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSAtIGhlaWdodCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTG9uZ1Nob3J0VHJhZGVzL0xvbmdTaG9ydFRyYWRlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMb25nU2hvcnRUcmFkZXNfTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0xvbmdTaG9ydFRyYWRlcy9Mb25nU2hvcnRUcmFkZXMudnVlXG52YXIgTG9uZ1Nob3J0VHJhZGVzX3JlbmRlciwgTG9uZ1Nob3J0VHJhZGVzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIExvbmdTaG9ydFRyYWRlc19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIExvbmdTaG9ydFRyYWRlc19Mb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIExvbmdTaG9ydFRyYWRlc19yZW5kZXIsXG4gIExvbmdTaG9ydFRyYWRlc19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIExvbmdTaG9ydFRyYWRlc19hcGk7IH1cbkxvbmdTaG9ydFRyYWRlc19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9Mb25nU2hvcnRUcmFkZXMvTG9uZ1Nob3J0VHJhZGVzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExvbmdTaG9ydFRyYWRlcyA9IChMb25nU2hvcnRUcmFkZXNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9NQUNEL01BQ0QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gVE9ETzogcGFzcyBjb2xvcnMgZnJvbSBzZXR0aW5ncyB0byB0aGUgc2NyaXB0XG4vLyBUT0RPOiBoaXN0IGxpbmVzID0+IHJlY2FuZ2xlcyAobGlrZSBpbiB2b2xiYXIuanMpXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdNQUNEJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMicsXG4gICAgICAgIGRlc2M6ICdNb3ZpbmcgQXZlcmFnZSBDb252ZXJnZW5jZS9EaXZlcmdlbmNlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ01BQ0QgJGZhc3QgJHNsb3cgJHNtb290aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgaGlzdFdpZHRoOiA0LFxuICAgICAgICAgICAgbWFjZFdpZHRoOiAxLFxuICAgICAgICAgICAgc2lnbmFsV2lkdGg6IDEsXG4gICAgICAgICAgICBkZWZDb2xvcjogXCIjNDJiMjhhXCIsXG4gICAgICAgICAgICBtYWNkQ29sb3I6IFwiIzM3ODJmMlwiLFxuICAgICAgICAgICAgc2lnbmFsQ29sb3I6IFwiI2Y0ODcwOVwiLFxuICAgICAgICAgICAgaGlzdENvbG9yczogW1wiIzM1YTc3NlwiLCBcIiM3OWUwYjNcIiwgXCIjZTU0MTUwXCIsIFwiI2VhOTY5ZVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0OyAvLyBISVNUT0dSQU1cblxuICAgICAgdmFyIGJhc2UgPSBsYXlvdXQuJDJzY3JlZW4oMCkgKyAwLjU7XG4gICAgICB2YXIgb2ZmID0gdGhpcy5oaXN0X3dpZHRoICUgMiA/IDAgOiAwLjU7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5oaXN0X3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSkgLSBvZmY7XG4gICAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXSkgLSAwLjU7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zZXR0Lmhpc3RDb2xvcnNbcFs0XV07XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgYmFzZSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH0gLy8gTUFDRCBMSU5FXG5cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubWFjZF93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMubWFjZF9jb2xvcjtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3ggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG5cbiAgICAgICAgICB2YXIgX3kgPSBsYXlvdXQuJDJzY3JlZW4ocFsyXSk7XG5cbiAgICAgICAgICBjdHgubGluZVRvKF94LCBfeSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7IC8vIFNJR05BTCBMSU5FXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnNpZ25hbF93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2lnbmFsX2NvbG9yO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIHZhciBfeDIgPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG5cbiAgICAgICAgICB2YXIgX3kyID0gbGF5b3V0LiQyc2NyZWVuKHBbM10pO1xuXG4gICAgICAgICAgY3R4LmxpbmVUbyhfeDIsIF95Mik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnTUFDRCddO1xuICAgIH0sXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQodmFsdWVzKSB7XG4gICAgICB2YXIgeHMgPSB2YWx1ZXMuc2xpY2UoMSwgNCkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvRml4ZWQoTWF0aC5hYnMoeCkgPiAwLjAwMSA/IDQgOiA4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZhbHVlOiB4c1swXSxcbiAgICAgICAgY29sb3I6IHRoaXMuaGlzdF9jb2xvcnNbdmFsdWVzWzRdXVxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogeHNbMV0sXG4gICAgICAgIGNvbG9yOiB0aGlzLm1hY2RfY29sb3JcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IHhzWzJdLFxuICAgICAgICBjb2xvcjogdGhpcy5zaWduYWxfY29sb3JcbiAgICAgIH1dO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZmFzdDoge1xuICAgICAgICAgICAgZGVmOiAxMixcbiAgICAgICAgICAgIHRleHQ6ICdGYXN0IExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNsb3c6IHtcbiAgICAgICAgICAgIGRlZjogMjYsXG4gICAgICAgICAgICB0ZXh0OiAnU2xvdyBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgIGRlZjogOSxcbiAgICAgICAgICAgIHRleHQ6ICdTaWduYWwgRU1BJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgbGV0IFttYWNkLCBzaWduYWwsIGhpc3RdID1cXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWNkKGNsb3NlLCBmYXN0LCBzbG93LCBzbW9vdGgpXFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaGlzdFswXSA+PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IDBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpc3RbMF0gPCBoaXN0WzFdKSBjb2xvciA9IDFcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSAyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpc3RbMF0gPiBoaXN0WzFdKSBjb2xvciA9IDNcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbaGlzdFswXSwgbWFjZFswXSwgc2lnbmFsWzBdLCBjb2xvcl1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGhpc3Rfd2lkdGg6IGZ1bmN0aW9uIGhpc3Rfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lmhpc3RXaWR0aCB8fCA0O1xuICAgIH0sXG4gICAgbWFjZF93aWR0aDogZnVuY3Rpb24gbWFjZF93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubWFjZFdpZHRoIHx8IDE7XG4gICAgfSxcbiAgICBzaWduYWxfd2lkdGg6IGZ1bmN0aW9uIHNpZ25hbF93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2lnbmFsV2lkdGggfHwgMTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZGVmQ29sb3IgfHwgXCIjNDJiMjhhXCI7XG4gICAgfSxcbiAgICBtYWNkX2NvbG9yOiBmdW5jdGlvbiBtYWNkX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5tYWNkQ29sb3IgfHwgXCIjMzc4MmYyXCI7XG4gICAgfSxcbiAgICBzaWduYWxfY29sb3I6IGZ1bmN0aW9uIHNpZ25hbF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2lnbmFsQ29sb3IgfHwgXCIjZjQ4NzA5XCI7XG4gICAgfSxcbiAgICBoaXN0X2NvbG9yczogZnVuY3Rpb24gaGlzdF9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lmhpc3RDb2xvcnM7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9NQUNEL01BQ0QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTUFDRF9NQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9NQUNEL01BQ0QudnVlXG52YXIgTUFDRF9yZW5kZXIsIE1BQ0Rfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgTUFDRF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1BQ0RfTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgTUFDRF9yZW5kZXIsXG4gIE1BQ0Rfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBNQUNEX2FwaTsgfVxuTUFDRF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9NQUNEL01BQ0QudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTUFDRCA9IChNQUNEX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvTUZJL01GSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTUZJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ01GSScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnTW9uZXkgRmxvdyBJbmRleCcsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdNRkkgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjODVjNDI3ZWUnLFxuICAgICAgICAgICAgYmFuZENvbG9yOiAnI2FhYWFhYScsXG4gICAgICAgICAgICBiYWNrQ29sb3I6ICcjODVjNDI3MTEnLFxuICAgICAgICAgICAgdXBwZXI6IDgwLFxuICAgICAgICAgICAgbG93ZXI6IDIwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ01GSSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDE0LFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1JhbmdlJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICBsZXQgaGxjMyA9IHRzKChoaWdoWzBdICsgbG93WzBdICsgY2xvc2VbMF0pIC8gMylcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZmkoaGxjMywgbGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL01GSS9NRkkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTUZJX01GSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChNRkl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9NRkkvTUZJLnZ1ZVxudmFyIE1GSV9yZW5kZXIsIE1GSV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBNRklfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNRklfTUZJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBNRklfcmVuZGVyLFxuICBNRklfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBNRklfYXBpOyB9XG5NRklfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvTUZJL01GSS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNRkkgPSAoTUZJX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvTU9NL01PTS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTU9NdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ01PTScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnTW9tZW50dW0nLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnTU9NICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2JjYzQyN2VlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydNT00nXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxMSxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb20oY2xvc2UsIGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9NT00vTU9NLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1PTV9NT012dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTU9NdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTU9NL01PTS52dWVcbnZhciBNT01fcmVuZGVyLCBNT01fc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgTU9NX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTU9NX01PTXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgTU9NX3JlbmRlcixcbiAgTU9NX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgTU9NX2FwaTsgfVxuTU9NX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL01PTS9NT00udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTU9NID0gKE1PTV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL01hcmtlcnMvTWFya2Vycy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdNYXJrZXJzJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4xJyxcbiAgICAgICAgZGVzYzogJ0ludGVyYWN0aXZlIG1hcmtlcnMnXG4gICAgICB9O1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMubW91c2Uub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gMS41O1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2F1dG8nO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IG51bGw7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHRoaXMuZHJhd19wb2ludChjdHgsIHApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmID0gdGhpcy5kYXRhLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhbMV0uc2VsO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChmKSB7XG4gICAgICAgIHRoaXMuZHJhd19wb2ludChjdHgsIGYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhd19wb2ludDogZnVuY3Rpb24gZHJhd19wb2ludChjdHgsIHApIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgc3Ryb2tlID0gdGhpcy5jb2xvcnMuYmFjaztcbiAgICAgIHZhciBmaWxsID0gcFsxXS5jb2xvciB8fCAnb3JhbmdlJztcbiAgICAgIHZhciByYWRpdXMgPSAyO1xuICAgICAgdmFyIGhlaWdodCA9IHBbMV0uc2VsID8gMjAgOiAxNDtcbiAgICAgIHZhciB3aWR0aCA9IHBbMV0uc2VsID8gMTcgOiAxMztcbiAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pIC0gd2lkdGggKiAwLjU7XG4gICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzFdLiQpIC0gKHBbMV0uc2VsID8gMjcgOiAyMCk7IC8vIENvbGxpc2lvbnNcblxuICAgICAgaWYgKHRoaXMubW91c2UueCA+IHggJiYgdGhpcy5tb3VzZS54IDwgeCArIHdpZHRoICYmIHRoaXMubW91c2UueSA+IHkgJiYgdGhpcy5tb3VzZS55IDwgeSArIGhlaWdodCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHA7XG4gICAgICAgIHN0cm9rZSA9IHRoaXMuY29sb3JzLnRleHQ7XG4gICAgICB9XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAqIDEgLyAyLCB5ICsgaGVpZ2h0ICsgaGVpZ2h0IC8gNSk7XG4gICAgICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwWzFdLnRleHRDb2xvciB8fCB0aGlzLmNvbG9ycy5iYWNrO1xuICAgICAgY3R4LmZvbnQgPSBcIlwiLmNvbmNhdChwWzFdLnNlbCA/IDE1IDogMTEsIFwicHggQXJpYWxcIik7XG4gICAgICBjdHguZmlsbFRleHQocFsxXS50ZXh0IHx8ICckJywgeCArIHdpZHRoIC8gMiwgeSArIGhlaWdodCAqIDAuOCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnTWFya2VycyddO1xuICAgIH0sXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bigpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ21hcmtlci1zZWxlY3RlZCcsIHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBkZWZhdWx0X2ZvbnQ6IGZ1bmN0aW9uIGRlZmF1bHRfZm9udCgpIHtcbiAgICAgIHJldHVybiAnMTJweCAnICsgdGhpcy4kcHJvcHMuZm9udC5zcGxpdCgncHgnKS5wb3AoKTtcbiAgICB9LFxuICAgIG5ld19mb250OiBmdW5jdGlvbiBuZXdfZm9udCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZm9udCB8fCB0aGlzLmRlZmF1bHRfZm9udDtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdGVkOiBudWxsXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTWFya2Vycy9NYXJrZXJzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1hcmtlcnNfTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTWFya2Vycy9NYXJrZXJzLnZ1ZVxudmFyIE1hcmtlcnNfcmVuZGVyLCBNYXJrZXJzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIE1hcmtlcnNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNYXJrZXJzX01hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIE1hcmtlcnNfcmVuZGVyLFxuICBNYXJrZXJzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgTWFya2Vyc19hcGk7IH1cbk1hcmtlcnNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvTWFya2Vycy9NYXJrZXJzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1hcmtlcnMgPSAoTWFya2Vyc19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1Bsb3RDcm9zcy9QbG90Q3Jvc3MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdQbG90Q3Jvc3MnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1Bsb3QgbGluZSB3aXRoIGNyb3NzZXMnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciB3ID0gY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGJhc2UgPSBsYXlvdXQuJDJzY3JlZW4oMCkgKyAwLjU7XG4gICAgICB2YXIgb2ZmID0gdGhpcy5saW5lX3dpZHRoICUgMiA/IDAgOiAwLjU7XG4gICAgICB2YXIgb2ZmMiA9IHRoaXMubGluZV93aWR0aCAlIDIgPyAwLjUgOiAxOyAvLyBDb2xvciBjaGFuZ2VkXG5cbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSkgLSBvZmY7XG4gICAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXSkgLSBvZmY7XG4gICAgICAgICAgdmFyIF9jaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAocFsyXSkge1xuICAgICAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gcFsyXSkge1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcFsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gdGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoYW5nZWQpIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgLSB3ICogMiArIG9mZjIpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHcgKiAyIC0gb2ZmMik7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4IC0gdyAqIDIgKyBvZmYyLCB5KTtcbiAgICAgICAgICBjdHgubGluZVRvKHggKyB3ICogMiAtIG9mZjIsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydQbG90Q3Jvc3MnXTtcbiAgICB9LFxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKHZhbHVlcykge1xuICAgICAgdmFyIHggPSB2YWx1ZXNbMV07XG5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ID0geC50b0ZpeGVkKE1hdGguYWJzKHgpID4gMC4wMDEgPyA0IDogOCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgY29sb3I6IHZhbHVlc1syXSB8fCB0aGlzLmNvbG9yXG4gICAgICB9XTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDI7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuJHByb3BzLm51bSAlIDU7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8IHRoaXMuQ09MT1JTW25dO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQ09MT1JTOiBbJyM4ODg4ODgnLCAnIzQyYjI4YScsICcjNTY5MWNlJywgJyM2MTJmZjknLCAnI2Q1MGI5MCcsICcjZmYyMzE2J11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9QbG90Q3Jvc3MvUGxvdENyb3NzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFBsb3RDcm9zc19QbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvUGxvdENyb3NzL1Bsb3RDcm9zcy52dWVcbnZhciBQbG90Q3Jvc3NfcmVuZGVyLCBQbG90Q3Jvc3Nfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgUGxvdENyb3NzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgUGxvdENyb3NzX1Bsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgUGxvdENyb3NzX3JlbmRlcixcbiAgUGxvdENyb3NzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgUGxvdENyb3NzX2FwaTsgfVxuUGxvdENyb3NzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1Bsb3RDcm9zcy9QbG90Q3Jvc3MudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUGxvdENyb3NzID0gKFBsb3RDcm9zc19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1JPQy9ST0MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJPQ3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdST0MnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1JhdGUgb2YgQ2hhbmdlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ1JPQyAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyMyNzlmYzQnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1JPQyddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDksXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9jKGNsb3NlLCBsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvUk9DL1JPQy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBST0NfUk9DdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFJPQ3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1JPQy9ST0MudnVlXG52YXIgUk9DX3JlbmRlciwgUk9DX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFJPQ19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFJPQ19ST0N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFJPQ19yZW5kZXIsXG4gIFJPQ19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFJPQ19hcGk7IH1cblJPQ19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9ST0MvUk9DLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJPQyA9IChST0NfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9SU0kvUlNJLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSU0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnUlNJJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdSZWxhdGl2ZSBTdHJlbmd0aCBJbmRleCcsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdSU0kgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjZWMyMDZlJyxcbiAgICAgICAgICAgIGJhbmRDb2xvcjogJyNhYWEnLFxuICAgICAgICAgICAgYmFja0NvbG9yOiAnIzliOWJhMzE2J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydSU0knXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxNCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdSYW5nZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcInJldHVybiByc2koY2xvc2UsIGxlbmd0aClbMF1cIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1JTSS9SU0kudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUlNJX1JTSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChSU0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9SU0kvUlNJLnZ1ZVxudmFyIFJTSV9yZW5kZXIsIFJTSV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBSU0lfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBSU0lfUlNJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBSU0lfcmVuZGVyLFxuICBSU0lfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBSU0lfYXBpOyB9XG5SU0lfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvUlNJL1JTSS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSU0kgPSAoUlNJX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvUmliYm9uL1JpYmJvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUmliYm9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1JpYmJvbicsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnTW92aW5nIEF2ZXJhZ2UgUmliYm9uJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0VNQSB4ICRudW1iZXInLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3JzOiBbXCIjM2FhYWY0ZWVcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnUmliYm9uJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgZGVmOiAxMCxcbiAgICAgICAgICAgIHRleHQ6ICdTdGFydCBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAgIGRlZjogNSxcbiAgICAgICAgICAgIHRleHQ6ICdOdW1iZXIgb2YgTGluZXMnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGVwOiB7XG4gICAgICAgICAgICBkZWY6IDEwLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCBTdGVwJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lcydcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1swXSA9IFtdXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlcjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBzdGFydCArIGkgKiBzdGVwXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXS5wdXNoKGVtYShjbG9zZSwgbClbMF0pXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvUmliYm9uL1JpYmJvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSaWJib25fUmliYm9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFJpYmJvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1JpYmJvbi9SaWJib24udnVlXG52YXIgUmliYm9uX3JlbmRlciwgUmliYm9uX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFJpYmJvbl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFJpYmJvbl9SaWJib252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFJpYmJvbl9yZW5kZXIsXG4gIFJpYmJvbl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFJpYmJvbl9hcGk7IH1cblJpYmJvbl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9SaWJib24vUmliYm9uLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJpYmJvbiA9IChSaWJib25fY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9TQVIvU0FSLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTQVJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU0FSJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdQYXJhYm9saWMgU0FSJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ1NBUiAkc3RhcnQgJGluYyAkbWF4JyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgICAgICAgIGNvbG9yOiAnIzM1YTljNidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnU0FSJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgZGVmOiAwLjAyLFxuICAgICAgICAgICAgdGV4dDogJ1N0YXJ0J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5jOiB7XG4gICAgICAgICAgICBkZWY6IDAuMDIsXG4gICAgICAgICAgICB0ZXh0OiAnSW5jcmVtZW50J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBkZWY6IDAuMixcbiAgICAgICAgICAgIHRleHQ6ICdNYXhpbXVtJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnUGxvdENyb3NzJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FyKHN0YXJ0LCBpbmMsIG1heClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9TQVIvU0FSLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNBUl9TQVJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU0FSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvU0FSL1NBUi52dWVcbnZhciBTQVJfcmVuZGVyLCBTQVJfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU0FSX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgU0FSX1NBUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU0FSX3JlbmRlcixcbiAgU0FSX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU0FSX2FwaTsgfVxuU0FSX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1NBUi9TQVIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU0FSID0gKFNBUl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1NNQS9TTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTTUEnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1NpbXBsZSBNb3ZpbmcgQXZlcmFnZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdTTUEgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNkMTM4NWMnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1NNQSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDI1LFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNtYShjbG9zZSwgbGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1NNQS9TTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU01BX1NNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9TTUEvU01BLnZ1ZVxudmFyIFNNQV9yZW5kZXIsIFNNQV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTTUFfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBTTUFfU01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTTUFfcmVuZGVyLFxuICBTTUFfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTTUFfYXBpOyB9XG5TTUFfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvU01BL1NNQS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTTUEgPSAoU01BX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvU1dNQS9TV01BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTV01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NXTUEnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1N5bW1ldHJpY2FsbHkgV2VpZ2h0ZWQgTW92aW5nIEF2ZXJhZ2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnU1dNQScsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNlNTc0NDAnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1NXTUEnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge30sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN3bWEoY2xvc2UpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvU1dNQS9TV01BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNXTUFfU1dNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTV01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvU1dNQS9TV01BLnZ1ZVxudmFyIFNXTUFfcmVuZGVyLCBTV01BX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFNXTUFfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBTV01BX1NXTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNXTUFfcmVuZGVyLFxuICBTV01BX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU1dNQV9hcGk7IH1cblNXTUFfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvU1dNQS9TV01BLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNXTUEgPSAoU1dNQV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1N0b2NoL1N0b2NoLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTdG9jaCcsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnU3RvY2hhc3RpYycsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdTdG9jaCAkcGFyYW1fayAkcGFyYW1fZCAkc21vb3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBrQ29sb3I6ICcjMzc4MmYyJyxcbiAgICAgICAgICAgIGRDb2xvcjogJyNmNDg3MDknLFxuICAgICAgICAgICAgYmFuZENvbG9yOiAnI2RkZCcsXG4gICAgICAgICAgICBiYWNrQ29sb3I6ICcjMzgxZTljMTYnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgdXBwZXIgPSBsYXlvdXQuJDJzY3JlZW4odGhpcy5zZXR0LnVwcGVyIHx8IDgwKTtcbiAgICAgIHZhciBsb3dlciA9IGxheW91dC4kMnNjcmVlbih0aGlzLnNldHQubG93ZXIgfHwgMjApOyAvLyBLXG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmtfY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcbiAgICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzFdKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTsgLy8gRFxuXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5kX2NvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3ggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG5cbiAgICAgICAgICB2YXIgX3kgPSBsYXlvdXQuJDJzY3JlZW4ocFsyXSk7XG5cbiAgICAgICAgICBjdHgubGluZVRvKF94LCBfeSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJhbmRfY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goWzVdKTsgLy8gV2lsbCBiZSByZW1vdmVkIGFmdGVyIGRyYXcoKVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7IC8vIEZpbGwgdGhlIGFyZWEgYmV0d2VlbiB0aGUgYmFuZHNcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja19jb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCB1cHBlciwgbGF5b3V0LndpZHRoLCBsb3dlciAtIHVwcGVyKTsgLy8gVXBwZXIgYmFuZFxuXG4gICAgICBjdHgubW92ZVRvKDAsIHVwcGVyKTtcbiAgICAgIGN0eC5saW5lVG8obGF5b3V0LndpZHRoLCB1cHBlcik7IC8vIExvd2VyIGJhbmRcblxuICAgICAgY3R4Lm1vdmVUbygwLCBsb3dlcik7XG4gICAgICBjdHgubGluZVRvKGxheW91dC53aWR0aCwgbG93ZXIpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1N0b2NoJ107XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3JdO1xuICAgIH0sXG4gICAgeV9yYW5nZTogZnVuY3Rpb24geV9yYW5nZShoaSwgbG8pIHtcbiAgICAgIHJldHVybiBbTWF0aC5tYXgoaGksIHRoaXMuc2V0dC51cHBlciB8fCA4MCksIE1hdGgubWluKGxvLCB0aGlzLnNldHQubG93ZXIgfHwgMjApXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHBhcmFtX2s6IHtcbiAgICAgICAgICAgIGRlZjogMTQsXG4gICAgICAgICAgICB0ZXh0OiAnSydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmFtX2Q6IHtcbiAgICAgICAgICAgIGRlZjogMyxcbiAgICAgICAgICAgIHRleHQ6ICdEJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICBkZWY6IDMsXG4gICAgICAgICAgICB0ZXh0OiAnU21vb3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGsgPSBzbWEoc3RvY2goY2xvc2UsIGhpZ2gsIGxvdywgcGFyYW1fayksIHNtb290aClcXG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gc21hKGssIHBhcmFtX2QpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2tbMF0sIGRbMF1dXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuNzU7XG4gICAgfSxcbiAgICBrX2NvbG9yOiBmdW5jdGlvbiBrX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5rQ29sb3IgfHwgJyMzNzgyZjInO1xuICAgIH0sXG4gICAgZF9jb2xvcjogZnVuY3Rpb24gZF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZENvbG9yIHx8ICcjZjQ4NzA5JztcbiAgICB9LFxuICAgIGJhbmRfY29sb3I6IGZ1bmN0aW9uIGJhbmRfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhbmRDb2xvciB8fCAnI2RkZCc7XG4gICAgfSxcbiAgICBiYWNrX2NvbG9yOiBmdW5jdGlvbiBiYWNrX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYWNrQ29sb3IgfHwgJyMzODFlOWMxNic7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9TdG9jaC9TdG9jaC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTdG9jaF9TdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1N0b2NoL1N0b2NoLnZ1ZVxudmFyIFN0b2NoX3JlbmRlciwgU3RvY2hfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU3RvY2hfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBTdG9jaF9TdG9jaHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU3RvY2hfcmVuZGVyLFxuICBTdG9jaF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFN0b2NoX2FwaTsgfVxuU3RvY2hfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvU3RvY2gvU3RvY2gudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3RvY2ggPSAoU3RvY2hfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9UU0kvVFNJLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUU0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVFNJJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdUcnVlIFN0cmVuZ3RoIEluZGV4JyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ1RTSSAkbG9uZyAkc2hvcnQgJHNpZ25hbCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3JzOiBbXCIjM2JiM2U0XCIsIFwiI2Y3MDQ2ZFwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydUU0knXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIFwibG9uZ1wiOiB7XG4gICAgICAgICAgICBkZWY6IDI1LFxuICAgICAgICAgICAgdGV4dDogJ0xvbmcgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaG9ydFwiOiB7XG4gICAgICAgICAgICBkZWY6IDEzLFxuICAgICAgICAgICAgdGV4dDogJ1Nob3J0IExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbDoge1xuICAgICAgICAgICAgZGVmOiAxMyxcbiAgICAgICAgICAgIHRleHQ6ICdTaWduYWwgTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lcydcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHRzaShjbG9zZSwgc2hvcnQsIGxvbmcpXFxuICAgICAgICAgICAgICAgICAgICBsZXQgc2lnID0gZW1hKHZhbCwgc2lnbmFsKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt2YWxbMF0gKiAxMDAsIHNpZ1swXSAqIDEwMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9UU0kvVFNJLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRTSV9UU0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVFNJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvVFNJL1RTSS52dWVcbnZhciBUU0lfcmVuZGVyLCBUU0lfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgVFNJX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgVFNJX1RTSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVFNJX3JlbmRlcixcbiAgVFNJX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVFNJX2FwaTsgfVxuVFNJX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1RTSS9UU0kudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVFNJID0gKFRTSV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1RyYWRlc1BsdXMvVHJhZGVzUGx1cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbnZhciBDUk9TUyA9IFwibTUxMi4wMDEgODQuODUzLTg0Ljg1My04NC44NTMtMTcxLjE0NyAxNzEuMTQ3LTE3MS4xNDgtMTcxLjE0Ny04NC44NTNcXG44NC44NTMgMTcxLjE0OCAxNzEuMTQ3LTE3MS4xNDggMTcxLjE0OCA4NC44NTMgODQuODUzIDE3MS4xNDgtMTcxLjE0N1xcbjE3MS4xNDcgMTcxLjE0NyA4NC44NTMtODQuODUzLTE3MS4xNDgtMTcxLjE0OHpcIjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdUcmFkZXNQbHVzJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4xJyxcbiAgICAgICAgZGVzYzogJ1RyYWRlcyBvdmVybGF5IHdpdGggc3RvcHMnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcFsxXSA/IHRoaXMuYnV5X2NvbG9yIDogdGhpcy5zZWxsX2NvbG9yO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pOyAvLyB4IC0gTWFwcGluZ1xuXG4gICAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsyXSk7IC8vIHkgLSBNYXBwaW5nXG5cbiAgICAgICAgICBpZiAocFszXSA9PT0gJ1N0b3AnKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdfY3Jvc3MoY3R4LCB4LCB5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3X2NpcmNsZShjdHgsIHgsIHkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnNob3dfbGFiZWwgJiYgcFszXSAmJiBwWzNdICE9PSAnU3RvcCcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd19sYWJlbChjdHgsIHgsIHksIHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhd19sYWJlbDogZnVuY3Rpb24gZHJhd19sYWJlbChjdHgsIHgsIHksIHApIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsX2NvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLm5ld19mb250O1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgY3R4LmZpbGxUZXh0KHBbM10sIHgsIHkgLSAyNSk7XG4gICAgfSxcbiAgICBkcmF3X2NpcmNsZTogZnVuY3Rpb24gZHJhd19jaXJjbGUoY3R4LCB4LCB5KSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gMS41O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyh4LCB5LCB0aGlzLm1hcmtlcl9zaXplICsgMC41LCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgZHJhd19jcm9zczogZnVuY3Rpb24gZHJhd19jcm9zcyhjdHgsIHgsIHkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgcCA9IG5ldyBQYXRoMkQoQ1JPU1MpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDE1MDtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCAtIDUsIHkgLSA1KTtcbiAgICAgIGN0eC5zY2FsZSgwLjAxNzUsIDAuMDE3NSk7XG4gICAgICBjdHguc3Ryb2tlKHApO1xuICAgICAgY3R4LmZpbGwocCk7XG4gICAgICBjdHguc2NhbGUoMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1RyYWRlc1BsdXMnXTtcbiAgICB9LFxuICAgIC8vIERlZmluZXMgbGVnZW5kIGZvcm1hdCAodmFsdWVzICYgY29sb3JzKVxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKHZhbHVlcykge1xuICAgICAgc3dpdGNoICh2YWx1ZXNbMV0pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHZhciBwb3MgPSAnU2VsbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHBvcyA9ICdCdXknO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcG9zID0gJ1Vua25vd24nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmFsdWU6IHBvc1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogdmFsdWVzWzJdLnRvRml4ZWQoNCksXG4gICAgICAgIGNvbG9yOiB0aGlzLiRwcm9wcy5jb2xvcnMuY29sb3JUZXh0XG4gICAgICB9XS5jb25jYXQodmFsdWVzWzNdID8gW3tcbiAgICAgICAgdmFsdWU6IHZhbHVlc1szXVxuICAgICAgfV0gOiBbXSk7XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGRlZmF1bHRfZm9udDogZnVuY3Rpb24gZGVmYXVsdF9mb250KCkge1xuICAgICAgcmV0dXJuICcxMnB4ICcgKyB0aGlzLiRwcm9wcy5mb250LnNwbGl0KCdweCcpLnBvcCgpO1xuICAgIH0sXG4gICAgYnV5X2NvbG9yOiBmdW5jdGlvbiBidXlfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJ1eUNvbG9yIHx8ICcjNjNkZjg5JztcbiAgICB9LFxuICAgIHNlbGxfY29sb3I6IGZ1bmN0aW9uIHNlbGxfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNlbGxDb2xvciB8fCAnI2VjNDY2Mic7XG4gICAgfSxcbiAgICBsYWJlbF9jb2xvcjogZnVuY3Rpb24gbGFiZWxfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxhYmVsQ29sb3IgfHwgdGhpcy5jb2xvcnMudGV4dDtcbiAgICB9LFxuICAgIG1hcmtlcl9zaXplOiBmdW5jdGlvbiBtYXJrZXJfc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubWFya2VyU2l6ZSB8fCA1O1xuICAgIH0sXG4gICAgc2hvd19sYWJlbDogZnVuY3Rpb24gc2hvd19sYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2hvd0xhYmVsICE9PSBmYWxzZTtcbiAgICB9LFxuICAgIG5ld19mb250OiBmdW5jdGlvbiBuZXdfZm9udCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZm9udCB8fCB0aGlzLmRlZmF1bHRfZm9udDtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1RyYWRlc1BsdXMvVHJhZGVzUGx1cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUcmFkZXNQbHVzX1RyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1RyYWRlc1BsdXMvVHJhZGVzUGx1cy52dWVcbnZhciBUcmFkZXNQbHVzX3JlbmRlciwgVHJhZGVzUGx1c19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBUcmFkZXNQbHVzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgVHJhZGVzUGx1c19UcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBUcmFkZXNQbHVzX3JlbmRlcixcbiAgVHJhZGVzUGx1c19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFRyYWRlc1BsdXNfYXBpOyB9XG5UcmFkZXNQbHVzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1RyYWRlc1BsdXMvVHJhZGVzUGx1cy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUcmFkZXNQbHVzID0gKFRyYWRlc1BsdXNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9WV01BL1ZXTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFZXTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVldNQScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnVm9sdW1lIFdlaWdodGVkIE1vdmluZyBBdmVyYWdlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ1ZXTUEgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNkYjA2NzAnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1ZXTUEnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAyMCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2d21hKGNsb3NlLCBsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvVldNQS9WV01BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFZXTUFfVldNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChWV01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvVldNQS9WV01BLnZ1ZVxudmFyIFZXTUFfcmVuZGVyLCBWV01BX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFZXTUFfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBWV01BX1ZXTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFZXTUFfcmVuZGVyLFxuICBWV01BX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVldNQV9hcGk7IH1cblZXTUFfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvVldNQS9WV01BLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFZXTUEgPSAoVldNQV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1dpbGxpYW1zUi9XaWxsaWFtc1IudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFdpbGxpYW1zUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdXaWxsaWFtc1InLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1dpbGxpYW1zICVSJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJyVSICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzA5ODBlOCcsXG4gICAgICAgICAgICBiYW5kQ29sb3I6ICcjYWFhJyxcbiAgICAgICAgICAgIGJhY2tDb2xvcjogJyM5YjliYTMxNicsXG4gICAgICAgICAgICB1cHBlcjogLTIwLFxuICAgICAgICAgICAgbG93ZXI6IC04MFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydXaWxsaWFtc1InXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxNCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdSYW5nZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdwcihsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvV2lsbGlhbXNSL1dpbGxpYW1zUi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBXaWxsaWFtc1JfV2lsbGlhbXNSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFdpbGxpYW1zUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1dpbGxpYW1zUi9XaWxsaWFtc1IudnVlXG52YXIgV2lsbGlhbXNSX3JlbmRlciwgV2lsbGlhbXNSX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFdpbGxpYW1zUl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFdpbGxpYW1zUl9XaWxsaWFtc1J2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFdpbGxpYW1zUl9yZW5kZXIsXG4gIFdpbGxpYW1zUl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFdpbGxpYW1zUl9hcGk7IH1cbldpbGxpYW1zUl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9XaWxsaWFtc1IvV2lsbGlhbXNSLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFdpbGxpYW1zUiA9IChXaWxsaWFtc1JfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanNcbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXMuanNcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qc1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qc1xuXG5cblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qc1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1hPaGxjQmFycy9wcmltaXRpdmVzL3hvaGxjYmFyLmpzXG5cblxuXG4vLyBPaGxjIG9iamVjdCBmb3IgT2hsY3Mgb3ZlcmxheVxudmFyIFhPaGxjQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWE9obGNCYXIob3ZlcmxheSwgY3R4LCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhPaGxjQmFyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuc2VsZiA9IG92ZXJsYXk7XG4gICAgdGhpcy5zdHlsZSA9IGRhdGEucmF3WzZdIHx8IHRoaXMuc2VsZjtcblxuICAgIHRoaXMuX2RyYXcoZGF0YSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWE9obGNCYXIsIFt7XG4gICAga2V5OiBcIl9kcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3KGRhdGEpIHtcbiAgICAgIHZhciBsaW5lX3dpZHRoID0gdGhpcy5zdHlsZS5saW5lV2lkdGg7XG4gICAgICB2YXIgaGxjX29ubHkgPSB0aGlzLnN0eWxlLmNoYXJ0VHlwZSA9PSBcIkhMQ1wiO1xuICAgICAgdmFyIGxpbmVfd2lkdGhfaGFsZiA9IGxpbmVfd2lkdGggLyAyOyAvLyBCYXIgY29sb3JcblxuICAgICAgdmFyIGJhcl9jb2xvciA9IGRhdGEuYyA8PSBkYXRhLm8gPyB0aGlzLnN0eWxlLnVwQmFyQ29sb3IgOiB0aGlzLnN0eWxlLmRvd25CYXJDb2xvcjtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KGRhdGEudywgMSk7XG4gICAgICB2YXIgaGFsZndpZHRoID0gTWF0aC5tYXgoTWF0aC5mbG9vcih3aWR0aCAqIDAuNSksIDEpO1xuICAgICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKGRhdGEubyAtIGRhdGEuYyk7XG4gICAgICB2YXIgbWF4X2ggPSBkYXRhLmMgPT09IGRhdGEubyA/IDEgOiAyO1xuICAgICAgdmFyIHMgPSBsaW5lX3dpZHRoICUgMiA9PT0gMCA/IDAgOiAwLjU7IC8vIERyYXcgdGhlIGxpbmUgZnJvbSBsb3cgdG8gaGlnaCBhbmQgb3BlbiBhbmQgY2xvc2UgYWxzb1xuXG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGJhcl9jb2xvcjtcbiAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IGxpbmVfd2lkdGg7XG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTsgLy8gRHJhdyBoaWdoIHRvIGxvd1xuXG4gICAgICB0aGlzLmN0eC5tb3ZlVG8oTWF0aC5mbG9vcihkYXRhLnggLSBsaW5lX3dpZHRoX2hhbGYpICsgcywgTWF0aC5mbG9vcihkYXRhLmgpKTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyhNYXRoLmZsb29yKGRhdGEueCAtIGxpbmVfd2lkdGhfaGFsZikgKyBzLCBNYXRoLmZsb29yKGRhdGEubCkpO1xuXG4gICAgICBpZiAod2lkdGggPiAxKSB7XG4gICAgICAgIC8vIERyYXcgb3BlbiBub3RjaFxuICAgICAgICBpZiAoaGxjX29ubHkpIHtcbiAgICAgICAgICAvLyBObyBvcGVuIHByaWNlIGluIGNvbnNpZGVyYXRpb25cbiAgICAgICAgICAvLyBEcmF3IG9wZW4gbm90Y2ggd2l0aCBjbG9zZSBwcmljZVxuICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhNYXRoLmZsb29yKGRhdGEueCAtIGhhbGZ3aWR0aCAtIGxpbmVfd2lkdGhfaGFsZiAtIDEpLCBNYXRoLmZsb29yKGRhdGEuYykgLSBzKTtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oTWF0aC5mbG9vcihkYXRhLnggLSBsaW5lX3dpZHRoX2hhbGYpLCBNYXRoLmZsb29yKGRhdGEuYykgLSBzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEcmF3IG9wZW4gbm90Y2ggd2l0aCBvcGVuIHByaWNlXG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKE1hdGguZmxvb3IoZGF0YS54IC0gaGFsZndpZHRoIC0gbGluZV93aWR0aF9oYWxmIC0gMSksIE1hdGguZmxvb3IoZGF0YS5vKSAtIHMpO1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyhNYXRoLmZsb29yKGRhdGEueCAtIGxpbmVfd2lkdGhfaGFsZiksIE1hdGguZmxvb3IoZGF0YS5vKSAtIHMpO1xuICAgICAgICB9IC8vIERyYXcgY2xvc2Ugbm90Y2hcblxuXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhNYXRoLmZsb29yKGRhdGEueCAtIGxpbmVfd2lkdGhfaGFsZiksIE1hdGguZmxvb3IoZGF0YS5jKSAtIHMpO1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oTWF0aC5mbG9vcihkYXRhLnggKyBoYWxmd2lkdGggLSBsaW5lX3dpZHRoX2hhbGYgKyAxKSwgTWF0aC5mbG9vcihkYXRhLmMpIC0gcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBYT2hsY0Jhcjtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvWE9obGNCYXJzL3ByaW1pdGl2ZXMveHZvbGJhci5qc1xuXG5cblxudmFyIFhWb2xiYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYVm9sYmFyKG92ZXJsYXksIGN0eCwgZGF0YSwgYmFyRGF0YSwgdGhpblZvbHVtZUJhcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYVm9sYmFyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuJHAgPSBvdmVybGF5LiRwcm9wcztcbiAgICB0aGlzLnNlbGYgPSBvdmVybGF5O1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnJhd1s2XSB8fCB0aGlzLnNlbGY7XG5cbiAgICB0aGlzLl9kcmF3KGRhdGEsIGJhckRhdGEsIHRoaW5Wb2x1bWVCYXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFhWb2xiYXIsIFt7XG4gICAga2V5OiBcIl9kcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3KGRhdGEsIGJhckRhdGEsIHRoaW5Wb2x1bWVCYXIpIHtcbiAgICAgIGlmICh0aGluVm9sdW1lQmFyKSB7XG4gICAgICAgIC8vIFRoaW4gVm9sdW1lIEJhclxuICAgICAgICB2YXIgYmFyX2NvbG9yID0gZGF0YS5ncmVlbiA/IHRoaXMuc3R5bGUudXBWb2xCYXJDb2xvciA6IHRoaXMuc3R5bGUuZG93blZvbEJhckNvbG9yO1xuICAgICAgICB2YXIgbGluZV93aWR0aCA9IHRoaXMuc3R5bGUudm9sQmFyV2lkdGg7XG4gICAgICAgIHZhciBsaW5lX3dpZHRoX2hhbGYgPSBsaW5lX3dpZHRoIC8gMjtcbiAgICAgICAgdmFyIHkwID0gdGhpcy4kcC5sYXlvdXQuaGVpZ2h0O1xuICAgICAgICB2YXIgdyA9IGRhdGEueDIgLSBkYXRhLngxO1xuICAgICAgICB2YXIgaCA9IE1hdGguZmxvb3IoZGF0YS5oKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBiYXJfY29sb3I7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IGxpbmVfd2lkdGg7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpOyAvLyBEcmF3IGhpZ2ggdG8gbG93XG5cbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKE1hdGguZmxvb3IoYmFyRGF0YS54IC0gbGluZV93aWR0aF9oYWxmKSwgTWF0aC5mbG9vcih5MCAtIGggLSAwLjUpKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKE1hdGguZmxvb3IoYmFyRGF0YS54IC0gbGluZV93aWR0aF9oYWxmKSwgTWF0aC5mbG9vcih5MCArIDAuNSkpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaWNrIFZvbHVtZSBCYXJcbiAgICAgICAgdmFyIF95ID0gdGhpcy4kcC5sYXlvdXQuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBfdyA9IGRhdGEueDIgLSBkYXRhLngxO1xuXG4gICAgICAgIHZhciBfaCA9IE1hdGguZmxvb3IoZGF0YS5oKTtcblxuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBkYXRhLmdyZWVuID8gdGhpcy5zdHlsZS51cFZvbEJhckNvbG9yIDogdGhpcy5zdHlsZS5kb3duVm9sQmFyQ29sb3I7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KE1hdGguZmxvb3IoZGF0YS54MSksIE1hdGguZmxvb3IoX3kgLSBfaCAtIDAuNSksIE1hdGguZmxvb3IoX3cpLCBNYXRoLmZsb29yKF9oICsgMSkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBYVm9sYmFyO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvWE9obGNCYXJzL1hPaGxjQmFycy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuZnVuY3Rpb24gWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gUmVuZWRyZXIgZm9yIG9obGNiYXIgKyB2b2x1bWUgKG9wdGlvbmFsKVxuLy8gSXQgY2FuIGJlIHVzZWQgYXMgdGhlIG1haW4gY2hhcnQgb3IgYW4gaW5kaWNhdG9yXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdYT2hsY0JhcnMnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1gnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4zLjAnLFxuICAgICAgICBkZXNjOiAnQmFyIENoYXJ0J1xuICAgICAgfTtcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7Ly90aGlzLnByaWNlID0gbmV3IFByaWNlKHRoaXMpIC8vIFRPRE86XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIlhPaGxjQmFyLmRyYXcoKSBjYWxsZWQuIHRoaXMuJHByb3BzLmRhdGEubGVuZ3RoID0gXCIgKyB0aGlzLiRwcm9wcy5kYXRhLmxlbmd0aClcbiAgICAgIC8vIHJlbmRlciBhcyBtYWluIGNoYXJ0OlxuICAgICAgaWYgKHRoaXMuJHByb3BzLnN1YiA9PT0gdGhpcy4kcHJvcHMuZGF0YSkge1xuICAgICAgICB2YXIgY252ID0ge1xuICAgICAgICAgIG9obGNiYXJzOiB0aGlzLiRwcm9wcy5sYXlvdXQuY2FuZGxlcyxcbiAgICAgICAgICB2b2x1bWU6IHRoaXMuJHByb3BzLmxheW91dC52b2x1bWVcbiAgICAgICAgfTsgLy8gRWxzZSwgYXMgb2ZmY2hhcnQgLyBvbmNoYXJ0IGluZGljYXRvcjpcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNudiA9ICgwLGV4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5sYXlvdXRfY252KSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd192b2x1bWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbnYudm9sdW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZvbHVtZURhdGEgPSBjbnYudm9sdW1lW2ldO1xuICAgICAgICAgIHZhciBfYmFyRGF0YSA9IGNudi5vaGxjYmFyc1tpXTtcbiAgICAgICAgICBuZXcgWFZvbGJhcih0aGlzLCBjdHgsIHZvbHVtZURhdGEsIF9iYXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjbnYub2hsY2JhcnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBiYXJEYXRhID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgbmV3IFhPaGxjQmFyKHRoaXMsIGN0eCwgYmFyRGF0YSk7XG4gICAgICAgIH0gLy9pZiAodGhpcy5wcmljZV9saW5lKSB0aGlzLnByaWNlLmRyYXcoY3R4KSAgLy8gVE9ETzpcblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1hPaGxjQmFycyddO1xuICAgIH0sXG4gICAgLy8gV2hlbiBhZGRlZCBhcyBvZmZjaGFydCBvdmVybGF5XG4gICAgeV9yYW5nZTogZnVuY3Rpb24geV9yYW5nZSgpIHtcbiAgICAgIHJldHVybiBbTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuJHByb3BzLnN1Yi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhbMl07XG4gICAgICB9KSkpLCBNYXRoLm1pbi5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy4kcHJvcHMuc3ViLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFszXTtcbiAgICAgIH0pKSldO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBzaG93X3ZvbHVtZTogZnVuY3Rpb24gc2hvd192b2x1bWUoKSB7XG4gICAgICByZXR1cm4gJ3Nob3dWb2x1bWUnIGluIHRoaXMuc2V0dCA/IHRoaXMuc2V0dC5zaG93Vm9sdW1lIDogdHJ1ZTtcbiAgICB9LFxuICAgIHByaWNlX2xpbmU6IGZ1bmN0aW9uIHByaWNlX2xpbmUoKSB7XG4gICAgICByZXR1cm4gJ3ByaWNlTGluZScgaW4gdGhpcy5zZXR0ID8gdGhpcy5zZXR0LnByaWNlTGluZSA6IHRydWU7XG4gICAgfSxcbiAgICB1cFZvbEJhckNvbG9yOiBmdW5jdGlvbiB1cFZvbEJhckNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC51cEJhckNvbG9yIHx8IFwiIzIzYTc3NjU1XCI7XG4gICAgfSxcbiAgICBkb3duVm9sQmFyQ29sb3I6IGZ1bmN0aW9uIGRvd25Wb2xCYXJDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZG93bkJhckNvbG9yIHx8IFwiI2U1NDE1MDU1XCI7XG4gICAgfSxcbiAgICB2b2xCYXJXaWR0aDogZnVuY3Rpb24gdm9sQmFyV2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhcldpZHRoIHx8IDI7XG4gICAgfSxcbiAgICB1cEJhckNvbG9yOiBmdW5jdGlvbiB1cEJhckNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC51cEJhckNvbG9yIHx8IFwiIzIzYTc3NlwiO1xuICAgIH0sXG4gICAgZG93bkJhckNvbG9yOiBmdW5jdGlvbiBkb3duQmFyQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmRvd25CYXJDb2xvciB8fCBcIiNlNTQxNTBcIjtcbiAgICB9LFxuICAgIGJhcldpZHRoOiBmdW5jdGlvbiBiYXJXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFyV2lkdGggfHwgMTtcbiAgICB9LFxuICAgIGhsY09ubHk6IGZ1bmN0aW9uIGhsY09ubHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmhsY09ubHkgfHwgZmFsc2U7XG4gICAgfSxcbiAgICBsaW5lV2lkdGg6IGZ1bmN0aW9uIGxpbmVXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDE7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmljZToge31cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9YT2hsY0JhcnMvWE9obGNCYXJzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFhPaGxjQmFyc19YT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvWE9obGNCYXJzL1hPaGxjQmFycy52dWVcbnZhciBYT2hsY0JhcnNfcmVuZGVyLCBYT2hsY0JhcnNfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgWE9obGNCYXJzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgWE9obGNCYXJzX1hPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgWE9obGNCYXJzX3JlbmRlcixcbiAgWE9obGNCYXJzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgWE9obGNCYXJzX2FwaTsgfVxuWE9obGNCYXJzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1hPaGxjQmFycy9YT2hsY0JhcnMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgWE9obGNCYXJzID0gKFhPaGxjQmFyc19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW5kZXhfcHJvZC5qc1xuLy8gLS0tLS0tLS0gUHJvZHVjdGlvbiBvdmVybGF5IGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIERvIG5vdCBjb21taXQgdGhpcyBmaWxlLCB0aGUgZmluYWwgaW5kZXggaXNcbi8vIGNvbXBpbGVkIGJ5IHRoZSByZXBvIG93bmVyLCB1c2UgaW5kZXhfZGV2LmpzIHRvXG4vLyBleHBlcmltZW50OiAnbnBtIHJ1biBjb21waWxlJ1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIFBhY2sgPSB7XG4gIEFMTUE6IEFMTUEsXG4gIEFUUjogQVRSLFxuICBBVFJwOiBBVFJwLFxuICBBcmVhNTE6IEFyZWE1MSxcbiAgQkI6IEJCLFxuICBCQlc6IEJCVyxcbiAgQ0NJOiBDQ0ksXG4gIENNTzogQ01PLFxuICBDT0c6IENPRyxcbiAgREhpc3RvZ3JhbTogREhpc3RvZ3JhbSxcbiAgRE1JOiBETUksXG4gIEVNQTogRU1BLFxuICBITUE6IEhNQSxcbiAgSGlzdG9ncmFtOiBIaXN0b2dyYW0sXG4gIEljaGk6IEljaGksXG4gIEljaGltb2t1OiBJY2hpbW9rdSxcbiAgS0M6IEtDLFxuICBLQ1c6IEtDVyxcbiAgTG9uZ1Nob3J0VHJhZGVzOiBMb25nU2hvcnRUcmFkZXMsXG4gIE1BQ0Q6IE1BQ0QsXG4gIE1GSTogTUZJLFxuICBNT006IE1PTSxcbiAgTWFya2VyczogTWFya2VycyxcbiAgUGxvdENyb3NzOiBQbG90Q3Jvc3MsXG4gIFJPQzogUk9DLFxuICBSU0k6IFJTSSxcbiAgUmliYm9uOiBSaWJib24sXG4gIFNBUjogU0FSLFxuICBTTUE6IFNNQSxcbiAgU1dNQTogU1dNQSxcbiAgU3RvY2g6IFN0b2NoLFxuICBUU0k6IFRTSSxcbiAgVHJhZGVzUGx1czogVHJhZGVzUGx1cyxcbiAgVldNQTogVldNQSxcbiAgV2lsbGlhbXNSOiBXaWxsaWFtc1IsXG4gIFhPaGxjQmFyczogWE9obGNCYXJzXG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVHZqc092ZXJsYXlzID0gUGFjaztcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBpbmRleF9wcm9kID0gKFBhY2spO1xuXG59KSgpO1xuXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9NYWluLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zZmZhZTZiMiZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vTWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vTWFpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzNmZmFlNmIyJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzNmZmFlNmIyJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzNmZmFlNmIyJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9NYWluLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zZmZhZTZiMiZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCczZmZhZTZiMicsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL01haW4udnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWUxZjFjMTcmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vU3RkSW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vU3RkSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIkM6XFxcXHhhbXBwXFxcXGh0ZG9jc1xcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCc1ZTFmMWMxNycpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc1ZTFmMWMxNycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc1ZTFmMWMxNycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vU3RkSW5wdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVlMWYxYzE3JlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzVlMWYxYzE3Jywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1dpbmRvdy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWIwMzBhMjAmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vV2luZG93LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vV2luZG93LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9XaW5kb3cudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIkM6XFxcXHhhbXBwXFxcXGh0ZG9jc1xcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCc1YjAzMGEyMCcpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc1YjAzMGEyMCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc1YjAzMGEyMCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vV2luZG93LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01YjAzMGEyMCZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc1YjAzMGEyMCcsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTE4OWZjY2FkJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1NwbGl0dGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL1NwbGl0dGVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTE4OWZjY2FkJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIxODlmY2NhZFwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIkM6XFxcXHhhbXBwXFxcXGh0ZG9jc1xcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCcxODlmY2NhZCcpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcxODlmY2NhZCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcxODlmY2NhZCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTE4OWZjY2FkJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzE4OWZjY2FkJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS9TcGxpdHRlci52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0FkZFdpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTM0MDhhYzcmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQWRkV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQWRkV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NTM0MDhhYzcmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjUzNDA4YWM3XCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzUzNDA4YWM3JykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzUzNDA4YWM3JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzUzNDA4YWM3JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTUzNDA4YWM3JnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzUzNDA4YWM3Jywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9BZGRXaW4udnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9TZXR0aW5nc1dpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWQyMjNiMGUmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vU2V0dGluZ3NXaW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9TZXR0aW5nc1dpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vU2V0dGluZ3NXaW4udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NWQyMjNiMGUmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjVkMjIzYjBlXCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzVkMjIzYjBlJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzVkMjIzYjBlJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzVkMjIzYjBlJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9TZXR0aW5nc1dpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWQyMjNiMGUmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNWQyMjNiMGUnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vV2luZG93LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1dpbmRvdy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FkZFdpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgIFwiZmxleC1zdGFydCBjb2wtMTAgY29sLXhsbC0xMCBjb2wteGwtMTAgY29sLWxnLTEwIGNvbC1tZC05IGNvbC1zbS0xMlwiLFxuICAgIH0sXG4gICAgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJ0dmpzLWhlYWRlclwiIH0gfSwgW1xuICAgICAgICBfdm0uX20oMCksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiYVwiLCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWUtMSBiYWRnZSBiZy1saWdodC1zZWNvbmRhcnlcIixcbiAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5jYW5kbGVzIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJiaSBiaS1iYXItY2hhcnRcIiB9KSxcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkLW1kLWlubGluZSBkLW5vbmVcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiICBDYW5kbGVzXCIpLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLFxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJhXCIsIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXNlY29uZGFyeVwiLFxuICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnNwbGluZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktZ3JhcGgtdXBcIiB9KSxcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkLW1kLWlubGluZSBkLW5vbmVcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiICBTcGxpbmVcIiksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfdm0uX20oMSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF92bS5fbSgyKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX3ZtLl9tKDMpLFxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgIFwiY29sbGFwc2UgY29sLWxnLTQgY29sLW1kLTUgY29sLXNtLTYgcG9zaXRpb24tYWJzb2x1dGUgc3RpY2t5LXRvcCBjYXJkLTExMCBcIixcbiAgICAgICAgICBhdHRyczogeyBpZDogXCJjb2xsYXBzZUluZm9zXCIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiY2FyZFwiLFxuICAgICAgICAgICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiIzEzMTcyMmU2IWltcG9ydGFudFwiLFxuICAgICAgICAgICAgICAgIFwiYm94LXNoYWRvd1wiOiBcIjAgNHB4IDI0cHggMCByZ2IoMCAwIDAgLyAzMCUpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNhcmQtaGVhZGVyXCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29sLW1kLThcIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfYyhcImg0XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC10aXRsZVwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS5zeW1ib2wpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfdm0uX20oNCksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uX20oNSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9tKDYpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImFwcC1jb250YWluZXJcIiwgc3RhdGljU3R5bGU6IHsgXCJtYXJnaW4tdG9wXCI6IFwiNDBweFwiIH0gfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwidHJhZGluZy12dWVcIiwge1xuICAgICAgICAgICAga2V5OiBfdm0ucmVzZXRrZXksXG4gICAgICAgICAgICByZWY6IFwidHZqc1wiLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgZGF0YTogX3ZtLmRjLFxuICAgICAgICAgICAgICB3aWR0aDogX3ZtLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IF92bS5oZWlnaHQsXG4gICAgICAgICAgICAgIFwidGl0bGUtdHh0XCI6IF92bS50aXRsZSxcbiAgICAgICAgICAgICAgXCJjb2xvci10aXRsZVwiOiBcIiNmZjlmNDNcIixcbiAgICAgICAgICAgICAgXCJsZWdlbmQtYnV0dG9uc1wiOiBbXG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCIsXG4gICAgICAgICAgICAgICAgXCJzZXR0aW5nc1wiLFxuICAgICAgICAgICAgICAgIFwidXBcIixcbiAgICAgICAgICAgICAgICBcImRvd25cIixcbiAgICAgICAgICAgICAgICBcImFkZFwiLFxuICAgICAgICAgICAgICAgIFwicmVtb3ZlXCIsXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFwiY2hhcnQtY29uZmlnXCI6IHsgREVGQVVMVF9MRU46IDYwLCBNSU5fWk9PTTogMSB9LFxuICAgICAgICAgICAgICB0b29sYmFyOiB0cnVlLFxuICAgICAgICAgICAgICBcImNvbG9yLWJhY2tcIjogX3ZtLmNvbG9ycy5jb2xvckJhY2ssXG4gICAgICAgICAgICAgIFwiY29sb3ItZ3JpZFwiOiBfdm0uY29sb3JzLmNvbG9yR3JpZCxcbiAgICAgICAgICAgICAgXCJjb2xvci10ZXh0XCI6IF92bS5jb2xvcnMuY29sb3JUZXh0LFxuICAgICAgICAgICAgICBleHRlbnNpb25zOiBfdm0uZXh0LFxuICAgICAgICAgICAgICBvdmVybGF5czogX3ZtLm92cyxcbiAgICAgICAgICAgICAgbmlnaHQ6IF92bS5uaWdodCxcbiAgICAgICAgICAgICAgcmVzZXRrZXk6IF92bS5yZXNldGtleSxcbiAgICAgICAgICAgICAgXCJ4LXNldHRpbmdzXCI6IF92bS54c2V0dCxcbiAgICAgICAgICAgICAgdGltZXpvbmU6IF92bS50aW1lem9uZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgXVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJhXCIsIFtcbiAgICAgIF9jKFxuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1wiLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBpZDogXCJ0b2dnbGVDb250cmFjdHNcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10b2dnbGVcIjogXCJjb2xsYXBzZVwiLFxuICAgICAgICAgICAgXCJkYXRhLWJzLXRhcmdldFwiOiBcIiNjb2xsYXBzZUNvbnRyYWN0c1wiLFxuICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBcImNvbGxhcHNlQ29udHJhY3RzXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImJpIGJpLWJyaWVmY2FzZVwiIH0pLFxuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZC1tZC1pbmxpbmUgZC1ub25lXCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFwiIENvbnRyYWN0c1wiKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJhXCIsIFtcbiAgICAgIF9jKFxuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1wiLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBpZDogXCJ0b2dnbGVJbmZvXCIsXG4gICAgICAgICAgICBcImRhdGEtYnMtdG9nZ2xlXCI6IFwiY29sbGFwc2VcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10YXJnZXRcIjogXCIjY29sbGFwc2VJbmZvc1wiLFxuICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBcImNvbGxhcHNlSW5mb3NcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktaW5mby1jaXJjbGVcIiB9KSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtbWQtaW5saW5lIGQtbm9uZVwiIH0sIFtfdm0uX3YoXCIgIEluZm9cIildKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJhXCIsIFtcbiAgICAgIF9jKFxuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtcHJpbWFyeSBcIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaWQ6IFwidG9nZ2xlRGVwdGhcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10b2dnbGVcIjogXCJjb2xsYXBzZVwiLFxuICAgICAgICAgICAgXCJkYXRhLWJzLXRhcmdldFwiOiBcIiNjb2xsYXBzZURlcHRoXCIsXG4gICAgICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuICAgICAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IFwiY29sbGFwc2VEZXB0aFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJiaSBiaS1rYW5iYW5cIiB9KSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtbWQtaW5saW5lIGQtbm9uZVwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIiAgRGVwdGggVmlld1wiKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJhXCIsIFtcbiAgICAgIF9jKFxuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtd2FybmluZyBcIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaWQ6IFwidG9nZ2xlT3JkZXJzXCIsXG4gICAgICAgICAgICBcImRhdGEtYnMtdG9nZ2xlXCI6IFwiY29sbGFwc2VcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10YXJnZXRcIjogXCIjY29sbGFwc2VPcmRlcnNcIixcbiAgICAgICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBcImFyaWEtY29udHJvbHNcIjogXCJjb2xsYXBzZU9yZGVyc1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJiaSBiaS1maWxlLWJhci1ncmFwaFwiIH0pLFxuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZC1tZC1pbmxpbmUgZC1ub25lXCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFwiICBPcmRlciBCb29rXCIpLFxuICAgICAgICAgIF0pLFxuICAgICAgICBdXG4gICAgICApLFxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNhcmQtY29udGVudFwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC1ib2R5XCIgfSwgW1xuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInJvd1wiIH0sIFtcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbC04XCIgfSwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1zdGFydCBmcy0xXCIsIGF0dHJzOiB7IGlkOiBcInNob3dfYlwiIH0gfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wtNFwiIH0sIFtcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcImZvbnQtc2l6ZVwiOiBcIjE0cHhcIiB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfcFwiIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRleHQtZW5kXCIsXG4gICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgXCJmb250LXNpemVcIjogXCIxNHB4XCIgfSxcbiAgICAgICAgICAgICAgICBhdHRyczogeyBpZDogXCJzaG93X1BcIiB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInJvdyBtdC0xXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwicHJvZ3Jlc3NcIiwgYXR0cnM6IHsgaWQ6IFwibXlSYW5nZUNvbG9yXCIgfSB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICBcInByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItc3RyaXBlZCBwcm9ncmVzcy1iYXItYW5pbWF0ZWRcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyB3aWR0aDogXCI4MCVcIiB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICBpZDogXCJteVJhbmdlXCIsXG4gICAgICAgICAgICAgICAgICByb2xlOiBcInByb2dyZXNzYmFyXCIsXG4gICAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogXCI1MFwiLFxuICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbWluXCI6IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IFwiMTAwXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKSxcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgIFwicm93IGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXJcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiY29sIHRleHQtc3RhcnQgdGV4dC1kYW5nZXJcIixcbiAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgXCJmb250LXNpemVcIjogXCIxMHB4XCIgfSxcbiAgICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwic2hvd19sXCIgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiY29sIHRleHQtZGFyayB0ZXh0LWNlbnRlclwiLFxuICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IFwiZm9udC1zaXplXCI6IFwiMTBweFwiIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXkgUmFuZ2VcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJkaXZcIiwge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJjb2wgdGV4dC1lbmQgdGV4dC1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IFwiZm9udC1zaXplXCI6IFwiMTBweFwiIH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfaFwiIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicm93IG10LTFcIiB9LCBbXG4gICAgICAgICAgX2MoXCJzbWFsbFwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIlZvbHVtZSAyNEhcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfdlwiIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImhyXCIpLFxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJyb3dcIiB9LCBbXG4gICAgICAgICAgX2MoXCJzbWFsbFwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIk1hcmtldCBDYXBcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfbWNcIiB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJoclwiKSxcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicm93XCIgfSwgW1xuICAgICAgICAgIF9jKFwic21hbGxcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhcmsgY2xlYXJmaXhcIiB9LCBbXG4gICAgICAgICAgICBfdm0uX3YoXCJUb3RhbCBTdXBwbHlcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfdHNcIiB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJoclwiKSxcbiAgICAgICAgXSksXG4gICAgICBdKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICBcImNvbGxhcHNlIGNvbC1sZy02IGNvbC1tZC0xMCBjb2wtc20tMTIgY29sLTEyIHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTAgXCIsXG4gICAgICAgIGF0dHJzOiB7IGlkOiBcImNvbGxhcHNlRGVwdGhcIiB9LFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJjYXJkXCIsXG4gICAgICAgICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxMzE3MjJlNiFpbXBvcnRhbnRcIixcbiAgICAgICAgICAgICAgXCJib3gtc2hhZG93XCI6IFwiMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSlcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNhcmQtY29udGVudFwiIH0sIFtcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJjaGFydGRpdlwiIH0gfSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICBdXG4gICAgKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICBcImNvbGxhcHNlIGNvbC1sZy00IGNvbC1tZC00IGNvbC1zbS02IGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwXCIsXG4gICAgICAgIHN0YXRpY1N0eWxlOiB7IFwibWF4LXdpZHRoXCI6IFwiMjgwcHhcIiB9LFxuICAgICAgICBhdHRyczogeyBpZDogXCJjb2xsYXBzZU9yZGVyc1wiIH0sXG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNhcmRcIixcbiAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiIzEzMTcyMmU2IWltcG9ydGFudFwiLFxuICAgICAgICAgICAgICBcImJveC1zaGFkb3dcIjogXCIwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC1jb250ZW50IG15LTFcIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYm94XCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwidGFibGVcIiwgW1xuICAgICAgICAgICAgICAgICAgX2MoXCJ0aGVhZFwiLCBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwidHJcIiwgeyBzdGF0aWNDbGFzczogXCJtYi0xXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGhcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LXN0YXJ0IHBzLTEgdGV4dC1kYXJrXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByaWNlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGhcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LWNlbnRlciBwcy0xIHRleHQtZGFya1wiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFudGl0eVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInRoXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1lbmQgcGUtMSB0ZXh0LWRhcmtcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG90YWxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXCJ0YWJsZVwiLCB7IHN0YXRpY0NsYXNzOiBcImFza3NcIiB9KSxcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibmV3ZXN0XCIgfSksXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICBfYyhcInRhYmxlXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmlkc1wiIH0pLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgIF1cbiAgICAgICAgKSxcbiAgICAgIF1cbiAgICApXG4gIH0sXG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwic3BhblwiLCBbXG4gICAgX3ZtLnR5cGUgPT09IFwidGV4dFwiIHx8ICFfdm0udHlwZVxuICAgICAgPyBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXN0ZC1pbnB1dFwiLFxuICAgICAgICAgIHN0eWxlOiBfdm0uc3R5bGUsXG4gICAgICAgICAgYXR0cnM6IHsgcGxhY2Vob2xkZXI6IF92bS5uYW1lIH0sXG4gICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS52YWx1ZSB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF92bS4kZW1pdChcImNoYW5nZVwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdm0uJGVtaXQoXCJpbnB1dFwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgOiBfdm0udHlwZSA9PT0gXCJzZWxlY3RcIlxuICAgICAgPyBfYyhcbiAgICAgICAgICBcInNlbGVjdFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMtc3RkLWlucHV0XCIsXG4gICAgICAgICAgICBzdHlsZTogX3ZtLnN0eWxlLFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS52YWx1ZSB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLiRlbWl0KFwiaW5wdXRcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfdm0uX2woX3ZtLmxpc3QsIGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBfYyhcIm9wdGlvblwiLCBbX3ZtLl92KF92bS5fcyhvcHQpKV0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgMFxuICAgICAgICApXG4gICAgICA6IF92bS5fZSgpLFxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyByZWY6IFwid2luXCIsIHN0YXRpY0NsYXNzOiBcInR2anMteC13aW5kb3dcIiwgc3R5bGU6IF92bS5zdHlsZSB9LFxuICAgIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidHZqcy14LXdpbmRvdy1oZWFkXCIgfSwgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMteC13aW5kb3ctdGl0bGVcIixcbiAgICAgICAgICAgIG9uOiB7IG1vdXNlZG93bjogX3ZtLm9uTW91c2VEb3duIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgICAgIFwiICsgX3ZtLl9zKF92bS50aXRsZSkgKyBcIlxcbiAgICAgICAgICAgIFwiKV1cbiAgICAgICAgKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXgtd2luZG93LWNsb3NlXCIsXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdm0uJGVtaXQoXCJjbG9zZVwiKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtfdm0uX3YoXCJcXG4gICAgICAgICAgICAgICAg4pWzXFxuICAgICAgICAgICAgXCIpXVxuICAgICAgICApLFxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0dmpzLXgtd2luZG93LWJvZHlcIiB9LCBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sIDIpLFxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwic3BhblwiLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaC1zcGxpdHRlclwiLFxuICAgIHN0eWxlOiBfdm0uaHNfc3R5bGUsXG4gICAgb246IHsgbW91c2Vkb3duOiBfdm0uaHNfbW91c2Vkb3duIH0sXG4gIH0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJ3aW5kb3dcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJhZGQtd2luXCIsXG4gICAgICBhdHRyczogeyB0aXRsZTogXCJBZGQgSW5kaWNhdG9yXCIsIHR2OiBfdm0udHYgfSxcbiAgICAgIG9uOiB7IGNsb3NlOiBfdm0ub25fY2xvc2UgfSxcbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImFkZC13aW4tbGlzdFwiIH0sXG4gICAgICAgIF92bS5fbChfdm0ub3ZzLCBmdW5jdGlvbiAob3YpIHtcbiAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJhZGQtd2luLWl0ZW1cIixcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5vbl9jbGljayhvdi5uYW1lKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgW192bS5fdihfdm0uX3Mob3YubmFtZSkpXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImFkZC13aW4taXRlbS1kZXNjXCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKG92Lm1ldGhvZHMubWV0YV9pbmZvKCkuZGVzYykgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICB9KSxcbiAgICAgICAgMFxuICAgICAgKSxcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIndpbmRvd1wiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcInNldHQtd2luXCIsXG4gICAgICBhdHRyczogeyB0aXRsZTogX3ZtLmRhdGEub3YubmFtZSwgdHY6IF92bS50diB9LFxuICAgICAgb246IHsgY2xvc2U6IF92bS5vbl9jbG9zZSB9LFxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLl9sKF92bS5zZXR0bGlzdCwgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJzZXR0LXdpbi1pdGVtXCIgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcImxhYmVsXCIsIFtfdm0uX3YoX3ZtLl9zKF92bS5zMmQoaykpKV0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwic3RkLWlucHV0XCIsIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHsgdmFsdWU6IF92bS5zZXR0W2tdIH0sXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0udXBkYXRlX3NldHQoaywgJGV2ZW50KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgIV92bS5zZXR0bGlzdC5sZW5ndGhcbiAgICAgICAgPyBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJzZXR0LXdpbi1lbXB0eVwiIH0sIFtcbiAgICAgICAgICAgIF9jKFwiaVwiLCBbX3ZtLl92KFwiTm8gc2NyaXB0IHNldHRpbmdzXCIpXSksXG4gICAgICAgICAgXSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjE0XG4gKiAoYykgMjAxNC0yMDIxIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIChcbiAgICBpc0RlZih2YWwpICYmXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAqL1xudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xudmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG52YXIgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgIC8vIG9yZGVyXG4gICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmIChoYXNQcm90bykge1xuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICApIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHZhciByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qJFwiKSkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSwgdm0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhdmVFeHBlY3RlZFR5cGVzID0gZXhwZWN0ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9KTtcbiAgaWYgKCF2YWxpZCAmJiBoYXZlRXhwZWN0ZWRUeXBlcykge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sfEJpZ0ludCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUsIHZtKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybignSW52YWxpZCBwcm9wIHR5cGU6IFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBpcyBub3QgYSBjb25zdHJ1Y3RvcicsIHZtKTtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxudmFyIGZ1bmN0aW9uVHlwZUNoZWNrUkUgPSAvXlxccypmdW5jdGlvbiAoXFx3KykvO1xuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKGZ1bmN0aW9uVHlwZUNoZWNrUkUpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gIGlmIChcbiAgICBleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgaXNFeHBsaWNhYmxlKHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKVxuICApIHtcbiAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyAoc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKSk7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIChzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpKSArIFwiLlwiO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIChcIlwiICsgKE51bWJlcih2YWx1ZSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxuICB9XG59XG5cbnZhciBFWFBMSUNBQkxFX1RZUEVTID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgcmV0dXJuIEVYUExJQ0FCTEVfVFlQRVMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICBpZiAodm0pIHtcbiAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIHZhciBjb3VudGVyID0gMTtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cyQxLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgdmFyIHNsb3RzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzLFxuICBwcmV2U2xvdHNcbikge1xuICB2YXIgcmVzO1xuICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICBpZiAoIXNsb3RzKSB7XG4gICAgcmVzID0ge307XG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgfSBlbHNlIGlmIChcbiAgICBpc1N0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBrZXkgPT09IHByZXZTbG90cy4ka2V5ICYmXG4gICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5JDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5JDFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5JDEsIHNsb3RzW2tleSQxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkkMiBpbiByZXMpKSB7XG4gICAgICByZXNba2V5JDJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMik7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICB2YXIgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgdmFyIHZub2RlID0gcmVzICYmIHJlc1swXTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgICF2bm9kZSB8fFxuICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgdm5vZGUuaXNDb21tZW50ICYmICFpc0FzeW5jUGxhY2Vob2xkZXIodm5vZGUpKSAvLyAjOTY1OCwgIzEwMzkxXG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrUmVuZGVyLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7XG4gICAgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2Fybignc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9XG4gICAgICBzY29wZWRTbG90Rm4ocHJvcHMpIHx8XG4gICAgICAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9XG4gICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxuICAgICAgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxuICByZXR1cm4gZXZlbnRLZXlDb2RlID09PSB1bmRlZmluZWRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXMsXG4gIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICBoYXNEeW5hbWljS2V5cyxcbiAgY29udGVudEhhc2hLZXlcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlY2lhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgdm5vZGUsXG4gIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRcbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICkge1xuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLm5hdGl2ZU9uKSAmJiBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJUaGUgLm5hdGl2ZSBtb2RpZmllciBmb3Igdi1vbiBpcyBvbmx5IHZhbGlkIG9uIGNvbXBvbmVudHMgYnV0IGl0IHdhcyB1c2VkIG9uIDxcIiArIHRhZyArIFwiPi5cIiksXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbnZhciBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdm0uJHNsb3RzLFxuICAgICAgICB2bS4kc2NvcGVkU2xvdHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVzZSBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yXG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICB2YXIgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKG93bmVyICYmICFpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcbiAgICB2YXIgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICB2YXIgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICB2YXIgdGltZXJUaW1lb3V0ID0gbnVsbFxuXG4gICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aW1lckxvYWRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJMb2FkaW5nKTtcbiAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lclRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHRpbWVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGV2ZW50LCBmbikge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldDtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZtLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdm0uJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBpbmZvID0gXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XG4gICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XG4gIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSkgfHxcbiAgICAoIW5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5KVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG52YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wXG4gICkge1xuICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgIC8vIHdlbGwuXG4gICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcodGhpcy5jYiwgdGhpcy52bSwgW3ZhbHVlLCBvbGRWYWx1ZV0sIHRoaXMudm0sIGluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIGlmICghaXNSb290KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgfVxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLm1ldGhvZHMgJiYga2V5IGluIHZtLiRvcHRpb25zLm1ldGhvZHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIG1ldGhvZC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHZhciBpbmZvID0gXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgIHB1c2hUYXJnZXQoKTtcbiAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNiLCB2bSwgW3dhdGNoZXIudmFsdWVdLCB2bSwgaW5mbyk7XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBlbnRyeSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB2YXIgbmFtZSA9IGVudHJ5Lm5hbWU7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgaWYgKGVudHJ5ICYmICghY3VycmVudCB8fCBlbnRyeS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGVudHJ5LmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBjYWNoZVZOb2RlOiBmdW5jdGlvbiBjYWNoZVZOb2RlKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZi5rZXlzO1xuICAgICAgdmFyIHZub2RlVG9DYWNoZSA9IHJlZi52bm9kZVRvQ2FjaGU7XG4gICAgICB2YXIga2V5VG9DYWNoZSA9IHJlZi5rZXlUb0NhY2hlO1xuICAgICAgaWYgKHZub2RlVG9DYWNoZSkge1xuICAgICAgICB2YXIgdGFnID0gdm5vZGVUb0NhY2hlLnRhZztcbiAgICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlVG9DYWNoZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBjYWNoZVtrZXlUb0NhY2hlXSA9IHtcbiAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpLFxuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlOiBjb21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgfTtcbiAgICAgICAga2V5cy5wdXNoKGtleVRvQ2FjaGUpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5jYWNoZVZOb2RlKCk7XG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxheSBzZXR0aW5nIHRoZSBjYWNoZSB1bnRpbCB1cGRhdGVcbiAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSB2bm9kZTtcbiAgICAgICAgdGhpcy5rZXlUb0NhY2hlID0ga2V5O1xuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gIFZ1ZS5vYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIG9ic2VydmUob2JqKTtcbiAgICByZXR1cm4gb2JqXG4gIH07XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjE0JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxudmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZSdcbiAgICA/ICdmYWxzZSdcbiAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICA6IGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiAndHJ1ZSdcbn07XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25vYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIsIHZub2RlLmRhdGEucHJlKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSwgaXNJblByZSkge1xuICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydtb3VzZXVwJzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG52YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxudmFyIHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICkge1xuICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0J1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XSs/XFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBuY25hbWUgPSBcIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSpcIjtcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKSxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOnxeIy87XG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvWyBcXGZcXHRcXHJcXG5dKy9nO1xuXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIShcbiAgICBlbC5jb21wb25lbnQgfHxcbiAgICBlbC5hdHRyc01hcFsnOmlzJ10gfHxcbiAgICBlbC5hdHRyc01hcFsndi1iaW5kOmlzJ10gfHxcbiAgICAhKGVsLmF0dHJzTWFwLmlzID8gaXNSZXNlcnZlZFRhZyhlbC5hdHRyc01hcC5pcykgOiBpc1Jlc2VydmVkVGFnKGVsLnRhZykpXG4gICk7IH07XG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAodGFnLCBzdGFydCwgZW5kJDEpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwiRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBcIiArXG4gICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLFxuICAgICAgICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKSxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCIsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4vLyBlLmcuIDx0ZW1wbGF0ZSBzbG90PVwieHh4XCI+LCA8ZGl2IHNsb3Qtc2NvcGU9XCJ4eHhcIj5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgdmFyIHNsb3RTY29wZTtcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgfVxuXG4gIC8vIHNsb3Q9XCJ4eHhcIlxuICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xuICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSxcIiArXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgIFwiKVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHRoaXMucHJlID0gZmFsc2U7XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICAvLyBmaXggIzExNDgzLCBSb290IGxldmVsIDxzY3JpcHQ+IHRhZ3Mgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cbiAgdmFyIGNvZGUgPSBhc3QgPyAoYXN0LnRhZyA9PT0gJ3NjcmlwdCcgPyAnbnVsbCcgOiBnZW5FbGVtZW50KGFzdCwgc3RhdGUpKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczpcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCIsXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgLy8gIzk0MzgsICM5NTA2XG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICBwYXJlbnQuZm9yXG4gICAgICApIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAuam9pbignLCcpO1xuXG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gaGFzaCA+Pj4gMFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBcIlwiXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixmdW5jdGlvbigpe3JldHVybiBcIiArIGNoaWxkcmVuICsgXCJ9XCIpIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgfSk7IH0pKVxuICAgIDogbnVsbDtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcIixcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IFwie1wiICsgKHN0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICB9XG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG5cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0LCB3YXJuKSB7XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2LXNsb3QnIHx8IG5hbWVbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgY2hlY2tGdW5jdGlvblBhcmFtZXRlckV4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgd2Fybik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB2YXIgc3RyaXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdHJpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdHJpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgd2FybixcbiAgcmFuZ2Vcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKGV4cCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgd2FybihcbiAgICAgIFwiaW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXIgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0LFxuICBlbmRcbikge1xuICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDA7XG4gIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIHsgY29udGludWUgfVxuICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIiBcIiwgcGFkKSArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCQxID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQkMSAoc3RyLCBuKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKG4gPiAwKSB7XG4gICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgIG4gPj4+PSAxO1xuICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICBzdHIgKz0gc3RyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuXG4gICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB2YXIgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0geyBtc2c6IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZSA9IHJlZiQxLmNvbXBpbGU7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsInZhciBkZWZlcnJlZCA9IFtdO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5PID0gKHJlc3VsdCwgY2h1bmtJZHMsIGZuLCBwcmlvcml0eSkgPT4ge1xuXHRpZihjaHVua0lkcykge1xuXHRcdHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRmb3IodmFyIGkgPSBkZWZlcnJlZC5sZW5ndGg7IGkgPiAwICYmIGRlZmVycmVkW2kgLSAxXVsyXSA+IHByaW9yaXR5OyBpLS0pIGRlZmVycmVkW2ldID0gZGVmZXJyZWRbaSAtIDFdO1xuXHRcdGRlZmVycmVkW2ldID0gW2NodW5rSWRzLCBmbiwgcHJpb3JpdHldO1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXIgbm90RnVsZmlsbGVkID0gSW5maW5pdHk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGVmZXJyZWQubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgW2NodW5rSWRzLCBmbiwgcHJpb3JpdHldID0gZGVmZXJyZWRbaV07XG5cdFx0dmFyIGZ1bGZpbGxlZCA9IHRydWU7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBjaHVua0lkcy5sZW5ndGg7IGorKykge1xuXHRcdFx0aWYgKChwcmlvcml0eSAmIDEgPT09IDAgfHwgbm90RnVsZmlsbGVkID49IHByaW9yaXR5KSAmJiBPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLk8pLmV2ZXJ5KChrZXkpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fLk9ba2V5XShjaHVua0lkc1tqXSkpKSkge1xuXHRcdFx0XHRjaHVua0lkcy5zcGxpY2Uoai0tLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ1bGZpbGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZihwcmlvcml0eSA8IG5vdEZ1bGZpbGxlZCkgbm90RnVsZmlsbGVkID0gcHJpb3JpdHk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGZ1bGZpbGxlZCkge1xuXHRcdFx0ZGVmZXJyZWQuc3BsaWNlKGktLSwgMSlcblx0XHRcdHZhciByID0gZm4oKTtcblx0XHRcdGlmIChyICE9PSB1bmRlZmluZWQpIHJlc3VsdCA9IHI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59OyIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwiL2pzL21haW5cIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCI6IDAsXG5cdFwiY3NzL3N0eWxlXCI6IDAsXG5cdFwiY3NzLXJ0bC9zdHlsZS1ydGxcIjogMCxcblx0XCJjc3MtcnRsL2N1c3RvbS1ydGxcIjogMCxcblx0XCJjc3Mvb3ZlcnJpZGVzXCI6IDAsXG5cdFwiY3NzL2NvcmVcIjogMCxcblx0XCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiOiAwLFxuXHRcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIjogMCxcblx0XCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiOiAwLFxuXHRcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiOiAwLFxuXHRcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiOiAwLFxuXHRcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiOiAwLFxuXHRcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiOiAwLFxuXHRcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiOiAwLFxuXHRcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8uaiA9IChjaHVua0lkKSA9PiAoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID09PSAwKTtcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSAocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24sIGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG5cdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuXHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwO1xuXHRpZihjaHVua0lkcy5zb21lKChpZCkgPT4gKGluc3RhbGxlZENodW5rc1tpZF0gIT09IDApKSkge1xuXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYocnVudGltZSkgdmFyIHJlc3VsdCA9IHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdH1cblx0aWYocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24pIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xuXHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSgpO1xuXHRcdH1cblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZHNbaV1dID0gMDtcblx0fVxuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHJlc3VsdCk7XG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rXCJdID0gc2VsZltcIndlYnBhY2tDaHVua1wiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBkZXBlbmRzIG9uIG90aGVyIGxvYWRlZCBjaHVua3MgYW5kIGV4ZWN1dGlvbiBuZWVkIHRvIGJlIGRlbGF5ZWRcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL21haW4uanNcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXguc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXIuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5ncy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0cy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXIuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXIuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlci5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3Iuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb24uc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXQuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vbi5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXIuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHMuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtZW1haWwuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlci5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW4uc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG8uc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb24uc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2Uuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGUuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlci5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlcy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnUuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnUuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnQuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYi5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW4uc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnMuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXQuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXQuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2NvcmUuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL292ZXJyaWRlcy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzLXJ0bC9zdHlsZS1ydGxcIixcImNzcy1ydGwvY3VzdG9tLXJ0bFwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9zZW1pLWRhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvYm9yZGVyZWQtbGF5b3V0XCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jdXN0b20tcnRsLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3MtcnRsL3N0eWxlLXJ0bFwiLFwiY3NzLXJ0bC9jdXN0b20tcnRsXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL3NlbWktZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9ib3JkZXJlZC1sYXlvdXRcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvYXNzZXRzL3Njc3Mvc3R5bGUtcnRsLnNjc3NcIikpKVxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy1ydGwvc3R5bGUtcnRsXCIsXCJjc3MtcnRsL2N1c3RvbS1ydGxcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvc2VtaS1kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2JvcmRlcmVkLWxheW91dFwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9hc3NldHMvc2Nzcy9zdHlsZS5zY3NzXCIpKSlcbl9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLk8oX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4iLCIiXSwibmFtZXMiOlsiTWFpbiIsIl9fbmFtZV9fIiwid2lkZ2V0cyIsImNvbXBvbmVudHMiLCJvdmVybGF5cyIsImNvbG9ycGFja3MiLCJza2lucyIsIlBhY2siLCJTZXR0aW5nc1dpbiIsIm1ldGhvZHMiLCJvbk1vdXNlRG93biIsImUiLCJ3aW5kb3ciLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiZHJhZyIsIm9mZnNldF94IiwiY2xpZW50WCIsIngiLCJvZmZzZXRfeSIsImNsaWVudFkiLCJ5IiwiZG9jdW1lbnQiLCJvbm1vdXNldXAiLCJzdG9wZHJhZyIsIm9ubW91c2Vtb3ZlIiwib25kcmFnIiwiZGF0YSIsIlNoYXJlZCIsIlV0aWxzIiwidHYiLCJkYyIsInNldHQiLCJ1c2Vfd2luZG93IiwieGNoYXJ0bGluayQiLCJzaGFyZWQiLCJ0YXJnZXRzIiwib25zZXR0aW5ncyIsImFsbCIsImNsZWFyVGltZW91dCIsInJlc2V0X2lkIiwicnVsZXMiLCJyZWZzIiwibWV0YSIsImVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJpZCIsImNvbWJpbmUiLCJzZXRUaW1lb3V0IiwicmVzZXQiLCJjb21iaW5lZCIsInIiLCJnZWJjbiIsImVscyIsInJhbmsiLCJkc3QiLCJwYWlyIiwiT2JqZWN0Iiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsImQiLCJhc3NpZ24iLCJvdXQiLCJzcGxpdHIiLCJtYXRjaGVzIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsInNyYyIsImluY2x1ZGVzIiwicnVsZSIsInRyaW0iLCJzcGxpdCIsIm1hcCIsInR1cCIsImxlbmd0aCIsImNvbXBpbGUiLCIkcmVmcyIsImNoYXJ0IiwiaG9va3MiLCIkd2F0Y2giLCJnZXQiLCJmaWx0ZXIiLCJzZXR0aW5ncyIsIiRzdGF0ZSIsIm9udG9vbHMiLCJiaW5kIiwiY3Vyc29yIiwiYXJncyIsIm1haW4iLCJfbGF5b3V0IiwiZ3JpZHMiLCJncmlkX2lkIiwibWMiLCJ0IiwiJCIsInkkIiwiZyIsInh4IiwiaXNYIiwieXkiLCJpc1kiLCJ1cGQiLCJ0MnNjcmVlbiIsIiQyc2NyZWVuIiwiY3Vyc29yX2NoYW5nZWQiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInBvc2l0aW9uIiwibG9jayIsInJhbmdlIiwibiIsInAiLCJyZW0iLCJyZW1vdmVkIiwiJHV1aWQiLCJ0b29scyIsImNvcHlfdG9vbHMiLCJmb3JFYWNoIiwiZGVsIiwidG9vbCIsInV1aWQiLCJleGkiLCJnZXRfb25lIiwiJHNldCIsImNvcHkiLCIkc2VsZWN0ZWQiLCJvdnMiLCJzZWMiLCJncmlkIiwiJGNoaWxkcmVuIiwib3YiLCJwaW5zIiwicmVfaW5pdCIsImFkZCIsIl9faWRfXyIsIk1hdGgiLCJyYW5kb20iLCJvYmoiLCJtb2QiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJpZHMiLCJwcmV2IiwibGlzdCIsIlZ1ZSIsIlNwbGl0dGVyIiwiJGVsIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ubW91c2VsZWF2ZSIsInBsYWNlX3NwbGl0dGVycyIsImNhbGNfaGVpZ2h0cyIsIm9uZ3JpZHMiLCJyZW1vdmVfd2lkZ2V0cyIsInMiLCJoc19tb3VzZW1vdmUiLCJoc19tb3VzZXVwIiwiaHNfbW91c2VsZWF2ZSIsImkiLCJnMSIsImcyIiwidXVpZDIiLCJzZXQiLCJjbHMiLCJncmlkMSIsImdyaWQyIiwiaHMiLCJoZWlnaHQiLCJzdW0iLCJyZWR1Y2UiLCJoIiwiZ3JpZF9vdnMiLCJvZmZjaGFydCIsInVuZGVmaW5lZCIsIiRkZWxldGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibW91c2V1cCIsIm1vdXNlbGVhdmUiLCJhZGRfc3R5bGUiLCJzdHlsZSIsInN0YnIiLCJzaGVldFBhcmVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInNoZWV0IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImlubmVySFRNTCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInJlbV9zdHlsZSIsIkFkZFdpbiIsIm9uYnV0dG9uIiwidHlwZSIsImRhdGFJbmRleCIsIm9uY2hhcnQiLCJidXR0b24iLCJkaXNwbGF5IiwiZmxhZyIsInNwbGljZSIsImkwIiwiaTEiLCJ1cGRhdGVfaWRzIiwiYXZnX2dyaWRfaCIsInVuc2hpZnQiLCJmIiwidmFsdWVzIiwiZmluZCIsImluZGV4IiwiY29uc29sZSIsImxvZyIsInByZXNldCIsImdldF9wcmVzZXQiLCJzaWRlIiwibmFtZSIsInByb3RvIiwibWV0YV9pbmZvIiwiZ2giLCJzZXR0MmRlc2MiLCJzZXRDaGFyQXQiLCJzdHIiLCJjaHIiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwidHVwbGUiLCJ0b1VwcGVyQ2FzZSIsImpvaW4iLCJDaGFydExpbmsiLCJHcmlkUmVzaXplIiwiTGVnZW5kQnV0dG9ucyIsIkFwcCIsInJlbmRlciIsIlN0cmVhbSIsInVybCIsIndzIiwiV2ViU29ja2V0IiwiY2IiLCJvbm9wZW4iLCJvbm1lc3NhZ2UiLCJvbnRyYWRlcyIsInZhbCIsIm9mZiIsImNsb3NlIiwiU0VDT05EIiwiTUlOVVRFIiwiTUlOVVRFMyIsIk1JTlVURTUiLCJNSU5VVEUxNSIsIk1JTlVURTMwIiwiSE9VUiIsIkhPVVI0IiwiSE9VUjEyIiwiREFZIiwiV0VFSyIsIk1PTlRIIiwiWUVBUiIsIk1PTlRITUFQIiwiVElNRVNDQUxFUyIsIiRTQ0FMRVMiLCJDaGFydENvbmZpZyIsIlNCTUlOIiwiU0JNQVgiLCJJbmZpbml0eSIsIlRPT0xCQVIiLCJUQl9JQ09OIiwiVEJfSVRFTV9NIiwiVEJfSUNPTl9CUkkiLCJUQl9JQ09OX0hPTEQiLCJUQl9CT1JERVIiLCJUQl9CX1NUWUxFIiwiVE9PTF9DT0xMIiwiRVhQQU5EIiwiQ0FORExFVyIsIkdSSURYIiwiR1JJRFkiLCJCT1RCQVIiLCJQQU5IRUlHSFQiLCJERUZBVUxUX0xFTiIsIk1JTklNVU1fTEVOIiwiTUlOX1pPT00iLCJNQVhfWk9PTSIsIlZPTFNDQUxFIiwiVVhfT1BBQ0lUWSIsIlpPT01fTU9ERSIsIkxfQlROX1NJWkUiLCJMX0JUTl9NQVJHSU4iLCJTQ1JPTExfV0hFRUwiLCJGT05UIiwiSUJfVEZfV0FSTiIsIk1BUF9VTklUIiwibWFwX3VuaXQiLCJJbmRleGVkQXJyYXkiLCJDb25zdCIsIm5hbWUyTmFtZSIsImNsYW1wIiwibnVtIiwibWluIiwibWF4IiwiYWRkX3plcm8iLCJkYXlfc3RhcnQiLCJzdGFydCIsInNldFVUQ0hvdXJzIiwibW9udGhfc3RhcnQiLCJkYXRlIiwiVVRDIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInllYXJfc3RhcnQiLCJnZXRfeWVhciIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0X21vbnRoIiwiZ2V0VVRDTW9udGgiLCJuZWFyZXN0X2EiLCJhcnJheSIsImRpc3QiLCJ4aSIsImFicyIsInJvdW5kIiwiZGVjaW1hbHMiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInN0cmlwIiwibnVtYmVyIiwidG9QcmVjaXNpb24iLCJnZXRfZGF5IiwiZ2V0RGF0ZSIsIm92ZXJ3cml0ZSIsImFyciIsIm5ld19hcnIiLCJjb3B5X2xheW91dCIsIm5ld19vYmoiLCJrIiwibSIsImRldGVjdF9pbnRlcnZhbCIsIm9obGN2IiwibGVuIiwic2xpY2UiLCJnZXRfbnVtX2lkIiwicGFyc2VJbnQiLCJwb3AiLCJmYXN0X2ZpbHRlciIsInQxIiwidDIiLCJpYSIsInJlcyIsImdldFJhbmdlIiwidmFscG9zIiwibmV4dCIsImZhc3RfZmlsdGVyX2kiLCJmbG9vciIsImkyIiwiZmFzdF9uZWFyZXN0IiwiZmV0Y2giLCJuZXh0bG93IiwibmV4dGhpZ2giLCJwYXVzZSIsImRlbGF5IiwiUHJvbWlzZSIsInJzIiwicmoiLCJzbWFydF93aGVlbCIsImRlbHRhIiwic2lnbiIsImdldF9kZWx0YVgiLCJvcmlnaW5hbEV2ZW50IiwiZGVsdGFYIiwiZ2V0X2RlbHRhWSIsImRlbHRhWSIsImFwcGx5X29wYWNpdHkiLCJjIiwib3AiLCJ0b1N0cmluZyIsInBhcnNlX3RmIiwic210aCIsImluZGV4X3NoaWZ0Iiwic3ViIiwiZmlyc3QiLCJzZWNvbmQiLCJqIiwibWVhc3VyZVRleHQiLCJjdHgiLCJ0ZXh0IiwidHZfaWQiLCJtZWFzdXJlVGV4dE9yZyIsIndpZHRoIiwiZG9jIiwiYmFzZSIsInRvcCIsImZvbnQiLCJpbm5lclRleHQiLCJvZmZzZXRXaWR0aCIsInRlbXAiLCJ2Iiwid2FybiIsImlzX3Njcl9wcm9wc191cGQiLCJwcm9wcyIsIiRwcm9wcyIsInNvbWUiLCJkZWxheWVkX2V4ZWMiLCJzY3JpcHQiLCJleGVjSW50ZXJ2YWwiLCJkdCIsIiRsYXN0X2V4ZWMiLCJmb3JtYXRfbmFtZSIsInJlZyIsIlJlZ0V4cCIsInhtb2RlIiwiaXNfbW9iaWxlIiwiZGVmYXVsdF9wcmV2ZW50ZWQiLCJvcmlnaW5hbCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ3IiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiRG9jdW1lbnRUb3VjaCJdLCJzb3VyY2VSb290IjoiIn0=